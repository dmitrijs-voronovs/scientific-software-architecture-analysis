quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Security,"TreeCache for parallel Unzipping ;  CUnzipState;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  ►CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CRealInstanceCache;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  ►CTTreePerfStatsTTree I/O performance measurement ;  CBasketInfo;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_tIterate through the entries of a TTree ;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_tRandom access iterator to the elements of a TTreeReaderArray ;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewA helper class that encapsulates a file and a tree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CTTVSessionI/O classes for TreeViewer session handling ;  CTUDPSocket;  CTUnfoldAn algorithm to unfold distributions from detector t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:214024,access,access,214024,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['access'],['access']
Security,"TreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning valida",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__DecisionTree.html:11259,validat,validationSample,11259,root/html534/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html534/TMVA__DecisionTree.html,2,['validat'],"['validation', 'validationSample']"
Security,"TreeReader.C; This example. You can generate a skeleton of TTreeReaderValue<T> and TTreeReaderArray<T> declarations for all of a tree's branches using TTree::MakeSelector().; Roottest contains an example showing the full power.; A simpler analysis example can be found below: it histograms a function of the px and py branches.; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }; TFile.h; TH1F.h; TTreeReaderValue.h; TTreeReader.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderA simple, robust and fast interfa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:1832,access,access,1832,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['access'],['access']
Security,Tuple. More...;  ; struct  RNTupleLocator;  Generic information about the physical location of data. More...;  ; struct  RNTupleLocatorObject64;  RNTupleLocator payload that is common for object stores using 64bit location information. More...;  ; class  RNTupleModel;  The RNTupleModel encapulates the schema of an ntuple. More...;  ; struct  RNTupleOpenSpec;  Used to specify the underlying RNTuples in RNTupleProcessor and RNTupleReader::OpenFriends() More...;  ; class  RNTupleParallelWriter;  A writer to fill an RNTuple from multiple contexts. More...;  ; class  RNTupleProcessor;  Interface for iterating over entries of RNTuples and vertically concatenated RNTuples (chains). More...;  ; class  RNTupleReader;  An RNTuple that is used to read data from storage. More...;  ; class  RNTupleReadOptions;  Common user-tunable settings for reading ntuples. More...;  ; class  RNTupleView;  An RNTupleView for a known type. More...;  ; class  RNTupleView< void >;  ; class  RNTupleViewBase;  An RNTupleView provides read-only access to a single field of the ntuple. More...;  ; class  RNTupleWriteOptions;  Common user-tunable settings for storing ntuples. More...;  ; class  RNTupleWriteOptionsDaos;  DAOS-specific user-tunable settings for storing ntuples. More...;  ; class  RNTupleWriter;  An RNTuple that gets filled with entries (data) and writes them to storage. More...;  ; class  RNullableField;  Template specializations for C++ std::optional and std::unique_ptr. More...;  ; class  ROnFrameDrawable;  Base class for drawable which can be drawn on frame or on pad. More...;  ; class  ROptionalField;  ; class  RPad;  Graphic container for RDrawable-s. More...;  ; class  RPadBase;  Base class for graphic containers for RDrawable-s. More...;  ; class  RPadBaseDisplayItem;  class RPadBaseDisplayItem More...;  ; class  RPadDisplayItem;  class RPadDisplayItem More...;  ; class  RPadExtent;  An extent / size (horizontal and vertical) in a RPad. More...;  ; class  RPadLength;  A length in,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html:19789,access,access,19789,doc/master/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html,1,['access'],['access']
Security,"Type.h:44; TDirectoryFile::GetFileTFile * GetFile() const overrideDefinition TDirectoryFile.h:92; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunctionDefinition TGlobal.h:53; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:457; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:23550,access,access,23550,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['access'],['access']
Security,"Type.h:44; TDirectoryFile::GetFileTFile * GetFile() const overrideDefinition TDirectoryFile.h:92; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TGlobalMappedFunctionDefinition TGlobal.h:53; TGlobalGlobal variables class (global variables are obtained from CINT).Definition TGlobal.h:28; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TNamed::fNameTString fNameDefinition TNamed.h:32; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:23549,access,access,23549,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['access'],['access']
Security,"UE);  Find frame located int container at position x,y. ;  ; virtual TGFrame * FindFrameByName (const char *name);  Find frame by name. ;  ; virtual void * FindItem (const TString &name, Bool_t direction=kTRUE, Bool_t caseSensitive=kTRUE, Bool_t subString=kFALSE);  ; TGCanvas * GetCanvas () const;  ; virtual TGHScrollBar * GetHScrollbar () const;  returns pointer to hor. scroll bar ;  ; virtual TGFrame * GetLastActive () const;  ; const TGWindow * GetMessageWindow () const;  ; virtual const TGFrame * GetNextSelected (void **current);  Return the next selected item. ;  ; const TGPicture * GetObjPicture (TGFrame *f);  Retrieve icons associated with class ""name"". ;  ; virtual TGPosition GetPagePosition () const;  Returns page position. ;  ; virtual TGVScrollBar * GetVScrollbar () const;  returns pointer to vert. scroll bar ;  ; Bool_t HandleDNDFinished () override;  ; Bool_t HandleDoubleClick (Event_t *event) override;  Handle double click mouse event. ;  ; Bool_t HandleExpose (Event_t *event) override;  Handle expose events. Do not use double buffer. ;  ; Bool_t HandleKey (Event_t *event) override;  The key press event handler converts a key press to some line editor action. ;  ; Bool_t HandleMotion (Event_t *event) override;  Handle mouse motion events. ;  ; virtual void Home (Bool_t select=kFALSE);  Move to upper-left corner of container. ;  ; virtual void InvertSelection ();  Invert the selection, all selected items become unselected and vice versa. ;  ; virtual void KeyPressed (TGFrame *, UInt_t keysym, UInt_t mask);  Signal emitted when keyboard key pressed. ;  ; void Layout () override;  Layout container entries. ;  ; virtual Int_t NumItems () const;  ; virtual Int_t NumSelected () const;  ; virtual void OnMouseOver (TGFrame *);  Signal emitted when pointer is over entry. ;  ; virtual void PageDown (Bool_t select=kFALSE);  Move position one page down. ;  ; virtual void PageUp (Bool_t select=kFALSE);  Move position one page up. ;  ; void RemoveAll () override;  Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGFileContainer.html:7808,expose,expose,7808,doc/master/classTGFileContainer.html,https://root.cern,https://root.cern/doc/master/classTGFileContainer.html,2,['expose'],['expose']
Security,"UE);  Find frame located int container at position x,y. ;  ; virtual TGFrame * FindFrameByName (const char *name);  Find frame by name. ;  ; virtual void * FindItem (const TString &name, Bool_t direction=kTRUE, Bool_t caseSensitive=kTRUE, Bool_t subString=kFALSE);  ; TGCanvas * GetCanvas () const;  ; virtual TGHScrollBar * GetHScrollbar () const;  returns pointer to hor. scroll bar ;  ; virtual TGFrame * GetLastActive () const;  ; const TGWindow * GetMessageWindow () const;  ; virtual const TGFrame * GetNextSelected (void **current);  Return the next selected item. ;  ; const TGPicture * GetObjPicture (TGFrame *f);  Retrieve icons associated with class ""name"". ;  ; virtual TGPosition GetPagePosition () const;  Returns page position. ;  ; virtual TGVScrollBar * GetVScrollbar () const;  returns pointer to vert. scroll bar ;  ; Bool_t HandleDNDFinished () override;  ; Bool_t HandleDoubleClick (Event_t *event) override;  Handle double click mouse event. ;  ; Bool_t HandleExpose (Event_t *event) override;  Handle expose events. Do not use double buffer. ;  ; Bool_t HandleKey (Event_t *event) override;  The key press event handler converts a key press to some line editor action. ;  ; virtual void Home (Bool_t select=kFALSE);  Move to upper-left corner of container. ;  ; virtual void InvertSelection ();  Invert the selection, all selected items become unselected and vice versa. ;  ; virtual void KeyPressed (TGFrame *, UInt_t keysym, UInt_t mask);  Signal emitted when keyboard key pressed. ;  ; void Layout () override;  Layout container entries. ;  ; virtual Int_t NumItems () const;  ; virtual Int_t NumSelected () const;  ; virtual void OnMouseOver (TGFrame *);  Signal emitted when pointer is over entry. ;  ; virtual void PageDown (Bool_t select=kFALSE);  Move position one page down. ;  ; virtual void PageUp (Bool_t select=kFALSE);  Move position one page up. ;  ; void RemoveAll () override;  Remove all items from the container. ;  ; virtual void RemoveItem (TGFrame *item); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTVLVContainer.html:6863,expose,expose,6863,doc/master/classTTVLVContainer.html,https://root.cern,https://root.cern/doc/master/classTTVLVContainer.html,1,['expose'],['expose']
Security,"UE, ReAllocCharFun_t reallocfunc=nullptr);  constructor ;  ; Long64_t GetObjectTag (const void *obj);  Returns tag for specified object from objects map (if exists) Returns 0 if object not included into objects map. ;  ;  Protected Member Functions inherited from TBuffer;  TBuffer ();  ;  TBuffer (const TBuffer &)=delete;  ; void operator= (const TBuffer &)=delete;  ; Int_t Read (const char *name) override;  Read contents of object with specified name from the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) override;  Write this object to the current directory. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from TBufferIO; static R__ALWAYS_INLINE ULong_t Void_Hash (const void *ptr);  Return hash value for provided object. ;  ;  Protected Attributes inherited from TBufferFile; TStreamerInfo * fInfo {nullptr};  Pointer to TStreamerInfo object writing/reading the buffer. ;  ; InfoList_t fInfoStack;  Stack of pointers to the TStreamerInfos. ;  ;  Protected Attributes inherited from TBufferIO; TExMap * fClassMap {nullptr};  Map containing object,class pairs for reading. ;  ; Int_t fDisplacement {0};  Value to be added to the map offsets. ;  ; TExMap * fMap {nullptr};  Map containing object,offset pairs for reading/writing. ;  ; Int_t fMapCount {0};  Number of objects or classes in map. ;  ; Int_t fMapSize {0};  Default size of map. ;  ; UShort_t fPidOffset {0};  Offset to be added to the pid index in this key/buffer. ;  ;  Protected Attributes inherited from TBuffer; char * fBufCur;  ; char * fBuffer;  ; char * fBufMax;  ; Int_t fBufSize;  ; CacheList_t fCacheStack;  Realloc function to be used when extending the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferSQL.html:37129,hash,hash,37129,doc/master/classTBufferSQL.html,https://root.cern,https://root.cern/doc/master/classTBufferSQL.html,1,['hash'],['hash']
Security,"UE;; 946 Bool_t done = kFALSE;; 947 Bool_t oldIsNonVersioned = kFALSE;; 948 if (fClassVersion!=0 && !fClass->TestBit(TClass::kWarned) && (fClassVersion == info->GetClassVersion()) && (fCheckSum != info->GetCheckSum())) {; 949 // The TStreamerInfo's checksum is different from the checksum for the compile class.; 950 ; 951 match = kFALSE;; 952 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 953 ; 954 if (fClass->IsLoaded() && (fClassVersion == fClass->GetClassVersion()) && fClass->HasDataMemberInfo()) {; 955 // In the case where the read-in TStreamerInfo does not; 956 // match in the 'current' in memory TStreamerInfo for; 957 // a non foreign class (we can not get here if this is; 958 // a foreign class so we do not need to test it),; 959 // we need to add this one more test since the CINT behaviour; 960 // with enums changed over time, so verify the checksum ignoring; 961 // members of type enum. We also used to not count the //[xyz] comment; 962 // in the checksum, so test for that too.; 963 if ( (fCheckSum == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(fCheckSum) ); 964 &&(info->GetCheckSum() == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(info->GetCheckSum())); 965 ); 966 {; 967 match = kTRUE;; 968 }; 969 if (fOldVersion <= 2) {; 970 // Names of STL base classes was modified in vers==3. Allocators removed; 971 // (We could be more specific (see test for the same case below); 972 match = kTRUE;; 973 }; 974 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 975 match = kTRUE;; 976 }; 977#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_CLASSES; 978 if (!match && file->GetVersion() < 51800 && fClass && (fClass->Property() & kIsAbstract); 979 && fClass->GetListOfDataMembers()->GetEntries() != 0); 980 {; 981 // In some instances of old files (v5.17 and less), some StreamerInfo for; 982 // an abstract class where not written correctly, and add no; 983 // data member listed. If in addition one of the da",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:35454,checksum,checksum,35454,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['checksum'],['checksum']
Security,"UID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t* seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t* uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. void SetUUIDNumber(UInt_t index); { fUUIDIndex = index; }. Int_t Sizeof() const; { return 18; }. » Author: Fons Rademakers 30/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUUID.html:6449,hash,hash,6449,root/html534/TUUID.html,https://root.cern,https://root.cern/root/html534/TUUID.html,1,['hash'],['hash']
Security,"UID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t* seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t* uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. void SetUUIDNumber(UInt_t index); { fUUIDIndex = index; }. Int_t Sizeof() const; { return 18; }. » Author: Fons Rademakers 30/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TUUID.h 27658 2009-02-28 05:34:57Z pcanal $ » Last generated: 2010-10-01 15:52; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUUID.html:6430,hash,hash,6430,root/html528/TUUID.html,https://root.cern,https://root.cern/root/html528/TUUID.html,1,['hash'],['hash']
Security,"UID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t* seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t* uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. void SetUUIDNumber(UInt_t index); { fUUIDIndex = index; }. Int_t Sizeof() const; { return 18; }. » Author: Fons Rademakers 30/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TUUID.h 27658 2009-02-28 05:34:57Z pcanal $ » Last generated: 2011-07-04 15:38; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TUUID.html:6430,hash,hash,6430,root/html530/TUUID.html,https://root.cern,https://root.cern/root/html530/TUUID.html,1,['hash'],['hash']
Security,"UID from input buffer. void StreamerV1(TBuffer& b); Stream UUID from input buffer.; This function is for the exclusive use of TDirectory::Streamer() to; read a non-versioned version of TUUID. void Format(UShort_t clockseq, TUUID::uuid_time_t ts); Make a UUID from timestamp, clockseq and node id. void GetCurrentTime(TUUID::uuid_time_t* timestamp); Get current time as 60 bit 100ns ticks since whenever.; Compensate for the fact that real clock resolution is less; than 100ns. void GetSystemTime(TUUID::uuid_time_t* timestamp); Get system time with 100ns precision. Time is since Oct 15, 1582. void GetNodeIdentifier(); Get node identifier. Try first to get network address, if no; network interface try random info based on some machine parameters. void GetRandomInfo(UChar_t* seed); Get random info based on some machine parameters. void Print() const; Print UUID. const char * AsString() const; Return UUID as string. Copy string immediately since it will be reused. UShort_t Hash() const; Compute 16-bit hash value of the UUID. Int_t Compare(const TUUID& u) const; Compare two UUIDs ""lexically"" and return; -1 this is lexically before u; 0 this is equal to u; 1 this is lexically after u. TInetAddress GetHostAddress() const; Get address of host encoded in UUID. If host id is not an ethernet; address, but random info, then the returned TInetAddress is not valid. TDatime GetTime() const; Get time from UUID. void GetUUID(UChar_t* uuid) const; Return uuid in specified buffer (16 byte = 128 bits). void SetUUID(const char* uuid_str); Set this UUID to the value specified in uuid ((which must be in; TUUID::AsString() format). TUUID(). UInt_t GetUUIDNumber() const; { return fUUIDIndex; }. void SetUUIDNumber(UInt_t index); { fUUIDIndex = index; }. Int_t Sizeof() const; { return 18; }. » Author: Fons Rademakers 30/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TUUID.h 27658 2009-02-28 05:34:57Z pcanal $ » Last generated: 2011-11-03 20:23; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUUID.html:6430,hash,hash,6430,root/html532/TUUID.html,https://root.cern,https://root.cern/root/html532/TUUID.html,1,['hash'],['hash']
Security,"UInt_t index); Returns class at index from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc.; Returns 0 if index points beyond last class name. int Classes(). { return fgTally; }. void Init(); { fgCursor = 0; SortTable(); }. void Add(const char* cname, Version_t id, const type_info& info, DictFuncPtr_t dict, Int_t pragmabits); Add a class to the class table (this is a static function).; Note that the given cname *must* be already normalized. void Add(TProtoClass* protoClass); Add a class to the class table (this is a static function). void AddAlternate(const char* normname, const char* alternate). Bool_t Check(const char* cname, string& normname). void Remove(const char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned.; cname can be any spelling of the class name. See FindElementImpl if the; name is already normalized. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. DictFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). DictFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). DictFuncP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClassTable.html:8794,hash,hash,8794,root/html602/TClassTable.html,https://root.cern,https://root.cern/root/html602/TClassTable.html,2,['hash'],['hash']
Security,"URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetFile(); TNetFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t repl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:1562,authenticat,authenticate,1562,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,4,['authenticat'],['authenticate']
Security,"URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetSystem(Bool_t ftpowner = kTRUE); TNetSystem(const char* url, Bool_t ftpowner = kTRUE); virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetSystem.html:1570,authenticat,authenticate,1570,root/html528/TNetSystem.html,https://root.cern,https://root.cern/root/html528/TNetSystem.html,4,['authenticat'],['authenticate']
Security,"URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetFile.html:1562,authenticat,authenticate,1562,root/html602/TNetFile.html,https://root.cern,https://root.cern/root/html602/TNetFile.html,2,['authenticat'],['authenticate']
Security,"URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::Add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetSystem.html:1570,authenticat,authenticate,1570,root/html602/TNetSystem.html,https://root.cern,https://root.cern/root/html602/TNetSystem.html,2,['authenticat'],['authenticate']
Security,"UserParameterStatefState; ROOT::Minuit2::MnStrategyfStrategy; boolfUseGrad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~MnApplication(); { }. FunctionMinimum operator()(unsigned int maxfcn = 0, double tolerance = 0.1). Minimize the function; @param maxfcn : max number of function calls (if = 0) default is used which is set to; 200 + 100 * npar + 5 * npar**2; @param tolerance : value used for terminating iteration procedure.; For example, MIGRAD will stop iterating when edm (expected distance from minimum) will be:; edm < tolerance * 10**-3; Default value of tolerance used is 0.1. const FCNBase& Fcnbase() const; {return fFCN;}. unsigned int NumOfCalls() const; {return fNumCall;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation; via MnUserParameterState; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const char* Name, double val, double err); add free Parameter. void Add(const char* Name, double val, double err, double , double ); add limited Parameter. void Add(const char* , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const char* ); interaction via Name of Parameter. void Release(const char* ). void SetValue(const char* , double ). void SetError(const char* , double ). void SetLimits(const char* , double , double ). void RemoveLimits(const char* ). void SetPrecision(double ). double Value(const char* ) const. double Error(const char* ) const. unsigned int Index(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Minuit2__MnApplication.html:3498,access,access,3498,root/html528/ROOT__Minuit2__MnApplication.html,https://root.cern,https://root.cern/root/html528/ROOT__Minuit2__MnApplication.html,4,['access'],['access']
Security,"UserParameterStatefState; ROOT::Minuit2::MnStrategyfStrategy; boolfUseGrad. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~MnApplication(); { }. FunctionMinimum operator()(unsigned int maxfcn = 0, double tolerance = 0.1). Minimize the function; @param maxfcn : max number of function calls (if = 0) default is used which is set to; 200 + 100 * npar + 5 * npar**2; @param tolerance : value used for terminating iteration procedure.; For example, MIGRAD will stop iterating when edm (expected distance from minimum) will be:; edm < tolerance * 10**-3; Default value of tolerance used is 0.1. const FCNBase& Fcnbase() const; {return fFCN;}. unsigned int NumOfCalls() const; {return fNumCall;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation; via MnUserParameterState; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const char* Name, double val, double err); add free Parameter. void Add(const char* Name, double val, double err, double , double ); add limited Parameter. void Add(const char* , double ); add const Parameter. void Fix(unsigned int); interaction via external number of Parameter. void Release(unsigned int). void SetValue(unsigned int, double). void SetError(unsigned int, double). void SetLimits(unsigned int, double, double). void RemoveLimits(unsigned int). double Value(unsigned int). double Error(unsigned int). void Fix(const char*); interaction via Name of Parameter. void Release(const char*). void SetValue(const char*, double). void SetError(const char*, double). void SetLimits(const char*, double, double). void RemoveLimits(const char*). void SetPrecision(double ). double Value(const char*). double Error(const char*). unsigned int Index(const char* ) const; convert Name into external numbe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__MnApplication.html:3498,access,access,3498,root/html526/ROOT__Minuit2__MnApplication.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__MnApplication.html,1,['access'],['access']
Security,"VA::IntervalTMVA::Interval::Interval(const TMVA::Interval& other); TMVA::IntervalTMVA::Interval::Interval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::MsgLogger&Log() const; TMVA::LogIntervalLogInterval(const TMVA::LogInterval& other); TMVA::LogIntervalLogInterval(Double_t min, Double_t max, Int_t nbins = 0); TMVA::LogInterval&operator=(const TMVA::LogInterval&); virtual voidTMVA::Interval::Print(ostream& os) const; voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. Double_tTMVA::Interval::fMaxthe constraints of the Interval; Double_tTMVA::Interval::fMinthe constraints of the Interval; Int_tTMVA::Interval::fNbinswhen >0 : number of bins (discrete interval); when ==0 continuous interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LogInterval(Double_t min, Double_t max, Int_t nbins = 0). LogInterval(const TMVA::LogInterval& other). ~LogInterval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize(Int_t iBin = 0) const; retuns the step size between the numbers of a ""discrete LogInterval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetWidth() const. Double_t GetMean() const. TMVA::MsgLogger& Log() const. Double_t GetMin() const; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Int_t GetNbins() const; { return fNbins; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Last changed: Tue Jun 2 16:16:21 2015 » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__LogInterval.html:2282,access,accessors,2282,root/html604/TMVA__LogInterval.html,https://root.cern,https://root.cern/root/html604/TMVA__LogInterval.html,1,['access'],['accessors']
Security,"VARCHAR; kSQL_INTEGER; kSQL_FLOAT; kSQL_DOUBLE; kSQL_NUMERIC; kSQL_BINARY; kSQL_TIMESTAMP; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTSQLServer::fDBcurrently selected DB; Int_tTSQLServer::fErrorCodeerror code of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. private:. Connection*fConnconnection to Oracle server; Environment*fEnvenvironment of Oracle access; TStringfInfoinfo string with Oracle version information; static const char*fgDatimeFormat! format for converting date and time stamps into string . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TOracleServer(const char* db, const char* uid, const char* pw); Open a connection to a Oracle DB server. The db arguments should be; of the form ""oracle://connection_identifier[/<database>]"", e.g.:; ""oracle://cmscald.fnal.gov/test"". The uid is the username and pw; the password that should be used for the connection. ~TOracleServer(); Close connection to Oracle DB server. void Close(Option_t* opt = """"); Close connection to Oracle DB server. TSQLStatement * Statement(const char* sql, Int_t niter = 100). TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise. Bool_t Exec(const char* sql); Execute sql command wich does not produce any result set.; Return kTRUE if succes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TOracleServer.html:9144,access,access,9144,root/html528/TOracleServer.html,https://root.cern,https://root.cern/root/html528/TOracleServer.html,1,['access'],['access']
Security,"ValueChange; };; enum OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>_boolAttribBoolean attributes; set<std::string>_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>_cacheListlist of caches; RooRefCountList_clientListlist of client objects; RooRefCountList_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountList_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*_clientShapeIter! Iterator over _clientListShape ; TIterator*_clientValueIter! Iterator over _clientListValue ; Bool_t_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_fastAllow fast access mode in getVal() and proxies; static Bool_t_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; static Int_tRooPrintable::_nameLength; TNamed*_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArray_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attributes; Bool_t_valueDirtyFlag set if value needs recalculating b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsArg.html:16976,access,access,16976,root/html532/RooAbsArg.html,https://root.cern,https://root.cern/root/html532/RooAbsArg.html,1,['access'],['access']
Security,"Variable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; double; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; AuthorAndreas Hoecker ; Definition in file TMVAClassificationApplication.C. tutorialstmvaTMVAClassificationApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C.html:28188,access,access,28188,doc/master/TMVAClassificationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C.html,2,['access'],['access']
Security,"Vector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5567,access,access,5567,root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,4,['access'],['access']
Security,"Vector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5567,access,access,5567,root/html528/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,4,['access'],['access']
Security,"Vector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5567,access,access,5567,root/html528/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,4,['access'],['access']
Security,"Vector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5567,access,access,5567,root/html528/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,4,['access'],['access']
Security,"Verb httpVerb) const. TS3HTTPRequest& SetTimeStamp(); Sets this request's time stamp according to:; http://code.google.com/apis/storage/docs/reference-headers.html#date. TString MakeRequestLine(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the first line of a HTTP request for this object. Note that since; we don't use the virtual host syntax which is supported by Amazon, we; must include the bucket name in thr resource. For example, we don't use; http://mybucket.s3.amazonaws.com/path/to/my/file but instead; http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request; will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1""; Also note that the path must include the leading '/'. TString MakeHostHeader() const; Returns the 'Host' header to include in the HTTP request. TString MakeDateHeader() const; Returns the date header for this HTTP request. TString MakeAuthPrefix() const; Returns the authentication prefix. TString MakeAuthHeader(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the authentication header for this HTTP request. TString GetRequest(TS3HTTPRequest::EHTTPVerb httpVerb, Bool_t appendCRLF = kTRUE); Returns the HTTP request ready to be sent to the server. TS3HTTPRequest& SetHost(const TString& host). TS3HTTPRequest& SetBucket(const TString& bucket). TS3HTTPRequest& SetObjectKey(const TString& objectKey). TS3HTTPRequest& SetAuthKeys(const TString& accessKey, const TString& secretKey). TS3HTTPRequest& SetAuthType(TS3HTTPRequest::EAuthType authType). TS3HTTPRequest& SetAccessKey(const TString& accessKey). TS3HTTPRequest& SetSecretKey(const TString& secretKey). virtual ~TS3HTTPRequest(); { }. EHTTPVerb GetHTTPVerb() const; { return fVerb; }. const TString& GetHost() const; { return fHost; }. const TString& GetBucket() const; { return fBucket; }. const TString& GetObjectKey() const; { return fObjectKey; }. const TString& GetTimeStamp() const; { return fTimeStamp; }. const TString& GetAccessKey() const; { return fAccessKey; }. const TString& Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3HTTPRequest.html:9252,authenticat,authentication,9252,root/html534/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html534/TS3HTTPRequest.html,3,['authenticat'],['authentication']
Security,"WebFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). overridevirtual . Read the nbuf blocks described in arrays pos and len. ; The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 311 of file TS3WebFile.cxx. ◆ SetAccessKey(). void TS3WebFile::SetAccessKey ; (; const TString & ; accessKey). inlineprotected . Definition at line 83 of file TS3WebFile.h. ◆ SetMsgReadBuffer10(). void TS3WebFile::SetMsgReadBuffer10 ; (; const char * ; redirectLocation = nullptr, . Bool_t ; tempRedirect = kFALSE . ). overrideprotectedvirtual . Overwrites TWebFile::SetMsgReadBuffer10() for setting the HTTP GET request compliant to the authentication mechanism used by the S3 protocol. ; The GET request must contain an ""Authorization"" header with the signature of the request, generated using the user's secret access key. ; Reimplemented from TWebFile.; Definition at line 301 of file TS3WebFile.cxx. ◆ SetSecretKey(). void TS3WebFile::SetSecretKey ; (; const TString & ; secretKey). inlineprotected . Definition at line 84 of file TS3WebFile.h. ◆ Streamer(). void TS3WebFile::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a TFile object. ; Reimplemented from TFile. ◆ StreamerNVirtual(). void TS3WebFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 105 of file TS3WebFile.h. Member Data Documentation. ◆ fS3Request. TS3HTTPRequest TS3WebFile::fS3Request. protected . Definition at line 87 of file TS3WebFile.h. ◆ fUseMultiRange. Bool_t TS3WebFile::fUseMultiRange. protected . Definition at line 88 of file TS3WebFile.h. Libraries for TS3WebFile:. [legend]; The documentation for this class was generated from the following files:; net/net/inc/TS3WebFile.h; net/net/src/TS3WebFile.cxx. TS3WebFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:56338,access,access,56338,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['access'],['access']
Security,"Window({}) Must be set before RWebWindow::Show() method is called. ; Parameters. args- arbitrary JSON data which can be provided to client side . Definition at line 1310 of file RWebWindow.cxx. ◆ Show(). unsigned RWebWindow::Show ; (; const RWebDisplayArgs & ; args = """"). Show window in specified location. ; See alsoROOT::RWebWindowsManager::Show for more info ; Returns(future) connection id (or 0 when fails) ; Definition at line 191 of file RWebWindow.cxx. ◆ ShowWindow(). unsigned RWebWindow::ShowWindow ; (; std::shared_ptr< RWebWindow > ; window, . const RWebDisplayArgs & ; args = """" . ). static . Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ; Definition at line 1915 of file RWebWindow.cxx. ◆ StartThread(). void RWebWindow::StartThread ; (; ). Start special thread which will be used by the window to handle all callbacks One has to be sure, that access to global ROOT structures are minimized and protected with ROOT::EnableThreadSafety(); call. ; Definition at line 1680 of file RWebWindow.cxx. ◆ StopThread(). void RWebWindow::StopThread ; (; ). Stop special thread. ; Definition at line 1702 of file RWebWindow.cxx. ◆ SubmitData(). void RWebWindow::SubmitData ; (; unsigned ; connid, . bool ; txt, . std::string && ; data, . int ; chid = 1 . ). private . Internal method to send data. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; txtis text message that should be sent ; datadata to be std-moved to SubmitData function ; chidchannel id, 1 - normal communication, 0 - internal with highest priority . Definition at line 1529 of file RWebWindow.cxx. ◆ Sync(). void RWebWindow::Sync ; (; ). Special method to process all internal activity when window runs in separate thread. ; Definition at line 1236 of file RWebWindow.cxx. ◆ TerminateROOT(). void RWebWindow::TerminateROOT ; (; ). Terminate ROOT session",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:49475,access,access,49475,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"Window({}) Must be set before RWebWindow::Show() method is called. ; Parameters. args- arbitrary JSON data which can be provided to client side . Definition at line 1352 of file RWebWindow.cxx. ◆ Show(). unsigned RWebWindow::Show ; (; const RWebDisplayArgs & ; args = """"). Show window in specified location. ; See alsoROOT::RWebWindowsManager::Show for more info ; Returns(future) connection id (or 0 when fails) ; Definition at line 191 of file RWebWindow.cxx. ◆ ShowWindow(). unsigned RWebWindow::ShowWindow ; (; std::shared_ptr< RWebWindow > ; window, . const RWebDisplayArgs & ; args = """" . ). static . Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ; Definition at line 1957 of file RWebWindow.cxx. ◆ StartThread(). void RWebWindow::StartThread ; (; ). Start special thread which will be used by the window to handle all callbacks One has to be sure, that access to global ROOT structures are minimized and protected with ROOT::EnableThreadSafety(); call. ; Definition at line 1722 of file RWebWindow.cxx. ◆ StopThread(). void RWebWindow::StopThread ; (; ). Stop special thread. ; Definition at line 1744 of file RWebWindow.cxx. ◆ SubmitData(). void RWebWindow::SubmitData ; (; unsigned ; connid, . bool ; txt, . std::string && ; data, . int ; chid = 1 . ). private . Internal method to send data. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; txtis text message that should be sent ; datadata to be std-moved to SubmitData function ; chidchannel id, 1 - normal communication, 0 - internal with highest priority . Definition at line 1571 of file RWebWindow.cxx. ◆ Sync(). void RWebWindow::Sync ; (; ). Special method to process all internal activity when window runs in separate thread. ; Definition at line 1269 of file RWebWindow.cxx. ◆ TerminateROOT(). void RWebWindow::TerminateROOT ; (; ). Terminate ROOT session",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:48359,access,access,48359,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"Window::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:278; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:163; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:421; ROOT::RWebWindow::HasKeybool HasKey(const std::string &key, bool also_newkey=false) constReturns true if provided key value already exists (in processes map or in existing connections) In sp...Definition RWebWindow.cxx:558; ROOT::RWebWindow::CompleteWSSendvoid CompleteWSSend(unsigned wsid)Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be start...Definition RWebWindow.cxx:1088; ROOT::RWebWindow::IsUseCurrentDirbool IsUseCurrentDir() constreturns true if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:328; ROOT::RWebWindow::fUseServerThreadsbool fUseServerThreads! indicates that server thread is using, no special window threadDefinition RWebWindow.hxx:142; ROOT::RWebWindow::FindHeadlessConnectionunsigned FindHeadlessConnection()Returns connection id of window running in headless mode This can be special connection which may run...Definition RWebWindow.cxx:221; ROOT::RWebWindow::WaitForTimedint WaitForTimed(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1803; ROOT::RWebWindow::fProcessMTbool fProcessMT! if window event processing performed in dedicated threadDefinition RWebWindow.hxx:144; ROOT::RWebWindow::fProtocolCntint fProtocolCnt! counter for protocol recordingDefinition RWebWindow.hxx:171; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:41995,access,access,41995,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['access'],['access']
Security,"Window::GetWidthunsigned GetWidth() constreturns configured window width (0 - default) actual window width can be differentDefinition RWebWindow.hxx:281; ROOT::RWebWindow::fWindowThrdstd::thread fWindowThrd! special thread for that windowDefinition RWebWindow.hxx:166; ROOT::RWebWindow::ProvideQueueEntryvoid ProvideQueueEntry(unsigned connid, EQueueEntryKind kind, std::string &&arg)Provide data to user callback User callback must be executed in the window thread.Definition RWebWindow.cxx:422; ROOT::RWebWindow::HasKeybool HasKey(const std::string &key, bool also_newkey=false) constReturns true if provided key value already exists (in processes map or in existing connections) In sp...Definition RWebWindow.cxx:559; ROOT::RWebWindow::CompleteWSSendvoid CompleteWSSend(unsigned wsid)Complete websocket send operation Clear ""doing send"" flag and check if next operation has to be start...Definition RWebWindow.cxx:1121; ROOT::RWebWindow::IsUseCurrentDirbool IsUseCurrentDir() constreturns true if window can access local files via currentdir/ path of http serverDefinition RWebWindow.hxx:331; ROOT::RWebWindow::fUseServerThreadsbool fUseServerThreads! indicates that server thread is using, no special window threadDefinition RWebWindow.hxx:145; ROOT::RWebWindow::FindHeadlessConnectionunsigned FindHeadlessConnection()Returns connection id of window running in headless mode This can be special connection which may run...Definition RWebWindow.cxx:221; ROOT::RWebWindow::WaitForTimedint WaitForTimed(WebWindowWaitFunc_t check)Waits until provided check function or lambdas returns non-zero value Check function has following si...Definition RWebWindow.cxx:1845; ROOT::RWebWindow::fProcessMTbool fProcessMT! if window event processing performed in dedicated threadDefinition RWebWindow.hxx:147; ROOT::RWebWindow::fProtocolCntint fProtocolCnt! counter for protocol recordingDefinition RWebWindow.hxx:174; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:42140,access,access,42140,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['access'],['access']
Security,"Write(const char *name, Int_t option, Int_t bsize) const; 649{; 650 if ((option & kSingleKey)) {; 651 return TObject::Write(name, option, bsize);; 652 } else {; 653 option &= ~kSingleKey;; 654 Int_t nbytes = 0;; 655 TIter next(this);; 656 TObject *obj;; 657 while ((obj = next())) {; 658 nbytes += obj->Write(name, option, bsize);; 659 }; 660 return nbytes;; 661 }; 662}; 663 ; 664////////////////////////////////////////////////////////////////////////////////; 665/// Write all objects in this collection. By default all objects in; 666/// the collection are written individually (each object gets its; 667/// own key). Note, this is recursive, i.e. objects in collections; 668/// in the collection are also written individually. To write all; 669/// objects using a single key specify a name and set option to; 670/// TObject::kSingleKey (i.e. 1).; 671 ; 672Int_t TCollection::Write(const char *name, Int_t option, Int_t bsize); 673{; 674 return ((const TCollection*)this)->Write(name,option,bsize);; 675}; 676 ; 677////////////////////////////////////////////////////////////////////////////////; 678/// Return the globally accessible collection.; 679 ; 680TCollection *TCollection::GetCurrentCollection(); 681{; 682 return fgCurrentCollection;; 683}; 684 ; 685////////////////////////////////////////////////////////////////////////////////; 686/// Set this collection to be the globally accessible collection.; 687 ; 688void TCollection::SetCurrentCollection(); 689{; 690 fgCurrentCollection = this;; 691}; 692 ; 693////////////////////////////////////////////////////////////////////////////////; 694/// Set up for garbage collection.; 695 ; 696void TCollection::StartGarbageCollection(); 697{; 698 R__LOCKGUARD2(gCollectionMutex);; 699 if (!fgGarbageCollection) {; 700 fgGarbageCollection = new TObjectTable;; 701 fgEmptyingGarbage = kFALSE;; 702 fgGarbageStack = 0;; 703 }; 704 fgGarbageStack++;; 705}; 706 ; 707///////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:22840,access,accessible,22840,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['access'],['accessible']
Security,"WriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>_ioReadStackreading stack ; static const UInt_tfnv1a32start; static const ULong64_tfnv1a64start. protected:. set<std::string>_boolAttribBoolean attributes; set<std::string>_boolAttribTransient! Transient boolean attributes (not copied in ctor); deque<RooAbsCache*>_cacheListlist of caches; RooRefCountList_clientListlist of client objects; RooRefCountList_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountList_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*_clientShapeIter! Iterator over _clientListShape ; TIterator*_clientValueIter! Iterator over _clientListValue ; Bool_t_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_fastAllow fast access mode in getVal() and proxies; static Bool_t_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_isConstant! Cached isConstant status ; Bool_t_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperMode_operModeDirty state propagation mode; RooArgSet*_ownedComponents! Set of owned component; Bool_t_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArray_proxyListlist of proxies; RooRefCountList_serverListlist of server objects; Bool_t_shapeDirtyFlag set if value needs recalculating because input shapes modified; map<std::string,std::string>_stringAttribString attribut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:17940,access,access,17940,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,1,['access'],['access']
Security,"X.; Definition at line 749 of file TGCocoa.mm. ◆ MoveWindow() [2/2]. void TGCocoa::MoveWindow ; (; Window_t ; id, . Int_t ; x, . Int_t ; y . ). overridevirtual . Moves the specified window to the specified x and y coordinates. ; It does not change the window's size, raise the window, or change the mapping state of the window.; Parameters. [in]idwindow identifier ; [in]x,ycoordinates, which define the new position of the window relative to its parent. . Reimplemented from TVirtualX.; Definition at line 1248 of file TGCocoa.mm. ◆ NeedRedraw(). Bool_t TGCocoa::NeedRedraw ; (; ULong_t ; tgwindow, . Bool_t ; force . ). overridevirtual . Notify the low level GUI layer ROOT requires ""tgwindow"" to be updated. ; Returns kTRUE if the notification was desirable and it was sent; At the moment only Qt4 layer needs that; One needs explicitly cast the first parameter to TGWindow to make it working in the implementation.; One needs to process the notification to confine all paint operations within ""expose"" / ""paint"" like low level event or equivalent ; Reimplemented from TVirtualX.; Definition at line 4182 of file TGCocoa.mm. ◆ NextEvent(). void TGCocoa::NextEvent ; (; Event_t & ; event). overridevirtual . The ""event"" is set to default event. ; This method however, should never be called. ; Reimplemented from TVirtualX.; Definition at line 3531 of file TGCocoa.mm. ◆ OpenDisplay(). Int_t TGCocoa::OpenDisplay ; (; const char * ; dpyName). overridevirtual . Opens connection to display server (if such a thing exist on the current platform). ; The encoding and interpretation of the display name.; On X11 this method returns on success the X display socket descriptor >0, 0 in case of batch mode, and <0 in case of failure (cannot connect to display dpyName). ; Reimplemented from TVirtualX.; Definition at line 500 of file TGCocoa.mm. ◆ OpenPixmap(). Int_t TGCocoa::OpenPixmap ; (; UInt_t ; w, . UInt_t ; h . ). overridevirtual . Creates a pixmap of the width ""w"" and height ""h"" you specified. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:100784,expose,expose,100784,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['expose'],['expose']
Security,"Zombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 240 of file TSQLFile.h. ◆ ReOpen(). Int_t TSQLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 719 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [1/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const char * ; clname, . Int_t ; version . ). protected . Search in database tables for specified class and return TSQLClassInfo object. ; Definition at line 1800 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [2/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const TClass * ; cl). protected . Search in database tables for specified class and return TSQLClassInfo object. ; Definition at line 1903 of file TSQLFile.cxx. ◆ ResetErrno(). void TSQLFile::ResetErrno ; (; ); const. inlinefinalvirtual . Method resetting the errno. ; Reimplemented from TFile.; Definition at line 216 of file TSQLFile.h. ◆ Rollback(). Bool_t TSQLFile::Rollback ; (; ). Rollback all operations, done after StartTransaction() call. ; Database should return to initial state. ; Definition at line 593 of file TSQLFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:86159,access,access,86159,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['access'],['access']
Security,"Zombie. protected:. TSignalHandler*TProofMgr::fIntHandlerInterrupt signal handler (ctrl-c); TStringTProofMgr::fMssUrlURL for the remote data pool, if any; TStringTNamed::fNameobject identifier; Int_tTProofMgr::fRemoteProtocolProtocol number run by the daemon server; TProofMgr::EServTypeTProofMgr::fServTypeType of server: old-proofd, XrdProofd; TList*TProofMgr::fSessionsPROOF session managed by this server; TStringTNamed::fTitleobject title; TUrlTProofMgr::fUrlServer URL; static TListTProofMgr::fgListOfManagersSub-list of TROOT::ListOfProofs for managers. private:. TXSocket*fSocketConnection to XRD. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TProofMgr. TXHandler. ←; TXProofMgr. Function documentation; TXProofMgr(const char* url, Int_t loglevel = -1, const char* alias = """"); Create a PROOF manager for the standard (old) environment. Int_t Init(Int_t loglevel = -1); Do real initialization: open the connection and set the relevant; variables.; Login and authentication are dealt with at this level, if required.; Return 0 in case of success, 1 if the remote server is a 'proofd',; -1 in case of error. ~TXProofMgr(); Destructor: close the connection. void SetInvalid(); Invalidate this manager by closing the connection. TProof * AttachSession(TProofDesc* d, Bool_t gui = kFALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. The boolena 'gui' should be kTRUE when invoked from the GUI. void DetachSession(Int_t , Option_t* = """"); Detach session with 'id' from its proofserv. The 'id' is the number; shown by QuerySessions. The correspondent TProof object is deleted.; If id == 0 all the known sessions are detached.; Option opt=""S"" or ""s"" forces session shutdown. void DetachSession(TProof* , Option_t* = """"); Detach session 'p' from its proofserv. The instance 'p' is invalidated; and should be deleted by the caller. Bool_t MatchUrl(const char* url); Checks if 'url",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXProofMgr.html:10574,authenticat,authentication,10574,root/html602/TXProofMgr.html,https://root.cern,https://root.cern/root/html602/TXProofMgr.html,2,['authenticat'],['authentication']
Security,"Zombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooDataHist_dh; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParamHistFunc.html:34240,validat,validate,34240,root/html602/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html602/RooParamHistFunc.html,4,"['access', 'validat']","['access', 'validate']"
Security,"[0] ; arr1[1]+arr2[1] and arr1[2]+0; Or with a variable size array arr3; tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); As a comparison; tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; will draw the sum arr3 for the index 0 to 2 only if the; actual_size_of_arr3 is greater or equal to 3.; Note that the array in 'primary' is flattened/linearized thus using; Alt$ with multi-dimensional arrays of different dimensions in unlikely; to yield the expected results. To visualize a bit more what elements; would be matched by TTree::Draw, TTree::Scan can be used:; tree->Scan(""arr1:Alt$(arr2,0)"");; will print on one line the value of arr1 and (arr2,0) that will be; matched by; tree->Draw(""arr1-Alt$(arr2,0)"");. The ternary operator is not directly supported in TTree::Draw however, to plot the; equivalent of 'var2<20 ? -99 : var1', you can use:; tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");. Drawing a user function accessing the TTree data directly. If the formula contains a file name, TTree::MakeProxy will be used; to load and execute this file. In particular it will draw the; result of a function with the same name as the file. The function; will be executed in a context where the name of the branches can; be used as a C++ variable. For example draw px using the file hsimple.root (generated by the; hsimple.C tutorial), we need a file named hsimple.cxx:. double hsimple() {; return px;; }. MakeProxy can then be used indirectly via the TTree::Draw interface; as follow:; new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");. A more complete example is available in the tutorials directory:; h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; which reimplement the selector found in h1analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:80931,access,accessing,80931,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['access'],['accessing']
Security,"[3/4]. template<class IT > . ROOT::Math::AxisAngle::AxisAngle ; (; IT ; begin, . IT ; end . ). inline . Construct given a pair of pointers or iterators defining the beginning and end of an array of four Scalars, to be treated as the x, y, and z components of a unit axis vector, and the angle of rotation. ; Precondition: The first three components are assumed to represent the rotation axis vector and the 4-th the rotation angle. The angle is assumed to be in the range (-pi,pi]. The axis vector is automatically normalized to be a unit vector ; Definition at line 78 of file AxisAngle.h. ◆ AxisAngle() [4/4]. template<class OtherRotation > . constexpr ROOT::Math::AxisAngle::AxisAngle ; (; const OtherRotation & ; r). inlineexplicitconstexpr . Construct from another supported rotation type (see gv_detail::convert ) ; Definition at line 94 of file AxisAngle.h. Member Function Documentation. ◆ Angle(). Scalar ROOT::Math::AxisAngle::Angle ; (; ); const. inline . access to rotation angle ; Definition at line 183 of file AxisAngle.h. ◆ Axis(). AxisVector ROOT::Math::AxisAngle::Axis ; (; ); const. inline . access to rotation axis ; Definition at line 178 of file AxisAngle.h. ◆ Distance(). template<class R > . Scalar ROOT::Math::AxisAngle::Distance ; (; const R & ; r); const. inline . Distance between two rotations. ; Definition at line 288 of file AxisAngle.h. ◆ GetComponents() [1/3]. template<class AnyVector > . void ROOT::Math::AxisAngle::GetComponents ; (; AnyVector & ; axis, . Scalar & ; angle . ); const. inline . Set components into a non-zero vector (x,y,z) and an angle. ; The vector is intended to be a cartesian displacement vector but any vector class assignable from one will work. ; Definition at line 170 of file AxisAngle.h. ◆ GetComponents() [2/3]. template<class IT > . void ROOT::Math::AxisAngle::GetComponents ; (; IT ; begin); const. inline . Get the axis and then the angle into data specified by an iterator begin. ; Definition at line 145 of file AxisAngle.h. ◆ GetC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AxisAngle.html:6894,access,access,6894,doc/master/classROOT_1_1Math_1_1AxisAngle.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AxisAngle.html,1,['access'],['access']
Security,"[curBufferPos++] = 0x80;; 244 while (curBufferPos != (64 - 8)) {; 245 curBufferPos &= 0x3F;; 246 if (curBufferPos == 0); 247 sha256_write_byte_block(p);; 248 p->buffer[curBufferPos++] = 0;; 249 }; 250 for (i = 0; i < 8; i++) {; 251 p->buffer[curBufferPos++] = (unsigned char)(lenInBits >> 56);; 252 lenInBits <<= 8;; 253 }; 254 sha256_write_byte_block(p);; 255 ; 256 for (i = 0; i < 8; i++) {; 257 *digest++ = (unsigned char)(p->state[i] >> 24);; 258 *digest++ = (unsigned char)(p->state[i] >> 16);; 259 *digest++ = (unsigned char)(p->state[i] >> 8);; 260 *digest++ = (unsigned char)(p->state[i]);; 261 }; 262 sha256_init(p);; 263}; 264 ; 265} // End NS SHA256; 266 ; 267void Sha256(const unsigned char *data, int len, ULong64_t *fDigest); 268{; 269 // Here the final cast is to match the interface of the C code and; 270 // the data member. The length is the same!; 271 SHA256::sha256_t hash;; 272 SHA256::sha256_init(&hash);; 273 SHA256::sha256_update(&hash, data, len);; 274 SHA256::sha256_final(&hash, reinterpret_cast<unsigned char *>(fDigest));; 275}; 276 ; 277} // End NS Internal; 278} // End NS ROOT; 279 ; 280#endif; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; RX_8#define RX_8(i)Definition RSha256.hxx:115; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; Rtypes.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; lenOption_t Option_t TPoint TPoint const char GetTextMag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSha256_8hxx_source.html:8291,hash,hash,8291,doc/master/RSha256_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RSha256_8hxx_source.html,4,['hash'],['hash']
Security,"[curBufferPos++] = 0x80;; 244 while (curBufferPos != (64 - 8)) {; 245 curBufferPos &= 0x3F;; 246 if (curBufferPos == 0); 247 sha256_write_byte_block(p);; 248 p->buffer[curBufferPos++] = 0;; 249 }; 250 for (i = 0; i < 8; i++) {; 251 p->buffer[curBufferPos++] = (unsigned char)(lenInBits >> 56);; 252 lenInBits <<= 8;; 253 }; 254 sha256_write_byte_block(p);; 255 ; 256 for (i = 0; i < 8; i++) {; 257 *digest++ = (unsigned char)(p->state[i] >> 24);; 258 *digest++ = (unsigned char)(p->state[i] >> 16);; 259 *digest++ = (unsigned char)(p->state[i] >> 8);; 260 *digest++ = (unsigned char)(p->state[i]);; 261 }; 262 sha256_init(p);; 263}; 264 ; 265} // End NS SHA256; 266 ; 267void Sha256(const unsigned char *data, int len, ULong64_t *fDigest); 268{; 269 // Here the final cast is to match the interface of the C code and; 270 // the data member. The length is the same!; 271 SHA256::sha256_t hash;; 272 SHA256::sha256_init(&hash);; 273 SHA256::sha256_update(&hash, data, len);; 274 SHA256::sha256_final(&hash, reinterpret_cast<unsigned char *>(fDigest));; 275}; 276 ; 277} // End NS Internal; 278} // End NS ROOT; 279 ; 280#endif; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; RX_8#define RX_8(i)Definition RSha256.hxx:115; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:81; Rtypes.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; lenOption_t Option_t TPoint TPoint const char GetTextMag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RSha256_8hxx_source.html:8290,hash,hash,8290,doc/v632/RSha256_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RSha256_8hxx_source.html,4,['hash'],['hash']
Security,"[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. stringRooAbsTestStatistic::_addCoefRangeNameName of reference to be used for RooAddPdf components; list<RooAbsBinning*>_binList! Bin ranges; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_extendedIs the input function and extended p.d.f.; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:31888,validat,validate,31888,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,3,['validat'],['validate']
Security,"\"" %d %"" INT64_FMT; 15386 "" %s %s"",; 15387 src_addr,; 15388 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15389 date,; 15390 ri->request_method ? ri->request_method : ""-"",; 15391 ri->request_uri ? ri->request_uri : ""-"",; 15392 ri->query_string ? ""?"" : """",; 15393 ri->query_string ? ri->query_string : """",; 15394 ri->http_version,; 15395 conn->status_code,; 15396 conn->num_bytes_sent,; 15397 referer,; 15398 user_agent);; 15399 }; 15400 ; 15401 /* Here we have a log message in log_buf. Call the callback */; 15402 if (conn->phys_ctx->callbacks.log_access) {; 15403 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15404 /* do not log if callack returns non-zero */; 15405 if (fi.access.fp) {; 15406 mg_fclose(&fi.access);; 15407 }; 15408 return;; 15409 }; 15410 }; 15411 ; 15412 /* Store in file */; 15413 if (fi.access.fp) {; 15414 int ok = 1;; 15415 flockfile(fi.access.fp);; 15416 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15417 ok = 0;; 15418 }; 15419 if (fflush(fi.access.fp) != 0) {; 15420 ok = 0;; 15421 }; 15422 funlockfile(fi.access.fp);; 15423 if (mg_fclose(&fi.access) != 0) {; 15424 ok = 0;; 15425 }; 15426 if (!ok) {; 15427 mg_cry_internal(conn,; 15428 ""Error writing log file %s"",; 15429 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15430 }; 15431 }; 15432}; 15433#else; 15434#error ""Either enable filesystems or provide a custom log_access implementation""; 15435#endif /* Externally provided function */; 15436 ; 15437 ; 15438/* Verify given socket address against the ACL.; 15439 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15440 */; 15441static int; 15442check_acl(struct mg_context *phys_ctx, const union usa *sa); 15443{; 15444 int allowed, flag, matched;; 15445 struct vec vec;; 15446 ; 15447 if (phys_ctx) {; 15448 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15449 ; 15450 /* If any ACL is set, deny by default */; 15451 allowed = (list == NULL) ? '+' : '-';; 15452 ; 15453 while ((list = next_option(list,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:455908,access,access,455908,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"\"" %d %"" INT64_FMT; 15387 "" %s %s"",; 15388 src_addr,; 15389 (ri->remote_user == NULL) ? ""-"" : ri->remote_user,; 15390 date,; 15391 ri->request_method ? ri->request_method : ""-"",; 15392 ri->request_uri ? ri->request_uri : ""-"",; 15393 ri->query_string ? ""?"" : """",; 15394 ri->query_string ? ri->query_string : """",; 15395 ri->http_version,; 15396 conn->status_code,; 15397 conn->num_bytes_sent,; 15398 referer,; 15399 user_agent);; 15400 }; 15401 ; 15402 /* Here we have a log message in log_buf. Call the callback */; 15403 if (conn->phys_ctx->callbacks.log_access) {; 15404 if (conn->phys_ctx->callbacks.log_access(conn, log_buf)) {; 15405 /* do not log if callack returns non-zero */; 15406 if (fi.access.fp) {; 15407 mg_fclose(&fi.access);; 15408 }; 15409 return;; 15410 }; 15411 }; 15412 ; 15413 /* Store in file */; 15414 if (fi.access.fp) {; 15415 int ok = 1;; 15416 flockfile(fi.access.fp);; 15417 if (fprintf(fi.access.fp, ""%s\n"", log_buf) < 1) {; 15418 ok = 0;; 15419 }; 15420 if (fflush(fi.access.fp) != 0) {; 15421 ok = 0;; 15422 }; 15423 funlockfile(fi.access.fp);; 15424 if (mg_fclose(&fi.access) != 0) {; 15425 ok = 0;; 15426 }; 15427 if (!ok) {; 15428 mg_cry_internal(conn,; 15429 ""Error writing log file %s"",; 15430 conn->dom_ctx->config[ACCESS_LOG_FILE]);; 15431 }; 15432 }; 15433}; 15434#else; 15435#error ""Either enable filesystems or provide a custom log_access implementation""; 15436#endif /* Externally provided function */; 15437 ; 15438 ; 15439/* Verify given socket address against the ACL.; 15440 * Return -1 if ACL is malformed, 0 if address is disallowed, 1 if allowed.; 15441 */; 15442static int; 15443check_acl(struct mg_context *phys_ctx, const union usa *sa); 15444{; 15445 int allowed, flag, matched;; 15446 struct vec vec;; 15447 ; 15448 if (phys_ctx) {; 15449 const char *list = phys_ctx->dd.config[ACCESS_CONTROL_LIST];; 15450 ; 15451 /* If any ACL is set, deny by default */; 15452 allowed = (list == NULL) ? '+' : '-';; 15453 ; 15454 while ((list = next_option(list,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:455941,access,access,455941,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"\'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it. Casts are; // necessary as the type information can not be otherwise derived.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] std::string s = (char*)m.gime( ""aap"" );; root [9] s; (class TString)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const char* cmd); static voidExecScript(const char* name, int argc = 0, const char** argv = 0); virtual TClass*IsA() const; static voidLoadMacro(const char* name); static Bool_tMethodProxy_Check(PyObject* pyobject); static Bool_tMethodProxy_CheckExact(PyObject* pyobject); static void*ObjectProxy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPython.html:1904,access,access,1904,root/html534/TPython.html,https://root.cern,https://root.cern/root/html534/TPython.html,1,['access'],['access']
Security,"\'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it. Casts are; // necessary as the type information can not be otherwise derived.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] std::string s = (char*)m.gime( ""aap"" );; root [9] s; (class TString)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const char* cmd); static voidExecScript(const char* name, int argc = 0, const char** argv = 0); virtual TClass*IsA() const; static voidLoadMacro(const char* name); static void*ObjectProxy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname); TPython&operator=(const TPython&); static voidPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPython.html:1904,access,access,1904,root/html530/TPython.html,https://root.cern,https://root.cern/root/html530/TPython.html,2,['access'],['access']
Security,"]); 773 /// df.DefinePerSample('weightbysample', 'rdfsampleinfo_.Contains(""sample1"") ? 1.0f : 2.0f'); 774 /// ~~~; 775 ///; 776 /// \note; 777 /// If you have declared some C++ function to the interpreter, the correct syntax to call that function with this; 778 /// overload of DefinePerSample is by calling it explicitly with the special names `rdfslot_` and `rdfsampleinfo_` as; 779 /// input parameters. This is for example the correct way to call this overload when working in PyROOT:; 780 /// ~~~{.py}; 781 /// ROOT.gInterpreter.Declare(; 782 /// """"""; 783 /// float weights(unsigned int slot, const ROOT::RDF::RSampleInfo &id){; 784 /// return id.Contains(""sample1"") ? 1.0f : 2.0f;; 785 /// }; 786 /// """"""); 787 /// df = ROOT.RDataFrame(""mytree"", [""sample1.root"",""sample2.root""]); 788 /// df.DefinePerSample(""weightsbysample"", ""weights(rdfslot_, rdfsampleinfo_)""); 789 /// ~~~; 790 ///; 791 /// \note; 792 /// Differently from what happens in Define(), the string expression passed to DefinePerSample cannot contain; 793 /// column names other than those mentioned above: the expression is evaluated once before the processing of the; 794 /// sample even starts, so column values are not accessible.; 795 // clang-format on; 796 RInterface<Proxied, DS_t> DefinePerSample(std::string_view name, std::string_view expression); 797 {; 798 RDFInternal::CheckValidCppVarName(name, ""DefinePerSample"");; 799 // these checks must be done before jitting lest we throw exceptions in jitted code; 800 RDFInternal::CheckForRedefinition(""DefinePerSample"", name, fColRegister, fLoopManager->GetBranchNames(),; 801 fDataSource ? fDataSource->GetColumnNames() : ColumnNames_t{});; 802 ; 803 auto upcastNodeOnHeap = RDFInternal::MakeSharedOnHeap(RDFInternal::UpcastNode(fProxiedPtr));; 804 auto jittedDefine =; 805 RDFInternal::BookDefinePerSampleJit(name, expression, *fLoopManager, fColRegister, upcastNodeOnHeap);; 806 ; 807 RDFInternal::RColumnRegister newCols(fColRegister);; 808 newCols.AddDefine(std::move(j",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:42249,access,accessible,42249,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['access'],['accessible']
Security,"]. DictFuncPtr_t TClassTable::GetDict ; (; const std::type_info & ; info). static . Given the std::type_info returns the Dictionary() function of a class (uses hash of std::type_info::name()). ; Definition at line 692 of file TClassTable.cxx. ◆ GetDictNorm(). DictFuncPtr_t TClassTable::GetDictNorm ; (; const char * ; cname). static . Given the normalized class name returns the Dictionary() function of a class (uses hash of name). ; Definition at line 717 of file TClassTable.cxx. ◆ GetID(). Version_t TClassTable::GetID ; (; const char * ; cname). static . Returns the ID of a class. ; Definition at line 647 of file TClassTable.cxx. ◆ GetPragmaBits(). Int_t TClassTable::GetPragmaBits ; (; const char * ; name). static . Returns the pragma bits as specified in the LinkDef.h file. ; Definition at line 660 of file TClassTable.cxx. ◆ GetProto(). TProtoClass * TClassTable::GetProto ; (; const char * ; cname). static . Given the class name returns the TClassProto object for the class. ; (uses hash of name). ; Definition at line 742 of file TClassTable.cxx. ◆ GetProtoNorm(). TProtoClass * TClassTable::GetProtoNorm ; (; const char * ; cname). static . Given the class normalized name returns the TClassProto object for the class. ; (uses hash of name). ; Definition at line 770 of file TClassTable.cxx. ◆ Init(). void TClassTable::Init ; (; ). static . Definition at line 390 of file TClassTable.cxx. ◆ IsA(). TClass * TClassTable::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 101 of file TClassTable.h. ◆ Next(). char * TClassTable::Next ; (; ). static . Returns next class from sorted class table. ; Don't use this iterator while modifying the class table. The class table can be modified when making calls like TClass::GetClass(), etc. ; Definition at line 807 of file TClassTable.cxx. ◆ Print(). void TClassTable::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print the class table. ; B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTable.html:18066,hash,hash,18066,doc/master/classTClassTable.html,https://root.cern,https://root.cern/doc/master/classTClassTable.html,1,['hash'],['hash']
Security,"]. char * TString::GetShortPointer ; (; ). inlineprivate . Definition at line 254 of file TString.h. ◆ GetShortPointer() [2/2]. const char * TString::GetShortPointer ; (; ); const. inlineprivate . Definition at line 255 of file TString.h. ◆ GetShortSize(). Ssiz_t TString::GetShortSize ; (; ); const. inlineprivate . Definition at line 244 of file TString.h. ◆ Hash() [1/2]. UInt_t TString::Hash ; (; const void * ; txt, . Int_t ; ntxt . ). static . Calculates hash index from any char string. ; (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher/ . Definition at line 850 of file TString.cxx. ◆ Hash() [2/2]. UInt_t TString::Hash ; (; ECaseCompare ; cmp = kExact); const. Return hash value. ; Definition at line 677 of file TString.cxx. ◆ HashCase(). UInt_t TString::HashCase ; (; ); const. private . Return a case-sensitive hash value (endian independent). ; Definition at line 633 of file TString.cxx. ◆ HashFoldCase(). UInt_t TString::HashFoldCase ; (; ); const. private . Return a case-insensitive hash value (endian independent). ; Definition at line 662 of file TString.cxx. ◆ Index() [1/8]. Ssiz_t TString::Index ; (; const char * ; pat, . Ssiz_t ; i = 0, . ECaseCompare ; cmp = kExact . ); const. inline . Definition at line 651 of file TString.h. ◆ Index() [2/8]. Ssiz_t TString::Index ; (; const char * ; pattern, . Ssiz_t ; plen, . Ssiz_t ; startIndex, . ECaseCompare ; cmp . ); const. Search for a string in the TString. ; Plen is the length of pattern, startIndex is the index from which to start and cmp selects the type of case-comparison. ; Definition at line 901 of file TString.cxx. ◆ Index() [3/8]. Ssiz_t TString::Index ; (; const TRegexp & ; r, . Ssiz_t * ; ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTString.html:34156,hash,hash,34156,doc/v632/classTString.html,https://root.cern,https://root.cern/doc/v632/classTString.html,2,['hash'],['hash']
Security,"];; 2907 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2908 switch (mode) {; 2909 case MG_FOPEN_MODE_READ:; 2910 filep->access.fp = _wfopen(wbuf, L""rb"");; 2911 break;; 2912 case MG_FOPEN_MODE_WRITE:; 2913 filep->access.fp = _wfopen(wbuf, L""wb"");; 2914 break;; 2915 case MG_FOPEN_MODE_APPEND:; 2916 filep->access.fp = _wfopen(wbuf, L""ab"");; 2917 break;; 2918 }; 2919 }; 2920#else; 2921 /* Linux et al already use unicode. No need to convert. */; 2922 switch (mode) {; 2923 case MG_FOPEN_MODE_READ:; 2924 filep->access.fp = fopen(path, ""r"");; 2925 break;; 2926 case MG_FOPEN_MODE_WRITE:; 2927 filep->access.fp = fopen(path, ""w"");; 2928 break;; 2929 case MG_FOPEN_MODE_APPEND:; 2930 filep->access.fp = fopen(path, ""a"");; 2931 break;; 2932 }; 2933 ; 2934#endif; 2935 if (!found) {; 2936 /* File did not exist before fopen was called.; 2937 * Maybe it has been created now. Get stat info; 2938 * like creation time now. */; 2939 found = mg_stat(conn, path, &(filep->stat));; 2940 (void)found;; 2941 }; 2942 ; 2943 /* return OK if file is opened */; 2944 return (filep->access.fp != NULL);; 2945}; 2946 ; 2947 ; 2948/* return 0 on success, just like fclose */; 2949static int; 2950mg_fclose(struct mg_file_access *fileacc); 2951{; 2952 int ret = -1;; 2953 if (fileacc != NULL) {; 2954 if (fileacc->fp != NULL) {; 2955 ret = fclose(fileacc->fp);; 2956 }; 2957 /* reset all members of fileacc */; 2958 memset(fileacc, 0, sizeof(*fileacc));; 2959 }; 2960 return ret;; 2961}; 2962#endif /* NO_FILESYSTEMS */; 2963 ; 2964 ; 2965static void; 2966mg_strlcpy(char *dst, const char *src, size_t n); 2967{; 2968 for (; *src != '\0' && n > 1; n--) {; 2969 *dst++ = *src++;; 2970 }; 2971 *dst = '\0';; 2972}; 2973 ; 2974 ; 2975static int; 2976lowercase(const char *s); 2977{; 2978 return tolower((unsigned char)*s);; 2979}; 2980 ; 2981 ; 2982int; 2983mg_strncasecmp(const char *s1, const char *s2, size_t len); 2984{; 2985 int diff = 0;; 2986 ; 2987 if (len > 0) {; 2988 do {; 2989 diff = lowercase(s1++) - lowe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:89915,access,access,89915,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"];; 2908 path_to_unicode(conn, path, wbuf, ARRAY_SIZE(wbuf));; 2909 switch (mode) {; 2910 case MG_FOPEN_MODE_READ:; 2911 filep->access.fp = _wfopen(wbuf, L""rb"");; 2912 break;; 2913 case MG_FOPEN_MODE_WRITE:; 2914 filep->access.fp = _wfopen(wbuf, L""wb"");; 2915 break;; 2916 case MG_FOPEN_MODE_APPEND:; 2917 filep->access.fp = _wfopen(wbuf, L""ab"");; 2918 break;; 2919 }; 2920 }; 2921#else; 2922 /* Linux et al already use unicode. No need to convert. */; 2923 switch (mode) {; 2924 case MG_FOPEN_MODE_READ:; 2925 filep->access.fp = fopen(path, ""r"");; 2926 break;; 2927 case MG_FOPEN_MODE_WRITE:; 2928 filep->access.fp = fopen(path, ""w"");; 2929 break;; 2930 case MG_FOPEN_MODE_APPEND:; 2931 filep->access.fp = fopen(path, ""a"");; 2932 break;; 2933 }; 2934 ; 2935#endif; 2936 if (!found) {; 2937 /* File did not exist before fopen was called.; 2938 * Maybe it has been created now. Get stat info; 2939 * like creation time now. */; 2940 found = mg_stat(conn, path, &(filep->stat));; 2941 (void)found;; 2942 }; 2943 ; 2944 /* return OK if file is opened */; 2945 return (filep->access.fp != NULL);; 2946}; 2947 ; 2948 ; 2949/* return 0 on success, just like fclose */; 2950static int; 2951mg_fclose(struct mg_file_access *fileacc); 2952{; 2953 int ret = -1;; 2954 if (fileacc != NULL) {; 2955 if (fileacc->fp != NULL) {; 2956 ret = fclose(fileacc->fp);; 2957 }; 2958 /* reset all members of fileacc */; 2959 memset(fileacc, 0, sizeof(*fileacc));; 2960 }; 2961 return ret;; 2962}; 2963#endif /* NO_FILESYSTEMS */; 2964 ; 2965 ; 2966static void; 2967mg_strlcpy(char *dst, const char *src, size_t n); 2968{; 2969 for (; *src != '\0' && n > 1; n--) {; 2970 *dst++ = *src++;; 2971 }; 2972 *dst = '\0';; 2973}; 2974 ; 2975 ; 2976static int; 2977lowercase(const char *s); 2978{; 2979 return tolower((unsigned char)*s);; 2980}; 2981 ; 2982 ; 2983int; 2984mg_strncasecmp(const char *s1, const char *s2, size_t len); 2985{; 2986 int diff = 0;; 2987 ; 2988 if (len > 0) {; 2989 do {; 2990 diff = lowercase(s1++) - lowe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:89947,access,access,89947,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"][]"" is:. for (Int_t i0; i < min(3,5); i++) {; for (Int_t i1; i1 < min(3,2); i1++) {; use the value of (fMatrix[i0][i1] - fMatrix[i0][i1]); }; }. So the loop equivalent to ""fMatrix[][fResults[][]]"" is:. for (Int_t i0; i0 < 3; i0++) {; for (Int_t j2; j2 < 5; j2++) {; for (Int_t j3; j3 < 2; j3++) {; i1 = fResults[j2][j3];; use the value of fMatrix[i0][i1]; }; }. Retrieving the result of Draw. By default the temporary histogram created is called ""htemp"", but only in; the one dimensional Draw(""e1"") it contains the TTree's data points. For; a two dimensional Draw, the data is filled into a TGraph which is named; ""Graph"". They can be retrieved by calling; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D. For a three and four dimensional Draw the TPloyMarker3D is unnamed, and; cannot be retrieved. gPad always contains a TH1 derived object called ""htemp"" which allows to; access the axes:; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D; TH2F *htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // empty, but has axes; TAxis *xaxis = htemp->GetXaxis();. Saving the result of Draw to an histogram. If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory (and also the current pad). This works for all dimensions.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. To retrieve it do:; TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");. The binning information is taken from the environment variables. Hist.Binning.?D.?. In addition, the name of the histogram can be followed by up to 9; numbers between '(' and ')', where the numbers describe the; following:. 1 - bins in x-direction; 2 - lower limit in x-direction; 3 - upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction. When a new binning is used the new value will become the defau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:70892,access,access,70892,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,2,['access'],['access']
Security,"][]"" is:. for (Int_t i0; i < min(3,5); i++) {; for (Int_t i1; i1 < min(3,2); i1++) {; use the value of (fMatrix[i0][i1] - fMatrix[i0][i1]); }; }. So the loop equivalent to ""fMatrix[][fResults[][]]"" is:. for (Int_t i0; i0 < 3; i0++) {; for (Int_t j2; j2 < 5; j2++) {; for (Int_t j3; j3 < 2; j3++) {; i1 = fResults[j2][j3];; use the value of fMatrix[i0][i1]; }; }. Retrieving the result of Draw. By default the temporary histogram created is called ""htemp"", but only in; the one dimensional Draw(""e1"") it contains the TTree's data points. For; a two dimensional Draw, the data is filled into a TGraph which is named; ""Graph"". They can be retrieved by calling; TH1F *htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D. For a three and four dimensional Draw the TPolyMarker3D is unnamed, and; cannot be retrieved. gPad always contains a TH1 derived object called ""htemp"" which allows to; access the axes:; TGraph *graph = (TGraph*)gPad->GetPrimitive(""Graph""); // 2D; TH2F *htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // empty, but has axes; TAxis *xaxis = htemp->GetXaxis();. Saving the result of Draw to an histogram. If varexp0 contains >>hnew (following the variable(s) name(s),; the new histogram created is called hnew and it is kept in the current; directory (and also the current pad). This works for all dimensions.; Example:; tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); will draw sqrt(x) and save the histogram as ""hsqrt"" in the current; directory. To retrieve it do:; TH1F *hsqrt = (TH1F*)gDirectory->Get(""hsqrt"");. The binning information is taken from the environment variables. Hist.Binning.?D.?. In addition, the name of the histogram can be followed by up to 9; numbers between '(' and ')', where the numbers describe the; following:. 1 - bins in x-direction; 2 - lower limit in x-direction; 3 - upper limit in x-direction; 4-6 same for y-direction; 7-9 same for z-direction. When a new binning is used the new value will become the defau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:74232,access,access,74232,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['access'],['access']
Security,"_LEN; static TZIPFile::EZIPConstantskZIP64_EXTENDED_DISK_OFF; static TZIPFile::EZIPConstantskZIP64_EXTENDED_HDR_OFFSET_LEN; static TZIPFile::EZIPConstantskZIP64_EXTENDED_HDR_OFFSET_OFF; static TZIPFile::EZIPConstantskZIP64_EXTENDED_MAGIC; static TZIPFile::EZIPConstantskZIP64_EXTENDED_MAGIC_LEN; static TZIPFile::EZIPConstantskZIP64_EXTENDED_MAGIC_OFF; static TZIPFile::EZIPConstantskZIP64_EXTENDED_SIZE; static TZIPFile::EZIPConstantskZIP64_EXTENDED_SIZE_LEN; static TZIPFile::EZIPConstantskZIP64_EXTENDED_SIZE_OFF; static TZIPFile::EZIPConstantskZIP64_EXTENDED_USIZE_LEN; static TZIPFile::EZIPConstantskZIP64_EXTENDED_USIZE_OFF; static TZIPFile::EZIPConstantskZIP64_EXTENTED_CSIZE_OFF; static TZIPFile::EZIPConstantskZIP_MAGIC_LEN. Class Charts. Inheritance Chart:. TObject. ←; TArchiveFile. ←; TZIPFile. Function documentation; TZIPFile(); Default ctor. TZIPFile(const char* archive, const char* member, TFile* file); Specify the archive name and member name. The member can be a decimal; number which allows to access the n-th member. Int_t OpenArchive(); Open archive and read end-header and directory. Returns -1 in case; of error, 0 otherwise. Long64_t FindEndHeader(); Find the end header of the ZIP archive. Returns 0 in case of error. Int_t ReadEndHeader(Long64_t pos); Read the end header of the ZIP archive including the archive comment; at the current file position. Check that it really was a single-disk; archive with all the entries as expected. Most importantly, figure; out where the central directory begins. Returns -1 in case of error,; 0 otherwise. Long64_t ReadZip64EndLocator(Long64_t pos); Read Zip64 end of central directory locator. Returns -1 in case of error,; -2 in case end locator magic is not found (i.e. not a zip64 file) and; offset of Zip64 end of central directory record in case of success. Int_t ReadZip64EndRecord(Long64_t pos); Read Zip64 end of central directory record. Returns -1 in case of error; and 0 in case of success. Int_t ReadDirectory(); Read the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TZIPFile.html:15766,access,access,15766,root/html602/TZIPFile.html,https://root.cern,https://root.cern/root/html602/TZIPFile.html,2,['access'],['access']
Security,"_StreamerNVirtual_b);  ; void VisibleDaughters (Bool_t vis=kTRUE);  Set visibility of the daughters (obsolete). ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNode.html:11710,hash,hash,11710,doc/master/classTGeoNode.html,https://root.cern,https://root.cern/doc/master/classTGeoNode.html,3,['hash'],['hash']
Security,"____________________________________________________________; 1057 ; 1058ClassImp(TClass);; 1059 ; 1060////////////////////////////////////////////////////////////////////////////////; 1061/// Internal, default constructor.; 1062///; 1063/// \note Use `TClass::GetClass(""ClassName"")` to get access to a TClass object for a certain class!; 1064 ; 1065TClass::TClass() :; 1066 TDictionary(),; 1067 fPersistentRef(nullptr),; 1068 fStreamerInfo(nullptr), fConversionStreamerInfo(nullptr), fRealData(nullptr),; 1069 fBase(nullptr), fData(nullptr), fUsingData(nullptr), fEnums(nullptr), fFuncTemplate(nullptr), fMethod(nullptr), fAllPubData(nullptr),; 1070 fAllPubMethod(nullptr), fClassMenuList(nullptr),; 1071 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1072 fInstanceCount(0), fOnHeap(0),; 1073 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1074 fTypeInfo(nullptr), fShowMembers(nullptr),; 1075 fStreamer(nullptr), fIsA(nullptr), fGlobalIsA(nullptr), fIsAMethod(nullptr),; 1076 fMerge(nullptr), fResetAfterMerge(nullptr), fNew(nullptr), fNewArray(nullptr), fDelete(nullptr), fDeleteArray(nullptr),; 1077 fDestructor(nullptr), fDirAutoAdd(nullptr), fStreamerFunc(nullptr), fConvStreamerFunc(nullptr), fSizeof(-1),; 1078 fCanSplit(-1), fIsSyntheticPair(kFALSE), fHasCustomStreamerMember(kFALSE), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),; 1079 fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),; 1080 fState(kNoInfo),; 1081 fCurrentInfo(nullptr), fLastReadInfo(nullptr), fRefProxy(nullptr),; 1082 fSchemaRules(nullptr), fStreamerImpl(&TClass::StreamerDefault); 1083 ; 1084{; 1085 // Default ctor.; 1086 ; 1087 R__LOCKGUARD(gInterpreterMutex);; 1088 {; 1089 TMmallocDescTemp setreset;; 1090 fStreamerInfo = new TObjArray(1, -2);; 1091 }; 1092 fDeclFileLine = -2; // -2 for standalone TClass (checked in dtor); 1093}; 109",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:36337,access,access,36337,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['access']
Security,"____________________________________________________________; 1124 ; 1125ClassImp(TClass);; 1126 ; 1127////////////////////////////////////////////////////////////////////////////////; 1128/// Internal, default constructor.; 1129///; 1130/// \note Use `TClass::GetClass(""ClassName"")` to get access to a TClass object for a certain class!; 1131 ; 1132TClass::TClass() :; 1133 TDictionary(),; 1134 fPersistentRef(nullptr),; 1135 fStreamerInfo(nullptr), fConversionStreamerInfo(nullptr), fRealData(nullptr),; 1136 fBase(nullptr), fData(nullptr), fUsingData(nullptr), fEnums(nullptr), fFuncTemplate(nullptr), fMethod(nullptr), fAllPubData(nullptr),; 1137 fAllPubMethod(nullptr), fClassMenuList(nullptr),; 1138 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1139 fInstanceCount(0), fOnHeap(0),; 1140 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1141 fTypeInfo(nullptr), fShowMembers(nullptr),; 1142 fStreamer(nullptr), fIsA(nullptr), fGlobalIsA(nullptr), fIsAMethod(nullptr),; 1143 fMerge(nullptr), fResetAfterMerge(nullptr), fNew(nullptr), fNewArray(nullptr), fDelete(nullptr), fDeleteArray(nullptr),; 1144 fDestructor(nullptr), fDirAutoAdd(nullptr), fStreamerFunc(nullptr), fConvStreamerFunc(nullptr), fSizeof(-1),; 1145 fCanSplit(-1), fIsSyntheticPair(kFALSE), fHasCustomStreamerMember(kFALSE), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),; 1146 fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),; 1147 fState(kNoInfo),; 1148 fCurrentInfo(nullptr), fLastReadInfo(nullptr), fRefProxy(nullptr),; 1149 fSchemaRules(nullptr), fStreamerImpl(&TClass::StreamerDefault); 1150 ; 1151{; 1152 // Default ctor.; 1153 ; 1154 R__LOCKGUARD(gInterpreterMutex);; 1155 {; 1156 TMmallocDescTemp setreset;; 1157 fStreamerInfo = new TObjArray(1, -2);; 1158 }; 1159 fDeclFileLine = -2; // -2 for standalone TClass (checked in dtor); 1160}; 116",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:39088,access,access,39088,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['access']
Security,"_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnPdfBinding.html:41558,access,access,41558,root/html602/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnPdfBinding.html,2,['access'],['access']
Security,"_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Bool_t_flip; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGExpModel.html:43178,access,access,43178,root/html534/RooGExpModel.html,https://root.cern,https://root.cern/root/html534/RooGExpModel.html,1,['access'],['access']
Security,_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooObjCacheManager_intCacheMgrManager of cache with integrals; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:42517,access,access,42517,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,1,['access'],['access']
Security,"_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; ROOT::Math::KahanSumThe Kahan summation is a compensated summation algorithm, which significantly reduces numerical error...Definition Util.h:122; ROOT::Math::KahanSum::SumT Sum() constDefinition Util.h:240; ROOT::Math::KahanSum::operator==bool operator==(KahanSum< U, M > const &other) constDefinition Util.h:305; ROOT::Math::KahanSum::operator-KahanSum< T, N > operator-()Definition Util.h:299; ROOT::Math::KahanSum::Accumulatestatic KahanSum< T, N > Accumulate(Iterator begin, Iterator end, T initialValue=T{})Iterate over a range and return an instance of a KahanSum.Definition Util.h:211; ROOT::Math::KahanSum::ResultT Result() constDefinition Util.h:245; ROOT::Math::KahanSum::Addvoid Add(Iterator begin, Iterator end)Accumulate from a range denoted by iterators.Definition Util.h:180; ROOT::Math::KahanSum::Addvoid Add(const Container_t &inputs)Fill from a container that supports index access.Definition Util.h:195; ROOT::Math::KahanSum::KahanSumKahanSum(KahanSum< T, M > const &other)Constructor to create a KahanSum from another KahanSum with a different number of accumulators.Definition Util.h:157; ROOT::Math::KahanSum::fCarryT fCarry[N]Definition Util.h:316; ROOT::Math::KahanSum::operator!=bool operator!=(KahanSum< U, M > const &other) constDefinition Util.h:310; ROOT::Math::KahanSum::CarryT Carry() constDefinition Util.h:250; ROOT::Math::KahanSum::AddIndexedvoid AddIndexed(T input, std::size_t index)Add input to the sum.Definition Util.h:231; ROOT::Math::KahanSum::operator+=KahanSum< T, N > & operator+=(T arg)Add arg into accumulator. Does not vectorise.Definition Util.h:255; ROOT::Math::KahanSum::operator+=KahanSum< T, N > & operator+=(const KahanSum< U, M > &other)Add other KahanSum into accumulator.Definition Util.h:277; ROOT::Math::KahanSum::fSumT fSum[N]Definition Util.h:315; ROOT::Math::KahanSum::KahanSumKaha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:15620,access,access,15620,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,1,['access'],['access']
Security,"_island"", ""south_carolina"", ""south_dakota"", ""tennessee"",; ""texas"", ""utah"", ""vermont"", ""virginia"",; ""washington"", ""west_virginia"", ""wisconsin"", ""wyoming""; };; Double_t pop[nx] = {; 4708708, 6595778, 2889450, 36961664, 5024748, 3518288, 885122, 18537969,; 9829211, 1545801, 12910409, 6423113, 3007856, 2818747, 4314113, 4492076,; 1318301, 5699478, 6593587, 9969727, 5266214, 2951996, 5987580, 974989,; 1796619, 2643085, 1324575, 8707739, 2009671, 19541453, 9380884, 646844,; 11542645, 3687050, 3825657, 12604767, 1053209, 4561242, 812383, 6296254,; 24782302, 2784572, 621760, 7882590, 6664195, 1819777, 5654774, 544270; };; ; TCanvas *usa = new TCanvas(""USA"", ""USA"");; usa->ToggleEventStatus();; Double_t lon1 = -130;; Double_t lon2 = -65;; Double_t lat1 = 24;; Double_t lat2 = 50;; TH2Poly *p = new TH2Poly(""Lower48"",""Lower 48 Population (2009);Latitude;Longitude"",lon1,lon2,lat1,lat2);; ; TFile::SetCacheFileDir(""."");; TFile *f = TFile::Open(""http://root.cern/files/usa.root"", ""CACHEREAD"");; ; if (!f) {; printf(""Cannot access usa.root. Is internet working ?\n"");; return;; }; ; // Define the TH2Poly bins.; TMultiGraph *mg;; TKey *key;; TIter nextkey(gDirectory->GetListOfKeys());; while ((key = (TKey*)nextkey())) {; TObject *obj = key->ReadObj();; if (obj->InheritsFrom(""TMultiGraph"")) {; mg = (TMultiGraph*)obj;; bin = p->AddBin(mg);; }; }; ; // Fill TH2Poly, with capital letters for the states names; for (i=0; i<nx; i++) p->Fill(states[i], pop[i]);; ; gStyle->SetOptStat(0);; p->Draw(""colz textn"");; ; // Add the reference for the population; TLatex pupulationRef(-128, 27, ""#scale[.55]{#splitline{Source:}{http://eadiv.state.wy.us/pop/st-09est.htm}}"");; pupulationRef.DrawClone();; }; f#define f(i)Definition RSha256.hxx:104; Int_tint Int_tDefinition RtypesCore.h:45; Double_tdouble Double_tDefinition RtypesCore.h:59; gDirectory#define gDirectoryDefinition TDirectory.h:384; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; gStyleR__EXTERN TStyle * gStyle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/th2polyUSA_8C.html:2235,access,access,2235,doc/master/th2polyUSA_8C.html,https://root.cern,https://root.cern/doc/master/th2polyUSA_8C.html,1,['access'],['access']
Security,"_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t, A > >;  CIterators;  CTFutureImpl;  CTRangeStaticCastTRangeStaticCast is an adaptater class that allows the typed iteration through a TCollection ;  ►CTSchemaRuleSet;  CTMatches;  ►CTStatusBitsChecker;  CRegistry;  CTTypedIterTTypedIter is a typed version of TIter ;  ►NExecutorUtilsThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CRArgsMenuItem;  CRCheckedMenuItem;  CRHistBinIterIterates over the bins of a RHist or RHistImpl ;  CRHistBinPtrPoints to a histogram bin (or actually a RHistBinRef) ;  CRHistBinRefRepresents a bin reference ;  CRHistBinStatConst view on a bin's statistical data ;  CRHistDataA RHistImplBase's data, provides accessors to all its statistics ;  CRHistImpl;  CRHistImplBaseInterface class for RHistImpl ;  CRHistImplPrecisionAgnosticBaseBase class for RHistImplBase that abstracts out the histogram's PRECISION ;  CRMenuArgument;  CRMenuItemClass contains info for producing menu item on the JS side ;  ►NHist;  CRCoordArray;  ►NInternal;  CAxisConfigToTypeConverts a RAxisConfig of whatever kind to the corresponding RAxisBase-derived object ;  CAxisConfigToType< RAxisConfig::kEquidistant >;  CAxisConfigToType< RAxisConfig::kGrow >;  CAxisConfigToType< RAxisConfig::kIrregular >;  CAxisConfigToType< RAxisConfig::kLabels >;  CRFillBinCoordFill coord with low bin edge or center or high bin edge of all axes ;  CRFillBinCoord<-1, COORD, AXES >;  CRFillIterRangeFill range with begin() and end() of all axes, including under/overflow as specified by over ;  CRFillIterRange<-1, AXES >;  CRGetBinCount;  CRGetBinCount< 0, AXES >;  CRGetBinIndex;  CRGetBinIndex<-1, HISTIMPL, AXES, GROW >;  CRHistBufferedFillBase;  C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:18241,access,accessors,18241,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,2,['access'],['accessors']
Security,"_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnections()Closes all connection to clients Normally leads to closing of all correspondent browser windows Some ...Definition RWebWindow.cxx:1438; ROOT::RWebWindow::fMasterstd::shared_ptr< RWebWindow > fMaster! master window where this window is embeddedDefinition RWebWindow.hxx:137; ROOT::RWebWindow::NumConnectionsint NumConnections(bool with_pending=false) constReturns current number of active clients connections.Definition RWebWindow.cxx:1330; ROOT::RWebWindow::fCallbacksThrdIdSetbool fCallbacksThrdIdSet! flag indicating that thread id is assignedDefinition RWebWindow.hxx:161; ROOT::RWebWindow::fUserArgsstd::string fUserArgs! arbitrary JSON code, which is accessible via conn.getUserArgs() methodDefinition RWebWindow.hxx:175; ROOT::RWebWindow::SetDefaultPagevoid SetDefaultPage(const std::string &page)Set content of default window HTML page This page returns when URL address of the window will be requ...Definition RWebWindow.hxx:257; ROOT::RWebWindow::fConnLimitunsigned fConnLimit! number of allowed active connectionsDefinition RWebWindow.hxx:152; ROOT::RWebWindow::InvokeCallbacksvoid InvokeCallbacks(bool force=false)Invoke callbacks with existing data Must be called from appropriate thread.Definition RWebWindow.cxx:438; ROOT::RWebWindow::FindConnectionstd::shared_ptr< WebConn > FindConnection(unsigned wsid)Find connection with specified websocket id.Definition RWebWindow.cxx:264; ROOT::RWebWindow::GetClientVersionstd::string GetClientVersion() constReturns current client version.Definition RWebWindow.cxx:1298; ROOT::RWebWindow::SetConnectCallBackvoid SetConnectCallBack(WebWindowConnectCallback_t func)Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:26216,access,accessible,26216,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['access'],['accessible']
Security,"_new=false)Start headless browser for specified window Normally only single instance is used,...Definition RWebWindow.cxx:202; ROOT::RWebWindow::GetUrlstd::string GetUrl(bool remote=true)Return URL string to connect web window URL typically includes extra parameters required for connecti...Definition RWebWindow.cxx:173; ROOT::RWebWindow::CloseConnectionsvoid CloseConnections()Closes all connection to clients Normally leads to closing of all correspondent browser windows Some ...Definition RWebWindow.cxx:1480; ROOT::RWebWindow::fMasterstd::shared_ptr< RWebWindow > fMaster! master window where this window is embeddedDefinition RWebWindow.hxx:140; ROOT::RWebWindow::NumConnectionsint NumConnections(bool with_pending=false) constReturns current number of active clients connections.Definition RWebWindow.cxx:1372; ROOT::RWebWindow::fCallbacksThrdIdSetbool fCallbacksThrdIdSet! flag indicating that thread id is assignedDefinition RWebWindow.hxx:164; ROOT::RWebWindow::fUserArgsstd::string fUserArgs! arbitrary JSON code, which is accessible via conn.getUserArgs() methodDefinition RWebWindow.hxx:178; ROOT::RWebWindow::SetDefaultPagevoid SetDefaultPage(const std::string &page)Set content of default window HTML page This page returns when URL address of the window will be requ...Definition RWebWindow.hxx:260; ROOT::RWebWindow::fConnLimitunsigned fConnLimit! number of allowed active connectionsDefinition RWebWindow.hxx:155; ROOT::RWebWindow::InvokeCallbacksvoid InvokeCallbacks(bool force=false)Invoke callbacks with existing data Must be called from appropriate thread.Definition RWebWindow.cxx:439; ROOT::RWebWindow::FindConnectionstd::shared_ptr< WebConn > FindConnection(unsigned wsid)Find connection with specified websocket id.Definition RWebWindow.cxx:264; ROOT::RWebWindow::GetClientVersionstd::string GetClientVersion() constReturns current client version.Definition RWebWindow.cxx:1340; ROOT::RWebWindow::SetConnectCallBackvoid SetConnectCallBack(WebWindowConnectCallback_t func)Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:26605,access,accessible,26605,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['access'],['accessible']
Security,"_str());; 4782 if (file.is_open()) {; 4783 ROOT::TMetaUtils::Info(nullptr, ""Selection XML file\n"");; 4784 ; 4785 XMLReader xmlr(interp);; 4786 if (!xmlr.Parse(linkdefFilename.c_str(), selectionRules)) {; 4787 ROOT::TMetaUtils::Error(nullptr, ""Parsing XML file %s\n"", linkdefFilename.c_str());; 4788 return 1; // Return here to propagate the failure up to the build system; 4789 } else {; 4790 ROOT::TMetaUtils::Info(nullptr, ""XML file successfully parsed\n"");; 4791 }; 4792 file.close();; 4793 } else {; 4794 ROOT::TMetaUtils::Error(nullptr, ""XML file %s couldn't be opened!\n"", linkdefFilename.c_str());; 4795 }; 4796 ; 4797 } else {; 4798 ; 4799 ROOT::TMetaUtils::Error(nullptr, ""Unrecognized selection file: %s\n"", linkdefFilename.c_str());; 4800 ; 4801 }; 4802 ; 4803 // Speed up the operations with rules; 4804 selectionRules.FillCache();; 4805 selectionRules.Optimize();; 4806 ; 4807 if (isGenreflex){; 4808 if (0 != selectionRules.CheckDuplicates()){; 4809 return 1;; 4810 }; 4811 }; 4812 ; 4813 // If we want to validate the selection only, we just quit.; 4814 if (gOptCheckSelectionSyntax); 4815 return 0;; 4816 ; 4817 //---------------------------------------------------------------------------; 4818 // Write schema evolution related headers and declarations; 4819 /////////////////////////////////////////////////////////////////////////////; 4820 ; 4821 if ((!ROOT::gReadRules.empty() || !ROOT::gReadRawRules.empty()) && !gOptIgnoreExistingDict) {; 4822 dictStream << ""#include \""TBuffer.h\""\n""; 4823 << ""#include \""TVirtualObject.h\""\n""; 4824 << ""#include <vector>\n""; 4825 << ""#include \""TSchemaHelper.h\""\n\n"";; 4826 ; 4827 std::list<std::string> includes;; 4828 GetRuleIncludes(includes);; 4829 for (auto & incFile : includes) {; 4830 dictStream << ""#include <"" << incFile << "">"" << std::endl;; 4831 }; 4832 dictStream << std::endl;; 4833 }; 4834 ; 4835 selectionRules.SearchNames(interp);; 4836 ; 4837 int scannerVerbLevel = 0;; 4838 {; 4839 using namespace ROOT::TMetaUtils;; 4840",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:197112,validat,validate,197112,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['validat'],['validate']
Security,"_t *option="""")TObjectvirtual; SetAttributes(const TString &attributes)ROOT::TSchemaRule; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetChecksum(const TString &checksum)ROOT::TSchemaRule; SetCode(const TString &code)ROOT::TSchemaRule; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetEmbed(Bool_t embed)ROOT::TSchemaRule; SetFromRule(const char *rule)ROOT::TSchemaRule; SetInclude(const TString &include)ROOT::TSchemaRule; SetObjectStat(Bool_t stat)TObjectstatic; SetReadFunctionPointer(ReadFuncPtr_t ptr)ROOT::TSchemaRule; SetReadRawFunctionPointer(ReadRawFuncPtr_t ptr)ROOT::TSchemaRule; SetRuleType(RuleType_t type)ROOT::TSchemaRule; SetSource(const TString &source)ROOT::TSchemaRule; SetSourceClass(const TString &classname)ROOT::TSchemaRule; SetTarget(const TString &target)ROOT::TSchemaRule; SetTargetClass(const TString &classname)ROOT::TSchemaRule; SetUniqueID(UInt_t uid)TObjectvirtual; SetVersion(const TString &version)ROOT::TSchemaRule; Streamer(TBuffer &) overrideROOT::TSchemaRulevirtual; StreamerNVirtual(TBuffer &ClassDef_StreamerNVirtual_b)ROOT::TSchemaRuleinline; SysError(const char *method, const char *msgfmt,...) constTObjectvirtual; TestBit(UInt_t f) constTObjectinline; TestBits(UInt_t f) constTObjectinline; TestChecksum(UInt_t checksum) constROOT::TSchemaRule; TestVersion(Int_t version) constROOT::TSchemaRule; TObject()TObjectinline; TObject(const TObject &object)TObjectinline; TSchemaRule()ROOT::TSchemaRule; TSchemaRule(const TSchemaRule &rhs)ROOT::TSchemaRule; UseCurrentStyle()TObjectvirtual; Warning(const char *method, const char *msgfmt,...) constTObjectvirtual; Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)TObjectvirtual; Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0) constTObjectvirtual; ~TObject()TObjectvirtual; ~TSchemaRule()ROOT::TSchemaRulevirtual. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:00 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TSchemaRule-members.html:7912,checksum,checksum,7912,doc/master/classROOT_1_1TSchemaRule-members.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TSchemaRule-members.html,1,['checksum'],['checksum']
Security,"_t HasDictionary() const;; 510 static Bool_t HasDictionarySelection(const char* clname);; 511 Bool_t HasLocalHashMember() const;; 512 void GetMissingDictionaries(THashTable& result, bool recurse = false);; 513 void IgnoreTObjectStreamer(Bool_t ignore=kTRUE);; 514 Bool_t InheritsFrom(const char *cl) const override;; 515 Bool_t InheritsFrom(const TClass *cl) const override;; 516 void InterpretedShowMembers(void* obj, TMemberInspector &insp, Bool_t isTransient);; 517 Bool_t IsFolder() const override { return kTRUE; }; 518 Bool_t IsLoaded() const;; 519 Bool_t IsForeign() const;; 520 Bool_t IsStartingWithTObject() const;; 521 Bool_t IsSyntheticPair() const { return fIsSyntheticPair; }; 522 Bool_t IsVersioned() const { return !( GetClassVersion()<=1 && IsForeign() ); }; 523 Bool_t IsTObject() const;; 524 static TClass *LoadClass(const char *requestedname, Bool_t silent);; 525 void ls(Option_t *opt="""") const override;; 526 void MakeCustomMenuList();; 527 Bool_t MatchLegacyCheckSum(UInt_t checksum) const;; 528 void Move(void *arenaFrom, void *arenaTo) const;; 529 void *New(ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const;; 530 void *New(void *arena, ENewType defConstructor = kClassNew) const;; 531 void *NewArray(Long_t nElements, ENewType defConstructor = kClassNew) const;; 532 void *NewArray(Long_t nElements, void *arena, ENewType defConstructor = kClassNew) const;; 533 ObjectPtr NewObject(ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const;; 534 ObjectPtr NewObject(void *arena, ENewType defConstructor = kClassNew) const;; 535 ObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor = kClassNew) const;; 536 ObjectPtr NewObjectArray(Long_t nElements, void *arena, ENewType defConstructor = kClassNew) const;; 537 virtual void PostLoadCheck();; 538 Long_t Property() const override;; 539 Int_t ReadBuffer(TBuffer &b, void *pointer, Int_t version, UInt_t start, UInt_t count);; 540 Int_t ReadBuffer(TBuffer &b, void *pointer);; 541 void Regis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:26977,checksum,checksum,26977,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['checksum'],['checksum']
Security,"_t TCling::HandleNewTransaction(const cling::Transaction &T); 3666{; 3667 R__LOCKGUARD(gInterpreterMutex);; 3668 ; 3669 if ((std::distance(T.decls_begin(), T.decls_end()) != 1); 3670 || T.deserialized_decls_begin() != T.deserialized_decls_end(); 3671 || T.macros_begin() != T.macros_end(); 3672 || ((!T.getFirstDecl().isNull()) && ((*T.getFirstDecl().begin()) != T.getWrapperFD()))) {; 3673 fTransactionCount++;; 3674 return true;; 3675 }; 3676 return false;; 3677}; 3678 ; 3679////////////////////////////////////////////////////////////////////////////////; 3680/// Delete object from cling symbol table so it can not be used anymore.; 3681/// cling objects are always on the heap.; 3682 ; 3683void TCling::RecursiveRemove(TObject* obj); 3684{; 3685 // NOTE: When replacing the mutex by a ReadWrite mutex, we **must**; 3686 // put in place the Read/Write part here. Keeping the write lock; 3687 // here is 'catasptrophic' for scaling as it means that ALL calls; 3688 // to RecursiveRemove will take the write lock and performance; 3689 // of many threads trying to access the write lock at the same; 3690 // time is relatively bad.; 3691 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 3692 // Note that fgSetOfSpecials is supposed to be updated by TClingCallbacks::tryFindROOTSpecialInternal; 3693 // (but isn't at the moment).; 3694 if (obj->IsOnHeap() && fgSetOfSpecials && !((std::set<TObject*>*)fgSetOfSpecials)->empty()) {; 3695 std::set<TObject*>::iterator iSpecial = ((std::set<TObject*>*)fgSetOfSpecials)->find(obj);; 3696 if (iSpecial != ((std::set<TObject*>*)fgSetOfSpecials)->end()) {; 3697 R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 3698 DeleteGlobal(obj);; 3699 ((std::set<TObject*>*)fgSetOfSpecials)->erase(iSpecial);; 3700 }; 3701 }; 3702}; 3703 ; 3704////////////////////////////////////////////////////////////////////////////////; 3705/// Pressing Ctrl+C should forward here. In the case where we have had; 3706/// continuation requested we must reset it.; 3707 ; 3708void TCling::Reset(); 370",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:143086,access,access,143086,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['access'],['access']
Security,"_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; TString ComputeSignature (TS3HTTPRequest::EHTTPVerb httpVerb) const;  Returns this request's signature. ;  ; TString HTTPVerbToTString (EHTTPVerb httpVerb) const;  ; TString MakeAuthHeader (TS3HTTPRequest::EHTTPVerb httpVerb) const;  Returns the authentication header for this HTTP request. ;  ; TString MakeAuthPrefix () const;  Returns the authentication prefix. ;  ; TString MakeDateHeader () const;  Returns the date header for this HTTP request. ;  ; TString MakeHostHeader () const;  Returns the 'Host' header to include in the HTTP request. ;  ; TString MakeRequestLine (TS3HTTPRequest::EHTTPVerb httpVerb) const;  Returns the first line of a HTTP request for this object. ;  ; TString MakeTokenHeader () const;  Returns the session security token header for this HTTP request. ;  ; TS3HTTPRequest & SetTimeStamp ();  Sets this request's time stamp according to: http://code.google.com/apis/storage/docs/reference-headers.html#date. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; TString fAccessKey;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3HTTPRequest.html:11191,authenticat,authentication,11191,doc/master/classTS3HTTPRequest.html,https://root.cern,https://root.cern/doc/master/classTS3HTTPRequest.html,1,['authenticat'],['authentication']
Security,"_t destBin) const;  set one entry in a bin map ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldBinningXML.html:11050,hash,hash,11050,doc/master/classTUnfoldBinningXML.html,https://root.cern,https://root.cern/doc/master/classTUnfoldBinningXML.html,1,['hash'],['hash']
Security,"_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object. TSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object.; User and host from url = user@host . TSecContext(const TSecContext& ); copy constructor. TSecContext& operator=(const TSecContext& ); assignement operator. ~TSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void Cleanup(); Cleanup what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". void AddForCleanup(Int_t port, Int_t proto, Int_t type); Create a new TSecContextCleanup; Internally is added to the list. Bool_t IsA(const char* methodname); Checks if this security context is for method named 'methname'; Case sensitive. Bool_t IsActive() const; Check remote OffSet and expiring Date. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void * GetContext() const; { return fContext; }. TDatime GetExpDate() const; { return fExpDate; }. const char * GetHost() const; { return fHost; }. const char * GetID() const; { return fID; }. Int_t GetMethod() const; { return fMethod; }. const char * GetMethodName() const; { return fMethodName; }. Int_t GetOffSet() const; { return fO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSecContext.html:7660,secur,security,7660,root/html528/TSecContext.html,https://root.cern,https://root.cern/root/html528/TSecContext.html,6,['secur'],['security']
Security,"_t z, Double_t *matrix, Double_t *dxnew, Double_t *rmatnew);  Compute new translation vector and global matrix. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNode.html:5481,hash,hash,5481,doc/master/classTNode.html,https://root.cern,https://root.cern/doc/master/classTNode.html,2,['hash'],['hash']
Security,"_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidSetAttributes(const TString& attributes); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Bool_tSetChecksum(const TString& checksum); voidSetCode(const TString& code); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEmbed(Bool_t embed); Bool_tSetFromRule(const char* rule); voidSetInclude(const TString& include); static voidTObject::SetObjectStat(Bool_t stat); voidSetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr); voidSetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr); voidSetRuleType(ROOT::TSchemaRule::RuleType_t type); voidSetSource(const TString& source); voidSetSourceClass(const TString& classname); voidSetTarget(const TString& target); voidSetTargetClass(const TString& classname); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetVersion(const TString& version); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTestChecksum(UInt_t checksum) const; Bool_tTestVersion(Int_t version) const; ROOT::TSchemaRuleTSchemaRule(); ROOT::TSchemaRuleTSchemaRule(const ROOT::TSchemaRule& rhs); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__TSchemaRule.html:5751,checksum,checksum,5751,root/html528/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html528/ROOT__TSchemaRule.html,1,['checksum'],['checksum']
Security,"_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitely specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:27183,authenticat,authentication,27183,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,3,['authenticat'],['authentication']
Security,"_t* pos, Int_t* len, Int_t nbuf); Read a list of buffers given in pos[] and len[] and return it in a single; buffer.; Returns kTRUE in case of error. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via rootd daemon.; Returns kTRUE in case of error. Int_t Recv(Int_t& status, EMessageTypes& kind); Return status from rootd server and message kind. Returns -1 in; case of error otherwise 8 (sizeof 2 words, status and kind). void Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); Set position from where to start reading. void ConnectServer(Int_t* stat, EMessageTypes* kind, Int_t netopt, Int_t tcpwindowsize, Bool_t forceOpen, Bool_t forceRead); Connect to remote rootd server. void Create(const char* url, Option_t* option, Int_t netopt); Create a NetFile object. A net file is the same as a TFile; except that it is being accessed via a rootd server. The url; argument must be of the form: root[s|k]://host.dom.ain/file.root.; When protocol is ""roots"" try using SRP authentication.; When protocol is ""rootk"" try using kerberos5 authentication.; If the file specified in the URL does not exist, is not accessable; or can not be created the kZombie bit will be set in the TNetFile; object. Use IsZombie() to see if the file is accessable.; If the remote daemon thinks the file is still connected, while you are; sure this is not the case you can force open the file by preceding the; option argument with an ""-"", e.g.: ""-recreate"". Do this only; in cases when you are very sure nobody else is using the file.; To bypass the writelock on a file, to allow the reading of a file; that is being written by another process, explicitly specify the; ""+read"" option (""read"" being the default option).; The netopt argument can be used to specify the size of the tcp window in; bytes (for more info see: http://www.psc.edu/networking/perf_tune.html).; The default and minimum tcp window size is 65535 bytes.; If netopt < -1 then |netopt| is the number of parallel s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetFile.html:28176,authenticat,authentication,28176,root/html534/TNetFile.html,https://root.cern,https://root.cern/root/html534/TNetFile.html,3,['authenticat'],['authentication']
Security,"_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >SMatrix<Double32_t,3,3,ROOT::Math::MatRepStd<Double32_t,3,3> >(const ROOT::Math::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:5636,access,access,5636,root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,2,['access'],"['access', 'accessing']"
Security,"_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >SMatrix<Double32_t,4,4,ROOT::Math::MatRepStd<Double32_t,4,4> >(const ROOT::Math::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html:5636,access,access,5636,root/html526/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepStd_Double32_t_4_4___.html,2,['access'],"['access', 'accessing']"
Security,"_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >SMatrix<Double32_t,5,5,ROOT::Math::MatRepStd<Double32_t,5,5> >(const ROOT::Math::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html:5636,access,access,5636,root/html526/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepStd_Double32_t_5_5___.html,2,['access'],"['access', 'accessing']"
Security,"_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const Double32_t& rhs); ROOT::Math::SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >SMatrix<Double32_t,6,6,ROOT::Math::MatRepStd<Double32_t,6,6> >(const ROOT::Math::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<Double32_t,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html:5636,access,access,5636,root/html526/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepStd_Double32_t_6_6___.html,2,['access'],"['access', 'accessing']"
Security,"_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooEffProd.html:40289,access,access,40289,root/html534/RooEffProd.html,https://root.cern,https://root.cern/root/html534/RooEffProd.html,1,['access'],['access']
Security,"_t ; nMaxDepth = 9999999, . Int_t ; iSeed = fgRandomSeed, . Float_t ; purityLimit = 0.5, . Int_t ; treeID = 0 . ). constructor specifying the separation type, the min number of events in a no that is still subjected to further splitting, the number of bins in the grid used in applying the cut for the node splitting. ; Definition at line 150 of file DecisionTree.cxx. ◆ DecisionTree() [3/3]. TMVA::DecisionTree::DecisionTree ; (; const DecisionTree & ; d). copy constructor that creates a true copy, i.e. ; a completely independent tree the node copy will recursively copy all the nodes ; Definition at line 200 of file DecisionTree.cxx. ◆ ~DecisionTree(). TMVA::DecisionTree::~DecisionTree ; (; void ; ). virtual . destructor ; Definition at line 236 of file DecisionTree.cxx. Member Function Documentation. ◆ ApplyValidationSample(). void TMVA::DecisionTree::ApplyValidationSample ; (; const EventConstList * ; validationSample); const. run the validation sample through the (pruned) tree and fill in the nodes the variables NSValidation and NBValidadtion (i.e. ; how many of the Signal and Background events from the validation sample. This is then later used when asking for the ""tree quality"" .. ; Definition at line 1029 of file DecisionTree.cxx. ◆ BuildTree(). UInt_t TMVA::DecisionTree::BuildTree ; (; const EventConstList & ; eventSample, . DecisionTreeNode * ; node = nullptr . ). building the decision tree by recursively calling the splitting of one (root-) node into two daughter nodes (returns the number of nodes) ; Definition at line 377 of file DecisionTree.cxx. ◆ CheckEvent(). Double_t TMVA::DecisionTree::CheckEvent ; (; const TMVA::Event * ; e, . Bool_t ; UseYesNoLeaf = kFALSE . ); const. the event e is put into the decision tree (starting at the root node) and the output is NodeType (signal) or (background) of the final node (basket) in which the given events ends up. ; I.e. the result of the classification if the event for this decision tree. ; Definition at line 2690 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:15140,validat,validation,15140,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['validat'],['validation']
Security,"_t Matches (const char *name);  Return kTRUE if this async request matches the open request specified by 'url'. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileOpenHandle.html:1566,hash,hash,1566,doc/master/classTFileOpenHandle.html,https://root.cern,https://root.cern/doc/master/classTFileOpenHandle.html,1,['hash'],['hash']
Security,"`\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. V.Perev. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Bool_t MaybeWildcard() const; Returns true if string contains one of the wildcard characters ""[]*?"". TString& Prepend(char c, Ssiz_t rep = 1); Prepend character c rep times to string. TString & Replace(Ssiz_t pos, Ssiz_t n, const char* s, Ssiz_t ns); Remove at most n1 characters from s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TString.html:11032,hash,hash,11032,root/html530/TString.html,https://root.cern,https://root.cern/root/html530/TString.html,2,['hash'],['hash']
Security,"a > const & uniqueId () const;  Returns a unique ID that is different for every instantiated RooAbsData object. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:23003,hash,hash,23003,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,2,['hash'],['hash']
Security,"a Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TList*fCleanupPoints to list with info for remote cleanup; void*fContextKrb5, Globus: ptr to specific sec context; TDatimefExpDateExpiring date (one sec precision); TStringfHostRemote host name; TStringfIDString identifying uniquely this context; Int_tfMethodAuthentication method used; TStringfMethodNameAuthentication method name; Int_tfOffSetoffset in remote host auth tab file (in bytes); TStringfTokenToken identifying this authentication; TStringfUserRemote login username. Class Charts. Inheritance Chart:. TObject. ←; TSecContext. ←. TRootSecContext. Function documentation; TSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object. TSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object.; User and host from url = user@host . TSecContext(const TSecContext& ); copy constructor. TSecContext& operator=(const TSecContext& ); assignement operator. ~TSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void Cleanup(); Cleanup what is still active. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSecContext.html:7034,authenticat,authentication,7034,root/html602/TSecContext.html,https://root.cern,https://root.cern/root/html602/TSecContext.html,2,['authenticat'],['authentication']
Security,"a ROOT session. One simply adds the name of the script(s) after the ROOT command. Be warned: after finishing the execution of the script, ROOT will normally enter a new session.; -q process command line script files and exit. For example if you would like to run a script myMacro.C in the background, redirect the output into a file myMacro.log, and exit after the script execution, use the following syntax:; root -b -q myMacro.C > myMacro.log; If you need to pass a parameter to the script use:; root -b -q 'myMacro.C(3)' > myMacro.log; Be mindful of the quotes, i.e. if you need to pass a string as a parameter, the syntax is:; root -b -q 'myMacro.C(""text"")' > myMacro.log; You can build a shared library with ACLiC and then use this shared library on the command line for a quicker execution (i.e. the compiled speed rather than the interpreted speed). See also “Cling the C++ Interpreter”.; root -b -q myMacro.so > myMacro.log; ROOT has a powerful C/C++ interpreter giving you access to all available ROOT classes, global variables, and functions via the command line. By typing C++ statements at the prompt, you can create objects, call functions, execute scripts, etc. For example:; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; To exit the ROOT session, type .q.; root[] .q; 2.3 Using the GUI; The basic whiteboard on which an object is drawn in ROOT is called a canvas (defined by the class TCanvas). Every object in the canvas is a graphical object in the sense that you can grab it, resize it, and change some characteristics using the mouse. The canvas area can be divided in several sub areas, so-called pads (the class TPad). A pad is a canvas sub area that can contain other pads or graphical objects. At any one time, just one pad is the so-called active pad. Any object at the moment of drawing will be drawn in the active pad. The obvious question is: what is th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:34644,access,access,34644,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"a class template (i.e. ; NOT a concrete class). ; Definition at line 1005 of file TClassTable.cxx. ◆ RemoveClass(). void ROOT::RemoveClass ; (; const char * ; cname, . TClass * ; cl . ). Global function called by the dtor of a class's init class (see the ClassImp macro). ; Definition at line 985 of file TClassTable.cxx. ◆ RemoveClassAlternate(). void ROOT::RemoveClassAlternate ; (; ROOT::TClassAlt * ; alt). Definition at line 931 of file TClassTable.cxx. ◆ ResetClassVersion(). void ROOT::ResetClassVersion ; (; TClass * ; cl, . const char * ; cname, . Short_t ; newid . ). Global function to update the version number. ; This is called via the RootClassVersion macro.; if cl!=0 and cname==-1, set the new class version if and only is greater than the existing one and greater or equal to 2; and also ignore the request if fVersionUsed is true.; Note on class version number:; If no class has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specify via ClassDef indicates that the I/O should use the TClass checksum to distinguish the layout of the class . Definition at line 951 of file TClassTable.cxx. ◆ RGeomLog(). ROOT::Experimental::RLogChannel & ROOT::RGeomLog ; (; ). Log channel for Geomviewer diagnostics. ; Definition at line 49 of file RGeomData.cxx. ◆ SetClassVersion(). template<class RootClass > . Short_t ROOT::SetClassVersion ; (; RootClass * ; ). ◆ Split(). std::vector< std::string > ROOT::Split ; (; std::string_view ; str, . std::string_view ; delims, . bool ; skipEmpty . ). Splits a string at each character in delims. ; The behavior mimics str.split from Python, Parameters. [in]strString to tokenise. ; [in]delimsOne or more delimiters used to split the string. ; [in]skipEmptyStrip empty strings from the output. . Definition at line 23 of file StringUtils.cxx. ◆ StrReplace(). static void ROOT::StrReplace ; (; std::string & ; proc, . const std::string & ; pat, . const std::st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:43032,checksum,checksum,43032,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['checksum'],['checksum']
Security,"a class template (i.e. ; NOT a concrete class). ; Definition at line 1012 of file TClassTable.cxx. ◆ RemoveClass(). void ROOT::RemoveClass ; (; const char * ; cname, . TClass * ; cl . ). Global function called by the dtor of a class's init class (see the ClassImp macro). ; Definition at line 992 of file TClassTable.cxx. ◆ RemoveClassAlternate(). void ROOT::RemoveClassAlternate ; (; ROOT::TClassAlt * ; alt). Definition at line 938 of file TClassTable.cxx. ◆ ResetClassVersion(). void ROOT::ResetClassVersion ; (; TClass * ; cl, . const char * ; cname, . Short_t ; newid . ). Global function to update the version number. ; This is called via the RootClassVersion macro.; if cl!=0 and cname==-1, set the new class version if and only is greater than the existing one and greater or equal to 2; and also ignore the request if fVersionUsed is true.; Note on class version number:; If no class has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specify via ClassDef indicates that the I/O should use the TClass checksum to distinguish the layout of the class . Definition at line 958 of file TClassTable.cxx. ◆ SetClassVersion(). template<class RootClass > . Short_t ROOT::SetClassVersion ; (; RootClass * ; ). ◆ Split(). std::vector< std::string > ROOT::Split ; (; std::string_view ; str, . std::string_view ; delims, . bool ; skipEmpty . ). Splits a string at each character in delims. ; The behavior mimics str.split from Python, Parameters. [in]strString to tokenise. ; [in]delimsOne or more delimiters used to split the string. ; [in]skipEmptyStrip empty strings from the output. . Definition at line 23 of file StringUtils.cxx. ◆ StrReplace(). static void ROOT::StrReplace ; (; std::string & ; proc, . const std::string & ; pat, . const std::string & ; tr . ). static . Replace all accurances of given string with other string. ; Definition at line 743 of file RConversionRuleParser.cxx. ◆ ToHumanReada",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:35583,checksum,checksum,35583,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['checksum'],['checksum']
Security,"a field with an initial value #include <ROOT/RNTupleModel.hxx>; using ROOT::Experimental::RNTupleModel;; ; auto model = RNTupleModel::Create();; // pt's initial value is 42.0; auto pt = model->MakeField<float>(""pt"", 42.0);; Example: create a field with a description #include <ROOT/RNTupleModel.hxx>; using ROOT::Experimental::RNTupleModel;; ; auto model = RNTupleModel::Create();; auto hadronFlavour = model->MakeField<float>({; ""hadronFlavour"", ""flavour from hadron ghost clustering""; });. Definition at line 295 of file RNTupleModel.hxx. ◆ operator=(). RNTupleModel & ROOT::Experimental::RNTupleModel::operator= ; (; const RNTupleModel & ; ). delete . ◆ RegisterSubfield(). void ROOT::Experimental::RNTupleModel::RegisterSubfield ; (; std::string_view ; qualifiedFieldName). Register a subfield so it can be accessed directly from entries belonging to the model. ; Because registering a subfield does not fundamentally change the model, previously created entries will not be invalidated, nor modified in any way; a registered subfield is merely an accessor added to the default entry (if present) and any entries created afterwards.; Using models with registered subfields for writing is not allowed. Attempting to do so will result in an exception.; Throws an exception if the provided subfield could not be found in the model. ; Definition at line 335 of file RNTupleModel.cxx. ◆ SetDescription(). void ROOT::Experimental::RNTupleModel::SetDescription ; (; std::string_view ; description). Definition at line 512 of file RNTupleModel.cxx. ◆ Unfreeze(). void ROOT::Experimental::RNTupleModel::Unfreeze ; (; ). Definition at line 493 of file RNTupleModel.cxx. Friends And Related Symbol Documentation. ◆ Internal::GetFieldZeroOfModel. RFieldZero & Internal::GetFieldZeroOfModel ; (; RNTupleModel & ; ). friend . ◆ Internal::GetProjectedFieldsOfModel. Internal::RProjectedFields & Internal::GetProjectedFieldsOfModel ; (; RNTupleModel & ; ). friend . Member Data Documentation. ◆ fDefaultEntry. std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html:18783,access,accessor,18783,doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleModel.html,1,['access'],['accessor']
Security,"a file or directory. Returns 0 when succesfull,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:27574,access,access,27574,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,3,['access'],['access']
Security,"a file or directory. Returns 0 when successful,; -1 in case of failure. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. Bool_t ExpandPathName(TString& patbuf); Expand a pathname getting rid of special shell characters like ~.$, etc.; For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; environment variables in a pathname. If compatibility is not an issue; you can use on Unix directly $XXX. Returns kFALSE in case of success; or kTRUE in case of error. int Chmod(const char* file, UInt_t mode); Set the file permission bits. Returns -1 in case or error, 0 otherwise. int Umask(Int_t mask); Set the process file creation mode mask. int Utime(const char* file, Long_t modtime, Long_t actime); Set a files modification and access times. If actime = 0 it will be; set to the modtime. Returns 0 on success and -1 in case of error. const char * FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); Find location of file ""wfil"" in a search path.; The search path is specified as a : separated list of directories.; Return value is pointing to wfile for compatibility with; Which(const char*,const char*,EAccessMode) version. Int_t GetUid(const char* user = 0); Returns the user's id. If user = 0, returns current user's id. Int_t GetEffectiveUid(); Returns the effective user id. The effective id corresponds to the; set id bit on the file being executed. Int_t GetGid(const char* group = 0); Returns the group's id. If group = 0, returns current user's group. Int_t GetEffectiveGid(); Returns the effective group id. The effective group id corresponds; to the set id bit on the file being executed. UserGroup_t * GetUserInfo(Int_t uid); Returns all user info in th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:27914,access,access,27914,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,3,['access'],['access']
Security,"a member corresponding to the Decl 'id'. TDictionary * Get(TListOfDataMembers::DeclId_t id); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = kFALSE); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object of class TListOfDataMembers. void Update(TDictionary* member); Move the member or data member to the expect set of list. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TDictionary* member); Mark 'func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfDataMembers.html:14719,hash,hash,14719,root/html604/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html,2,['hash'],['hash']
Security,"a named service. ; Set reuse to true to force reuse of the server socket (i.e. do not wait for the time out to pass). Using backlog one can set the desirable queue length for pending connections. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option is set (for tcpwindowsize > 65KB and for platforms supporting window scaling). Use IsValid() to check the validity of the server socket. In case server socket is not valid use GetErrorCode() to obtain the specific error value. These values are: 0 = no error (socket is valid) -1 = low level socket() call failed -2 = low level bind() call failed -3 = low level listen() call failed Every valid server socket is added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. ; Definition at line 76 of file TServerSocket.cxx. ◆ ~TServerSocket(). TServerSocket::~TServerSocket ; (; ). virtual . Destructor: cleanup authentication stuff (if any) and close. ; Definition at line 162 of file TServerSocket.cxx. Member Function Documentation. ◆ Accept(). TSocket * TServerSocket::Accept ; (; UChar_t ; opt = 0). virtual . Accept a connection on a server socket. ; Returns a full-duplex communication TSocket object. If no pending connections are present on the queue and nonblocking mode has not been enabled with SetOption(kNoBlock,1) the call blocks until a connection is present. The returned socket must be deleted by the user. The socket is also added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. In case of error 0 is returned and in case non-blocking I/O is enabled and no connections are available -1 is returned.; The opt can be used to require client authentication; valid options are; kSrvAuth = require client authentication kSrvNoAuth = force no client authentication; Example: use Opt = kSrvAuth to require client authentication.; Default options ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTServerSocket.html:21841,authenticat,authentication,21841,doc/master/classTServerSocket.html,https://root.cern,https://root.cern/doc/master/classTServerSocket.html,1,['authenticat'],['authentication']
Security,"a set. The 2D histogram has equidistant bins along the X and Y directions. The number of bins along each direction can be change using SetNpx() and SetNpy(). Each bin is filled with the Z value found via a linear interpolation on the plane defined by the triangle above the (X,Y) coordinates of the bin center.; The existing (X,Y,Z) points can be randomly scattered. The Delaunay triangles are build in the (X,Y) plane. These 2D triangles are then used to define flat planes in (X,Y,Z) over which the interpolation is done to fill the 2D histogram. The 3D triangles int takes build a 3D surface in the form of tessellating triangles at various angles. The triangles found can be drawn in 3D with one of the TGraph2D specific drawing options.; The histogram generated by the Delaunay interpolation can be accessed using the GetHistogram() method.; The axis settings (title, ranges etc ...) can be changed accessing the axis via the GetXaxis GetYaxis and GetZaxis methods. They access the histogram axis created at drawing time only. Therefore they should called after the TGraph2D is drawn:; auto g = new TGraph2D();; ; [...]; ; g->Draw(""tri1"");; gPad->Update();; g->GetXaxis()->SetTitle(""X axis title"");; gPad#define gPadDefinition TVirtualPad.h:308. Examples. SURF1 Example; {; auto c = new TCanvas(""c"",""Graph2D example"",0,0,600,400);; Double_t x, y, z, P = 6.;; Int_t np = 200;; auto dt = new TGraph2D();; dt->SetTitle(""Graph title; X axis title; Y axis title; Z axis title"");; auto r = new TRandom();; for (Int_t N=0; N<np; N++) {; x = 2*P*(r->Rndm(N))-P;; y = 2*P*(r->Rndm(N))-P;; z = (sin(x)/x)*(sin(y)/y)+0.2;; dt->SetPoint(N,x,y,z);; }; gStyle->SetPalette(1);; dt->Draw(""surf1"");; }; c#define c(i)Definition RSha256.hxx:101; N#define N; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2D.html:4213,access,access,4213,doc/master/classTGraph2D.html,https://root.cern,https://root.cern/doc/master/classTGraph2D.html,1,['access'],['access']
Security,"a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). const TString& GetColumnName(Int_t colnum); Get the name of a column given its index (column>=0).; In case of error the column name is """". TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFITSHDU.html:13054,access,access,13054,root/html534/TFITSHDU.html,https://root.cern,https://root.cern/root/html534/TFITSHDU.html,1,['access'],['access']
Security,"a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). const TString& GetColumnName(Int_t colnum); Get the name of a column given its index (column>=0).; In case of error the column name is """". TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id$ » Last generated: 2015-06-02 15:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFITSHDU.html:13651,access,access,13651,root/html604/TFITSHDU.html,https://root.cern,https://root.cern/root/html604/TFITSHDU.html,1,['access'],['access']
Security,"a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). const TString& GetColumnName(Int_t colnum); Get the name of a column given its index (column>=0).; In case of error the column name is """". TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id$ » Last generated: 2015-06-30 14:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFITSHDU.html:13651,access,access,13651,root/html602/TFITSHDU.html,https://root.cern,https://root.cern/root/html602/TFITSHDU.html,1,['access'],['access']
Security,a top-level field or a nested field. Returns nullptr if the field is not in the...Definition RNTupleModel.cxx:291; ROOT::Experimental::RNTupleModel::RNTupleModelRNTupleModel(std::unique_ptr< RFieldZero > fieldZero)Definition RNTupleModel.cxx:232; ROOT::Experimental::RNTupleModel::GetMutableFieldRFieldBase & GetMutableField(std::string_view fieldName)Definition RNTupleModel.cxx:406; ROOT::Experimental::RNTupleModel::Freezevoid Freeze()Definition RNTupleModel.cxx:507; ROOT::Experimental::RNTupleModel::CreateBarestatic std::unique_ptr< RNTupleModel > CreateBare()A bare model has no default entry.Definition RNTupleModel.cxx:236; ROOT::Experimental::RNTupleModel::IsFrozenbool IsFrozen() constDefinition RNTupleModel.hxx:363; ROOT::Experimental::RNTupleModel::AddFieldvoid AddField(std::unique_ptr< RFieldBase > field)Adds a field whose type is not known at compile time.Definition RNTupleModel.cxx:312; ROOT::Experimental::RNTupleModel::RegisterSubfieldvoid RegisterSubfield(std::string_view qualifiedFieldName)Register a subfield so it can be accessed directly from entries belonging to the model.Definition RNTupleModel.cxx:335; ROOT::Experimental::RNTupleModel::Unfreezevoid Unfreeze()Definition RNTupleModel.cxx:493; ROOT::Experimental::RNTupleModel::fFieldZerostd::unique_ptr< RFieldZero > fFieldZeroHierarchy of fields consisting of simple types and collections (sub trees)Definition RNTupleModel.hxx:198; ROOT::Experimental::RNTupleWriteOptionsCommon user-tunable settings for storing ntuples.Definition RNTupleWriteOptions.hxx:48; ROOT::Experimental::RNTupleWriteOptions::GetCompressionint GetCompression() constDefinition RNTupleWriteOptions.hxx:105; ROOT::Experimental::RNTupleWriteOptions::GetPageBufferBudgetstd::size_t GetPageBufferBudget() constDefinition RNTupleWriteOptions.cxx:77; ROOT::Experimental::RNTupleWriteOptions::GetApproxZippedClusterSizestd::size_t GetApproxZippedClusterSize() constDefinition RNTupleWriteOptions.hxx:112; ROOT::Experimental::RNTupleWriteOptions::GetI,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleModel_8cxx_source.html:33088,access,accessed,33088,doc/master/RNTupleModel_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleModel_8cxx_source.html,1,['access'],['accessed']
Security,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetFile(); TNetFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetFile.html:1667,secur,secure,1667,root/html528/TNetFile.html,https://root.cern,https://root.cern/root/html528/TNetFile.html,4,['secur'],['secure']
Security,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetSystem(Bool_t ftpowner = kTRUE); TNetSystem(const char* url, Bool_t ftpowner = kTRUE); virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::Add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetSystem.html:1675,secur,secure,1675,root/html528/TNetSystem.html,https://root.cern,https://root.cern/root/html528/TNetSystem.html,4,['secur'],['secure']
Security,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetFile.html:1667,secur,secure,1667,root/html602/TNetFile.html,https://root.cern,https://root.cern/root/html602/TNetFile.html,2,['secur'],['secure']
Security,"a49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddDynamicPath(const char* pathname); virtual voidTSystem::AddFileHandler(TFileHandler* fh); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetSystem.html:1675,secur,secure,1675,root/html602/TNetSystem.html,https://root.cern,https://root.cern/root/html602/TNetSystem.html,2,['secur'],['secure']
Security,"a8); ROOT::Math::SVector<Double32_t,3>SVector<Double32_t,3>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,3>SVector<Double32_t,3>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,3>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_3_.html:5039,access,access,5039,root/html528/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"a8); ROOT::Math::SVector<Double32_t,3>SVector<Double32_t,3>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,3>SVector<Double32_t,3>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,3>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html:5039,access,access,5039,root/html526/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_3_.html,1,['access'],['access']
Security,"a8); ROOT::Math::SVector<Double32_t,4>SVector<Double32_t,4>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,4>SVector<Double32_t,4>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,4>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_4_.html:5039,access,access,5039,root/html528/ROOT__Math__SVector_Double32_t_4_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_4_.html,4,['access'],['access']
Security,"a8); ROOT::Math::SVector<Double32_t,4>SVector<Double32_t,4>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,4>SVector<Double32_t,4>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,4>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_4_.html:5039,access,access,5039,root/html526/ROOT__Math__SVector_Double32_t_4_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_4_.html,1,['access'],['access']
Security,"a8); ROOT::Math::SVector<Double32_t,5>SVector<Double32_t,5>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,5>SVector<Double32_t,5>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,5>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_5_.html:5039,access,access,5039,root/html528/ROOT__Math__SVector_Double32_t_5_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_5_.html,4,['access'],['access']
Security,"a8); ROOT::Math::SVector<Double32_t,5>SVector<Double32_t,5>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,5>SVector<Double32_t,5>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,5>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_5_.html:5039,access,access,5039,root/html526/ROOT__Math__SVector_Double32_t_5_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_5_.html,1,['access'],['access']
Security,"a8); ROOT::Math::SVector<Double32_t,6>SVector<Double32_t,6>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,6>SVector<Double32_t,6>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,6>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_6_.html:5134,access,access,5134,root/html528/ROOT__Math__SVector_Double32_t_6_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_6_.html,4,['access'],['access']
Security,"a8); ROOT::Math::SVector<Double32_t,6>SVector<Double32_t,6>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9); ROOT::Math::SVector<Double32_t,6>SVector<Double32_t,6>(const Double32_t& a1, const Double32_t& a2, const Double32_t& a3, const Double32_t& a4, const Double32_t& a5, const Double32_t& a6, const Double32_t& a7, const Double32_t& a8, const Double32_t& a9, const Double32_t& a10); ROOT::Math::SVector<Double32_t,6>&Unit(). Data Members; public:. enum { kSize; };. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array(); return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index start",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_6_.html:5134,access,access,5134,root/html526/ROOT__Math__SVector_Double32_t_6_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_Double32_t_6_.html,1,['access'],['access']
Security,"a; 228// reference count of 1 (meaning: it could delete the C++ instance any moment); 229 if (pyobject->ob_refcnt <= 1 && (((CPPInstance*)pyobject)->fFlags & CPPInstance::kIsOwner)); 230 return false;; 231 ; 232 return true;; 233}; 234 ; 235//-----------------------------------------------------------------------------; 236bool CPyCppyy::Overload_Check(PyObject* pyobject); 237{; 238// Test if the given pyobject is of CPPOverload derived type.; 239 if (!Initialize()); 240 return false;; 241 ; 242// detailed walk through inheritance hierarchy; 243 return CPPOverload_Check(pyobject);; 244}; 245 ; 246//-----------------------------------------------------------------------------; 247bool CPyCppyy::Overload_CheckExact(PyObject* pyobject); 248{; 249// Test if the given pyobject is of CPPOverload type.; 250 if (!Initialize()); 251 return false;; 252 ; 253// direct pointer comparison of type member; 254 return CPPOverload_CheckExact(pyobject);; 255}; 256 ; 257 ; 258//- access to the python interpreter ----------------------------------------; 259bool CPyCppyy::Import(const std::string& mod_name); 260{; 261// Import the named python module and create Cling equivalents for its classes.; 262 if (!Initialize()); 263 return false;; 264 ; 265 PyObject* mod = PyImport_ImportModule(mod_name.c_str());; 266 if (!mod) {; 267 PyErr_Print();; 268 return false;; 269 }; 270 ; 271// allow finding to prevent creation of a python proxy for the C++ proxy; 272 Py_INCREF(mod);; 273 PyModule_AddObject(gThisModule, mod_name.c_str(), mod);; 274 ; 275// force creation of the module as a namespace; 276// TODO: the following is broken (and should live in Cppyy.cxx); 277// TClass::GetClass(mod_name, true);; 278 ; 279 PyObject* dct = PyModule_GetDict(mod);; 280 ; 281// create Cling classes for all new python classes; 282 PyObject* values = PyDict_Values(dct);; 283 for (int i = 0; i < PyList_GET_SIZE(values); ++i) {; 284 PyObject* value = PyList_GET_ITEM(values, i);; 285 Py_INCREF(value);; 286 ; 287 // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/API_8cxx_source.html:8870,access,access,8870,doc/master/API_8cxx_source.html,https://root.cern,https://root.cern/doc/master/API_8cxx_source.html,1,['access'],['access']
Security,"aMember(). TClass * TClass::GetBaseDataMember ; (; const char * ; datamember). Return pointer to (base) class that contains datamember. ; Definition at line 2827 of file TClass.cxx. ◆ GetCheckSum() [1/3]. UInt_t TClass::GetCheckSum ; (; Bool_t & ; isvalid); const. Return GetCheckSum(kCurrentCheckSum,isvalid);. ; Definition at line 6514 of file TClass.cxx. ◆ GetCheckSum() [2/3]. UInt_t TClass::GetCheckSum ; (; ECheckSum ; code, . Bool_t & ; isvalid . ); const. Compute and/or return the class check sum. ; isvalid is set to false, if the function is unable to calculate the checksum.; The class ckecksum is used by the automatic schema evolution algorithm to uniquely identify a class version. The check sum is built from the names/types of base classes and data members. Original algorithm from Victor Perevovchikov (perev.nosp@m.@bnl.nosp@m..gov).; The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility.; WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum. They are both used to handle backward compatibility and should both return the same values. TStreamerInfo uses the information in TStreamerElement while TClass uses the information from TClass::GetListOfBases and TClass::GetListOfDataMembers. ; Definition at line 6544 of file TClass.cxx. ◆ GetCheckSum() [3/3]. UInt_t TClass::GetCheckSum ; (; ECheckSum ; code = kCurrentCheckSum); const. Call GetCheckSum with validity check. ; Definition at line 6505 of file TClass.cxx. ◆ GetClass() [1/6]. template<typename T > . TClass * TClass::GetClass ; (; Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Definition at line 655 of file TClass.h. ◆ GetClass() [2/6]. TClass * TClass::GetClass ; (; ClassInfo_t * ; in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:71923,checksum,checksum,71923,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['checksum'],['checksum']
Security,"aMember(). TClass * TClass::GetBaseDataMember ; (; const char * ; datamember). Return pointer to (base) class that contains datamember. ; Definition at line 2894 of file TClass.cxx. ◆ GetCheckSum() [1/3]. UInt_t TClass::GetCheckSum ; (; Bool_t & ; isvalid); const. Return GetCheckSum(kCurrentCheckSum,isvalid);. ; Definition at line 6581 of file TClass.cxx. ◆ GetCheckSum() [2/3]. UInt_t TClass::GetCheckSum ; (; ECheckSum ; code, . Bool_t & ; isvalid . ); const. Compute and/or return the class check sum. ; isvalid is set to false, if the function is unable to calculate the checksum.; The class ckecksum is used by the automatic schema evolution algorithm to uniquely identify a class version. The check sum is built from the names/types of base classes and data members. Original algorithm from Victor Perevovchikov (perev.nosp@m.@bnl.nosp@m..gov).; The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility.; WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum. They are both used to handle backward compatibility and should both return the same values. TStreamerInfo uses the information in TStreamerElement while TClass uses the information from TClass::GetListOfBases and TClass::GetListOfDataMembers. ; Definition at line 6611 of file TClass.cxx. ◆ GetCheckSum() [3/3]. UInt_t TClass::GetCheckSum ; (; ECheckSum ; code = kCurrentCheckSum); const. Call GetCheckSum with validity check. ; Definition at line 6572 of file TClass.cxx. ◆ GetClass() [1/6]. template<typename T > . TClass * TClass::GetClass ; (; Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Definition at line 655 of file TClass.h. ◆ GetClass() [2/6]. TClass * TClass::GetClass ; (; ClassInfo_t * ; in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:71924,checksum,checksum,71924,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,2,['checksum'],['checksum']
Security,"aSet (const char *dataset, const char *optStr="""");  Verify if all files in the specified dataset are available. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:23206,hash,hash,23206,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['hash'],['hash']
Security,"aSetManagerFile.cxx. ◆ GetMSSUrl(). const char * TDataSetManagerFile::GetMSSUrl ; (; ); const. inline . Definition at line 94 of file TDataSetManagerFile.h. ◆ GetStageOpts(). const char * TDataSetManagerFile::GetStageOpts ; (; ); const. inline . Definition at line 95 of file TDataSetManagerFile.h. ◆ Init(). void TDataSetManagerFile::Init ; (; ). protected . Do the real inititialization. ; Definition at line 93 of file TDataSetManagerFile.cxx. ◆ InitLocalCache(). void TDataSetManagerFile::InitLocalCache ; (; ). private . Init the local cache if required. ; Definition at line 234 of file TDataSetManagerFile.cxx. ◆ IsA(). TClass * TDataSetManagerFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TDataSetManager.; Definition at line 100 of file TDataSetManagerFile.h. ◆ NotifyUpdate(). Int_t TDataSetManagerFile::NotifyUpdate ; (; const char * ; group, . const char * ; user, . const char * ; dsName, . Long_t ; mtime, . const char * ; checksum = 0 . ). overridevirtual . Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated or created or modified dataset. ; For still existing datasets, fill the modification date in seconds anf the checksum. Returns 0 on success, -1 on error ; Reimplemented from TDataSetManager.; Definition at line 382 of file TDataSetManagerFile.cxx. ◆ ParseInitOpts(). void TDataSetManagerFile::ParseInitOpts ; (; const char * ; ins). overridevirtual . Parse the input string and set the init bits accordingly Format is dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>] The <datasetdir> is mandatory. ; See TDataSetManager::ParseInitOpts for the available base options. The base options are already initialized by the base constructor ; Reimplemented from TDataSetManager.; Definition at line 317 of file TDataSetManagerFile.cxx. ◆ RegisterDataSet(). Int_t TDataSetManagerFile::RegisterDataSet ; (; const char * ; uri, . TFileCollection * ; newDataSet, . const char * ; opts . ). over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:30406,checksum,checksum,30406,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['checksum'],['checksum']
Security,"aType > & ; data, . const std::shared_ptr< IModelFunction > & ; func . ). inlineprotected . Constructor from data set and model function. ; Definition at line 55 of file BasicFCN.h. ◆ ~BasicFCN(). template<class DerivFunType , class ModelFunType , class DataType > . virtual ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::~BasicFCN ; (; ). inlineprotectedvirtual . Destructor (no operations) ; Definition at line 66 of file BasicFCN.h. Member Function Documentation. ◆ Data(). template<class DerivFunType , class ModelFunType , class DataType > . virtual const DataType & ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::Data ; (; ); const. inlinevirtual . access to const reference to the data ; Definition at line 72 of file BasicFCN.h. ◆ DataPtr(). template<class DerivFunType , class ModelFunType , class DataType > . std::shared_ptr< DataType > ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::DataPtr ; (; ); const. inline . access to data pointer ; Definition at line 75 of file BasicFCN.h. ◆ HasHessian(). template<class DerivFunType , class ModelFunType , class DataType > . virtual bool ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::HasHessian ; (; ); const. inlinevirtual . flag to indicate if can compute Hessian ; Reimplemented from ROOT::Math::BasicFitMethodFunction< DerivFunType >.; Definition at line 84 of file BasicFCN.h. ◆ ModelFunction(). template<class DerivFunType , class ModelFunType , class DataType > . virtual const IModelFunction & ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::ModelFunction ; (; ); const. inlinevirtual . access to const reference to the model function ; Definition at line 78 of file BasicFCN.h. ◆ ModelFunctionPtr(). template<class DerivFunType , class ModelFunType , class DataType > . std::shared_ptr< IModelFunction > ROOT::Fit::BasicFCN< DerivFunType, ModelFunType, DataType >::ModelFunctionPtr ; (; ); const. inline . access to function pointer ; Definition at line 81 of file Ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BasicFCN.html:6579,access,access,6579,doc/master/classROOT_1_1Fit_1_1BasicFCN.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BasicFCN.html,1,['access'],['access']
Security,"a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6866,access,access,6866,root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,90,['access'],['access']
Security,"able and can be retrieved via all methods,; the implementation for SQLite interprets the column content as; a timestamp with second fraction.; Due to these differences, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from a 'DATE' column in Oracle, one should use the GetDatime() method. The only difference between timestamp and date/time is that timestamp has a fractional; seconds part. Be aware that the fractional part has different meanings; (actual value) in different SQL plugins.; For PostgreSQL, it is given back as microseconds, while for SQLite3,; milliseconds correspond to the fraction (similar to the DATETIME-functions; implemented in the SQLite3 language). 5. Binary data. Most modern data bases support just binary data, which is; typically has SQL type name 'BLOB'. To access data in such; columns, GetBinary()/SetBinary() methods should be used.; The current implementation implies that the complete content of the; column must be retrieved at once. Therefore, very big data of; gigabytes size may cause a problem. In addition, for PostgresSQL, the methods GetLargeObject()/SetLargeObject(); are implemented with similar syntax. They retrieve a large object for the OID; given in the column of the statement. For non-PostgreSQL databases,; calling GetLargeObject()/SetLargeObject() is redirected to GetBinary()/SetBinary(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLStatement(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSQLStatement.html:9751,access,access,9751,root/html534/TSQLStatement.html,https://root.cern,https://root.cern/root/html534/TSQLStatement.html,3,['access'],['access']
Security,"able::WriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidDeclareOptions(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. virtual ~FitterBase(); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: FitterBase.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__FitterBase.html:7231,access,accessor,7231,root/html528/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html528/TMVA__FitterBase.html,1,['access'],['accessor']
Security,able::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TString_bnameName of the binning specification to be used to perform the mapping; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooRealProxy_inputVarInput variable that is mapped; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArray,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooBinningCategory.html:22688,access,access,22688,root/html602/RooBinningCategory.html,https://root.cern,https://root.cern/root/html602/RooBinningCategory.html,2,['access'],['access']
Security,"ables_t>fgGeneratorslist of MethodCreateListOfBrowsables_t called by CreateListOfBrowsables; static Bool_tfgGeneratorsSethave we set the generators yet? empty is not good enough - user might have removed them. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualBranchBrowsable(const TBranch* b, TClass* type, Bool_t typeIsPointer, const TVirtualBranchBrowsable* parent = 0); constructor setting all members according to parameters. ~TVirtualBranchBrowsable(); Destructor. Delete our leaves. void Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualBranchBrowsable.html:9583,access,access,9583,root/html528/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html528/TVirtualBranchBrowsable.html,4,['access'],['access']
Security,"access data from one window into another window Used for instance when inserting panel into canvas. ;  ; int GetSendQueueLength (unsigned connid) const;  Returns send queue length for specified connection. ;  ; THttpServer * GetServer ();  Return THttpServer instance serving requests to the window. ;  ; std::string GetUrl (bool remote=true);  Return URL string to connect web window URL typically includes extra parameters required for connection with the window like http://localhost:9635/win1/?key=<connection_key>#<session_key> When. ;  ; std::string GetUserArgs () const;  Returns configured user arguments for web window See SetUserArgs method for more details. ;  ; unsigned GetWidth () const;  returns configured window width (0 - default) actual window width can be different ;  ; int GetX () const;  returns configured window X position (-1 - default) ;  ; int GetY () const;  returns configured window Y position (-1 - default) ;  ; bool HasConnection (unsigned connid=0, bool only_active=true) const;  returns true if specified connection id exists ;  ; bool IsNativeOnlyConn () const;  returns true if only native (own-created) connections are allowed ;  ; bool IsRequireAuthKey () const;  returns true if authentication string is required ;  ; bool IsShown () const;  Returns true when window was shown at least once. ;  ; bool IsUseCurrentDir () const;  returns true if window can access local files via currentdir/ path of http server ;  ; int NumConnections (bool with_pending=false) const;  Returns current number of active clients connections. ;  ; void RecordData (const std::string &fname=""protocol.json"", const std::string &fprefix="""");  Configures recording of communication data in protocol file Provided filename will be used to store JSON array with names of written files - text or binary If data was send from client, ""send"" entry will be placed. ;  ; void Run (double tm=0.);  Run window functionality for specified time If no action can be performed - just sleep specif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:5472,authenticat,authentication,5472,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['authenticat'],['authentication']
Security,"access to your application from external nodes!! ; Definition at line 128 of file RWebWindowsManager.cxx. ◆ SetShowCallback(). void ROOT::RWebWindowsManager::SetShowCallback ; (; WebWindowShowCallback_t ; func). inline . Assign show callback which can catch window showing, used by RBrowser. ; Definition at line 90 of file RWebWindowsManager.hxx. ◆ SetUseConnectionKey(). void RWebWindowsManager::SetUseConnectionKey ; (; bool ; on = true). static . Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection) to widget requires unique key Connection key used together with session key to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ; Definition at line 167 of file RWebWindowsManager.cxx. ◆ SetUseSessionKey(). void RWebWindowsManager::SetUseSessionKey ; (; bool ; on = true). static . Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ; Definition at line 156 of file RWebWindowsManager.cxx. ◆ ShowWindow(). unsigned RWebWindowsManager::ShowWindow ; (; RWebWindow & ; win, . const RWebDisplayArgs & ; user_args . ). private . Show window in specified location, see Show() method for more details. ; Show web window in specified location.; Parameters. [in,out]winweb window by reference ; user_argsspecifies where and how display web window. As display args one can use string like ""firefox"" or ""chrome"" - these are two main supported web browsers. See RWebDisplayArgs::SetBrowserKind() for all available options. Default value for the browser can be configured when starting root with –web argument like: ""root --web=chrome"". When root started in web server mode ""root --web=server"", no any web browser will be started - just URL will be printout, which can be entered in any running web browser; If allowed, same window can be disp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:14798,hash,hash,14798,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['hash'],['hash']
Security,"access to your application from external nodes!! ; Definition at line 129 of file RWebWindowsManager.cxx. ◆ SetShowCallback(). void ROOT::RWebWindowsManager::SetShowCallback ; (; WebWindowShowCallback_t ; func). inline . Assign show callback which can catch window showing, used by RBrowser. ; Definition at line 95 of file RWebWindowsManager.hxx. ◆ SetUseConnectionKey(). void RWebWindowsManager::SetUseConnectionKey ; (; bool ; on = true). static . Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection) to widget requires unique key Connection key used together with session key to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ; Definition at line 168 of file RWebWindowsManager.cxx. ◆ SetUseSessionKey(). void RWebWindowsManager::SetUseSessionKey ; (; bool ; on = true). static . Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ; Definition at line 157 of file RWebWindowsManager.cxx. ◆ ShowWindow(). unsigned RWebWindowsManager::ShowWindow ; (; RWebWindow & ; win, . const RWebDisplayArgs & ; user_args . ). private . Show window in specified location, see Show() method for more details. ; Show web window in specified location.; Parameters. [in,out]winweb window by reference ; user_argsspecifies where and how display web window. As display args one can use string like ""firefox"" or ""chrome"" - these are two main supported web browsers. See RWebDisplayArgs::SetBrowserKind() for all available options. Default value for the browser can be configured when starting root with –web argument like: ""root --web=chrome"". When root started in web server mode ""root --web=server"", no any web browser will be started - just URL will be printout, which can be entered in any running web browser; If allowed, same window can be disp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:17237,hash,hash,17237,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['hash'],['hash']
Security,"ace * ws () const;  The RooWorkspace this node belong to, if any. ;  ; template<typename T > ; T * xget () const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNode.html:9254,hash,hash,9254,doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNode.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1XRooFit_1_1xRooNode.html,1,['hash'],['hash']
Security,"ace to system lseek.Definition TFile.cxx:4525; TFile::SysStatvirtual Int_t SysStat(Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime)Return file stat information.Definition TFile.cxx:4543; TFile::SysOpenvirtual Int_t SysOpen(const char *pathname, Int_t flags, UInt_t mode)Interface to system open. All arguments like in POSIX open().Definition TFile.cxx:4481; TFile::ECacheActionECacheActionTTreeCache flushing semantics.Definition TFile.h:70; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::SetOpenTimeoutstatic UInt_t SetOpenTimeout(UInt_t timeout)Sets open timeout time (in ms). Returns previous timeout value.Definition TFile.cxx:4724; TFile::ReadFreevirtual void ReadFree()Read the FREE linked list.Definition TFile.cxx:1925; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TFile::fgTsSIHashesstatic ROOT::Internal::RConcurrentHashColl fgTsSIHashes!TS Set of hashes built from read streamer infosDefinition TFile.h:120; TFile::fBytesReadExtraLong64_t fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer.Definition TFile.h:77; TFile::fBytesWriteLong64_t fBytesWriteNumber of bytes written to this file.Definition TFile.h:75; TFile::fIsRootFileBool_t fIsRootFile!True is this is a ROOT file, raw file otherwiseDefinition TFile.h:104; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::fFreeTList * fFreeFree segments linked list table.Definition TFile.h:93; TFile::ReadBufferAsyncvirtual Bool_t ReadBufferAsync(Long64_t offs, Int_t len)Definition TFile.cxx:5208; TFile::Deletevoid Delete(const char *namecycle="""") overrideDelete object namecycle.Definition TFile.cxx:1098; TFile::fInitDoneBool_t fInitDone!True if the file has been initializedDefinition TFile.h:105; TFile::DrawMapvirtual void DrawMap(const char *keys=""*"", Option_t *option="""")Draw ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:225318,hash,hashes,225318,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['hash'],['hashes']
Security,"ace. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_float_2_.html:5810,access,access,5810,root/html526/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_float_2_.html,6,['access'],['access']
Security,"ace: ROOT::ResetClassVersion defined in TClassTable.cxx; Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the I/O should use the TClass checksum to distinguish the layout of the class . Definition at line 5675 of file TClass.cxx. ◆ SetCollectionProxy(). void TClass::SetCollectionProxy ; (; const ROOT::Detail::TCollectionProxyInfo & ; info). Create the collection proxy object (and the streamer object) from using the information in the TCollectionProxyInfo. ; Definition at line 6244 of file TClass.cxx. ◆ SetContextMenuTitle(). void TClass::SetContextMenuTitle ; (; const char * ; title). Change (i.e. set) the title of the TNamed. ; Definition at line 6269 of file TClass.cxx. ◆ SetConvStreamerFunc(). void TClass::SetConvStreamerFunc ; (; ClassConvStreamerFunc_t ; strm). Set a wrapper/accessor function around this class custom conversion streamer. ; Definition at line 6945 of file TClass.cxx. ◆ SetCurrentStreamerInfo(). void TClass::SetCurrentStreamerInfo ; (; TVirtualStreamerInfo * ; info). Set pointer to current TVirtualStreamerInfo. ; Definition at line 5696 of file TClass.cxx. ◆ SetDeclFile(). void TClass::SetDeclFile ; (; const char * ; name, . Short_t ; line . ). inline . Definition at line 555 of file TClass.h. ◆ SetDelete(). void TClass::SetDelete ; (; ROOT::DelFunc_t ; deleteFunc). Install a new wrapper around 'delete'. ; Definition at line 7001 of file TClass.cxx. ◆ SetDeleteArray(). void TClass::SetDeleteArray ; (; ROOT::DelArrFunc_t ; deleteArrayFunc). Install a new wrapper around 'delete []'. ; Definition at line 7009 of file TClass.cxx. ◆ SetDestructor(). void TClass::SetDestructor ; (; ROOT::DesFunc_t ; destructorFunc). Install a new wrapper around the destructor. ; Definition at line 7017 of file TClass.cxx. ◆ SetDirectoryAutoAdd(). void TClass::SetDirectoryAutoAdd ; (; ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:115170,access,accessor,115170,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['accessor']
Security,"ace: ROOT::ResetClassVersion defined in TClassTable.cxx; Note on class version numbers:; If no class number has been specified, TClass::GetVersion will return -1; The Class Version 0 request the whole object to be transient; The Class Version 1, unless specified via ClassDef indicates that the I/O should use the TClass checksum to distinguish the layout of the class . Definition at line 5742 of file TClass.cxx. ◆ SetCollectionProxy(). void TClass::SetCollectionProxy ; (; const ROOT::Detail::TCollectionProxyInfo & ; info). Create the collection proxy object (and the streamer object) from using the information in the TCollectionProxyInfo. ; Definition at line 6311 of file TClass.cxx. ◆ SetContextMenuTitle(). void TClass::SetContextMenuTitle ; (; const char * ; title). Change (i.e. set) the title of the TNamed. ; Definition at line 6336 of file TClass.cxx. ◆ SetConvStreamerFunc(). void TClass::SetConvStreamerFunc ; (; ClassConvStreamerFunc_t ; strm). Set a wrapper/accessor function around this class custom conversion streamer. ; Definition at line 7012 of file TClass.cxx. ◆ SetCurrentStreamerInfo(). void TClass::SetCurrentStreamerInfo ; (; TVirtualStreamerInfo * ; info). Set pointer to current TVirtualStreamerInfo. ; Definition at line 5763 of file TClass.cxx. ◆ SetDeclFile(). void TClass::SetDeclFile ; (; const char * ; name, . Short_t ; line . ). inline . Definition at line 555 of file TClass.h. ◆ SetDelete(). void TClass::SetDelete ; (; ROOT::DelFunc_t ; deleteFunc). Install a new wrapper around 'delete'. ; Definition at line 7068 of file TClass.cxx. ◆ SetDeleteArray(). void TClass::SetDeleteArray ; (; ROOT::DelArrFunc_t ; deleteArrayFunc). Install a new wrapper around 'delete []'. ; Definition at line 7076 of file TClass.cxx. ◆ SetDestructor(). void TClass::SetDestructor ; (; ROOT::DesFunc_t ; destructorFunc). Install a new wrapper around the destructor. ; Definition at line 7084 of file TClass.cxx. ◆ SetDirectoryAutoAdd(). void TClass::SetDirectoryAutoAdd ; (; ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:115171,access,accessor,115171,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['accessor']
Security,"aced.; 1987 if (oldcl->GetState() != TClass::kHasTClassInit) {; 1988 // if (gDebug > 2) Info(""RegisterModule"", ""Forcing TClass init for %s"", oldcl->GetName());; 1989 DictFuncPtr_t dict = fClassesToUpdate.back().second;; 1990 fClassesToUpdate.pop_back();; 1991 // Calling func could manipulate the list so, let maintain the list; 1992 // then call the dictionary function.; 1993 TClass *ncl = dict();; 1994 if (ncl) ncl->PostLoadCheck();; 1995 } else {; 1996 fClassesToUpdate.pop_back();; 1997 }; 1998 }; 1999}; 2000////////////////////////////////////////////////////////////////////////////////; 2001/// Inject the module named ""modulename"" into cling; load all headers.; 2002/// headers is a 0-terminated array of header files to `#include` after; 2003/// loading the module. The module is searched for in all $LD_LIBRARY_PATH; 2004/// entries (or %PATH% on Windows).; 2005/// This function gets called by the static initialization of dictionary; 2006/// libraries.; 2007/// The payload code is injected ""as is"" in the interpreter.; 2008/// The value of 'triggerFunc' is used to find the shared library location.; 2009 ; 2010void TCling::RegisterModule(const char* modulename,; 2011 const char** headers,; 2012 const char** includePaths,; 2013 const char* payloadCode,; 2014 const char* fwdDeclsCode,; 2015 void (*triggerFunc)(),; 2016 const FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip,; 2017 const char** classesHeaders,; 2018 Bool_t lateRegistration /*=false*/,; 2019 Bool_t hasCxxModule /*=false*/); 2020{; 2021 const bool fromRootCling = IsFromRootCling();; 2022 // We need the dictionary initialization but we don't want to inject the; 2023 // declarations into the interpreter, except for those we really need for; 2024 // I/O; see rootcling.cxx after the call to TCling__GetInterpreter().; 2025 if (fromRootCling) return;; 2026 ; 2027 // When we cannot provide a module for the library we should enable header; 2028 // parsing. This 'mixed' mode ensures gradual migration to modules.; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:76217,inject,injected,76217,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['inject'],['injected']
Security,aced;  ; int fNForm;  ; int fNInput;  ; int fNText;  ; int fNToken;  ; ColorStruct_t * fOldLinkColor;  ; int fOverrideColors;  ; int fOverrideFonts;  ; int fParaAlignment;  ; TGHtmlElement * fPFirst;  ; TGHtmlBlock * fPInsBlock;  ; TGHtmlElement * fPLast;  ; TGHtmlScript * fPScript;  ; TGHtmlBlock * fPSelEndBlock;  ; TGHtmlBlock * fPSelStartBlock;  ; int fRadioIdx;  ; int fRowAlignment;  ; int fRulePadding;  ; int fRuleRelief;  ; SHtmlIndex_t fSelBegin;  ; ColorStruct_t * fSelectionColor;  ; SHtmlIndex_t fSelEnd;  ; Html_16_t fSelEndIndex;  ; Html_16_t fSelStartIndex;  ; SHtmlStyleStack_t * fStyleStack;  ; int fTableBorderMin;  ; int fTableRelief;  ; THashTable * fUidTable;  ; int fUnderlineLinks;  ; int fVarId;  ; int fVarind;  ; const char * fZBase;  ; char * fZBaseHref;  ; char * fZGoto;  ; char * fZText;  ;  Protected Attributes inherited from TGView; TGViewFrame * fCanvas;  frame containing the text ;  ; Atom_t fClipboard;  clipboard property ;  ; TGRectangle fExposedRegion;  exposed area ;  ; TGHScrollBar * fHsb;  horizontal scrollbar ;  ; TGLongPosition fMousePos;  position of mouse ;  ; Int_t fScrolling;  scrolling direction ;  ; TGLongPosition fScrollVal;  scroll value ;  ; TGDimension fVirtualSize;  the current virtual window size ;  ; TGLongPosition fVisible;  position of visible region ;  ; TGVScrollBar * fVsb;  vertical scrollbar ;  ; TGGC fWhiteGC;  graphics context used for scrolling generates GraphicsExposure events ;  ; UInt_t fXMargin;  x margin ;  ; UInt_t fYMargin;  y margin ;  ;  Protected Attributes inherited from TGCompositeFrame; Bool_t fLayoutBroken;  no layout manager is used ;  ; TGLayoutManager * fLayoutManager;  layout manager ;  ; TList * fList;  container of frame elements ;  ; Bool_t fMapSubwindows;  kTRUE - map subwindows ;  ; Int_t fMustCleanup;  cleanup mode (see EFrameCleanup) ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDND,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:41866,expose,exposed,41866,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['expose'],['exposed']
Security,"acementVector3D< Cartesian3D< Scalar > > AxisVector;  definition of vector axis ;  ; typedef double Scalar;  ; typedef DisplacementVector3D< Cartesian3D< double >, DefaultCoordinateSystemTag > XYZVector;  Rotation operation on a cartesian vector. ;  . Public Member Functions;  AxisAngle ();  Default constructor (axis is z and angle is zero) ;  ; template<class AnyVector > ;  AxisAngle (const AnyVector &v, Scalar angle);  Construct from a non-zero vector (x,y,z) and an angle. ;  ; template<class OtherRotation > ; constexpr AxisAngle (const OtherRotation &r);  Construct from another supported rotation type (see gv_detail::convert ) ;  ; template<class IT > ;  AxisAngle (IT begin, IT end);  Construct given a pair of pointers or iterators defining the beginning and end of an array of four Scalars, to be treated as the x, y, and z components of a unit axis vector, and the angle of rotation. ;  ; Scalar Angle () const;  access to rotation angle ;  ; AxisVector Axis () const;  access to rotation axis ;  ; template<class R > ; Scalar Distance (const R &r) const;  Distance between two rotations. ;  ; template<class AnyVector > ; void GetComponents (AnyVector &axis, Scalar &angle) const;  Set components into a non-zero vector (x,y,z) and an angle. ;  ; template<class IT > ; void GetComponents (IT begin) const;  Get the axis and then the angle into data specified by an iterator begin. ;  ; template<class IT > ; void GetComponents (IT begin, IT end) const;  Get the axis and then the angle into data specified by an iterator begin and another to the end of the desired data (4 past start). ;  ; AxisAngle Inverse () const;  Return inverse of an AxisAngle rotation. ;  ; void Invert ();  Invert an AxisAngle rotation in place. ;  ; bool operator!= (const AxisAngle &rhs) const;  ; template<class CoordSystem , class Tag > ; DisplacementVector3D< CoordSystem, Tag > operator() (const DisplacementVector3D< CoordSystem, Tag > &v) const;  Rotation operation on a displacement vector in any coo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AxisAngle.html:1536,access,access,1536,doc/master/classROOT_1_1Math_1_1AxisAngle.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AxisAngle.html,2,['access'],['access']
Security,"achine fqdn> login <user> password <passwd>; <machine fqdn> may be a domain name or contain the wild card '*'.; for the secure protocols. All lines must start in the first column. ; Definition at line 908 of file TAuthenticate.cxx. ◆ CheckProofAuth(). Bool_t TAuthenticate::CheckProofAuth ; (; Int_t ; cSec, . TString & ; det . ). static . Check if the authentication method can be attempted for the client. ; Definition at line 3541 of file TAuthenticate.cxx. ◆ Class(). static TClass * TAuthenticate::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TAuthenticate::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TAuthenticate::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 207 of file TAuthenticate.h. ◆ ClearAuth(). Int_t TAuthenticate::ClearAuth ; (; TString & ; user, . TString & ; passwd, . Bool_t & ; pwdhash . ). private . UsrPwd client authentication code. ; Returns 0 in case authentication failed 1 in case of success ; Definition at line 1509 of file TAuthenticate.cxx. ◆ DeclFileName(). static const char * TAuthenticate::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 207 of file TAuthenticate.h. ◆ DecodeRSAPublic(). Int_t TAuthenticate::DecodeRSAPublic ; (; const char * ; rsapubexport, . R__rsa_NUMBER & ; n, . R__rsa_NUMBER & ; d, . char ** ; rsassl = nullptr . ). static . Store RSA public keys from export string rsaPubExport. ; Definition at line 2936 of file TAuthenticate.cxx. ◆ FileExpand(). void TAuthenticate::FileExpand ; (; const char * ; fexp, . FILE * ; ftmp . ). staticprivate . Expands include directives found in fexp files The expanded, temporary file, is pointed to by 'ftmp' and should be already open. ; To be called recursively. ; Definition at line 2093 of file TAuthenticate.cxx. ◆ GenRSAKeys(). Int_t TAuthenticate::GenRSAKeys ; (; ). priva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:24930,authenticat,authentication,24930,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"acity greater than or equal to newCap. ;  ; static Ssiz_t Align (Ssiz_t s);  ; static Ssiz_t Recommend (Ssiz_t s);  . Protected Attributes; Rep_t fRep;  . Private Types; enum  { kShortMask = 0x80; , kLongMask = 0x80000000; };  ; enum  ;  ; enum  { kNwords = sizeof(UStr_t) / sizeof(Ssiz_t); };  . Private Member Functions; void Clone (Ssiz_t nc);  Make self a distinct copy with capacity of at least tot, where tot cannot be smaller than the current length. ;  ; void FormImp (const char *fmt, va_list ap);  Formats a string using a printf style format descriptor. ;  ; Ssiz_t GetLongCap () const;  ; char * GetLongPointer ();  ; const char * GetLongPointer () const;  ; Ssiz_t GetLongSize () const;  ; char * GetPointer ();  ; const char * GetPointer () const;  ; char * GetShortPointer ();  ; const char * GetShortPointer () const;  ; Ssiz_t GetShortSize () const;  ; UInt_t HashCase () const;  Return a case-sensitive hash value (endian independent). ;  ; UInt_t HashFoldCase () const;  Return a case-insensitive hash value (endian independent). ;  ; char * Init (Ssiz_t capacity, Ssiz_t nchar);  Private member function returning an empty string representation of size capacity and containing nchar characters. ;  ; Bool_t IsLong () const;  ; void SetLongCap (Ssiz_t s);  ; void SetLongPointer (char *p);  ; void SetLongSize (Ssiz_t s);  ; void SetShortSize (Ssiz_t s);  ; void SetSize (Ssiz_t s);  ; void UnLink () const;  ; void Zero ();  . Static Private Member Functions; static Ssiz_t MaxSize ();  . Friends; TString operator+ (char c, const TString &s);  Add string to char. ;  ; TString operator+ (const char *cs, const TString &s);  Use the special concatenation constructor. ;  ; TString operator+ (const TString &s, char c);  Add char to string. ;  ; TString operator+ (const TString &s, const char *cs);  Use the special concatenation constructor. ;  ; TString operator+ (const TString &s1, const TString &s2);  Use the special concatenation constructor. ;  ; template<class T > ; std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTString.html:16111,hash,hash,16111,doc/v632/classTString.html,https://root.cern,https://root.cern/doc/v632/classTString.html,2,['hash'],['hash']
Security,"ackage {stats}. void BubbleHigh(Int_t Narr, Double_t* arr1, Int_t* arr2); Bubble sort variant to obtain the order of an array's elements into; an index in order to do more useful things than the standard built; in functions.; *arr1 is unchanged;; *arr2 is the array of indicies corresponding to the decending value; of arr1 with arr2[0] corresponding to the largest arr1 value and; arr2[Narr] the smallest. Author: Adrian Bevan (bevan@slac.stanford.edu). void BubbleLow(Int_t Narr, Double_t* arr1, Int_t* arr2); Opposite ordering of the array arr2[] to that of BubbleHigh. Author: Adrian Bevan (bevan@slac.stanford.edu). ULong_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string.; Based on precalculated table of 256 specially selected numbers.; These numbers are selected in such a way, that for string; length == 4 (integer number) the hash is unambigous, i.e.; from hash value we can recalculate input (no degeneration). The quality of hash method is good enough, that; ""random"" numbers made as R = Hash(1), Hash(2), ...Hash(N); tested by <R>, <R*R>, <Ri*Ri+1> gives the same result; as for libc rand(). For string: i = TMath::Hash(string,nstring);; For int: i = TMath::Hash(&intword,sizeof(int));; For pointer: i = TMath::Hash(&pointer,sizeof(void*));. V.Perev; This function is kept for back compatibility. The code previously in this function; has been moved to the static function TString::Hash. ULong_t Hash(const char* str). Double_t BesselI0(Double_t x); Compute the modified Bessel function I_0(x) for any real x. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselK0(Double_t x); Compute the modified Bessel function K_0(x) for positive real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; Applied Mathematics Series vol. 55 (1964), Washington. --- NvE 12-mar-2000 UU-SAP Utrecht. Double_t BesselI1(Double_t x); Compute the modified Bessel function I_1(x) for any real x. M.Abramowitz and I.A.Stegun, Handbook of Mathematical Functions,; A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:24589,hash,hash,24589,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,6,['hash'],['hash']
Security,"acro () override;  ; Longptr_t Exec (const char *params=""0"", Int_t *error=nullptr) override;  Execute the macro. ;  ; TClass * IsA () const override;  ; void ResetRoot ();  Call gROOT->Reset() via interpreter. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMacro;  TMacro ();  Create an empty macro, use AddLine() or ReadFile() to fill this macro. ;  ;  TMacro (const char *name, const char *title="""");  Create a macro with a name and a title. ;  ;  TMacro (const TMacro &);  Copy constructor. ;  ; virtual ~TMacro ();  Delete this macro. ;  ; virtual TObjString * AddLine (const char *text);  Add line with text in the list of lines of this macro. ;  ; void Browse (TBrowser *b) override;  When clicking in the browser, the following action is performed on this macro, depending the content of the variable TMacro.Browse. ;  ; virtual TMD5 * Checksum ();  Returns checksum of the current content. ;  ; virtual TObjString * GetLineWith (const char *text) const;  Search the first line containing text. ;  ; TList * GetListOfLines () const;  ; TClass * IsA () const override;  ; virtual Bool_t Load () const;  Load the macro into the interpreter. ;  ; TMacro & operator= (const TMacro &);  Copy constructor. ;  ; void Paint (Option_t *option="""") override;  Execute this macro (called by TPad::Paint). ;  ; void Print (Option_t *option="""") const override;  Print contents of this macro. ;  ; virtual Int_t ReadFile (const char *filename);  Read lines in filename in this macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save macro source on stream out. ;  ; virtual void SaveSource (const char *filename);  Save macro source in filename. ;  ; virtual void SetParams (const char *params=nullptr);  Set default parameters to execute this macro. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveMacro.html:1584,checksum,checksum,1584,doc/master/classTEveMacro.html,https://root.cern,https://root.cern/doc/master/classTEveMacro.html,1,['checksum'],['checksum']
Security,acroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TStringfGitBranchGit branch; TStringfGitCommitGit commit SHA1 of built; TStringfGitDateDate and time when make was run; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrupted; TList*TDirectory::fListList of objects in memory; TSeqCollection*fMappedFilesList of memory mapped files; TSeqCollection*fMessageHandlersList of message handlers; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustCleanTrue if object destructor scans canvases; TStringTNamed::fNameobject identifier; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TPluginManager*fPluginManagerKeeps track of plugin library handlers; const TObject*fPrimitiveCurrently selected primitive; TSeqCollection*fProofsList of proof sessions; Bool_tfReadingObjectTrue while reading an object [Deprecated (will be removed in next release); TFolder*fRootFoldertop level folder //root; TSeqCollection*fSecContextsList of security contexts (TSecContext); TVirtualPad*fSelectPadCurrently selected pad; TSeqCollection*fSocketsList of network sockets; TSeqCollection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; Int_tfSvnRevisionSubversion revision number of built (dec value of Git short SHA1); TSeqCollection*fTasksList of tasks; Int_tfTimerTimer flag; TStringTNamed::fTitleobject title; TCollection*fTypesList of data types definition; TUUIDTDirectory::fUUIDUnique identifier; TProcessUUID*fUUIDsPointer to TProcessID managing TUUIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TROOT.html:18952,secur,security,18952,root/html534/TROOT.html,https://root.cern,https://root.cern/root/html534/TROOT.html,1,['secur'],['security']
Security,"acting; executable archive files. The members are stored in the archive sequentially, each with a; local header followed by the (optionally) compressed data; the local; header describes the member, including its file name and compressed; and real sizes. The central directory includes the member details; again, plus allows an extra member comment to be added. The last; member in the central directory is an end marker that can contain; a comment for the whole archive. Both the local header and the; central directory can also carry extra member-specific data; the; data in the local and global parts can be different.; The fact that the archive has a global directory makes it efficient; and allows for only the reading of the desired data, one does not; have to scan through the whole file to find the desired sub-file. Once the archive has been opened, the client can query the members; and read their contents by asking the archive for an offset where; the sub-file starts. The members can be accessed in any order. Function Members (Methods); public:. TZIPFile(); TZIPFile(const char* archive, const char* member, TFile* file); virtual~TZIPFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TZIPFile.html:2329,access,accessed,2329,root/html528/TZIPFile.html,https://root.cern,https://root.cern/root/html528/TZIPFile.html,1,['access'],['accessed']
Security,"acting; executable archive files. The members are stored in the archive sequentially, each with a; local header followed by the (optionally) compressed data; the local; header describes the member, including its file name and compressed; and real sizes. The central directory includes the member details; again, plus allows an extra member comment to be added. The last; member in the central directory is an end marker that can contain; a comment for the whole archive. Both the local header and the; central directory can also carry extra member-specific data; the; data in the local and global parts can be different.; The fact that the archive has a global directory makes it efficient; and allows for only the reading of the desired data, one does not; have to scan through the whole file to find the desired sub-file. Once the archive has been opened, the client can query the members; and read their contents by asking the archive for an offset where; the sub-file starts. The members can be accessed in any order. Function Members (Methods); public:. TZIPMember(); TZIPMember(const char* name); TZIPMember(const TZIPMember& member); virtual~TZIPMember(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TZIPMember.html:2337,access,accessed,2337,root/html528/TZIPMember.html,https://root.cern,https://root.cern/root/html528/TZIPMember.html,1,['access'],['accessed']
Security,"action &T)Helper function to increase the internal Cling count of transactions that change the AST.Definition TCling.cxx:3665; TCling::ReadRootmapFileint ReadRootmapFile(const char *rootmapfile, TUniqueString *uniqueString=nullptr)Read and parse a rootmapfile in its new format, and return 0 in case of success, -1 if the file has a...Definition TCling.cxx:5528; TCling::fSpecialObjectMapsstd::map< SpecialObjectLookupCtx_t, SpecialObjectMap_t > fSpecialObjectMapsDefinition TCling.h:153; TCling::ClassInfo_Nextint ClassInfo_Next(ClassInfo_t *info) const finalDefinition TCling.cxx:8352; TCling::SetErrmsgcallbackvoid SetErrmsgcallback(void *p) const finalSet a callback to receive error messages.Definition TCling.cxx:7606; TCling::MethodArgInfo_IsValidbool MethodArgInfo_IsValid(MethodArgInfo_t *marginfo) const finalDefinition TCling.cxx:9272; TCling::TypeInfo_Sizeint TypeInfo_Size(TypeInfo_t *tinfo) const finalDefinition TCling.cxx:9412; TCling::DeleteGlobalInt_t DeleteGlobal(void *obj) finalDelete obj from Cling symbol table so it cannot be accessed anymore.Definition TCling.cxx:3783; TCling::GetSecurityErrorint GetSecurityError() const finalInterface to cling function.Definition TCling.cxx:7487; TCling::SetTempLevelvoid SetTempLevel(int val) const finalCreate / close a scope for temporaries.Definition TCling.cxx:7642; TCling::fPayloadsstd::set< size_t > fPayloadsDefinition TCling.h:122; TCling::FuncTempInfo_TemplateNargsUInt_t FuncTempInfo_TemplateNargs(FuncTempInfo_t *) const finalReturn the maximum number of template arguments of the function template described by ft_info.Definition TCling.cxx:8849; TCling::GetFunctionWithPrototypeDeclId_t GetFunctionWithPrototype(ClassInfo_t *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5155; TCling::TypedefInfo_FactoryTypedefInfo_t * Ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:429299,access,accessed,429299,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['access'],['accessed']
Security,"active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". void AddForCleanup(Int_t port, Int_t proto, Int_t type); Create a new TSecContextCleanup; Internally is added to the list. Bool_t IsA(const char* methodname); Checks if this security context is for method named 'methname'; Case sensitive. Bool_t IsActive() const; Check remote OffSet and expiring Date. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void * GetContext() const; { return fContext; }. TDatime GetExpDate() const; { return fExpDate; }. const char * GetHost() const; { return fHost; }. const char * GetID() const; { return fID; }. Int_t GetMethod() const; { return fMethod; }. const char * GetMethodName() const; { return fMethodName; }. Int_t GetOffSet() const; { return fOffSet; }. TList * GetSecContextCleanup() const; { return fCleanup; }. const char * GetToken() const; { return fToken; }. const char * GetUser() const; { return fUser; }. Bool_t IsA(const char* methodname). void SetExpDate(TDatime expdate); { fExpDate= expdate; }. void SetID(const char* id); { fID= id; }. void SetOffSet(Int_t offset); { fOffSet = offset; }. void SetUser(const char* user); { fUser = user; }. » Author: G. Ganis 31/03/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-03-14 16:49; This page has been",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSecContext.html:8328,secur,security,8328,root/html534/TSecContext.html,https://root.cern,https://root.cern/root/html534/TSecContext.html,1,['secur'],['security']
Security,"active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". void AddForCleanup(Int_t port, Int_t proto, Int_t type); Create a new TSecContextCleanup; Internally is added to the list. Bool_t IsA(const char* methodname); Checks if this security context is for method named 'methname'; Case sensitive. Bool_t IsActive() const; Check remote OffSet and expiring Date. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void * GetContext() const; { return fContext; }. TDatime GetExpDate() const; { return fExpDate; }. const char * GetHost() const; { return fHost; }. const char * GetID() const; { return fID; }. Int_t GetMethod() const; { return fMethod; }. const char * GetMethodName() const; { return fMethodName; }. Int_t GetOffSet() const; { return fOffSet; }. TList * GetSecContextCleanup() const; { return fCleanup; }. const char * GetToken() const; { return fToken; }. const char * GetUser() const; { return fUser; }. Bool_t IsA(const char* methodname). void SetExpDate(TDatime expdate); { fExpDate= expdate; }. void SetID(const char* id); { fID= id; }. void SetOffSet(Int_t offset); { fOffSet = offset; }. void SetUser(const char* user); { fUser = user; }. » Author: G. Ganis 31/03/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:32; This page has been",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSecContext.html:8825,secur,security,8825,root/html604/TSecContext.html,https://root.cern,https://root.cern/root/html604/TSecContext.html,1,['secur'],['security']
Security,"active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". void AddForCleanup(Int_t port, Int_t proto, Int_t type); Create a new TSecContextCleanup; Internally is added to the list. Bool_t IsA(const char* methodname); Checks if this security context is for method named 'methname'; Case sensitive. Bool_t IsActive() const; Check remote OffSet and expiring Date. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void * GetContext() const; { return fContext; }. TDatime GetExpDate() const; { return fExpDate; }. const char * GetHost() const; { return fHost; }. const char * GetID() const; { return fID; }. Int_t GetMethod() const; { return fMethod; }. const char * GetMethodName() const; { return fMethodName; }. Int_t GetOffSet() const; { return fOffSet; }. TList * GetSecContextCleanup() const; { return fCleanup; }. const char * GetToken() const; { return fToken; }. const char * GetUser() const; { return fUser; }. Bool_t IsA(const char* methodname). void SetExpDate(TDatime expdate); { fExpDate= expdate; }. void SetID(const char* id); { fID= id; }. void SetOffSet(Int_t offset); { fOffSet = offset; }. void SetUser(const char* user); { fUser = user; }. » Author: G. Ganis 31/03/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:29; This page has been",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSecContext.html:8825,secur,security,8825,root/html602/TSecContext.html,https://root.cern,https://root.cern/root/html602/TSecContext.html,1,['secur'],['security']
Security,"active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". void AddForCleanup(Int_t port, Int_t proto, Int_t type); Create a new TSecContextCleanup; Internally is added to the list. Bool_t IsA(const char* methodname); Checks if this security context is for method named 'methname'; Case sensitive. Bool_t IsActive() const; Check remote OffSet and expiring Date. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void * GetContext() const; { return fContext; }. TDatime GetExpDate() const; { return fExpDate; }. const char * GetHost() const; { return fHost; }. const char * GetID() const; { return fID; }. Int_t GetMethod() const; { return fMethod; }. const char * GetMethodName() const; { return fMethodName; }. Int_t GetOffSet() const; { return fOffSet; }. TList * GetSecContextCleanup() const; { return fCleanup; }. const char * GetToken() const; { return fToken; }. const char * GetUser() const; { return fUser; }. Bool_t IsA(const char* methodname). void SetExpDate(TDatime expdate); { fExpDate= expdate; }. void SetID(const char* id); { fID= id; }. void SetOffSet(Int_t offset); { fOffSet = offset; }. void SetUser(const char* user); { fUser = user; }. » Author: G. Ganis 31/03/2003 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TSecContext.h 23091 2008-04-09 15:04:27Z rdm $ » Last ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSecContext.html:8240,secur,security,8240,root/html528/TSecContext.html,https://root.cern,https://root.cern/root/html528/TSecContext.html,3,['secur'],['security']
Security,"ad(TClass* oldcl); we found at least one equivalent.; let's force a reload. void Init(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, const char* dfil, const char* ifil, Int_t dl, Int_t il, ClassInfo_t* classInfo, Bool_t silent); Initialize a TClass object. This object contains the full dictionary; of a class. It has list to baseclasses, datamembers and methods. ~TClass(); TClass dtor. Deletes all list that might have been created. Int_t ReadRules(); Read the class.rules files from the default location:.; $ROOTSYS/etc/class.rules (or ROOTETCDIR/class.rules). Int_t ReadRules(const char* filename); Read a class.rules file which contains one rule per line with comment; starting with a #; Returns the number of rules loaded.; Returns -1 in case of error. Bool_t AddRule(const char* rule); Add a schema evolution customization rule.; The syntax of the rule can be either the short form:; [type=Read] classname membername [attributes=... ] [version=[...] ] [checksum=[...] ] [oldtype=...] [code={...}]; or the long form; [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:27594,checksum,checksum,27594,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['checksum'],['checksum']
Security,"ad;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  ►NDetail;  ►NTDF;  CTCustomColumn;  CTCustomColumnBase;  CTFilter;  CTFilterBase;  CTLoopManager;  CTRange;  CTRangeBase;  CTBranchProxyBase class for all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CEnvironSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CIteratorsSmall helper to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< bool > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  ►CTSchemaRuleSet;  CTMatches;  ►NExecutorUtilsThis namespace contains pre-defined functions to be used in con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:11030,access,access,11030,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['access'],['access']
Security,"added, i.e. when you iterate over an unordered collection, you are not likely to retrieve elements in the same order they were added to the collection. The following unordered collections are available:. THashTable; TMap. 16.2 Iterators: Processing a Collection; The concept of processing all the members of a collection is generic, i.e. independent of any specific representation of a collection. To process each object in a collection one needs some type of cursor that is initialized and then steps over each member of the collection in turn. Collection objects could provide this service but there is a snag: as there is only one collection object per collection there would only be one cursor. Instead, to permit the use of as many cursors as required, they are made separate classes called iterator. For each collection class there is an associated iterator class that knows how to sequentially retrieve each member in turn. The relationship between a collection and its iterator is very close and may require that the iterator has full access to the collection (i.e. it is a friend class). In general iterator will be used via the TIter wrapper class. For example:. TList TListIter; TMap TMapIter. 16.3 Foundation Classes; All collections are based on the fundamental classes: TCollection and TIterator. They are so generic that it is not possible to create objects from them; they are only used as base classes for other classes (i.e. they are abstract base classes).; The TCollection class provides the basic protocol (i.e. the minimum set of member functions) that all collection classes have to implement. These include:. Add Adds another object to the collection.; GetSize Returns the number of objects in the collection.; Clear Clears out the collection, but does not delete the removed objects.; Delete Clears out the collection and deletes the removed objects. This should only be used if the collection owns its objects (which are not normally the case).; FindObject Finds an object gi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:844721,access,access,844721,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"adedObject.hxx. ◆ Merge(). template<class T > . std::shared_ptr< T > ROOT::TThreadedObject< T >::Merge ; (; TThreadedObjectUtils::MergeFunctionType< T > ; mergeFunction = TThreadedObjectUtils::MergeTObjects<T>). inline . Merge all the thread private objects. ; Can be called once: it does not create any new object but destroys the present bookkeping collapsing all objects into the one at slot 0. ; Definition at line 294 of file TThreadedObject.hxx. ◆ operator->(). template<class T > . T * ROOT::TThreadedObject< T >::operator-> ; (; ). inline . Access the wrapped object and allow to call its methods. ; Definition at line 286 of file TThreadedObject.hxx. ◆ SetAtSlot(). template<class T > . void ROOT::TThreadedObject< T >::SetAtSlot ; (; unsigned ; i, . std::shared_ptr< T > ; v . ). inline . Set the value of a particular slot. ; This method is thread-safe as long as concurrent calls access different slots (i.e. pass a different argument) and no thread accesses slot i via the arrow operator, so mixing usage of SetAtSlot with usage of the arrow operator can be dangerous. ; Definition at line 227 of file TThreadedObject.hxx. ◆ SnapshotMerge(). template<class T > . std::unique_ptr< T > ROOT::TThreadedObject< T >::SnapshotMerge ; (; TThreadedObjectUtils::MergeFunctionType< T > ; mergeFunction = TThreadedObjectUtils::MergeTObjects<T>). inline . Merge all the thread private objects. ; Can be called many times. It does create a new instance of class T to represent the ""Sum"" object. This method is not thread safe: correct or acceptable behaviours depend on the nature of T and of the merging function. ; Definition at line 312 of file TThreadedObject.hxx. Member Data Documentation. ◆ fDirectories. template<class T > . std::deque<TDirectory*> ROOT::TThreadedObject< T >::fDirectories. private . A TDirectory per slot. ; Definition at line 332 of file TThreadedObject.hxx. ◆ fgMaxSlots. template<class T > . constexpr const TNumSlots ROOT::TThreadedObject< T >::fgMaxSlots {64}. staticcon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html:8711,access,accesses,8711,doc/v632/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadedObject.html,2,['access'],['accesses']
Security,"afari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TUnixSystem(). TUnixSystem::TUnixSystem ; (; ). Definition at line 575 of file TUnixSystem.cxx. ◆ ~TUnixSystem(). TUnixSystem::~TUnixSystem ; (; ). virtual . Reset to original state. ; Definition at line 581 of file TUnixSystem.cxx. Member Function Documentation. ◆ Abort(). void TUnixSystem::Abort ; (; int ; code = 0). overridevirtual . Abort the application. ; Reimplemented from TSystem.; Definition at line 2202 of file TUnixSystem.cxx. ◆ AcceptConnection(). int TUnixSystem::AcceptConnection ; (; int ; sock). overridevirtual . Accept a connection. ; In case of an error return -1. In case non-blocking I/O is enabled and no connections are available return -2. ; Reimplemented from TSystem.; Definition at line 3276 of file TUnixSystem.cxx. ◆ AccessPathName(). Bool_t TUnixSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode = kFileExists . ). overridevirtual . Returns FALSE if one can access a file using the specified access mode. ; Mode is the same as for the Unix access(2) function. Attention, bizarre convention of return value!! ; Reimplemented from TSystem.; Definition at line 1579 of file TUnixSystem.cxx. ◆ AddDynamicPath(). void TUnixSystem::AddDynamicPath ; (; const char * ; lib). overridevirtual . Add a new directory to the dynamic path. ; Reimplemented from TSystem.; Definition at line 4725 of file TUnixSystem.cxx. ◆ AddFileHandler(). void TUnixSystem::AddFileHandler ; (; TFileHandler * ; h). overridevirtual . Add a file handler to the list of system file handlers. ; Only adds the handler if it is not already in the list of file handlers. ; Reimplemented from TSystem.; Definition at line 782 of file TUnixSystem.cxx. ◆ AddSignalHandler(). void TUnixSystem::AddSignalHandler ; (; TSignalHandler * ; h). overridevirtual . Add a signal handler to list of system signal handlers. ; Only adds the handler if it is not already in the list of signal handlers. ; Reimplemented fro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:38750,access,access,38750,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,2,['access'],['access']
Security,"after having deduced the list of necessary branches; 574from the names of the variables specified by the user.; 575 ; 576#### Custom columns as function of slot and entry number; 577 ; 578It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can; 579be invoked are:; 580- `DefineSlot(name, f, columnList)`. In this case the callable f has this signature `R(unsigned int, T1, T2, ...)`: the; 581first parameter is the slot number which ranges from 0 to ROOT::GetThreadPoolSize() - 1.; 582- `DefineSlotEntry(name, f, columnList)`. In this case the callable f has this signature `R(unsigned int, ULong64_t,; 583T1, T2, ...)`: the first parameter is the slot number while the second one the number of the entry being processed.; 584 ; 585\anchor actions; 586## Actions: getting results; 587### Instant and lazy actions; 588Actions can be **instant** or **lazy**. Instant actions are executed as soon as they are called, while lazy actions are; 589executed whenever the object they return is accessed for the first time. As a rule of thumb, actions with a return value; 590are lazy, the others are instant.; 591 ; 592### Return type of a lazy action; 593 ; 594When a lazy action is called, it returns a \link ROOT::RDF::RResultPtr ROOT::RDF::RResultPtr<T>\endlink, where T is the; 595type of the result of the action. The final result will be stored in the `RResultPtr` and can be retrieved by; 596dereferencing it or via its `GetValue` method.; 597 ; 598### Actions that return collections; 599 ; 600If the type of the return value of an action is a collection, e.g. `std::vector<int>`, you can iterate its elements; 601directly through the wrapping `RResultPtr`:; 602 ; 603~~~{.cpp}; 604ROOT::RDataFrame df{5};; 605auto df1 = df.Define(""x"", []{ return 42; });; 606for (const auto &el: df1.Take<int>(""x"")){; 607 std::cout << ""Element: "" << el << ""\n"";; 608}; 609~~~; 610 ; 611~~~{.py}; 612df = ROOT.RDataFrame(5).Define(""x"", ""42""); 613for el",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:36136,access,accessed,36136,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['accessed']
Security,"after having deduced the list of necessary branches; 614from the names of the variables specified by the user.; 615 ; 616#### Custom columns as function of slot and entry number; 617 ; 618It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can; 619be invoked are:; 620- `DefineSlot(name, f, columnList)`. In this case the callable f has this signature `R(unsigned int, T1, T2, ...)`: the; 621first parameter is the slot number which ranges from 0 to ROOT::GetThreadPoolSize() - 1.; 622- `DefineSlotEntry(name, f, columnList)`. In this case the callable f has this signature `R(unsigned int, ULong64_t,; 623T1, T2, ...)`: the first parameter is the slot number while the second one the number of the entry being processed.; 624 ; 625\anchor actions; 626## Actions: getting results; 627### Instant and lazy actions; 628Actions can be **instant** or **lazy**. Instant actions are executed as soon as they are called, while lazy actions are; 629executed whenever the object they return is accessed for the first time. As a rule of thumb, actions with a return value; 630are lazy, the others are instant.; 631 ; 632### Return type of a lazy action; 633 ; 634When a lazy action is called, it returns a \link ROOT::RDF::RResultPtr ROOT::RDF::RResultPtr<T>\endlink, where T is the; 635type of the result of the action. The final result will be stored in the `RResultPtr` and can be retrieved by; 636dereferencing it or via its `GetValue` method.; 637 ; 638### Actions that return collections; 639 ; 640If the type of the return value of an action is a collection, e.g. `std::vector<int>`, you can iterate its elements; 641directly through the wrapping `RResultPtr`:; 642 ; 643~~~{.cpp}; 644ROOT::RDataFrame df{5};; 645auto df1 = df.Define(""x"", []{ return 42; });; 646for (const auto &el: df1.Take<int>(""x"")){; 647 std::cout << ""Element: "" << el << ""\n"";; 648}; 649~~~; 650 ; 651~~~{.py}; 652df = ROOT.RDataFrame(5).Define(""x"", ""42""); 653for el",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:37776,access,accessed,37776,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['accessed']
Security,"ag for specified object from objects map (if exists) Returns 0 if object not included into objects map. ;  ; virtual void WriteObjectClass (const void *actualObjStart, const TClass *actualClass, Bool_t cacheReuse)=0;  ;  Protected Member Functions inherited from TBuffer;  TBuffer ();  ;  TBuffer (const TBuffer &)=delete;  ; void operator= (const TBuffer &)=delete;  ; Int_t Read (const char *name) override;  Read contents of object with specified name from the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name, Int_t opt, Int_t bufs) override;  Write this object to the current directory. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Static Protected Member Functions; static R__ALWAYS_INLINE ULong_t Void_Hash (const void *ptr);  Return hash value for provided object. ;  . Protected Attributes; TExMap * fClassMap {nullptr};  Map containing object,class pairs for reading. ;  ; Int_t fDisplacement {0};  Value to be added to the map offsets. ;  ; TExMap * fMap {nullptr};  Map containing object,offset pairs for reading/writing. ;  ; Int_t fMapCount {0};  Number of objects or classes in map. ;  ; Int_t fMapSize {0};  Default size of map. ;  ; UShort_t fPidOffset {0};  Offset to be added to the pid index in this key/buffer. ;  ;  Protected Attributes inherited from TBuffer; char * fBufCur;  ; char * fBuffer;  ; char * fBufMax;  ; Int_t fBufSize;  ; CacheList_t fCacheStack;  Realloc function to be used when extending the buffer. ;  ; Bool_t fMode;  ; TObject * fParent;  ; ReAllocCharFun_t fReAllocFunc;  ; Int_t fVersion;  . Static Protected Attributes; static Int_t fgMapSize = kMapSize;  Default map size for all TBuffer objects. ;  . #include <TBufferIO.h>. Inheritance diagram for TBuffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:28328,hash,hash,28328,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['hash'],['hash']
Security,"ag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11252,access,access,11252,root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"ageOpt opt=kUntar, TList *workers=0);  Upload a PROOF archive (PAR file). ;  ; Bool_t UseDynamicStartup () const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:21574,hash,hash,21574,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['hash'],['hash']
Security,"ager class.; 135 ; 136\image html geom_mgr.jpg; 137 ; 138## An interactive session; 139 ; 140 Provided that a geometry was successfully built and closed (for instance the; 141previous example $ROOTSYS/tutorials/geom/rootgeom.C ), the manager class will register; 142itself to ROOT and the logical/physical structures will become immediately browsable.; 143The ROOT browser will display starting from the geometry folder : the list of; 144transformations and media, the top volume and the top logical node. These last; 145two can be fully expanded, any intermediate volume/node in the browser being subject; 146of direct access context menu operations (right mouse button click). All user; 147utilities of classes TGeoManager, TGeoVolume and TGeoNode can be called via the; 148context menu.; 149 ; 150\image html geom_browser.jpg; 151 ; 152### Drawing the geometry; 153 ; 154 Any logical volume can be drawn via TGeoVolume::Draw() member function.; 155This can be directly accessed from the context menu of the volume object; 156directly from the browser.; 157 There are several drawing options that can be set with; 158TGeoManager::SetVisOption(Int_t opt) method :; 159 ; 160#### opt=0; 161 only the content of the volume is drawn, N levels down (default N=3).; 162 This is the default behavior. The number of levels to be drawn can be changed; 163 via TGeoManager::SetVisLevel(Int_t level) method.; 164 ; 165\image html geom_frame0.jpg; 166 ; 167#### opt=1; 168 the final leaves (e.g. daughters with no containment) of the branch; 169 starting from volume are drawn down to the current number of levels.; 170 WARNING : This mode is memory consuming; 171 depending of the size of geometry, so drawing from top level within this mode; 172 should be handled with care for expensive geometries. In future there will be; 173 a limitation on the maximum number of nodes to be visualized.; 174 ; 175\image html geom_frame1.jpg; 176 ; 177#### opt=2; 178 only the clicked volume is visualized. This is automa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:9100,access,accessed,9100,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['access'],['accessed']
Security,"ager->SetCurrentTrack(track);; // or directly; gGeoManager->SetCurrentTrack(track_index);; TVirtualGeoTrack *current = gGeoManager->GetCurrentTrack();; One can also look for a track by user id or track index:; ptrTrack = gGeoManager->GetTrackOfId(user_id);; ptrParent = gGeoManager->GetParentTrackOfId(user_id);; ptrTrack = gGeoManager->GetTrack(index);; Supposing a particle represented by a primary track decays or interacts, one should not create new primaries as described before, but rather add them as secondary:; TVirtualGeoTrack *secondary =; ptrTrack->AddTrack(secondId,pdg,secondParticle);; At any step made by the current track, one is able to add control points to either primary or secondary:; track->AddPoint(x,y,z,t);; After tracks were defined and filled during tracking, one will be able to browse directly the list of tracks held by the manager class. Any track can be drawn using its Draw() and Animate() methods, but there are also global methods for drawing or animation that can be accessed from TGeoManager context menu:; TGeoManager::DrawTracks(Option_t *option);; TGeoManager::AnimateTracks(Double_t tmin=0.,Double_t tmax=1E-8,; Int_t nframes=200,Option_t *option="""");; The drawing/animation time range is a global variable that can be directly set:; gGeoManager->SetTminTmax(tmin, tmax);; // without arguments resets the time range to the maximum value; Once set, the time range will be active both for individual or global track drawing. For animation, this range is divided to the desired number of frames and will be automatically updated at each frame in order to get the animation effect.; The option provided to all track-drawing methods can trigger different track selections:; default:A track (or all primary tracks) drawn without daughters; /D: Track and first level descendents only are drawn; /*: Track and all descendents are drawn; /Ntype: All tracks having name=type are drawn; Generally several options can be concatenated in the same string (E.g. ""/D /Npion-""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:996110,access,accessed,996110,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessed']
Security,"agma GCC diagnostic push; 3364#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3365#endif; 3366 ; 3367 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3368 ; 3369#if defined(GCC_DIAGNOSTIC); 3370#pragma GCC diagnostic pop; 3371#endif; 3372 ; 3373 buf[sizeof(buf) - 1] = 0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:101109,access,access,101109,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"agma GCC diagnostic push; 3365#pragma GCC diagnostic ignored ""-Wformat-nonliteral""; 3366#endif; 3367 ; 3368 IGNORE_UNUSED_RESULT(vsnprintf_impl(buf, sizeof(buf), fmt, ap));; 3369 ; 3370#if defined(GCC_DIAGNOSTIC); 3371#pragma GCC diagnostic pop; 3372#endif; 3373 ; 3374 buf[sizeof(buf) - 1] = 0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:101141,access,access,101141,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"ails(). char * TAuthenticate::GetDefaultDetails ; (; Int_t ; method, . Int_t ; opt, . const char * ; usr . ). static . Determine default authentication details for method 'sec' and user 'usr'. ; Checks .rootrc family files. Returned string must be deleted by the user. ; Definition at line 2172 of file TAuthenticate.cxx. ◆ GetDefaultUser(). const char * TAuthenticate::GetDefaultUser ; (; ). static . Static method returning the default user information. ; Definition at line 1034 of file TAuthenticate.cxx. ◆ GetGlobalExpDate(). TDatime TAuthenticate::GetGlobalExpDate ; (; ). static . Static method returning default expiring date for new validity contexts. ; Definition at line 1026 of file TAuthenticate.cxx. ◆ GetGlobalPwHash(). Bool_t TAuthenticate::GetGlobalPwHash ; (; ). static . Static method returning the global password hash flag. ; Definition at line 1010 of file TAuthenticate.cxx. ◆ GetGlobalSRPPwd(). Bool_t TAuthenticate::GetGlobalSRPPwd ; (; ). static . Static method returning the global SRP password flag. ; Definition at line 1018 of file TAuthenticate.cxx. ◆ GetGlobalUser(). const char * TAuthenticate::GetGlobalUser ; (; ). static . Static method returning the global user. ; Definition at line 1002 of file TAuthenticate.cxx. ◆ GetGlobusAuthHook(). GlobusAuth_t TAuthenticate::GetGlobusAuthHook ; (; ). static . Static method returning the globus authorization hook (no longer supported) ; Definition at line 1194 of file TAuthenticate.cxx. ◆ GetHostAuth() [1/2]. THostAuth * TAuthenticate::GetHostAuth ; (; ); const. inline . Definition at line 140 of file TAuthenticate.h. ◆ GetHostAuth() [2/2]. THostAuth * TAuthenticate::GetHostAuth ; (; const char * ; host, . const char * ; user = """", . Option_t * ; opt = ""R"", . Int_t * ; exact = nullptr . ). static . Sets fUser=user and search fgAuthInfo for the entry pertaining to (host,user), setting fHostAuth accordingly. ; If opt = ""P"" use fgProofAuthInfo list instead If no entry is found fHostAuth is not changed ; Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:28151,password,password,28151,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['password'],['password']
Security,"ains all keys; >= n[i].key.; Order is at least 3. The values of InnerLowWaterMark and LeafLowWaterMark may actually be set; by the user when the tree is initialized, but currently they are set; automatically to:. InnerLowWaterMark = ceiling(Order/2); LeafLowWaterMark = Order - 1. If the tree is only filled, then all the nodes will be at least 2/3 full.; They will almost all be exactly 2/3 full if the elements are added to the; tree in order (either increasing or decreasing). [Knuth says McCreight's; experiments showed almost 100% memory utilization. I don't see how that; can be given the algorithms that Knuth gives. McCreight must have used; a different scheme for balancing. [No, he used a different scheme for; splitting: he did a two-way split instead of the three way split as we do; here. Which means that McCreight does better on insertion of ordered data,; but we should do better on insertion of random data.]]. It must also be noted that B-trees were designed for DISK access algorithms,; not necessarily in-memory sorting, as we intend it to be used here. However,; if the order is kept small (< 6?) any inefficiency is negligible for; in-memory sorting. Knuth points out that balanced trees are actually; preferable for memory sorting. I'm not sure that I believe this, but; it's interesting. Also, deleting elements from balanced binary trees, being; beyond the scope of Knuth's book (p. 465), is beyond my scope. B-trees; are good enough. A B-tree is declared to be of a certain ORDER (3 by default). This number; determines the number of keys contained in any interior node of the tree.; Each interior node will contain ORDER keys, and therefore ORDER+1 pointers; to sub-trees. The keys are numbered and indexed 1 to ORDER while the; pointers are numbered and indexed 0 to ORDER. The 0th ptr points to the; sub-tree of all elements that are less than key[1]. Ptr[1] points to the; sub-tree that contains all the elements greater than key[1] and less than; key[2]. etc. The array",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBtree.html:2774,access,access,2774,root/html526/TBtree.html,https://root.cern,https://root.cern/root/html526/TBtree.html,7,['access'],['access']
Security,"al RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); voidfixRefRange(const char* rangeName); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:14483,hash,hash,14483,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,3,['hash'],['hash']
Security,"al code. The mechanism of handling multiple geometries; 100at the same time will be soon implemented.; 101 ; 102 TGeoManager is the owner of all geometry objects defined in a session,; 103therefore users must not try to control their deletion. It contains lists of; 104media, materials, transformations, shapes and volumes. Logical nodes (positioned; 105volumes) are created and destroyed by the TGeoVolume class. Physical; 106nodes and their global transformations are subjected to a caching mechanism; 107due to the sometimes very large memory requirements of logical graph expansion.; 108The caching mechanism is triggered by the total number of physical instances; 109of volumes and the cache manager is a client of TGeoManager. The manager class; 110also controls the painter client. This is linked with ROOT graphical libraries; 111loaded on demand in order to control visualization actions.; 112 ; 113## Rules for building a valid geometry; 114 ; 115 A given geometry can be built in various ways, but there are mandatory steps; 116that have to be followed in order to be validated by the modeler. There are; 117general rules : volumes needs media and shapes in order to be created,; 118both container and containee volumes must be created before linking them together,; 119and the relative transformation matrix must be provided. All branches must; 120have an upper link point otherwise they will not be considered as part of the; 121geometry. Visibility or tracking properties of volumes can be provided both; 122at build time or after geometry is closed, but global visualization settings; 123(see TGeoPainter class) should not be provided at build time, otherwise the; 124drawing package will be loaded. There is also a list of specific rules :; 125positioned daughters should not extrude their mother or intersect with sisters; 126unless this is specified (see TGeoVolume::AddNodeOverlap()), the top volume; 127(containing all geometry tree) must be specified before closing the geometry; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:6904,validat,validated,6904,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['validat'],['validated']
Security,"al gradient. ; Definition at line 287 of file TColorGradient.cxx. ◆ SetStartEndR1R2(). void TRadialGradient::SetStartEndR1R2 ; (; const Point & ; p1, . Double_t ; r1, . const Point & ; p2, . Double_t ; r2 . ). Set start and end R1 and R2. ; Definition at line 242 of file TColorGradient.cxx. ◆ Streamer(). void TRadialGradient::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TColorGradient. ◆ StreamerNVirtual(). void TRadialGradient::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 160 of file TColorGradient.h. ◆ TColorGradient() [1/3]. TColorGradient::TColorGradient ; (; ). inline . Definition at line 70 of file TColorGradient.h. ◆ TColorGradient() [2/3]. TColorGradient::TColorGradient ; (; Color_t ; newColor, . UInt_t ; nPoints, . const Double_t * ; points, . const Color_t * ; colorIndices, . ECoordinateMode ; mode = kObjectBoundingMode . ). There is no way to validate parameters here, so it's up to user to pass correct arguments. ; Definition at line 71 of file TColorGradient.cxx. ◆ TColorGradient() [3/3]. TColorGradient::TColorGradient ; (; Color_t ; newColor, . UInt_t ; nPoints, . const Double_t * ; points, . const Double_t * ; colors, . ECoordinateMode ; mode = kObjectBoundingMode . ). There is no way to validate parameters here, so it's up to user to pass correct arguments. ; Definition at line 73 of file TColorGradient.cxx. Member Data Documentation. ◆ fEnd. Point TRadialGradient::fEnd. private . Definition at line 155 of file TColorGradient.h. ◆ fR1. Double_t TRadialGradient::fR1 = 0. private . Definition at line 154 of file TColorGradient.h. ◆ fR2. Double_t TRadialGradient::fR2 = 0. private . Definition at line 156 of file TColorGradient.h. ◆ fStart. Point TRadialGradient::fStart. private . Definition at line 153 of file TColorGradient.h. ◆ fType. EGradientType TRadialGradient::fType = kSimple. private . Definition at line 158 of file TColorGradient.h. Librar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRadialGradient.html:25408,validat,validate,25408,doc/master/classTRadialGradient.html,https://root.cern,https://root.cern/doc/master/classTRadialGradient.html,1,['validat'],['validate']
Security,"al interpolation between the bins may improve the result if coarse binnings are chosen. These can be activated in the constructor or by calling setInterpolationOrder(). For N >> 1000, interpolation will not substantially improve the accuracy.; Additionial information on caching can be displayed by monitoring the message stream with topic ""Caching"" at the INFO level, i.e. by calling RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")) to see these message on stdout.; Multi-dimensional convolutions are not supported at the moment. Installing an external version of FFTW on Linux and compiling ROOT to use it; You have two options:; Recommended: ROOT can automatically install FFTW for itself, see builtin_fftw3 at https://root.cern/building-root; Install FFTW and let ROOT discover it. fftw3 is on by default (see https://root.cern/building-root). 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file); If you have root access to your machine and want to make a system installation of FFTW; 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory and type './configure' followed by 'make install'. This will install fftw in /usr/local/bin,lib etc...; 3) Start from a source installation of ROOT. ROOT should discover it. See https://root.cern/building-root; If you do not have root access and want to make a private installation of FFTW; 2) Make a private install area for FFTW, e.g. /home/myself/fftw; 3) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory and type './configure –prefix=/home/myself/fftw' followed by 'make install'. Substitute /home/myself/fftw with a directory of your choice. This procedure will install FFTW in the location designated by you; 4) Start from a source installation of ROOT. Look up and set the proper paths for ROOT to discover FFTW. See https://root.cern/building-root ; Definition at line 25 of file RooFFTConvPdf.h. Classes; class  FFTCacheElem;  . Public Types; enum  BufStrat { Extend =0; , ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:4155,access,access,4155,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['access'],['access']
Security,"al number of entries; ++fNumberOfEvents;. return kTRUE;; }. And finally, at the end of the process, in TSelector::Terminate(), print the total number of entries:; void EventSelector::Terminate(); {; // ... // print the result; printf(""\nTotal Number of Events: %d\n"", fNumberOfEvents);; }. As you can see, the fNumberOfEvents member is accessed in Process() and Terminate(), hence the reason of making it a data member.; More Complex Task; We want to calculate the sum of all event sizes. For this we need a new data member of type int. Create it - like the other data members in the class declaration. Don't forget to initialize it to 0 in the constructor. You also have to declare the reader variables used to access the tree's data. At the end, the code in EventSelector.h should look like this:; class EventSelector : public TSelector {; public :; Int_t fTotalDataSize; // Sum of data size (in bytes) of all events. // Variables used to access and store the data; TTreeReader fReader; // The tree reader ; TTreeReaderValue<Int_t> fCurrentEventSize; // Size of the current event. EventSelector(TTree * = 0):; fTotalDataSize(0),; fCurrentEventSize(fReader, ""fEventSize"") { }; virtual ~EventSelector() { }. virtual void Init(TTree *tree);; ... Connecting a Tree Branch with the Data Member; As already explained in the Using a Macro to Read a TTree tutorial, here again we have to ""connect"" the TTreeReader to the tree we want to read by calling TTreeReader::SetTree(). This has to be done in the TSelector::Init() method, as shown below:; void EventSelector::Init(TTree *tree); {; //... // Associate the TTreeReader with the tree we want to read; fReader.SetTree(tree);; }. Loading TTree's Data; For the analysis example we need to get the events' size, which is accessible through the selector's data member fCurrentEventSize. But the TTreeReader first needs know which TTree entry is the current one, i.e. which entry Process() is called on. So instead of looping yourself using TTreeReader::Next(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tselector.html:5489,access,access,5489,d/accessing-ttree-tselector.html,https://root.cern,https://root.cern/d/accessing-ttree-tselector.html,1,['access'],['access']
Security,"al void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static UChar_t GetAcceptOptions ();  Return default options for Accept. ;  ; static void SetAcceptOptions (UChar_t Opt);  Set default options for Accept according to modifier 'mod'. ;  ; static void ShowAcceptOptions ();  Print default options for Accept. ;  ;  Static Public Member Functions inherited from TSocket; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TSocket * CreateAuthSocket (const char *url, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server. ;  ; static TSocket * CreateAuthSocket (const char *user, const char *host, Int_t port, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ;  ; static const char * DeclFileName ();  ; static Int_t GetClientProtocol ();  Static method returning supported client protocol. ;  ; static ULong64_t GetSocketBytesRecv ();  Get total number of bytes received via all sockets. ;  ; static ULong64_t GetSocketBytesSent ();  Get total number of bytes sent via all sockets. ;  ; static void NetError (const char *where, Int_t error);  Print error string depending on error code. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTServerSocket.html:15141,authenticat,authenticates,15141,doc/master/classTServerSocket.html,https://root.cern,https://root.cern/doc/master/classTServerSocket.html,1,['authenticat'],['authenticates']
Security,"al(phys_ctx,; 16565 ""Domain SSL callback returned error: %i"",; 16566 callback_ret);; 16567 return 0;; 16568 }; 16569 if (callback_ret > 0) {; 16570 /* Domain callback did everything. */; 16571 return 1;; 16572 }; 16573 ; 16574 /* Use some combination of start time, domain and port as a SSL; 16575 * context ID. This should be unique on the current machine. */; 16576 md5_init(&md5state);; 16577 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16578 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16579 md5_append(&md5state,; 16580 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16581 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16582 md5_append(&md5state,; 16583 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16584 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16585 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16586 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16587 md5_finish(&md5state, ssl_context_id);; 16588 ; 16589 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16590 (unsigned char *)ssl_context_id,; 16591 sizeof(ssl_context_id));; 16592 ; 16593 if (pem != NULL) {; 16594 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16595 return 0;; 16596 }; 16597 }; 16598 ; 16599 /* Should we support client certificates? */; 16600 /* Default is ""no"". */; 16601 should_verify_peer = 0;; 16602 peer_certificate_optional = 0;; 16603 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16604 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16605 /* Yes, they are mandatory */; 16606 should_verify_peer = 1;; 16607 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16608 ""optional""); 16609 == 0) {; 16610 /* Yes, they are optional */; 16611 should_verify_peer = 1;; 16612 peer_certificate_optional = 1;; 16613 }; 16614 }; 16615 ; 16616 use_default_verify_paths =; 16617 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16618 && (mg_strcasecmp(dom_c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:492189,certificate,certificates,492189,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['certificate'],['certificates']
Security,"al(phys_ctx,; 16566 ""Domain SSL callback returned error: %i"",; 16567 callback_ret);; 16568 return 0;; 16569 }; 16570 if (callback_ret > 0) {; 16571 /* Domain callback did everything. */; 16572 return 1;; 16573 }; 16574 ; 16575 /* Use some combination of start time, domain and port as a SSL; 16576 * context ID. This should be unique on the current machine. */; 16577 md5_init(&md5state);; 16578 clock_gettime(CLOCK_MONOTONIC, &now_mt);; 16579 md5_append(&md5state, (const md5_byte_t *)&now_mt, sizeof(now_mt));; 16580 md5_append(&md5state,; 16581 (const md5_byte_t *)phys_ctx->dd.config[LISTENING_PORTS],; 16582 strlen(phys_ctx->dd.config[LISTENING_PORTS]));; 16583 md5_append(&md5state,; 16584 (const md5_byte_t *)dom_ctx->config[AUTHENTICATION_DOMAIN],; 16585 strlen(dom_ctx->config[AUTHENTICATION_DOMAIN]));; 16586 md5_append(&md5state, (const md5_byte_t *)phys_ctx, sizeof(*phys_ctx));; 16587 md5_append(&md5state, (const md5_byte_t *)dom_ctx, sizeof(*dom_ctx));; 16588 md5_finish(&md5state, ssl_context_id);; 16589 ; 16590 SSL_CTX_set_session_id_context(dom_ctx->ssl_ctx,; 16591 (unsigned char *)ssl_context_id,; 16592 sizeof(ssl_context_id));; 16593 ; 16594 if (pem != NULL) {; 16595 if (!ssl_use_pem_file(phys_ctx, dom_ctx, pem, chain)) {; 16596 return 0;; 16597 }; 16598 }; 16599 ; 16600 /* Should we support client certificates? */; 16601 /* Default is ""no"". */; 16602 should_verify_peer = 0;; 16603 peer_certificate_optional = 0;; 16604 if (dom_ctx->config[SSL_DO_VERIFY_PEER] != NULL) {; 16605 if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER], ""yes"") == 0) {; 16606 /* Yes, they are mandatory */; 16607 should_verify_peer = 1;; 16608 } else if (mg_strcasecmp(dom_ctx->config[SSL_DO_VERIFY_PEER],; 16609 ""optional""); 16610 == 0) {; 16611 /* Yes, they are optional */; 16612 should_verify_peer = 1;; 16613 peer_certificate_optional = 1;; 16614 }; 16615 }; 16616 ; 16617 use_default_verify_paths =; 16618 (dom_ctx->config[SSL_DEFAULT_VERIFY_PATHS] != NULL); 16619 && (mg_strcasecmp(dom_c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:492222,certificate,certificates,492222,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['certificate'],['certificates']
Security,"al, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tTClass::GetCheckSum(Bool_t& isvalid) const; UInt_tTClass::GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tTClass::GetClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:6389,checksum,checksum,6389,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,2,['checksum'],['checksum']
Security,"al, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; virtual void DeletePlayer ();  Delete player instance. ;  ; virtual Int_t Fork ();  Fork a child. ;  ; Int_t GetSessionStatus ();  Return the status of this session: 0 idle 1 running 2 being terminated (currently unused) 3 queued 4 idle timed-out (not set in here but in TIdleTOTimer::Notify) This is typically run in the reader thread, so access needs to be protected. ;  ; virtual void HandleArchive (TMessage *mess, TString *slb=0);  Handle archive request. ;  ; virtual Int_t HandleCache (TMessage *mess, TString *slb=0);  Handle here all cache and package requests. ;  ; virtual void HandleCheckFile (TMessage *mess, TString *slb=0);  Handle file checking request. ;  ; virtual Int_t HandleDataSets (TMessage *mess, TString *slb=0);  Handle here requests about datasets. ;  ; virtual void HandleFork (TMessage *mess);  Cloning itself via fork. Not implemented. ;  ; virtual Int_t HandleLibIncPath (TMessage *mess);  Handle lib, inc search paths modification request. ;  ; virtual void HandleProcess (TMessage *mess, TString *slb=0);  Handle processing request. ;  ; virtual void HandleQueryList (TMessage *mess);  Handle request for list of queries. ;  ; virtual void HandleRemove (TMessage *mess, TString *slb=0);  Handle remov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:23092,access,access,23092,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['access'],['access']
Security,"al-chain like approach ;  tdf001_introduction.py This tutorial illustrates the basic features of the TDataFrame class, a utility which allows to interact with data stored in TTrees following a functional-chain like approach ;  tdf002_dataModel.C This tutorial shows the possibility to use data models which are more complex than flat ntuples with TDataFrame ;  tdf002_dataModel.py This tutorial shows the possibility to use data models which are more complex than flat ntuples with TDataFrame ;  tdf003_profiles.C This tutorial illustrates how to use TProfiles in combination with the TDataFrame ;  tdf003_profiles.py This tutorial illustrates how to use TProfiles in combination with the TDataFrame ;  tdf004_cutFlowReport.CThis tutorial shows how to get information about the efficiency of the filters applied ;  tdf004_cutFlowReport.pyThis tutorial shows how to get information about the efficiency of the filters applied ;  tdf005_fillAnyObject.C This tutorial shows how to fill any object the class of which exposes a Fill method ;  tdf006_ranges.C This tutorial shows how to express the concept of ranges when working with the TDataFrame ;  tdf006_ranges.py This tutorial shows how to express the concept of ranges when working with the TDataFrame ;  tdf007_snapshot.C This tutorial shows how to write out datasets in ROOT formatusing the TDataFrame ;  tdf007_snapshot.py This tutorial shows how to write out datasets in ROOT formatusing the TDataFrame ;  tdf008_createDataSetFromScratch.C This tutorial shows how to create a dataset from scratch with TDataFrame ;  tdf008_createDataSetFromScratch.py This tutorial shows how to create a dataset from scratch with TDataFrame ;  tdf009_FromScratchVSTTree.C This tutorial illustrates how simpler it can be to use a TDataFrame to create a dataset with respect to the usage of the TTree interfaces ;  tdf010_trivialDataSource.C This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf010_trivialDataSource.py This tut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:97184,expose,exposes,97184,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['expose'],['exposes']
Security,"alPwHash (Bool_t pwhash);  Set global passwd hash flag to be used for authentication to rootd or proofd. ;  ; static void SetGlobalSRPPwd (Bool_t srppwd);  Set global SRP passwd flag to be used for authentication to rootd or proofd. ;  ; static void SetGlobalUser (const char *user);  Set global user name to be used for authentication to rootd or proofd. ;  ; static void SetGlobusAuthHook (GlobusAuth_t func);  Set Globus authorization function. ;  ; static void SetKrb5AuthHook (Krb5Auth_t func);  Set kerberos5 authorization function. ;  ; static void SetPromptUser (Bool_t promptuser);  Set global PromptUser flag. ;  ; static void SetReadHomeAuthrc (Bool_t readhomeauthrc);  Set flag controlling the reading of $HOME/.rootauthrc. ;  ; static void SetRSAInit (Int_t init=1);  Static method setting RSA initialization flag. ;  ; static Int_t SetRSAPublic (const char *rsapubexport, Int_t klen);  Store RSA public keys from export string rsaPubExport. ;  ; static void SetSecureAuthHook (SecureAuth_t func);  Set secure authorization function. ;  ; static void SetTimeOut (Int_t to);  Set timeout (active if > 0) ;  ; static void Show (Option_t *opt=""S"");  Print info about the authentication sector. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; Int_t ClearAuth (TString &user, TString &passwd, Bool_t &pwhash);  UsrPwd client authentication code. ;  ; Int_t GenRSAKeys ();  Generate a valid pair of private/public RSA keys to protect for authentication token exchange. ;  ; Bool_t GetPwHash (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:16162,secur,secure,16162,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,2,"['authoriz', 'secur']","['authorization', 'secure']"
Security,"alStreamerInfo *sinfo = fLastReadInfo;; 4602 ; 4603 // Version 0 is special, it means the currently loaded version.; 4604 // We need to set it at the beginning to be able to guess it correctly.; 4605 ; 4606 if (version == 0); 4607 version = fClassVersion;; 4608 ; 4609 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4610 // guaranteed it was built and compiled.; 4611 if (sinfo && sinfo->GetClassVersion() == version); 4612 return sinfo;; 4613 ; 4614 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4615 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4616 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4617 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4618 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4619 // to indicates they are not yet properly protection against mutli-thread access.; 4620 //; 4621 // However, the use of these functions is rare and mostly done at library loading time which should; 4622 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4623 // on that same TClass object.; 4624 //; 4625 // Summary: need careful review but risk of problem is extremely low.; 4626 ; 4627 R__LOCKGUARD(gInterpreterMutex);; 4628 ; 4629 return GetStreamerInfoImpl(version, isTransient);; 4630};; 4631 ; 4632// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4633// This routine assumes the global lock has been taken.; 4634TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4635{; 4636 // Warning: version may be -1 for an emulated class, or -2 if the; 4637 // user requested the emulated streamerInfo for an abstract; 4638 // base class, even though we have a dictionary for it.; 4639 ; 46",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:174920,access,access,174920,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['access']
Security,"alStreamerInfo *sinfo = fLastReadInfo;; 4669 ; 4670 // Version 0 is special, it means the currently loaded version.; 4671 // We need to set it at the beginning to be able to guess it correctly.; 4672 ; 4673 if (version == 0); 4674 version = fClassVersion;; 4675 ; 4676 // If the StreamerInfo is assigned to the fLastReadInfo, we are; 4677 // guaranteed it was built and compiled.; 4678 if (sinfo && sinfo->GetClassVersion() == version); 4679 return sinfo;; 4680 ; 4681 // Note that the access to fClassVersion above is technically not thread-safe with a low probably of problems.; 4682 // fClassVersion is not an atomic and is modified TClass::SetClassVersion (called from RootClassVersion via; 4683 // ROOT::ResetClassVersion) and is 'somewhat' protected by the atomic fVersionUsed.; 4684 // However, direct access to fClassVersion should be replaced by calls to GetClassVersion to set fVersionUsed.; 4685 // Even with such a change the code here and in these functions need to be reviewed as a cursory look seem; 4686 // to indicates they are not yet properly protection against mutli-thread access.; 4687 //; 4688 // However, the use of these functions is rare and mostly done at library loading time which should; 4689 // in almost all cases preceeds the possibility of GetStreamerInfo being called from multiple thread; 4690 // on that same TClass object.; 4691 //; 4692 // Summary: need careful review but risk of problem is extremely low.; 4693 ; 4694 R__LOCKGUARD(gInterpreterMutex);; 4695 ; 4696 return GetStreamerInfoImpl(version, isTransient);; 4697};; 4698 ; 4699// Implementation of/for TStreamerInfo::GetStreamerInfo.; 4700// This routine assumes the global lock has been taken.; 4701TVirtualStreamerInfo* TClass::GetStreamerInfoImpl(Int_t version, Bool_t silent) const; 4702{; 4703 // Warning: version may be -1 for an emulated class, or -2 if the; 4704 // user requested the emulated streamerInfo for an abstract; 4705 // base class, even though we have a dictionary for it.; 4706 ; 47",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:177671,access,access,177671,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['access']
Security,"alTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& parameters); minimisation algorithm. SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges). void SetMaxCalls(Int_t mc); accessors. { fMaxCalls = mc; }. void SetInitTemp(Double_t it); { fInitialTemperature = it; }. void SetMinTemp(Double_t min); { fMinTemperature = min; }. void SetAccuracy(Double_t eps); { fEps = eps; }. void SetTemperatureScale(Double_t scale); { fTemperatureScale = scale; }. void SetAdaptiveSpeed(Double_t speed); { fAdaptiveSpeed = speed; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk » Copyright (c) 2008: *; » Last changed: root/tmva $Id: SimulatedAnnealing.h 31574 2009-12-05 18:23:21Z stelzer $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__SimulatedAnnealing.html:4368,access,accessors,4368,root/html528/TMVA__SimulatedAnnealing.html,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealing.html,1,['access'],['accessors']
Security,"alTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& parameters); minimisation algorithm. SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges). void SetMaxCalls(Int_t mc); accessors. { fMaxCalls = mc; }. void SetInitTemp(Double_t it); { fInitialTemperature = it; }. void SetMinTemp(Double_t min); { fMinTemperature = min; }. void SetAccuracy(Double_t eps); { fEps = eps; }. void SetTemperatureScale(Double_t scale); { fTemperatureScale = scale; }. void SetAdaptiveSpeed(Double_t speed); { fAdaptiveSpeed = speed; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk » Copyright (c) 2008: *; » Last changed: root/tmva $Id: SimulatedAnnealing.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__SimulatedAnnealing.html:4368,access,accessors,4368,root/html532/TMVA__SimulatedAnnealing.html,https://root.cern,https://root.cern/root/html532/TMVA__SimulatedAnnealing.html,1,['access'],['accessors']
Security,"alUser(); Static method returning the global user. Bool_t GetGlobalPwHash(); Static method returning the global password hash flag. Bool_t GetGlobalSRPPwd(); Static method returning the global SRP password flag. TDatime GetGlobalExpDate(); Static method returning default expiring date for new validity contexts. const char * GetDefaultUser(); Static method returning the default user information. const char * GetKrb5Principal(); Static method returning the principal to be used to init Krb5 tickets. Bool_t GetAuthReUse(); Static method returning the authentication reuse settings. Bool_t GetPromptUser(); Static method returning the prompt user settings. const char * GetAuthMethod(Int_t idx); Static method returning the method corresponding to idx. Int_t GetAuthMethodIdx(const char* meth); Static method returning the method index (which can be used to find; the method in GetAuthMethod()). Returns -1 in case meth is not found. char * PromptUser(const char* remote); Static method to prompt for the user name to be used for authentication; to rootd or proofd. User is asked to type user name.; Returns user name (which must be deleted by caller) or 0.; If non-interactive run (eg ProofServ) returns default user. char * PromptPasswd(const char* prompt = ""Password: ""); Static method to prompt for the user's passwd to be used for; authentication to rootd or proofd. Uses non-echoing command line; to get passwd. Returns passwd (which must de deleted by caller) or 0.; If non-interactive run (eg ProofServ) returns -1. GlobusAuth_t GetGlobusAuthHook(); Static method returning the globus authorization hook. const char * GetRSAPubExport(Int_t key = 0); Static method returning the RSA public keys. Int_t GetRSAInit(); Static method returning the RSA initialization flag. void SetDefaultRSAKeyType(Int_t key); Static method setting the default type of RSA key. void SetRSAInit(Int_t init = 1); Static method setting RSA initialization flag. TList * GetAuthInfo(); Static method returning the lis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:14032,authenticat,authentication,14032,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"alent; 50 // of 'template <int N> struct TCollectionProxyInfo::Type<std::bitset<N> >' which; 51 // is not effective in C++ (as of gcc 4.3.3).; 52};; 53}; 54 ; 55namespace Detail {; 56 ; 57 class TCollectionProxyInfo {; 58 // This class is a place holder for the information needed; 59 // to create the proper Collection Proxy.; 60 // This is similar to Reflex's CollFuncTable.; 61 ; 62 public:; 63 ; 64 // Same value as TVirtualCollectionProxy.; 65 static const UInt_t fgIteratorArenaSize = 16; // greater than sizeof(void*) + sizeof(UInt_t); 66 ; 67 /** @class ROOT::Detail::TCollectionProxyInfo::IteratorValue; 68 *; 69 * Small helper to encapsulate whether to return the value; 70 * pointed to by the iterator or its address.; 71 *; 72 **/; 73 ; 74 template <typename Cont_t, typename value> struct IteratorValue {; 75 static void* get(typename Cont_t::iterator &iter) {; 76 return (void*)&(*iter);; 77 }; 78 };; 79 ; 80 template <typename Cont_t, typename value_ptr> struct IteratorValue<Cont_t, value_ptr*> {; 81 static void* get(typename Cont_t::iterator &iter) {; 82 return (void*)(*iter);; 83 }; 84 };; 85 ; 86 /** @class ROOT::Detail::TCollectionProxyInfo::Iterators; 87 *; 88 * Small helper to implement the function to create,access and destroy; 89 * iterators.; 90 *; 91 **/; 92 ; 93 template <typename Cont_t, bool large = false>; 94 struct Iterators {; 95 typedef Cont_t *PCont_t;; 96 typedef typename Cont_t::iterator iterator;; 97 ; 98 static void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy*) {; 99 PCont_t c = PCont_t(coll);; 100 new (*begin_arena) iterator(c->begin());; 101 new (*end_arena) iterator(c->end());; 102 }; 103 static void* copy(void *dest_arena, const void *source_ptr) {; 104 iterator *source = (iterator *)(source_ptr);; 105 new (dest_arena) iterator(*source);; 106 return dest_arena;; 107 }; 108 static void* next(void *iter_loc, const void *end_loc) {; 109 iterator *end = (iterator *)(end_loc);; 110 iterator *iter = (iterato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:2855,access,access,2855,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['access'],['access']
Security,"alidity contexts. const char * GetDefaultUser(); Static method returning the default user information. const char * GetKrb5Principal(); Static method returning the principal to be used to init Krb5 tickets. Bool_t GetAuthReUse(); Static method returning the authentication reuse settings. Bool_t GetPromptUser(); Static method returning the prompt user settings. const char * GetAuthMethod(Int_t idx); Static method returning the method corresponding to idx. Int_t GetAuthMethodIdx(const char* meth); Static method returning the method index (which can be used to find; the method in GetAuthMethod()). Returns -1 in case meth is not found. char * PromptUser(const char* remote); Static method to prompt for the user name to be used for authentication; to rootd or proofd. User is asked to type user name.; Returns user name (which must be deleted by caller) or 0.; If non-interactive run (eg ProofServ) returns default user. char * PromptPasswd(const char* prompt = ""Password: ""); Static method to prompt for the user's passwd to be used for; authentication to rootd or proofd. Uses non-echoing command line; to get passwd. Returns passwd (which must de deleted by caller) or 0.; If non-interactive run (eg ProofServ) returns -1. GlobusAuth_t GetGlobusAuthHook(); Static method returning the globus authorization hook. const char * GetRSAPubExport(Int_t key = 0); Static method returning the RSA public keys. Int_t GetRSAInit(); Static method returning the RSA initialization flag. void SetDefaultRSAKeyType(Int_t key); Static method setting the default type of RSA key. void SetRSAInit(Int_t init = 1); Static method setting RSA initialization flag. TList * GetAuthInfo(); Static method returning the list with authentication details. TList * GetProofAuthInfo(); Static method returning the list with authentication directives; to be sent to proof. void AuthError(const char* where, Int_t error); Print error string depending on error code. void SetGlobalUser(const char* user); Set global user name ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:14339,authenticat,authentication,14339,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"ality which allows a single merged value to be returned to the user. ; Definition at line 35 of file TSelectorScalar.h. Public Member Functions;  TSelectorScalar (const char *name="""", Long64_t val=0);  ;  ~TSelectorScalar () override;  ; void Inc (Long_t n=1);  Increment scalar value by n. ;  ; TClass * IsA () const override;  ; Int_t Merge (TCollection *list) override;  Merge scalars with scalars in the list. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TParameter< Long64_t >;  TParameter ();  ;  TParameter (const char *name, const Long64_t &val);  ;  TParameter (const char *name, const Long64_t &val, char mergemode);  ; virtual ~TParameter ();  ; Int_t Compare (const TObject *obj) const override;  Compare abstract method. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const Long64_t & GetVal () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsConst () const;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *) const override;  The ls function lists the contents of a class on stdout. ;  ; Int_t Merge (TCollection *in);  ; void Print (Option_t *) const override;  This method must be overridden when a class wants to print itself. ;  ; void SetMergeMode (char mergemode='+');  ; void SetVal (const Long64_t &val);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorScalar.html:1466,hash,hash,1466,doc/master/classTSelectorScalar.html,https://root.cern,https://root.cern/doc/master/classTSelectorScalar.html,1,['hash'],['hash']
Security,"alization without setting the corresponding pointers in the same moment ( has to be an atomic operation in case of multithreading ). ; Definition at line 171 of file FitData.h. ◆ InitFromRange(). template<class Iterator > . void ROOT::Fit::FitData::InitFromRange ; (; Iterator ; dataItr). inlineprotected . Definition at line 190 of file FitData.h. ◆ NDim(). unsigned int ROOT::Fit::FitData::NDim ; (; ); const. inline . return coordinate data dimension ; Definition at line 301 of file FitData.h. ◆ NPoints(). unsigned int ROOT::Fit::FitData::NPoints ; (; ); const. inline . return number of fit points ; Definition at line 285 of file FitData.h. ◆ operator=(). FitData & ROOT::Fit::FitData::operator= ; (; const FitData & ; rhs). Definition at line 218 of file FitData.cxx. ◆ Opt() [1/2]. DataOptions & ROOT::Fit::FitData::Opt ; (; ). inline . Definition at line 313 of file FitData.h. ◆ Opt() [2/2]. const DataOptions & ROOT::Fit::FitData::Opt ; (; ); const. inline . access to options ; Definition at line 309 of file FitData.h. ◆ Range(). const DataRange & ROOT::Fit::FitData::Range ; (; ); const. inline . access to range ; Definition at line 321 of file FitData.h. ◆ Size(). unsigned int ROOT::Fit::FitData::Size ; (; ); const. inline . return number of fit points ; Definition at line 293 of file FitData.h. ◆ UnWrap(). void ROOT::Fit::FitData::UnWrap ; (; ). inlineprotected . Definition at line 336 of file FitData.h. ◆ VectorPadding(). static constexpr unsigned ROOT::Fit::FitData::VectorPadding ; (; const unsigned ; ). inlinestaticconstexprprotected . If VecCore is not defined, there is no vectorization available and the SIMD vector size will always be one. ; Then, as every number is a multiple of SIMD vector size, the padding will always be zero. ; Definition at line 372 of file FitData.h. Member Data Documentation. ◆ fCoords. std::vector< std::vector< double > > ROOT::Fit::FitData::fCoords. private . This vector stores the vectorizable data: The inner vectors contain the coord",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitData.html:12620,access,access,12620,doc/master/classROOT_1_1Fit_1_1FitData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitData.html,1,['access'],['access']
Security,"all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Public Attributes |; Static Public Attributes |; List of all members ; ROOT::Detail::TCollectionProxyInfo Class Reference. . Definition at line 57 of file TCollectionProxyInfo.h. Classes; struct  Address;  ; struct  Address< std::vector< Bool_t, A > >;  ; class  Environ;  Small helper to save proxy environment in the event of recursive calls. More...;  ; struct  EnvironBase;  ; class  Insert;  Small helper to encapsulate all necessary data accesses for containers like set, multiset etc. More...;  ; class  Iterators;  Small helper to implement the function to create,access and destroy iterators. More...;  ; struct  Iterators< Cont_t, true >;  ; struct  Iterators< std::vector< T >, false >;  ; class  IteratorValue;  Small helper to encapsulate whether to return the value pointed to by the iterator or its address. More...;  ; struct  IteratorValue< Cont_t, value_ptr * >;  ; class  MapInsert;  Small helper to encapsulate all necessary data accesses for containers like set, multiset etc. More...;  ; struct  PairHolder;  ; class  Pushback;  Small helper to encapsulate all necessary data accesses for containers like vector, list, deque. More...;  ; struct  Pushback< Internal::TStdBitsetHelper< Bitset_t > >;  ; struct  Pushback< std::vector< Bool_t, A > >;  ; class  Pushfront;  Small helper to encapsulate all necessary data accesses for containers like forward_list. More...;  ; struct  SfinaeHelper;  ; class  Type;  Small helper to encapsulate basic data accesses for all STL continers. More...;  ; struct  Type< Internal::TStdBitsetHelper< Bitset_t > >;  ; struct  Type< std::vector< Bool_t, A > >;  . Public Member Functions;  TCollectionProxyInfo (const std::type_info &info, size_t iter_size, size_t value_diff, int value_offset, void *(*size_func)(void *), void(*resize_func)(void *, size_t), void *(*clear_func)(void *), void *(*first_func)(void *), void *(*next_func)(void *), void *(*constr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1TCollectionProxyInfo.html:1186,access,accesses,1186,doc/master/classROOT_1_1Detail_1_1TCollectionProxyInfo.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1TCollectionProxyInfo.html,1,['access'],['accesses']
Security,"all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(TClass::ECheckSum code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void GenerateDeclaration(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:18582,checksum,checksum,18582,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,3,['checksum'],['checksum']
Security,"all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; TODO --> adapt to variable,target,spectator selection; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); TODO --> adapt to variable,target,spectator selection; update min and max of a given variable (target) and a given transformation method. void AttachXMLTo(void* parent); create XML description the transformation (write out info of selected variables). void ReadFromXML(void* trfnode); Read the input variables from the XML node. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); getinput and setoutput equivalent. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ). const Event* Transform(const TMVA::Event *const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event *const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void ToggleInputSortOrder(Bool_t sortOrder); { fSortGet = sortOrder; }. void SetOutputDataSetInfo(TMVA::DataSetInfo* outputDsi); { fDsiOutput = outputDsi; }. void SetUseSignalTransform(Bool_t e = kTRUE); { fUseSignalTransform = e; }. Bool_t UseSignalTransform() const; { return fUseSignalTransform; }. const char* GetName() const; { return fTransformName.Data(); }. TString GetShortName() const; { TString a(fTransformName); a.ReplaceAll(""Transform"",""""); return a; }. void WriteTransformationToStream(ostream& o) const. void ReadTransformationFromStream(istream& istr, const TString& classname = """"). Types::EVariableTransform GetVariableTransform() const; { return fVariableTransform; }. void PrintTransformation(ostream& ); {}. const std::vector<TMVA::Variable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__VariableTransformBase.html:10780,access,accessors,10780,root/html530/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html530/TMVA__VariableTransformBase.html,3,['access'],['accessors']
Security,"allArg &arg);  Processing of websockets call-backs, invoked from RWebWindowWSHandler Method invoked from http server thread, therefore appropriate mutex must be used on all relevant data. ;  ; void ProvideQueueEntry (unsigned connid, EQueueEntryKind kind, std::string &&arg);  Provide data to user callback User callback must be executed in the window thread. ;  ; std::shared_ptr< WebConn > RemoveConnection (unsigned wsid);  Remove connection with given websocket id. ;  ; void RemoveEmbedWindow (unsigned connid, int channel);  Remove RWebWindow associated with the channelfEmbed. ;  ; void RemoveKey (const std::string &key);  Removes all connections with the key. ;  ; void RemoveMasterConnection (unsigned connid=0);  Remove master connection - if any. ;  ; void SubmitData (unsigned connid, bool txt, std::string &&data, int chid=1);  Internal method to send data. ;  . Static Private Member Functions; static std::string HMAC (const std::string &key, const std::string &sessionKey, const char *msg, int msglen);  Calculate HMAC checksum for provided key and message Key combained from connection key and session key. ;  ; static void SetStartDialogFunc (std::function< bool(const std::shared_ptr< RWebWindow > &, unsigned, const std::string &)>);  Configure func which has to be used for starting dialog. ;  . Private Attributes; std::thread::id fCallbacksThrdId;  ! thread id where callbacks should be invoked ;  ; bool fCallbacksThrdIdSet {false};  ! flag indicating that thread id is assigned ;  ; std::shared_ptr< void > fClearOnClose;  ! entry which is cleared when last connection is closed ;  ; std::string fClientVersion;  ! configured client version, used as prefix in scripts URL ;  ; ConnectionsList_t fConn;  ! list of all accepted connections ;  ; WebWindowConnectCallback_t fConnCallback;  ! callback for connect event ;  ; unsigned fConnCnt {0};  ! counter of new connections to assign ids ;  ; unsigned fConnLimit {1};  ! number of allowed active connections ;  ; std::mutex f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:17630,checksum,checksum,17630,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['checksum'],['checksum']
Security,"alling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THashList.html:11629,hash,hashtable,11629,root/html602/THashList.html,https://root.cern,https://root.cern/root/html602/THashList.html,2,['hash'],['hashtable']
Security,"alo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. ~TWebFile(); Cleanup. void Init(Bool_t readHeadOnly); Initialize a TWebFile object. void SetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); Set GET command for use by ReadBuffer(s)10(), handle redirection if; needed. Give full URL so Apache's virtual hosts solution works. void CheckProxy(); Check if shell var ""http_proxy"" has been set and should be used. Bool_t IsOpen() const; A TWebFile that has been correctly constructed is always considered open. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. A TWebFile cannot be reopened in update mode. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via HTTP daemon. This; routine connects to the remote host, sends the request and returns; the buffer. Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via HTTP daemon. This; routine connects to the remote host, sends the request and returns; the buffer. Returns kTRUE in case of error. Bool_t ReadBuffer10(char* buf, Int_t len); Read specified byte range from remote file via HTTP 1.0 daemon (without; mod-root installed). This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:25089,access,access,25089,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,6,['access'],['access']
Security,"alog::Embedded() providing received string as second argument. ;  ; static bool IsFileDialogMessage (const std::string &msg);  Check if this could be the message send by client to start new file dialog If returns true, one can call RWebWindow::EmbedFileDialog() to really create file dialog instance inside existing widget. ;  ; static unsigned ShowWindow (std::shared_ptr< RWebWindow > window, const RWebDisplayArgs &args="""");  Static method to show web window Has to be used instead of RWebWindow::Show() when window potentially can be embed into other windows Soon RWebWindow::Show() method will be done protected. ;  . Private Types; using ConnectionsList_t = std::vector< std::shared_ptr< WebConn > >;  ; enum  EQueueEntryKind { kind_None; , kind_Connect; , kind_Data; , kind_Disconnect; };  ; using timestamp_t = std::chrono::time_point< std::chrono::system_clock >;  . Private Member Functions; bool _CanTrustIn (std::shared_ptr< WebConn > &conn, const std::string &key, const std::string &ntry, bool remote, bool test_first_time);  Check if provided hash, ntry parameters from the connection request could be accepted. ;  ; std::string _MakeSendHeader (std::shared_ptr< WebConn > &conn, bool txt, const std::string &data, int chid);  Internal method to prepare text part of send data Should be called under locked connection mutex. ;  ; unsigned AddDisplayHandle (bool headless_mode, const std::string &key, std::unique_ptr< RWebDisplayHandle > &handle);  Add display handle and associated key Key is large random string generated when starting new window When client is connected, key should be supplied to correctly identify it. ;  ; unsigned AddEmbedWindow (std::shared_ptr< RWebWindow > window, unsigned connid, int channel);  Add embed window. ;  ; void AddMasterConnection (std::shared_ptr< RWebWindow > window, unsigned connid, int channel);  Add new master connection If there are many connections - only same master is allowed. ;  ; void CheckDataToSend (bool only_once=false);  Check",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:12982,hash,hash,12982,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['hash'],['hash']
Security,"alogMessage ; (; const std::string & ; msg). static . Check if this could be the message send by client to start new file dialog If returns true, one can call RWebWindow::EmbedFileDialog() to really create file dialog instance inside existing widget. ; Definition at line 1963 of file RWebWindow.cxx. ◆ IsNativeOnlyConn(). bool ROOT::RWebWindow::IsNativeOnlyConn ; (; ); const. inline . returns true if only native (own-created) connections are allowed ; Definition at line 312 of file RWebWindow.hxx. ◆ IsRequireAuthKey(). bool ROOT::RWebWindow::IsRequireAuthKey ; (; ); const. inline . returns true if authentication string is required ; Definition at line 320 of file RWebWindow.hxx. ◆ IsShown(). bool ROOT::RWebWindow::IsShown ; (; ); const. inline . Returns true when window was shown at least once. ; Definition at line 369 of file RWebWindow.hxx. ◆ IsUseCurrentDir(). bool ROOT::RWebWindow::IsUseCurrentDir ; (; ); const. inline . returns true if window can access local files via currentdir/ path of http server ; Definition at line 328 of file RWebWindow.hxx. ◆ MakeHeadless(). unsigned RWebWindow::MakeHeadless ; (; bool ; create_new = false). private . Start headless browser for specified window Normally only single instance is used, but many can be created See ROOT::RWebWindowsManager::Show() docu for more info returns (future) connection id (or 0 when fails) ; Definition at line 202 of file RWebWindow.cxx. ◆ NumConnections(). int RWebWindow::NumConnections ; (; bool ; with_pending = false); const. Returns current number of active clients connections. ; Parameters. with_pendingif true, also pending (not yet established) connection accounted . Definition at line 1330 of file RWebWindow.cxx. ◆ ProcessBatchHolder(). bool RWebWindow::ProcessBatchHolder ; (; std::shared_ptr< THttpCallArg > & ; arg). private . Process special http request, used to hold headless browser running Such requests should not be replied for the long time Be aware that function called directly from THttp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:37801,access,access,37801,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"alogMessage ; (; const std::string & ; msg). static . Check if this could be the message send by client to start new file dialog If returns true, one can call RWebWindow::EmbedFileDialog() to really create file dialog instance inside existing widget. ; Definition at line 2005 of file RWebWindow.cxx. ◆ IsNativeOnlyConn(). bool ROOT::RWebWindow::IsNativeOnlyConn ; (; ); const. inline . returns true if only native (own-created) connections are allowed ; Definition at line 315 of file RWebWindow.hxx. ◆ IsRequireAuthKey(). bool ROOT::RWebWindow::IsRequireAuthKey ; (; ); const. inline . returns true if authentication string is required ; Definition at line 323 of file RWebWindow.hxx. ◆ IsShown(). bool ROOT::RWebWindow::IsShown ; (; ); const. inline . Returns true when window was shown at least once. ; Definition at line 372 of file RWebWindow.hxx. ◆ IsUseCurrentDir(). bool ROOT::RWebWindow::IsUseCurrentDir ; (; ); const. inline . returns true if window can access local files via currentdir/ path of http server ; Definition at line 331 of file RWebWindow.hxx. ◆ MakeHeadless(). unsigned RWebWindow::MakeHeadless ; (; bool ; create_new = false). private . Start headless browser for specified window Normally only single instance is used, but many can be created See ROOT::RWebWindowsManager::Show() docu for more info returns (future) connection id (or 0 when fails) ; Definition at line 202 of file RWebWindow.cxx. ◆ NumConnections(). int RWebWindow::NumConnections ; (; bool ; with_pending = false); const. Returns current number of active clients connections. ; Parameters. with_pendingif true, also pending (not yet established) connection accounted . Definition at line 1372 of file RWebWindow.cxx. ◆ ProcessBatchHolder(). bool RWebWindow::ProcessBatchHolder ; (; std::shared_ptr< THttpCallArg > & ; arg). private . Process special http request, used to hold headless browser running Such requests should not be replied for the long time Be aware that function called directly from THttp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:36685,access,access,36685,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"als"";; 12116 cors4 = cors_cred_cfg;; 12117 } else {; 12118 cors3 = cors4 = """";; 12119 }; 12120 ; 12121 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 12122 /* File exists (precondition for calling this function),; 12123 * but can not be opened by the server. */; 12124 mg_send_http_error(conn,; 12125 500,; 12126 ""Error: Cannot read file\nfopen(%s): %s"",; 12127 path,; 12128 strerror(ERRNO));; 12129 } else {; 12130 /* Set ""must_close"" for HTTP/1.x, since we do not know the; 12131 * content length */; 12132 conn->must_close = 1;; 12133 gmt_time_string(date, sizeof(date), &curtime);; 12134 fclose_on_exec(&filep->access, conn);; 12135 ; 12136 /* 200 OK response */; 12137 mg_response_header_start(conn, 200);; 12138 send_no_cache_header(conn);; 12139 send_additional_header(conn);; 12140 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12141 if (cors1[0]) {; 12142 mg_response_header_add(conn, cors1, cors2, -1);; 12143 }; 12144 if (cors3[0]) {; 12145 mg_response_header_add(conn, cors3, cors4, -1);; 12146 }; 12147 mg_response_header_send(conn);; 12148 ; 12149 /* Header sent, now send body */; 12150 send_ssi_file(conn, path, filep, 0);; 12151 (void)mg_fclose(&filep->access); /* Ignore errors for readonly files */; 12152 }; 12153}; 12154#endif /* NO_FILESYSTEMS */; 12155 ; 12156 ; 12157#if !defined(NO_FILES); 12158static void; 12159send_options(struct mg_connection *conn); 12160{; 12161 if (!conn) {; 12162 return;; 12163 }; 12164 ; 12165 /* We do not set a ""Cache-Control"" header here, but leave the default.; 12166 * Since browsers do not send an OPTIONS request, we can not test the; 12167 * effect anyway. */; 12168 ; 12169 mg_response_header_start(conn, 200);; 12170 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12171 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 12172 /* Use the same as before */; 12173 mg_response_header_add(; 12174 conn,; 12175 ""Allow"",; 12176 ""GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, PROPFIND, MKCOL"",; 121",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:351077,access,access,351077,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['access'],['access']
Security,"als"";; 12117 cors4 = cors_cred_cfg;; 12118 } else {; 12119 cors3 = cors4 = """";; 12120 }; 12121 ; 12122 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 12123 /* File exists (precondition for calling this function),; 12124 * but can not be opened by the server. */; 12125 mg_send_http_error(conn,; 12126 500,; 12127 ""Error: Cannot read file\nfopen(%s): %s"",; 12128 path,; 12129 strerror(ERRNO));; 12130 } else {; 12131 /* Set ""must_close"" for HTTP/1.x, since we do not know the; 12132 * content length */; 12133 conn->must_close = 1;; 12134 gmt_time_string(date, sizeof(date), &curtime);; 12135 fclose_on_exec(&filep->access, conn);; 12136 ; 12137 /* 200 OK response */; 12138 mg_response_header_start(conn, 200);; 12139 send_no_cache_header(conn);; 12140 send_additional_header(conn);; 12141 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12142 if (cors1[0]) {; 12143 mg_response_header_add(conn, cors1, cors2, -1);; 12144 }; 12145 if (cors3[0]) {; 12146 mg_response_header_add(conn, cors3, cors4, -1);; 12147 }; 12148 mg_response_header_send(conn);; 12149 ; 12150 /* Header sent, now send body */; 12151 send_ssi_file(conn, path, filep, 0);; 12152 (void)mg_fclose(&filep->access); /* Ignore errors for readonly files */; 12153 }; 12154}; 12155#endif /* NO_FILESYSTEMS */; 12156 ; 12157 ; 12158#if !defined(NO_FILES); 12159static void; 12160send_options(struct mg_connection *conn); 12161{; 12162 if (!conn) {; 12163 return;; 12164 }; 12165 ; 12166 /* We do not set a ""Cache-Control"" header here, but leave the default.; 12167 * Since browsers do not send an OPTIONS request, we can not test the; 12168 * effect anyway. */; 12169 ; 12170 mg_response_header_start(conn, 200);; 12171 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12172 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 12173 /* Use the same as before */; 12174 mg_response_header_add(; 12175 conn,; 12176 ""Allow"",; 12177 ""GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, PROPFIND, MKCOL"",; 121",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:351110,access,access,351110,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['access'],['access']
Security,"als; // dictionary context after ResetGlobals().; 113 TString fSharedLibs; // Shared libraries loaded by G__loadfile().; 114 Int_t fGlobalsListSerial;// Last time we refreshed the ROOT list of globals.; 115 TString fIncludePath; // Interpreter include path.; 116 TString fRootmapLoadPath; // Dynamic load path for rootmap files.; 117 TEnv* fMapfile; // Association of classes to libraries.; 118 std::vector<std::string> fAutoLoadLibStorage; // A storage to return a const char* from GetClassSharedLibsForModule.; 119 std::map<size_t,std::vector<const char*>> fClassesHeadersMap; // Map of classes hashes and headers associated; 120 std::map<const cling::Transaction*,size_t> fTransactionHeadersMap; // Map which transaction contains which autoparse.; 121 std::set<size_t> fLookedUpClasses; // Set of classes for which headers were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently runn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:4388,hash,hash,4388,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,2,['hash'],"['hash', 'hashing']"
Security,"alse);  Factory method to resurrect a field from the stored on-disk type information. ;  ; static std::unique_ptr< RDeleter > GetDeleterOf (const RFieldBase &other);  ; static Internal::RColumn * GetPrincipalColumnOf (const RFieldBase &other);  Fields may need direct access to the principal column of their sub fields, e.g. in RRVecField::ReadBulk. ;  ;  Protected Attributes inherited from ROOT::Experimental::RFieldBase; Internal::RColumn * fAuxiliaryColumn = nullptr;  Some fields have a second column in its column representation. ;  ; std::vector< std::unique_ptr< Internal::RColumn > > fAvailableColumns;  The columns are connected either to a sink or to a source (not to both); they are owned by the field. ;  ; std::vector< std::reference_wrapper< const ColumnRepresentation_t > > fColumnRepresentatives;  Pointers into the static vector GetColumnRepresentations().GetSerializationTypes() when SetColumnRepresentatives is called. ;  ; std::uint32_t fOnDiskTypeChecksum = 0;  TClass checksum cached from the descriptor after a call to ConnectPageSource(). ;  ; std::uint32_t fOnDiskTypeVersion = kInvalidTypeVersion;  C++ type version cached from the descriptor after a call to ConnectPageSource() ;  ; RFieldBase * fParent;  Sub fields point to their mother field. ;  ; Internal::RColumn * fPrincipalColumn = nullptr;  All fields that have columns have a distinct main column. ;  ; std::vector< ReadCallback_t > fReadCallbacks;  List of functions to be called after reading a value. ;  ; std::vector< std::unique_ptr< RFieldBase > > fSubFields;  Collections and classes own sub fields. ;  ; int fTraits = 0;  Properties of the type that allow for optimizations of collections of that type. ;  ; std::string fTypeAlias;  A typedef or using name that was used when creating the field. ;  . #include <ROOT/RField.hxx>. Inheritance diagram for ROOT::Experimental::RField< T, typename >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html:12417,checksum,checksum,12417,doc/master/classROOT_1_1Experimental_1_1RField.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RField.html,1,['checksum'],['checksum']
Security,"alue of fStreamerType.Definition TClass.cxx:6215; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3623; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2183; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:3973; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4142; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6086; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7393; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3874; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:6985; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1820; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2247; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:335095,access,access,335095,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['access'],['access']
Security,"alue of fStreamerType.Definition TClass.cxx:6282; TClass::GetSharedLibsconst char * GetSharedLibs()Get the list of shared libraries containing the code for class cls.Definition TClass.cxx:3690; TClass::CalculateStreamerOffsetvoid CalculateStreamerOffset() constCalculate the offset between an object of this class to its base class TObject.Definition TClass.cxx:2250; TClass::GetMissingDictionariesForPairElementsvoid GetMissingDictionariesForPairElements(TCollection &result, TCollection &visited, bool recurse)Definition TClass.cxx:4040; TClass::ReplaceWithvoid ReplaceWith(TClass *newcl) constDefinition TClass.cxx:4209; TClass::RegisterAddressInRepositoryvoid RegisterAddressInRepository(const char *where, void *location, const TClass *what) constDefinition TClass.cxx:290; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::HasDefaultConstructorBool_t HasDefaultConstructor(Bool_t testio=kFALSE) constReturn true if we have access to a constructor usable for I/O.Definition TClass.cxx:7460; TClass::GetMenuItemsvoid GetMenuItems(TList *listitems)Returns list of methods accessible by context menu.Definition TClass.cxx:3941; TClass::SetNewvoid SetNew(ROOT::NewFunc_t newFunc)Install a new wrapper around 'new'.Definition TClass.cxx:7052; TClass::fIsAMethodstd::atomic< TMethodCall * > fIsAMethodDefinition TClass.h:231; TClass::ReadRulesstatic Int_t ReadRules()Read the class.rules files from the default location:.Definition TClass.cxx:1887; TClass::CanSplitBaseAllowBool_t CanSplitBaseAllow()Pointer to the function implementing streaming for this class.Definition TClass.cxx:2314; TClass::MoveAddressInRepositoryvoid MoveAddressInRepository(const char *where, void *oldadd, void *newadd, const TClass *what) constDefinition TClass.cxx:337; TClass::fStreamerImplstd::atomic< StreamerImpl_t > fStreamerImplDefinition TClass.h:287; TClass::SetContextMenuTitlevoid SetContextMenuTitle(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:337733,access,access,337733,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['access'],['access']
Security,always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry! carry of Kahan sum in evaluatePartition; Int_t_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpMode_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! Is object initialized; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot labe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsTestStatistic.html:37308,access,access,37308,root/html602/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsTestStatistic.html,2,['access'],['access']
Security,"al ~TNetFile ();  TNetFile dtor. Send close message and close socket. ;  ; void Close (Option_t *option="""") override;  Close remote file. ;  ; void Flush () override;  Flush file to disk. ;  ; const TUrl * GetEndpointUrl () const override;  ; Int_t GetErrorCode () const;  ; TClass * IsA () const override;  ; Bool_t IsOpen () const override;  Retruns kTRUE if file is open, kFALSE otherwise. ;  ; Bool_t Matches (const char *url) override;  Return kTRUE if 'url' matches the coordinates of this file. ;  ; Bool_t ReadBuffer (char *buf, Int_t len) override;  Read specified byte range from remote file via rootd daemon. ;  ; Bool_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read specified byte range from remote file via rootd daemon. ;  ; Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf) override;  Read a list of buffers given in pos[] and len[] and return it in a single buffer. ;  ; Int_t ReOpen (Option_t *mode) override;  Reopen a file with a different access mode, like from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. ;  ; void Seek (Long64_t offset, ERelativeTo pos=kBeg) override;  Set position from where to start reading. ;  ; void Streamer (TBuffer &) override;  Stream a TFile object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t WriteBuffer (const char *buf, Int_t len) override;  Write specified byte range to remote file via rootd daemon. ;  ;  Public Member Functions inherited from TFile;  TFile ();  File default Constructor. ;  ;  TFile (const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Opens or creates a local ROOT file. ;  ;  ~TFile () override;  File destructor. ;  ; void Copy (TObject &) const override;  Copy this to obj. ;  ; virtual Bool_t Cp (const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy this file to the dst URL. ;  ; virtual TKey * CreateKey (TDir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:3120,access,access,3120,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['access'],['access']
Security,"am ;  ; void WriteOptionsReferenceToFile ();  write complete options to output stream ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; void CreateMLPOptions (TString);  translates options from option string into TMlpANN language ;  ; void DeclareOptions ();  define the options (their key words) that can be set in the option string ;  ; void Init (void);  default initialisations ;  ; void ProcessOptions ();  builds the neural network as specified by the user ;  . Private Attributes; TString fHiddenLayer;  string containing the hidden layer structure ;  ; TString fLayerSpec;  Layer specification option. ;  ; TString fLearningMethod;  the learning method (given via option string) ;  ; TTree * fLocalTrainingTree;  local copy of training tree ;  ; TMultiLayerPerceptron * fMLP;  the TMLP ;  ; TString fMLPBuildOptions;  option string to build the mlp ;  ; Int_t fNcycles;  number of training cycles ;  ; Double_t fValidationFraction;  fraction of events in training tree used for cross validation ;  . Additional Inherited Members;  Public Types inherited from TMVA::MethodBase; enum  EWeightFileType { kROOT =0; , kTEXT; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Attributes inherited from TM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodTMlpANN.html:27014,validat,validation,27014,doc/master/classTMVA_1_1MethodTMlpANN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodTMlpANN.html,1,['validat'],['validation']
Security,"am into a 1-D histogram along Y.Definition TH2.cxx:2476; TH2::fTsumwxyDouble_t fTsumwxyTotal Sum of weight*X*Y.Definition TH2.h:36; TH2::fTsumwy2Double_t fTsumwy2Total Sum of weight*Y*Y.Definition TH2.h:35; TH2::GetBinInt_t GetBin(Int_t binx, Int_t biny, Int_t binz=0) const overrideReturn Global bin number corresponding to binx,y,z.Definition TH2.cxx:1086; TH2::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Int_t firstybin=0, Int_t lastybin=-1, Option_t *option="""") constProject a 2-D histogram into a 1-D histogram along X.Definition TH2.cxx:2436; TH2::fTsumwyDouble_t fTsumwyTotal Sum of weight*Y.Definition TH2.h:34; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition THashList.cxx:189; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique object id.Definition TObject.cxx:462; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:84795,hash,hash,84795,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['hash'],['hash']
Security,"amVect::operator- ; (; const TFoamVect & ; p2). subtraction operator -; difference of 2 vectors; c=a-b, a=a-b, NEVER USE IT, VERY SLOW!!! ; Definition at line 169 of file TFoamVect.cxx. ◆ operator-=(). TFoamVect & TFoamVect::operator-= ; (; const TFoamVect & ; Shift). unary subtraction operator -= ; Definition at line 143 of file TFoamVect.cxx. ◆ operator=() [1/3]. TFoamVect & TFoamVect::operator= ; (; const TFoamVect & ; Vect). substitution operator ; Definition at line 86 of file TFoamVect.cxx. ◆ operator=() [2/3]. TFoamVect & TFoamVect::operator= ; (; Double_t ; x). Loading in double prec. number, sometimes can be useful. ; Definition at line 191 of file TFoamVect.cxx. ◆ operator=() [3/3]. TFoamVect & TFoamVect::operator= ; (; Double_t ; Vect[]). Loading in ordinary double prec. vector, sometimes can be useful. ; Definition at line 180 of file TFoamVect.cxx. ◆ operator[](). Double_t & TFoamVect::operator[] ; (; Int_t ; n). [] is for access to elements as in ordinary matrix like a[j]=b[j] (Perhaps against some strict rules but rather practical.) Range protection is built in, consequently for substitution one should use rather use a=b than explicit loop! ; Definition at line 109 of file TFoamVect.cxx. ◆ Print(). void TFoamVect::Print ; (; Option_t * ; option); const. overridevirtual . Printout of all vector components on ""std::cout"". ; Reimplemented from TObject.; Definition at line 203 of file TFoamVect.cxx. ◆ Streamer(). void TFoamVect::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFoamVect::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 35 of file TFoamVect.h. Member Data Documentation. ◆ fCoords. Double_t* TFoamVect::fCoords. private . [fDim] Coordinates ; Definition at line 14 of file TFoamVect.h. ◆ fDim. Int_t TFoamVect::fDim. private . Dimension. ; Definition at line 13 of file TFoamVect.h. Libraries for TFoamVect:. [l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFoamVect.html:14664,access,access,14664,doc/master/classTFoamVect.html,https://root.cern,https://root.cern/doc/master/classTFoamVect.html,1,['access'],['access']
Security,"ame () const;  returns file name from request URL ;  ; TString GetHeader (const char *name);  Return specified header. ;  ; TString GetHeaderName (Int_t number) const;  returns field name in header ;  ; const char * GetMethod () const;  returns request method like GET or POST ;  ; const char * GetPathName () const;  returns path name from request URL ;  ; const void * GetPostData () const;  return pointer on posted with request data ;  ; Long_t GetPostDataLength () const;  return length of posted with request data ;  ; const char * GetQuery () const;  returns request query (string after ? in request URL) ;  ; TString GetRequestHeader (const char *name);  get named field from request header ;  ; TString GetRequestHeaderName (Int_t number) const;  returns field name in request header ;  ; const char * GetTopName () const;  returns engine-specific top-name ;  ; const char * GetUserName () const;  return authenticated user name (0 - when no authentication) ;  ; UInt_t GetWSId () const;  get web-socket id ;  ; virtual const char * GetWSKind () const;  provide WS kind - websocket, longpoll, rawlongpoll ;  ; virtual const char * GetWSPlatform () const;  provide WS platform - http, fastcgi, cef3, qt5 ;  ; Int_t GetZipping () const;  ; virtual void HttpReplied ();  virtual method to inform object that http request is processed ;  ; Bool_t Is404 () const;  ; TClass * IsA () const override;  ; Bool_t IsBinary () const;  ; Bool_t IsContentType (const char *typ) const;  ; Bool_t IsFile () const;  ; Bool_t IsJson () const;  ; Bool_t IsMethod (const char *name) const;  returns kTRUE if post method is used ;  ; Bool_t IsPostMethod () const;  returns kTRUE if post method is used ;  ; Bool_t IsPostponed () const;  ; Bool_t IsText () const;  ; Bool_t IsXml () const;  ; void NotifyCondition ();  Method used to notify condition which waiting when operation will complete. ;  ; Int_t NumHeader () const;  returns number of fields in header ;  ; Int_t NumRequestHeader () const;  returns num",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpCallArg.html:2996,authenticat,authenticated,2996,doc/master/classTHttpCallArg.html,https://root.cern,https://root.cern/doc/master/classTHttpCallArg.html,2,['authenticat'],"['authenticated', 'authentication']"
Security,"ame ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void InitStreaming (Bool_t isTransient);  Error message in case of checksum/version mismatch. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; UInt_t & fBaseCheckSum;  ; TClass * fBaseClass;  checksum of the base class (used during memberwise streaming) ;  ; Int_t fBaseVersion;  ; ClassConvStreamerFunc_t fConvStreamerFunc;  Pointer to a wrapper around a custom streamer member function. ;  ; TString fErrorMsg;  Pointer to the current StreamerInfo for the baset class. ;  ; TClass * fNewBaseClass;  pointer to base class ;  ; ClassStreamerFunc_t fStreamerFunc;  pointer to new base class if renamed ;  ; TVirtualStreamerInfo * fStreamerInfo;  Pointer to a wrapper around a custom convertion streamer member function. ;  ;  Protected Attributes inherited from TStreamerElement; Int_t fArrayDim;  ; Int_t fArrayLength;  ; TClass * fClassObject;  ; Double_t fFactor;  Maximum of data member if a range is specified [xmin,xmax,nbits]. ;  ; Int_t fMaxIndex [5];  ; TClass * fNewClass;  pointer to class of object ;  ; Int_t fNewType;  base offset for TObject if the element inherits from it ;  ; Int_t fOffset;  ; Int_t fSize;  ; TMemberStreamer * fStreamer;  new element class when reading ;  ; Int_t fTObjectOffset;  element offset in class ;  ; Int_t fTy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBase.html:14803,checksum,checksum,14803,doc/master/classTStreamerBase.html,https://root.cern,https://root.cern/doc/master/classTStreamerBase.html,1,['checksum'],['checksum']
Security,"ame name as the file. x_t and y_t needs to be types that can convert respectively to a double; and a bool (because the skeleton uses:; if (cutfilename()) htemp->Fill(macrofilename());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:45582,access,access,45582,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,6,['access'],['access']
Security,"ame way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_zero = {0};; 3439 *fc = conn_zero;; 3440 fc->phys_ctx = ctx;; 3441 fc->dom_ctx = &(ctx->dd);; 3442 return fc;; 3443}; 3444 ; 3445 ; 3446static void; 3447mg_cry_internal_wrap(const struct mg_connection *conn,; 3448 struct mg_context *ctx,; 3449 const char *func,; 3450 unsigned line,; 3451 const char *f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:101702,access,access,101702,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"ame way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_zero = {0};; 3440 *fc = conn_zero;; 3441 fc->phys_ctx = ctx;; 3442 fc->dom_ctx = &(ctx->dd);; 3443 return fc;; 3444}; 3445 ; 3446 ; 3447static void; 3448mg_cry_internal_wrap(const struct mg_connection *conn,; 3449 struct mg_context *ctx,; 3450 const char *func,; 3451 unsigned line,; 3452 const char *f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:101734,access,access,101734,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"ame);; 681 ; 682 TClassRec *r = FindElement(guard.GetNormalizedName().c_str(), kFALSE);; 683 if (r); 684 return r->fDict;; 685 return nullptr;; 686}; 687 ; 688////////////////////////////////////////////////////////////////////////////////; 689/// Given the std::type_info returns the Dictionary() function of a class; 690/// (uses hash of std::type_info::name()).; 691 ; 692DictFuncPtr_t TClassTable::GetDict(const std::type_info& info); 693{; 694 if (!CheckClassTableInit()); 695 return nullptr;; 696 ; 697 if (gDebug > 9); 698 ROOT::GetROOT(); // Info might recursively call TClassTable during the gROOT init; 699 ; 700 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 701 ; 702 if (gDebug > 9) {; 703 ::Info(""GetDict"", ""searches for %s at 0x%zx"", info.name(), (size_t)&info);; 704 fgIdMap->Print();; 705 }; 706 ; 707 TClassRec *r = fgIdMap->Find(info.name());; 708 if (r); 709 return r->fDict;; 710 return nullptr;; 711}; 712 ; 713////////////////////////////////////////////////////////////////////////////////; 714/// Given the normalized class name returns the Dictionary() function of a class; 715/// (uses hash of name).; 716 ; 717DictFuncPtr_t TClassTable::GetDictNorm(const char *cname); 718{; 719 if (!CheckClassTableInit()); 720 return nullptr;; 721 ; 722 if (gDebug > 9); 723 ROOT::GetROOT(); // Info might recursively call TClassTable during the gROOT init; 724 ; 725 std::lock_guard<std::mutex> lock(GetClassTableMutex());; 726 ; 727 if (gDebug > 9) {; 728 ::Info(""GetDict"", ""searches for %s"", cname);; 729 fgIdMap->Print();; 730 }; 731 ; 732 TClassRec *r = FindElement(cname, kFALSE);; 733 if (r); 734 return r->fDict;; 735 return nullptr;; 736}; 737 ; 738////////////////////////////////////////////////////////////////////////////////; 739/// Given the class name returns the TClassProto object for the class.; 740/// (uses hash of name).; 741 ; 742TProtoClass *TClassTable::GetProto(const char *cname); 743{; 744 if (gDebug > 9) {; 745 ::Info(""GetDict"", ""searches for %s"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClassTable_8cxx_source.html:23368,hash,hash,23368,doc/master/TClassTable_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClassTable_8cxx_source.html,2,['hash'],['hash']
Security,"ame, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTransient = kFALSE); Build a full list of persistent data members.; Scans the list of all data members in the class itself and also; in all base classes. For each persistent data member, inserts a; TRealData object in the list fRealData. void BuildEmulatedRealData(const char* name, Long_t offset, TClass* cl); Build the list of real data for an emulated class. void CalculateStreamerOffset() const; Calculate the offset between an object of this class to; its base class TObject. The pointer can be adjusted by; that offset to access any virtual method of TObject like; Streamer() and ShowMembers(). Bool_t CallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient = kFALSE) const; Call ShowMembers() on the obj of this class type, passing insp and parent.; isATObject is -1 if unknown, 0 if it is not a TObject, and 1 if it is a TObject.; The function returns whether it was able to call ShowMembers(). void InterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); Do a ShowMembers() traversal of all members and base classes' members; using the reflection information from the interpreter. Works also for; interpreted objects. Bool_t CanSplit() const; Return true if the data member of this TClass can be saved separately. Long_t ClassProperty() const; Return the C++ property of this class, eg. is abstract, has virtual base; class, see EClassProperty in TDictionary.h. TObject * Clone(const char* newname = """") const; Create a Clone of this TClass object using a different name but using the sam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:30362,access,access,30362,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['access'],['access']
Security,"ame,; 8304 sizeof(name),; 8305 ""%s/%s"",; 8306 path,; 8307 PASSWORDS_FILE_NAME);; 8308 ; 8309 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8310#if defined(DEBUG); 8311 /* Don't use mg_cry_internal here, but only a trace, since; 8312 * this is a typical case. It will occur for every directory; 8313 * without a password file. */; 8314 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8315#endif; 8316 }; 8317 } else {; 8318 /* Try to find .htpasswd in requested directory. */; 8319 for (p = path, e = p + strlen(p) - 1; e > p; e--) {; 8320 if (e[0] == '/') {; 8321 break;; 8322 }; 8323 }; 8324 mg_snprintf(conn,; 8325 &truncated,; 8326 name,; 8327 sizeof(name),; 8328 ""%.*s/%s"",; 8329 (int)(e - p),; 8330 p,; 8331 PASSWORDS_FILE_NAME);; 8332 ; 8333 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8334#if defined(DEBUG); 8335 /* Don't use mg_cry_internal here, but only a trace, since; 8336 * this is a typical case. It will occur for every directory; 8337 * without a password file. */; 8338 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8339#endif; 8340 }; 8341 }; 8342 }; 8343}; 8344#endif /* NO_FILESYSTEMS */; 8345 ; 8346 ; 8347/* Parsed Authorization header */; 8348struct ah {; 8349 char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;; 8350};; 8351 ; 8352 ; 8353/* Return 1 on success. Always initializes the ah structure. */; 8354static int; 8355parse_auth_header(struct mg_connection *conn,; 8356 char *buf,; 8357 size_t buf_size,; 8358 struct ah *ah); 8359{; 8360 char *name, *value, *s;; 8361 const char *auth_header;; 8362 uint64_t nonce;; 8363 ; 8364 if (!ah || !conn) {; 8365 return 0;; 8366 }; 8367 ; 8368 (void)memset(ah, 0, sizeof(*ah));; 8369 if (((auth_header = mg_get_header(conn, ""Authorization"")) == NULL); 8370 || mg_strncasecmp(auth_header, ""Digest "", 7) != 0) {; 8371 return 0;; 8372 }; 8373 ; 8374 /* Make modifiable copy of the auth header */; 8375 (void)mg_strlcpy(buf, auth_header + 7, buf_size);; 8376 s = b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:240687,password,password,240687,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['password'],['password']
Security,"ame,; 8305 sizeof(name),; 8306 ""%s/%s"",; 8307 path,; 8308 PASSWORDS_FILE_NAME);; 8309 ; 8310 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8311#if defined(DEBUG); 8312 /* Don't use mg_cry_internal here, but only a trace, since; 8313 * this is a typical case. It will occur for every directory; 8314 * without a password file. */; 8315 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8316#endif; 8317 }; 8318 } else {; 8319 /* Try to find .htpasswd in requested directory. */; 8320 for (p = path, e = p + strlen(p) - 1; e > p; e--) {; 8321 if (e[0] == '/') {; 8322 break;; 8323 }; 8324 }; 8325 mg_snprintf(conn,; 8326 &truncated,; 8327 name,; 8328 sizeof(name),; 8329 ""%.*s/%s"",; 8330 (int)(e - p),; 8331 p,; 8332 PASSWORDS_FILE_NAME);; 8333 ; 8334 if (truncated || !mg_fopen(conn, name, MG_FOPEN_MODE_READ, filep)) {; 8335#if defined(DEBUG); 8336 /* Don't use mg_cry_internal here, but only a trace, since; 8337 * this is a typical case. It will occur for every directory; 8338 * without a password file. */; 8339 DEBUG_TRACE(""fopen(%s): %s"", name, strerror(ERRNO));; 8340#endif; 8341 }; 8342 }; 8343 }; 8344}; 8345#endif /* NO_FILESYSTEMS */; 8346 ; 8347 ; 8348/* Parsed Authorization header */; 8349struct ah {; 8350 char *user, *uri, *cnonce, *response, *qop, *nc, *nonce;; 8351};; 8352 ; 8353 ; 8354/* Return 1 on success. Always initializes the ah structure. */; 8355static int; 8356parse_auth_header(struct mg_connection *conn,; 8357 char *buf,; 8358 size_t buf_size,; 8359 struct ah *ah); 8360{; 8361 char *name, *value, *s;; 8362 const char *auth_header;; 8363 uint64_t nonce;; 8364 ; 8365 if (!ah || !conn) {; 8366 return 0;; 8367 }; 8368 ; 8369 (void)memset(ah, 0, sizeof(*ah));; 8370 if (((auth_header = mg_get_header(conn, ""Authorization"")) == NULL); 8371 || mg_strncasecmp(auth_header, ""Digest "", 7) != 0) {; 8372 return 0;; 8373 }; 8374 ; 8375 /* Make modifiable copy of the auth header */; 8376 (void)mg_strlcpy(buf, auth_header + 7, buf_size);; 8377 s = b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:240719,password,password,240719,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['password'],['password']
Security,"ame.cxx:1729; The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each sample in the ""metadata"" key.; A simple example for the formatting of the specification in the JSON file is the following:; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; The metadata information from the specification file can be then accessed using the DefinePerSample function. For example, to access luminosity information (stored as a double):; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); or sample_category information (stored as a string):; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); or directly the filename:; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also provides a corresponding exemplary JSON file for the dataset specification. Adding a progress bar; A progress bar showing the processed event statistics can be added to any RDataFrame program. The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:77648,access,access,77648,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['access'],['access']
Security,"ame.cxx:1906; The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each sample in the ""metadata"" key.; A simple example for the formatting of the specification in the JSON file is the following:; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; The metadata information from the specification file can be then accessed using the DefinePerSample function. For example, to access luminosity information (stored as a double):; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); or sample_category information (stored as a string):; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); or directly the filename:; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also provides a corresponding exemplary JSON file for the dataset specification. Adding a progress bar; A progress bar showing the processed event statistics can be added to any RDataFrame program. The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:79070,access,access,79070,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['access'],['access']
Security,"ame/df028_SQliteIPLocation.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. df028_SQliteIPLocation.C File ReferenceTutorials » Dataframe tutorials. Detailed Description; Plot the location of ROOT downloads reading a remote sqlite3 file. ; The world map is held by a TH2Poly histogram which, after filling, will show the world wide dispersion of ROOT's users. To histogram filling, is done thanks to a lambda expression having as input parameters the two columns of the database: ""IPLongitude' - for the longitude, and the; ""IPLatitude"" - for the latitude.; The data related to the latitude and the longitude has been provided from the; log files storing the users IP.; This product includes GeoLite2 data created by MaxMind, available from; <a href=""http://www.maxmind.com"">http://www.maxmind.com.; ; void df028_SQliteIPLocation() {; ; auto rdf = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; ; auto f = TFile::Open(""http://root.cern/files/WM.root"");; auto worldMap = f->Get<TH2Poly>(""WMUSA"");; ; auto fillIPLocation = [&worldMap] ( const std::string &sLongitude, const std::string &sLatitude ) {; if (!( sLongitude == """" ) && !( sLatitude == """" )) {; auto latitude = std::stof(sLatitude);; auto longitude = std::stof(sLongitude);; worldMap->Fill(longitude, latitude);; }; };; ; rdf.Foreach( fillIPLocation, { ""IPLongitude"", ""IPLatitude"" } );; ; auto worldMapCanvas = new TCanvas();; worldMapCanvas->SetLogz();; worldMap->SetTitle(""ROOT Downloads per Location (GitHub excluded);Longitude;Latitude"");; worldMap->DrawClone(""colz"");; }; f#define f(i)Definition RSha256.hxx:104; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH2Poly2D Histogram with Polygonal Bin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df028__SQliteIPLocation_8C.html:1011,access,accesslog,1011,doc/master/df028__SQliteIPLocation_8C.html,https://root.cern,https://root.cern/doc/master/df028__SQliteIPLocation_8C.html,1,['access'],['accesslog']
Security,"amer(). void TRadialGradient::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TColorGradient. ◆ StreamerNVirtual(). void TRadialGradient::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 160 of file TColorGradient.h. ◆ TColorGradient() [1/3]. TColorGradient::TColorGradient ; (; ). inline . Definition at line 70 of file TColorGradient.h. ◆ TColorGradient() [2/3]. TColorGradient::TColorGradient ; (; Color_t ; newColor, . UInt_t ; nPoints, . const Double_t * ; points, . const Color_t * ; colorIndices, . ECoordinateMode ; mode = kObjectBoundingMode . ). There is no way to validate parameters here, so it's up to user to pass correct arguments. ; Definition at line 71 of file TColorGradient.cxx. ◆ TColorGradient() [3/3]. TColorGradient::TColorGradient ; (; Color_t ; newColor, . UInt_t ; nPoints, . const Double_t * ; points, . const Double_t * ; colors, . ECoordinateMode ; mode = kObjectBoundingMode . ). There is no way to validate parameters here, so it's up to user to pass correct arguments. ; Definition at line 73 of file TColorGradient.cxx. Member Data Documentation. ◆ fEnd. Point TRadialGradient::fEnd. private . Definition at line 155 of file TColorGradient.h. ◆ fR1. Double_t TRadialGradient::fR1 = 0. private . Definition at line 154 of file TColorGradient.h. ◆ fR2. Double_t TRadialGradient::fR2 = 0. private . Definition at line 156 of file TColorGradient.h. ◆ fStart. Point TRadialGradient::fStart. private . Definition at line 153 of file TColorGradient.h. ◆ fType. EGradientType TRadialGradient::fType = kSimple. private . Definition at line 158 of file TColorGradient.h. Libraries for TRadialGradient:. [legend]; The documentation for this class was generated from the following files:; core/base/inc/TColorGradient.h; core/base/src/TColorGradient.cxx. TRadialGradient. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRadialGradient.html:25763,validat,validate,25763,doc/master/classTRadialGradient.html,https://root.cern,https://root.cern/doc/master/classTRadialGradient.html,1,['validat'],['validate']
Security,"amerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateFormulaLeaves (const TTree *parent)=0;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualIndex.html:2191,hash,hash,2191,doc/master/classTVirtualIndex.html,https://root.cern,https://root.cern/doc/master/classTVirtualIndex.html,1,['hash'],['hash']
Security,"amerNVirtual_b);  ; bool TypeIsPointer () const;  return whether the type of this browsable object is a pointer ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCollectionMethodBrowsable.html:3815,hash,hash,3815,doc/master/classTCollectionMethodBrowsable.html,https://root.cern,https://root.cern/doc/master/classTCollectionMethodBrowsable.html,5,['hash'],['hash']
Security,"ampling density of the cache is controlled by the binning of the; the convolution observable, which can be changed from RooRealVar::setBins(N); For good results N should be large (>1000). Additional interpolation of; cache values may improve the result if courser binning are chosen. These can be; set in the constructor or through the setInterpolationOrder() member function.; For N>1000 interpolation will not substantially improve the performance. Additionial information on caching activities can be displayed by monitoring; the message stream with topic ""Caching"" at the INFO level, i.e.; do RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")); to see these message on stdout. Multi-dimensional convolutions are not supported yet, but will be in the future; as FFTW can calculate them. Installing a copy of FFTW on Linux and compiling ROOT to use it. 1) Go to www.fftw.org and download the latest stable version (a .tar.gz file). If you have root access to your machine and want to make a system installation of FFTW. 2) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure' followed by 'make install'.; This will install fftw in /usr/local/bin,lib etc... 3) Start from a source installation of ROOT. If you now have a binary distribution,; first download a source tar ball from root.cern.ch for your ROOT version and untar it.; Run 'configure', following the instruction from 'configure --help' but be sure run 'configure'; with additional flags '--enable-fftw3' and '--enable-roofit', then run 'make'. If you do not have root access and want to make a private installation of FFTW. 2) Make a private install area for FFTW, e.g. /home/myself/fftw. 3) Untar fftw-XXX.tar.gz in /tmp, cd into the untarred directory; and type './configure --prefix=/home/myself/fftw' followed by 'make install'.; Substitute /home/myself/fftw with a directory of your choice. This; procedure will install FFTW in the location designated by you. 4) Start from a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:3342,access,access,3342,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,7,['access'],['access']
Security,"an act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:. Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; We can finally make our volume having a box shape. Note that the world volume does not need to be a box - it can be any other shape. Generally, boxes and tubes are the most recommendable shapes for this purpose due to their fast navigation algorithms.; root[] TGeoVolume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:4607,access,accessed,4607,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['access'],['accessed']
Security,"an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMD5.html:4498,checksum,checksum,4498,root/html528/TMD5.html,https://root.cern,https://root.cern/root/html528/TMD5.html,1,['checksum'],['checksum']
Security,"an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMD5.html:4498,checksum,checksum,4498,root/html530/TMD5.html,https://root.cern,https://root.cern/root/html530/TMD5.html,1,['checksum'],['checksum']
Security,"an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const char* file); Returns checksum of specified file. The returned TMD5 object must; be deleted by the user. Returns 0 in case the file does not exists; or in case of error. This function preserves the modtime of the file; so it can be safely used in conjunction with methods that keep track; of the file's modtime. Static utility function. Int_t FileChecksum(const char* file, UChar_t* digest); Returns checksum of specified file in digest argument. Returns -1 in; case of error, 0 otherwise. This method preserves the modtime of the; file so it can be safely used in conjunction with methods that keep; track of the file's modtime. Static utility function. virtual ~TMD5(); { }. » Author: Fons Rademakers 29/9/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMD5.h 33386 2010-05-05 13:41:15Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMD5.html:4498,checksum,checksum,4498,root/html532/TMD5.html,https://root.cern,https://root.cern/root/html532/TMD5.html,1,['checksum'],['checksum']
Security,"an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClonesArray.html:16825,access,access,16825,doc/master/classTClonesArray.html,https://root.cern,https://root.cern/doc/master/classTClonesArray.html,1,['access'],['access']
Security,"an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Unzoom ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to cur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelCoordVar.html:6652,hash,hash,6652,doc/master/classTParallelCoordVar.html,https://root.cern,https://root.cern/doc/master/classTParallelCoordVar.html,1,['hash'],['hash']
Security,"an of course have as many subscriptions as you need. Pick a subscription!; The subscription manager is called the TTreeReader. You subscribe to a branch by creating a TTreeReaderValue (or TTreeReaderArray for arrays of any sort) and register it with the TTreeReader:; // Our subscription manager:; TTreeReader subscriptionManager(theTree);; // Tell the manager that we want to subscribe to the branch ""TribuneDeGeneve"",; // and that we expect to get an object of type Newspaper.; TTreeReaderValue<Newspaper> myTribuneDeGeneve(subscriptionManager, ""TribuneDeGeneve"");. TTreeReader::Next(); You would not want to have all issues of the Tribune de Geneve at once, but only one, say today's. You do that by requesting delivery of an issue from the subscription manager: Data delivery; // In this example, we loop over all entries on the TTree.; while (subscriptionManager.Next()) {; // Now myTribuneDeGeneve has loaded its data and we can access it.; // TTreeReaderValue behaves like an iterator; you need to use ""->"" on; // it to access the data it refers to.; myTribuneDeGeneve->read();; ...; }. Summary; As you saw, TTree is about. Chunking up similar, disconnected entries of which typically only one needs to be available, just like newspaper issues or data from High Energy Physics collisions, also known as the entries of a TTree; Selecting which data the TTree should provide, i.e. subscribing to certain branches only. Branches can be nested, so depending on the tree you could even subscribe to only the sports section or even only an article, reducing data transfer. A precedure like this is actually what most physicists do to analyze data from a series of TTrees. So let's try it in practice!; . ‹ Using TTree::Draw() to access a TTree; up; Using a Macro to Read a TTree ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/ttree-and-its-data.html:3674,access,access,3674,d/ttree-and-its-data.html,https://root.cern,https://root.cern/d/ttree-and-its-data.html,1,['access'],['access']
Security,"an opacity of 35% (i.e. a transparency of 65%). (The color kBlue itself is internally stored as fully opaque.); histo->SetMarkerColorAlpha(kBlue, 0.35);; kBlue@ kBlueDefinition Rtypes.h:66; The transparency is available on all platforms when the flag OpenGL.CanvasPreferGL is set to 1 in $ROOTSYS/etc/system.rootrc, or on Mac with the Cocoa backend. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; Alternatively, you can call at the top of your script gSytle->SetCanvasPreferGL();. Or if you prefer to activate GL for a single canvas c, then use c->SetSupportGL(true);. Marker style; The Marker style defines the markers' shape. The marker style of any class inheriting from TAttMarker can be changed using the method SetMarkerStyle and retrieved using the method GetMarkerStyle.; The following list gives the currently supported markers (screen and PostScript) style. Each marker style is identified by an integer number (first column) corresponding to a marker shape (second column) and can be also accessed via a global name (third column).; Marker number Marker shape Marker name; 1 dot kDot; 2 + kPlus; 3 * kStar; 4 o kCircle; 5 x kMultiply; 6 small dot kFullDotSmall; 7 medium dot kFullDotMedium; 8 large scalable dot kFullDotLarge; 9 -->19 large scalable dot; 20 full circle kFullCircle; 21 full square kFullSquare; 22 full triangle up kFullTriangleUp; 23 full triangle down kFullTriangleDown; 24 open circle kOpenCircle; 25 open square kOpenSquare; 26 open triangle up kOpenTriangleUp; 27 open diamond kOpenDiamond; 28 open cross kOpenCross; 29 full star kFullStar; 30 open star kOpenStar; 31 *; 32 open triangle down kOpenTriangleDown; 33 full diamond kFullDiamond; 34 full cross kFullCross; 35 open diamond cross kOpenDiamondCross; 36 open square diagonal kOpenSquareDiagonal; 37 open three triangle kOpenThreeTriangles; 38 octagon with cross kOctagonCross; 39 full three triangles kFullThreeTriangles; 40 open four triangleX kOpenFourTrianglesX;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAttMarker.html:2128,access,accessed,2128,doc/master/classTAttMarker.html,https://root.cern,https://root.cern/doc/master/classTAttMarker.html,1,['access'],['accessed']
Security,"an provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the modtime. Returns 0 on success and -1 in case of error.; 1526 ; 1527int TSystem::Utime(const char *, Long_t, Long_t); 1528{; 1529 AbstractMethod(""Utime"");; 1530 return -1;; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Find location of file in a search path. Return value points to TString for; 1535/// compatibility with Which(const char *, const char *, EAccessMode).; 1536/// Returns 0 in case file is not found.; 1537 ; 1538const char *TSystem::FindFile(const char *, TString&, EAccessMode); 1539{; 1540 AbstractMethod(""FindFile"");; 1541 return nullptr;; 1542}; 1543 ; 1544////////////////////////////////////////////////////////////////////////////////; 1545/// Find location of file in a search path. User must delete returned string.; 1546/// Returns 0 in case f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:48056,access,access,48056,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['access'],['access']
Security,"ance sampling weight of the event when not successful and decrease it when successful ;  ; Types::ETreeType GetCurrentType () const;  ; const Event * GetEvent () const;  returns event without transformations ;  ; const Event * GetEvent (Long64_t ievt) const;  ; const Event * GetEvent (Long64_t ievt, Types::ETreeType type) const;  ; const std::vector< Event * > & GetEventCollection (Types::ETreeType type=Types::kMaxTreeType) const;  ; const TTree * GetEventCollectionAsTree ();  ; Long64_t GetNClassEvents (Int_t type, UInt_t classNumber);  ; Long64_t GetNEvents (Types::ETreeType type=Types::kMaxTreeType) const;  ; Long64_t GetNEvtBkgdTest ();  return number of background test events in dataset ;  ; Long64_t GetNEvtBkgdTrain ();  return number of background training events in dataset ;  ; Long64_t GetNEvtSigTest ();  return number of signal test events in dataset ;  ; Long64_t GetNEvtSigTrain ();  return number of signal training events in dataset ;  ; UInt_t GetNSpectators () const;  access the number of targets through the datasetinfo ;  ; UInt_t GetNTargets () const;  access the number of targets through the datasetinfo ;  ; Long64_t GetNTestEvents () const;  ; Long64_t GetNTrainingEvents () const;  ; UInt_t GetNVariables () const;  access the number of variables through the datasetinfo ;  ; Results * GetResults (const TString &, Types::ETreeType type, Types::EAnalysisType analysistype);  ; const Event * GetTestEvent (Long64_t ievt) const;  ; const Event * GetTrainingEvent (Long64_t ievt) const;  ; TTree * GetTree (Types::ETreeType type);  create the test/trainings tree with all the variables, the weights, the classes, the targets, the spectators, the MVA outputs ;  ; Bool_t HasNegativeEventWeights () const;  ; void IncrementNClassEvents (Int_t type, UInt_t classNumber);  ; void InitSampling (Float_t fraction, Float_t weight, UInt_t seed=0);  initialize random or importance sampling ;  ; virtual TClass * IsA () const;  ; void MoveTrainingBlock (Int_t blockInd, Types:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSet.html:2243,access,access,2243,doc/master/classTMVA_1_1DataSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSet.html,1,['access'],['access']
Security,"anceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTNamespace for new ROOT classes and functions ;  ►NDetail;  ►NTDF;  CTCustomColumn;  CTCustomColumnBase;  CTFilter;  CTFilterBase;  CTLoopManager;  CTRange;  CTRangeBase;  CTBranchProxyBase class for all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CEnvironSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CIteratorsSmall helper to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< bool > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  ►",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:10921,access,accesses,10921,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['access'],['accesses']
Security,"anch supports bulk IO, false otherwise. ;  ; virtual void UpdateFile ();  Refresh the value of fDirectory (i.e. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchObject.html:11217,hash,hash,11217,doc/master/classTBranchObject.html,https://root.cern,https://root.cern/doc/master/classTBranchObject.html,1,['hash'],['hash']
Security,"and an angle; ROOT::Math::Quaternion, rotation described by a quaternion (4 numbers); ROOT::Math::RotationX, specialized rotation along the X axis; ROOT::Math::RotationY, specialized rotation along the Y axis; ROOT::Math::RotationZ, specialized rotation along the Z axis. 3D Transformation. ROOT::Math::Translation3D, (only translation) described by a 3D vector; ROOT::Math::Transform3D, (rotations and then translation) described by a 3x4 matrix (12 numbers). Lorentz Rotation. ROOT::Math::LorentzRotation , 4D rotation (3D rotation plus a boost) described by a 4x4 matrix; ROOT::Math::Boost, a Lorentz boost in an arbitrary direction and described by a 4x4 symmetric matrix (10 numbers); ROOT::Math::BoostX, a boost in the X axis direction; ROOT::Math::BoostY, a boost in the Y axis direction; ROOT::Math::BoostZ, a boost in the Z axis direction. Compatibility with CLHEP Vector classes; For compatibility with CLHEP, the vector classes can be constructed easily from a CLHEP Hep3Vector or HepLorentzVector, by using a template constructor, which requires only that the classes implement the accessors x(), y() and z() (and t() for HepLorentzVector). The vector classes also provide member function with the same naming convention as CLHEP for the most used functions like x(), y() and z(). Additional Documentation; A more detailed description of all the GenVector classes is available in this document. . Namespaces; namespace  ROOT::Math::VectorUtil;  Global Helper functions for generic Vector classes. ;  . Classes; class  ROOT::Math::AxisAngle;  AxisAngle class describing rotation represented with direction axis (3D Vector) and an angle of rotation around that axis. More...;  ; class  ROOT::Math::Boost;  Lorentz boost class with the (4D) transformation represented internally by a 4x4 orthosymplectic matrix. More...;  ; class  ROOT::Math::BoostX;  Class representing a Lorentz Boost along the X axis, by beta. More...;  ; class  ROOT::Math::BoostY;  Class representing a Lorentz Boost al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:9442,access,accessors,9442,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['access'],['accessors']
Security,"and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; TMatrixTBase::fNelemsInt_t fNelemsDefinition TMatrixTBase.h:94; TMatrixTBase::fNrowsInt_t fNrowsDefinition TMatrixTBase.h:90; TMatrixTSparse::fRowIndexInt_t * fRowIndexDefinition TMatrixTSparse.h:40; TMatrixTSparse::fColIndexInt_t * fColIndexDefinition TMatrixTSparse.h:41; As an example how to access all sparse data elements:; for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }; TMatrixTBase::fColLwbInt_t fColLwbDefinition TMatrixTBase.h:93; TMatrixTBase::fRowLwbInt_t fRowLwbDefinition TMatrixTBase.h:92; TMatrixTSparse::fElementsElement * fElementsDefinition TMatrixTSparse.h:42; int; When checking whether sparse matrices are compatible (like in an assignment !), not only the shape parameters are compared but also the sparse structure through fRowIndex and fColIndex .; Several methods exist to fill a sparse matrix with data entries. Most are the same like for dense matrices but some care has to be taken with regard to performance. In the constructor, always the shape of the matrix has to be specified in some form . Data can be entered through the following methods :; constructor from COO matrix format TMatrixTSparse(Int_t row_lwb,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:1684,access,access,1684,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['access'],['access']
Security,"and its ""dark"" and ""bright"" associated colors. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRadialGradient.html:6397,hash,hash,6397,doc/master/classTRadialGradient.html,https://root.cern,https://root.cern/doc/master/classTRadialGradient.html,1,['hash'],['hash']
Security,"and its ""dark"" and ""bright"" associated colors. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColorGradient.html:5707,hash,hash,5707,doc/master/classTColorGradient.html,https://root.cern,https://root.cern/doc/master/classTColorGradient.html,2,['hash'],['hash']
Security,"and len, where pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 517 of file TWebFile.cxx. ◆ ReadBuffers10(). Bool_t TWebFile::ReadBuffers10 ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). protectedvirtual . Read specified byte ranges from remote file via HTTP 1.0 daemon (without mod-root installed). ; Read the nbuf blocks described in arrays pos and len, where pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Definition at line 566 of file TWebFile.cxx. ◆ ReOpen(). Int_t TWebFile::ReOpen ; (; Option_t * ; mode). overridevirtual . Reopen a file with a different access mode, like from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. ; Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or wrong input arguments) and -1 in case of failure, in which case the file cannot be used anymore. A TWebFile cannot be reopened in update mode. ; Reimplemented from TFile.; Definition at line 394 of file TWebFile.cxx. ◆ Seek(). void TWebFile::Seek ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). overridevirtual . Set position from where to start reading. ; Reimplemented from TFile.; Definition at line 989 of file TWebFile.cxx. ◆ SetMaxFullCacheSize(). void TWebFile::SetMaxFullCacheSize ; (; Long64_t ; sz). static . Static method, set maxmimal size of full cache,. ; Definition at line 1449 of file TWebFile.cxx. ◆ SetMsgReadBuffer10(). void TWebFile::SetMsgReadBuffer10 ; (; const char * ; redirectLocation = nullptr, . Bool_t ; tempRedirect ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:55251,access,access,55251,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['access'],['access']
Security,"and line, argv[0]) and copy it in gProgName. ;  ; int SetSockOpt (int sock, int option, int val) override;  Set socket option. ;  ; void SigAlarmInterruptsSyscalls (Bool_t set) override;  When the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be restarted by the kernel. ;  ; void Sleep (UInt_t milliSec) override;  Sleep milliSec milliseconds. ;  ; void StackTrace () override;  Print a stack trace. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Symlink (const char *from, const char *to) override;  Create a symlink from file1 to file2. ;  ; void Syslog (ELogLevel level, const char *mess) override;  Send mess to syslog daemon. ;  ; const char * TempDirectory () const override;  Return a user configured or systemwide directory to create temporary files in. ;  ; FILE * TempFileName (TString &base, const char *dir=nullptr, const char *suffix=nullptr) override;  Create a secure temporary file by appending a unique 6 letter string to base. ;  ; int Umask (Int_t mask) override;  Set the process file creation mode mask. ;  ; int Unlink (const char *name) override;  Unlink, i.e. ;  ; void Unload (const char *module) override;  Unload a shared library. ;  ; void Unsetenv (const char *name) override;  Unset environment variable. ;  ; int Utime (const char *file, Long_t modtime, Long_t actime) override;  Set a files modification and access times. ;  ; const char * WorkingDirectory () override;  Return working directory. ;  ;  Public Member Functions inherited from TSystem;  TSystem (const char *name=""Generic"", const char *title=""Generic System"");  Create a new OS interface. ;  ; virtual ~TSystem ();  Delete the OS interface. ;  ; virtual void AddIncludePath (const char *includePath);  Add a directory to the already set include path. ;  ; virtual void AddLinkedLibs (const char *linkedLib);  Add linkedLib to already set linked libs. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:12056,secur,secure,12056,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['secur'],['secure']
Security,"and recursively remove the object from all other objects (and collections). ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void SetClass (TClass *cl);  ; void Streamer (TBuffer &) override;  Stream an object of class TListOfDataMembers. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Unload ();  Mark 'all func' as being unloaded. ;  ; void Unload (TDictionary *member);  Mark 'func' as being unloaded. ;  ; void Update (TDictionary *member);  Move the member or data member to the expect set of list. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:5101,hash,hashlist,5101,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['hash'],['hashlist']
Security,"and vertical) combination of TPadLengths ;  CTPadPainterAbstract interface for object painting on the pad/canvas ;  CTPadUserAxisBaseBase class for user coordinates (e.g ;  ►CTUniWeakPtr;  CAccessorGives transparent access to the shared or unique pointer ;  ►CTVirtualCanvasPainterAbstract interface for painting a canvas ;  CGenerator;  ►CTAxisBaseHistogram axis base class ;  Cconst_iteratorRandom const_iterator through bins ;  ►CTAxisConfigObjects used to configure the different axis types ;  CGrow_tTag type signalling that an axis should be able to grow; used for calling the appropriate constructor ;  CTAxisEquidistantAxis with equidistant bin borders ;  CTAxisGrowAn axis that can extend its range, keeping the number of its bins unchanged ;  CTAxisIrregularAn axis with non-equidistant bins (also known as ""variable binning"") ;  CTAxisLabelsA TAxisGrow that has a label assigned to each bin and a bin width of 1 ;  CTAxisViewCommon view on a TAxis, no matter what its kind ;  CTBufferMergerTBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file ;  CTBufferMergerFile;  CTCanvasA window's topmost TPad ;  ►CTDirectoryKey/value store of objects ;  CToContentType;  CTDirectoryTypeMismatchObjects of this class are thrown to signal that the value known under the given name ;  CTDirectoryUnknownKeyObjects of this class are thrown to signal that no key with that name exists ;  CTDrawableBase class for drawable entities: objects that can be painted on a TPad ;  CTDrawableBase;  ►CTFileA ROOT file ;  COptions_tOptions for TFile construction ;  CTFilePtrPoints to an object that stores or reads objects in ROOT's binary format ;  CTFitResult;  ►CTFrameHolds a user coordinate system with a palette ;  CDrawingOpts;  CTFunction;  CTFutureA TFuture class. It can wrap an std::future ;  CTHistHistogram class for histograms with DIMENSIONS dimensions, where each bin count is stored by a value of type PRECISION ;  CTHist< D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:17847,access,access,17847,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['access'],['access']
Security,"anels (see TPaveText). One can set the number of stacked panels at building time. It has the following constructor: By default, the number of stacked panels is 5, option=“br”.; TPavesText(Double_t x1, Double_t y1, Double_t x2, Double_t y2,; Int_t npaves, Option_t* option). A PaveText example. 9.4.10 The TeX Processor TMathText; TMathText’s purpose is to write mathematical equations, exactly as TeX would do it. The syntax is the same as the TeX’s one.; The script $ROOTSYS/tutorials/graphics/tmathtex.C:; gives the following output:. A TMathText example. TMathText uses plain TeX syntax and uses “\” as control instead of “#”. If a piece of text containing “\” is given to TLatex then TMathText is automatically invoked. Therefore, as histograms’ titles, axis titles, labels etc … are drawn using TLatex, the TMathText syntax can be used for them also.; 9.5 Axis; The axis objects are automatically built by various high level objects such as histograms or graphs. Once build, one may access them and change their characteristics. It is also possible, for some particular purposes to build axis on their own. This may be useful for example in the case one wants to draw two axis for the same plot, one on the left and one on the right.; For historical reasons, there are two classes representing axis. TAxis * axis is the axis object, which will be returned when calling the TH1::GetAxis() method.; TAxis *axis = histo->GetXaxis(); Of course, you may do the same for Y and Z-axis. The graphical representation of an axis is done with the TGaxis class. The histogram classes and TGraph generate instances of this class. This is internal and the user should not have to see it.; 9.5.1 Axis Title; The axis title is set, as with all named objects, by; axis->SetTitle(""Whatever title you want"");; When the axis is embedded into a histogram or a graph, one has to first extract the axis object:; h->GetXaxis()->SetTitle(""Whatever title you want""); 9.5.2 Axis Options and Characteristics; The axis optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:334914,access,access,334914,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ange node hangs from a filter node, and the range has a begin parameter of 10, that means the range will skip the first 10 entries that pass the preceding filter.; Ranges allow ""early quitting"": if all branches of execution of a functional graph reached their end value of processed entries, the event-loop is immediately interrupted. This is useful for debugging and quick data explorations. Custom columns; Custom columns are created by invoking Define(name, f, columnList). As usual, f can be any callable object (function, lambda expression, functor class...); it takes the values of the columns listed in columnList (a list of strings) as parameters, in the same order as they are listed in columnList. f must return the value that will be assigned to the temporary column.; A new variable is created called name, accessible as if it was contained in the dataset from subsequent transformations/actions.; Use cases include:; caching the results of complex calculations for easy and efficient multiple access; extraction of quantities of interest from complex objects; branch aliasing, i.e. changing the name of a branch. An exception is thrown if the name of the new column/branch is already in use for another branch in the TTree.; It is also possible to specify the quantity to be stored in the new temporary column as a C++ expression with the method Define(name, expression). For example this invocation; df.Define(""pt"", ""sqrt(px*px + py*py)"");; will create a new column called ""pt"" the value of which is calculated starting from the columns px and py. The system builds a just-in-time compiled function starting from the expression after having deduced the list of necessary branches from the names of the variables specified by the user.; Custom columns as function of slot and entry number; It is possible to create custom columns also as a function of the processing slot and entry numbers. The methods that can be invoked are:; DefineSlot(name, f, columnList). In this case the callable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:31193,access,access,31193,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['access'],['access']
Security,"angle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t UChar_t lenDefinition TGWin32VirtualXProxy.cxx:249; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TLeaf::GetLenvirtual Int_t GetLen() constReturn the number of effective elements of this leaf, for the current entry.Definition TLeaf.cxx:404; and the value in the BranchCount corresponding to that entry (can be obtained from branch->GetBranchCount()).; NoteThis interface is not meant to be exposed to end users, but rather it should be wrapped by higher-level interfaces. See TBranch::GetEntriesSerialized() for an alternative that does not perform byte swapping (useful to save one pass over data in some cases). ; Definition at line 1472 of file TBranch.cxx. ◆ GetBulkRead(). ROOT::Experimental::Internal::TBulkBranchRead & TBranch::GetBulkRead ; (; ). inline . Definition at line 218 of file TBranch.h. ◆ GetClassName(). const char * TBranch::GetClassName ; (; ); const. virtual . Return the name of the user class whose content is stored in this branch, if any. ; If this branch was created using the 'leaflist' technique, this function returns an empty string. ; Reimplemented in TBranchClones, TBranchElement, TBranchObject, and TBranchSTL.; Definition at line 1324 of file TBranch.cxx. ◆ GetCompressionAlgorithm(). Int_t TBranch::GetCompressionAlgorithm ; (; ); const. inline . Definition at line 299 of file TBranch.h. ◆ GetCompressionLevel(). Int_t TBranch::GetCompressionLevel ; (; ); const. inline . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranch.html:44543,expose,exposed,44543,doc/master/classTBranch.html,https://root.cern,https://root.cern/doc/master/classTBranch.html,1,['expose'],['exposed']
Security,"angle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definition TObject.cxx:648; or the long form [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]; targetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t targetDefinition TGWin32VirtualXProxy.cxx:247; For example to set HepMC::GenVertex::m_event to not owned the object it is pointing to: HepMC::GenVertex m_event attributes=NotOwner; Semantic ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:54314,checksum,checksum,54314,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['checksum'],['checksum']
Security,"angle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definition TObject.cxx:654; or the long form [type=Read] sourceClass=classname [targetclass=newClassname] [ source=""type membername; [type2 membername2]"" ]; [target=""membername3;membername4""] [attributes=... ] [version=...] [checksum=...] [code={...}|functionname]; targetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t targetDefinition TGWin32VirtualXProxy.cxx:247; For example to set HepMC::GenVertex::m_event to not owned the object it is pointing to: HepMC::GenVertex m_event attributes=NotOwner; Semantic ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:54315,checksum,checksum,54315,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['checksum'],['checksum']
Security,"ank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu^T\). A.RandomizePD(alpha,beta,seed)`; TMatrixX; \(A_{ij} = (\beta-\alpha)\bigcup(0,1)+\alpha\) a random symmetric positive-definite matrix is generated with elements uniformly distributed between \(\alpha\) and \(\beta\). Output TMatrixX indicates that the returned matrix is of the same type as A, being TMatrixD, TMatrixDSym or TMatrixDSparse. Next table shows miscellaneous operations for TMatrixD. Format; Output; Description. A.Rank1Update(v1,v2,alpha); TMatrixD; Perform with vector v1 and v2, a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu2^T\). 14.5 Matrix Views; Another way to access matrix elements is through the matrix-view classes, TMatrixDRow, TMatrixDColumn, TMatrixDDiag and TMatrixDSub (each has also a const version which is obtained by simply appending const to the class name). These classes create a reference to the underlying matrix, so no memory management is involved. The next table shows how the classes access different parts of the matrix:. class; view. TMatrixDRow const(X,i) TMatrixDRow(X,i); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & & & & \\; x_{i0} & ... & x_{ij} & ... & x_{in} \\; & & & & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDColumn const(X,j) TMatrixDColumn(X,j); \[ \left(\begin{array}{ccccc}; x_{00} & & x_{0j} & & x_{0n} \\; & & ... & & \\; & & x_{ij} & & \\; & & ... & & \\; x_{n0} & & x_{nj} & & x_{nn}; \end{array}\right)\]. TMatrixDDiag const(X) TMatrixDDiag(X); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & ... & & & \\; & & ... & & \\; & & & ... & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDSub const(X,i,l,j,k) TMatrixDSub(X,i,l,j,k); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & & & & \\; & & x_{ij} & ... & x_{ik} \\; & & x_{lj} & ... & x_{lk} \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. 14.5.1 View Operators; For the matrix views TMatrixDRow, TMatrixDColumn and TMatrixDDiag, the necessary assign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:784144,access,access,784144,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ank), for instance:; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"". Examples:; TFile* f1 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f2 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");. If there is no authentication information in the 'options' argument; (i.e. not AUTH=""...."") the values of the environmental variables; S3_ACCESS_KEY and S3_SECRET_KEY (if set) are expected to contain; the access key id and the secret access key, respectively. You have; been provided with these credentials by your S3 service provider. If neither the AUTH information is provided in the 'options' argument; nor the environmental variables are set, we try to open the file; without providing any authentication information to the server. This; is useful when the file is set an access control that allows for; any unidentified user to read the file. Bool_t ParseOptions(Option_t* options, TString& accessKey, TString& secretKey); Extracts the S3 authentication key pair (access key and secret key); from the options. The authentication credentials can be specified in; the options provided to the constructor of this class as a string; containing: ""AUTH=<access key>:<secret key>"" and can include other; options, for instance ""NOPROXY"" for not using the HTTP proxy for; accessing this file's contents.; For instance:; ""NOPROXY AUTH=F38XYZABCDeFgHiJkLm:V+frt4re7J1euSNFnmaf8wwmI401234E7kzxZ/TTM+"". Int_t GetHead(); Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this; file. Uses TS3HTTPRequest to generate an HTTP HEAD request which includes; the authorization header expected by the S3 server. void SetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); Overwrites TWebFile::SetMsgReadBuffer10() for setting the HTTP GET; request compliant to th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:29564,access,access,29564,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,3,['access'],['access']
Security,"ansient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Double_t_interpBoundary; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Bool_t_logInit! flag used for chaching polynomial coefficients; vector<double>_low; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html:35860,access,access,35860,root/html602/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html,2,['access'],['access']
Security,"ansient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedPdf.html:43962,access,access,43962,root/html602/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedPdf.html,2,['access'],['access']
Security,anup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategory.html:19688,access,access,19688,root/html532/RooAbsCategory.html,https://root.cern,https://root.cern/root/html532/RooAbsCategory.html,1,['access'],['access']
Security,"anvas.; To automate files loading and objects drawing, one can provide number of URL parameters in address string like:. file - name of the file, which will be automatically open with page loading; files - array of file names for loading; json - name of JSON file with stored ROOT object like histogram or canvas; item - item name to be displayed; opt - drawing option for the item; items - array of items name to be displayed; opts - array of drawing options for the items; expand - item name(s) to be expanded in the hierarchy browser; focus - item name to be focused on in the hierarchy browser; title - set browser title; dir - list files in directory on http server, see https://github.com/root-project/jsroot/issues/283; layout - can be ‘simple’, ‘flex’, ‘tabs’, ‘gridNxM’, ‘horizNMK’, ‘vertNMK’; browser - layout of the browser ‘fix’ (default), ‘float’, ‘no’ (hidden), ‘off’ (fully disabled); nobrowser - do not display file browser (same as browser=no); float - display floating browser (same as browser=float); status - configure status line ‘no’ (default), ‘off’ (completely disable), ‘size’; inject - name of extra JavaScript to load, see several examples in demo/ subdir; optimize - drawing optimization 0:off, 1:only large histograms (default), 2:always; palette - id of default color palette, 51..121 - new ROOT6 palette (default 57); interactive - enable/disable interactive functions 0 - disable all, 1 - enable all; noselect - hide file-selection part in the browser (only when file name is specified); mathjax - use MathJax for latex output; latex - ‘off’, ‘symbols’, ‘normal’, ‘mathjax’, ‘alwaysmath’ control of TLatex processor; style - name of TStyle object to define global JSROOT style; toolbar - show canvas tool buttons ‘off’, ‘on’ and ‘popup’, ‘left’ or ‘right’ for position, ‘vert’ for vertical; divsize - fixed size in pixels for main div element like &dvisize=1500x800; canvsize - default canvas size in pixels like &canvsize=1200x800; optstat - settings for stat box, def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:2346,inject,inject,2346,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['inject'],['inject']
Security,"anvas::GetUIDstd::string GetUID() constReturn unique identifier for the canvas Used in iPython display.Definition RCanvas.cxx:199; ROOT::Experimental::RCanvas::CreateJSONstd::string CreateJSON()Provide JSON which can be used for offline display.Definition RCanvas.cxx:211; ROOT::Experimental::RCanvas::Createstatic std::shared_ptr< RCanvas > Create(const std::string &title)Create new canvas instance.Definition RCanvas.cxx:89; ROOT::Experimental::RCanvas::ClearOnClosevoid ClearOnClose(const std::shared_ptr< void > &handle)Set handle which will be cleared when connection is closed.Definition RCanvas.cxx:239; ROOT::Experimental::RCanvas::Updatevoid Update(bool async=false, CanvasCallback_t callback=nullptr)update drawingDefinition RCanvas.cxx:78; ROOT::Experimental::RCanvas::Hidevoid Hide()Hide all canvas displays.Definition RCanvas.cxx:171; ROOT::Experimental::RChangeAttrRequest::Processstd::unique_ptr< RDrawableReply > Process() overrideApply attributes changes to the drawable Return mask with actions which were really applied.Definition RCanvas.cxx:327; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; int; nconst Int_t nDefinition legend1.C:16; ROOT::Experimental::Internal::RIOSharedVector_tstd::vector< RIOSharedBase * > RIOSharedVector_tDefinition RDrawable.hxx:52; ROOT::Experimental::CanvasCallback_tstd::function< void(bool)> CanvasCallback_tDefinition RVirtualCanvasPainter.hxx:22; ROOT::Experimental::GPadLogRLogChannel & GPadLog()Log channel for GPad diagnostics.Definition RAttrBase.cxx:17. graf2dgpadv7srcRCanvas.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8cxx_source.html:16557,hash,hash,16557,doc/master/RCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html,1,['hash'],['hash']
Security,"anvases and files; Also all registered objects are included.; One could reimplement this method to provide alternative; scan methods or to extend some collection kinds. Bool_t IsDrawableClass(TClass* cl); return true if object can be drawn. void ScanHierarchy(const char* topname, const char* path, TRootSnifferStore* store, Bool_t only_fields = kFALSE); scan ROOT hierarchy with provided store object. void * FindInHierarchy(const char* path, TClass** cl = 0, TDataMember** member = 0, Int_t* chld = 0); Search element with specified path; Returns pointer on element; Optionally one could obtain element class, member description; and number of childs. When chld!=0, not only element is searched,; but also number of childs are counted. When member!=0, any object; will be scanned for its data members (disregard of extra options). TObject * FindTObjectInHierarchy(const char* path); Search element in hierarchy, derived from TObject. ULong_t GetStreamerInfoHash(); Returns hash value for streamer infos; At the moment - just number of items in streamer infos list. ULong_t GetItemHash(const char* itemname); Get hash function for specified item; used to detect any changes in the specified object. Bool_t CanDrawItem(const char* path); Method verifies if object can be drawn. Bool_t CanExploreItem(const char* path); Method returns true when object has childs or; one could try to expand item. void CreateMemFile(); Creates TMemFile instance, which used for objects streaming; One could not use TBufferFile directly,; while one also require streamer infos list. Bool_t ProduceJson(const char* path, const char* options, TString& res); produce JSON data for specified item; For object conversion TBufferJSON is used. Bool_t ExecuteCmd(const char* path, const char* options, TString& res); execute command marked as _kind=='Command'. Bool_t ProduceItem(const char* path, const char* options, TString& res, Bool_t asjson = kTRUE); produce JSON/XML for specified item; contrary to h.json request, only f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootSniffer.html:14056,hash,hash,14056,root/html534/TRootSniffer.html,https://root.cern,https://root.cern/root/html534/TRootSniffer.html,2,['hash'],['hash']
Security,"apInstanceCount() const { return fOnHeap; }; 468 void GetMenuItems(TList *listitems);; 469 TList *GetMenuList() const;; 470 TMethod *GetMethod(const char *method, const char *params, Bool_t objectIsConst = kFALSE);; 471 TMethod *GetMethodWithPrototype(const char *method, const char *proto, Bool_t objectIsConst = kFALSE,; 472 ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);; 473 TMethod *GetMethodAny(const char *method);; 474 TMethod *GetMethodAllAny(const char *method);; 475 Int_t GetNdata();; 476 ROOT::MergeFunc_t GetMerge() const;; 477 ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const;; 478 ROOT::NewFunc_t GetNew() const;; 479 ROOT::NewArrFunc_t GetNewArray() const;; 480 Int_t GetNmethods();; 481 TClass *const*GetPersistentRef() const { return fPersistentRef; }; 482 TRealData *GetRealData(const char *name) const;; 483 TVirtualRefProxy *GetReferenceProxy() const { return fRefProxy; }; 484 const ROOT::Detail::TSchemaRuleSet *GetSchemaRules() const;; 485 ROOT::Detail::TSchemaRuleSet *GetSchemaRules(Bool_t create = kFALSE);; 486 const char *GetSharedLibs();; 487 ShowMembersFunc_t GetShowMembersWrapper() const { return fShowMembers; }; 488 EState GetState() const { return fState; }; 489 TClassStreamer *GetStreamer() const;; 490 ClassStreamerFunc_t GetStreamerFunc() const;; 491 ClassConvStreamerFunc_t GetConvStreamerFunc() const;; 492 const TObjArray *GetStreamerInfos() const { return fStreamerInfo; }; 493 TVirtualStreamerInfo *GetStreamerInfo(Int_t version=0, Bool_t isTransient = kFALSE) const;; 494 TVirtualStreamerInfo *GetStreamerInfoAbstractEmulated(Int_t version=0) const;; 495 TVirtualStreamerInfo *FindStreamerInfoAbstractEmulated(UInt_t checksum) const;; 496 const std::type_info *GetTypeInfo() const { return fTypeInfo; };; 497 ; 498 /// @brief Return 'true' if we can guarantee that if this class (or any class in; 499 /// this class inheritance hierarchy) overload TObject::Hash it also starts; 500 /// the RecursiveRemove process from its own destructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:25242,checksum,checksum,25242,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['checksum'],['checksum']
Security,"apacity(). Int_t TExMap::Capacity ; (; ); const. inline . Definition at line 69 of file TExMap.h. ◆ Class(). static TClass * TExMap::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TExMap::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TExMap::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file TExMap.h. ◆ DeclFileName(). static const char * TExMap::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 81 of file TExMap.h. ◆ Delete(). void TExMap::Delete ; (; Option_t * ; opt = """"). overridevirtual . Delete all entries stored in the TExMap. ; Reimplemented from TObject.; Definition at line 164 of file TExMap.cxx. ◆ Expand(). void TExMap::Expand ; (; Int_t ; newsize). Expand the TExMap. ; Definition at line 279 of file TExMap.cxx. ◆ FindElement(). Int_t TExMap::FindElement ; (; ULong64_t ; hash, . Long64_t ; key . ). private . Find an entry with specified hash and key in the TExMap. ; Returns the slot of the key or the next empty slot. ; Definition at line 237 of file TExMap.cxx. ◆ FixCollisions(). void TExMap::FixCollisions ; (; Int_t ; index). private . Rehash the map in case an entry has been removed. ; Definition at line 257 of file TExMap.cxx. ◆ GetSize(). Int_t TExMap::GetSize ; (; ); const. inline . Definition at line 71 of file TExMap.h. ◆ GetValue() [1/3]. Long64_t TExMap::GetValue ; (; Long64_t ; key). inline . Definition at line 73 of file TExMap.h. ◆ GetValue() [2/3]. Long64_t TExMap::GetValue ; (; ULong64_t ; hash, . Long64_t ; key . ). Return the value belonging to specified key and hash value. ; If key not found return 0. ; Definition at line 174 of file TExMap.cxx. ◆ GetValue() [3/3]. Long64_t TExMap::GetValue ; (; ULong64_t ; hash, . Long64_t ; key, . UInt_t & ; slot . ). Return the value belonging to specified key and hash value. ; If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:14321,hash,hash,14321,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,1,['hash'],['hash']
Security,"ape, which were passed around in the community.; 2D Graphics Libraries. Add the method AddPointto TGraph(x,y) and TGraph2D(x,y,z), equivalent to SetPoint(g->GetN(),x,y)and SetPoint(g->GetN(),x,y,z); Option E0 draws error bars and markers are drawn for bins with 0 contents. Now, combined with options E1 and E2, it avoids error bars clipping.; Fix TAxis::ChangeLabel for vertical axes and 3D plots. Networking Libraries; Multithreaded support for FastCGI; Now when THttpServer creates FastCGI engine, 10 worker threads used to process requests received via FastCGI channel. This significantly increase a performance, especially when several clients are connected.; Better security for THttpServer with webgui; If THttpServer created for use with webgui widgets (RBrowser, RCanvas, REve), it only will provide access to the widgets via websocket connection - any other kind of requests like root.json or exe.json will be refused completely. Combined with connection tokens and https protocol, this makes usage of webgui components in public networks more secure.; Enabled WLCG Bearer Tokens support in RDavix; Bearer tokens are part of WLCG capability-based infrastructure with capability-based scheme which uses an infrastructure that describes what the bearer is allowed to do as opposed to who that bearer is. Token discovery procedure are developed according to the WLCG Bearer Token Discovery specification document. Short overview:. If the BEARER_TOKEN environment variable is set, then the value is taken to be the token contents.; If the BEARER_TOKEN_FILE environment variable is set, then its value is interpreted as a filename. The contents of the specified file are taken to be the token contents.; If the XDG_RUNTIME_DIR environment variable is set, then take the token from the contents of $XDG_RUNTIME_DIR/bt_u$ID(this additional location is intended to provide improved security for shared login environments as $XDG_RUNTIME_DIR is defined to be user-specific as opposed to a system-wid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:27017,secur,secure,27017,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['secur'],['secure']
Security,"apeChars ; (; const char * ; text); const. Introduce an escape character (@) in front of a special chars. ; You need to use the result immediately before it is being overwritten. ; Definition at line 2568 of file TClass.cxx. ◆ FindClassOrBaseMethodWithId(). TMethod * TClass::FindClassOrBaseMethodWithId ; (; DeclId_t ; faddr). private . Find a method with decl id in this class or its bases. ; Definition at line 4440 of file TClass.cxx. ◆ FindConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const char * ; onfile_classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7193 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7204 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7066 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7036 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:67475,checksum,checksum,67475,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['checksum'],['checksum']
Security,"apeChars ; (; const char * ; text); const. Introduce an escape character (@) in front of a special chars. ; You need to use the result immediately before it is being overwritten. ; Definition at line 2635 of file TClass.cxx. ◆ FindClassOrBaseMethodWithId(). TMethod * TClass::FindClassOrBaseMethodWithId ; (; DeclId_t ; faddr). private . Find a method with decl id in this class or its bases. ; Definition at line 4507 of file TClass.cxx. ◆ FindConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const char * ; onfile_classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7260 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7271 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7133 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7103 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:67476,checksum,checksum,67476,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['checksum'],['checksum']
Security,"app/"" ""fcgi://localhost:9000/"" enablereuse=on; More information can be found in FastCGI proxy docu. After restarting apache server one should be able to open address: http://apache_host_name/root.app/. There are many ways to configure user authentication in Apache. Example of digest auth for FastCGI server:; <Location ""/root.app/"">; AuthType Digest; AuthName ""root""; AuthDigestDomain ""/root.app/"" ""root""; AuthDigestProvider file; AuthUserFile ""/srv/auth/auth.txt""; Require valid-user; </Location>; 1.7.2 Configure fastcgi with lighttpd; An example of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:11504,authoriz,authorization,11504,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['authoriz'],['authorization']
Security,"apper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex). CCTreeNode* GetRoot(); return the root node for this tree. { return fRoot; }. » Last changed: Mon Jul 4 15:33:59 2011 » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__CCTreeWrapper.html:1617,validat,validationSample,1617,root/html530/TMVA__CCTreeWrapper.html,https://root.cern,https://root.cern/root/html530/TMVA__CCTreeWrapper.html,4,['validat'],"['validation', 'validationSample']"
Security,"apper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex). CCTreeNode* GetRoot(); return the root node for this tree. { return fRoot; }. » Last changed: Thu Nov 3 20:19:24 2011 » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__CCTreeWrapper.html:1617,validat,validationSample,1617,root/html532/TMVA__CCTreeWrapper.html,https://root.cern,https://root.cern/root/html532/TMVA__CCTreeWrapper.html,4,['validat'],"['validation', 'validationSample']"
Security,"apper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex). CCTreeNode* GetRoot(); return the root node for this tree. { return fRoot; }. » Last changed: Tue Sep 8 17:04:41 2015 » Last generated: 2015-09-08 17:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__CCTreeWrapper.html:1617,validat,validationSample,1617,root/html534/TMVA__CCTreeWrapper.html,https://root.cern,https://root.cern/root/html534/TMVA__CCTreeWrapper.html,4,['validat'],"['validation', 'validationSample']"
Security,"apper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex). CCTreeNode* GetRoot(); return the root node for this tree. { return fRoot; }. » Last changed: Tue Sep 8 17:45:50 2015 » Last generated: 2015-09-08 17:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__CCTreeWrapper.html:1625,validat,validationSample,1625,root/html604/TMVA__CCTreeWrapper.html,https://root.cern,https://root.cern/root/html604/TMVA__CCTreeWrapper.html,4,['validat'],"['validation', 'validationSample']"
Security,"application/json"" and also assigns content. ;  ; void SetMethod (const char *method);  set request method kind like GET or POST ;  ; void SetPathAndFileName (const char *fullpath);  Set complete path of requested http element. ;  ; void SetPathName (const char *p);  set request path name ;  ; void SetPostData (std::string &&data);  Set data, which is posted with the request. ;  ; void SetPostData (void *data, Long_t length, Bool_t make_copy=kFALSE);  Set data, posted with the request. ;  ; void SetPostponed ();  mark as postponed - reply will not be send to client immediately ;  ; void SetQuery (const char *q);  set request query ;  ; void SetRequestHeader (const char *h);  set full set of request header ;  ; void SetText ();  Set content type as ""text/plain"". ;  ; void SetTextContent (std::string &&txt);  Set content type as ""text/plain"" and also assigns content. ;  ; void SetTopName (const char *topname);  set engine-specific top-name ;  ; void SetUserName (const char *n);  set name of authenticated user ;  ; void SetWSId (UInt_t id);  set web-socket id ;  ; void SetXml ();  Set content type as ""text/xml"". ;  ; void SetXmlContent (std::string &&xml);  Set content type as ""text/xml"" and also assigns content. ;  ; void SetZipping (Int_t mode=kZipLarge);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpCallArg.html:6327,authenticat,authenticated,6327,doc/master/classTHttpCallArg.html,https://root.cern,https://root.cern/doc/master/classTHttpCallArg.html,1,['authenticat'],['authenticated']
Security,"apsize). overridevirtual . Set the initial size of the map used to store object and class references during reading. ; The default size is TBufferFile::kMapSize. Increasing the default has the benefit that when reading many small objects the map does not need to be resized too often (the system is always dynamic, even with the default everything will work, only the initial resizing will cost some time). This method can only be called directly after the creation of the TBuffer, before any reading is done. Globally this option can be changed using SetGlobalReadParam(). ; Implements TBuffer.; Definition at line 97 of file TBufferIO.cxx. ◆ SetWriteParam(). void TBufferIO::SetWriteParam ; (; Int_t ; mapsize). overridevirtual . Set the initial size of the hashtable used to store object and class references during writing. ; The default size is TBufferFile::kMapSize. Increasing the default has the benefit that when writing many small objects the hashtable does not get too many collisions (the system is always dynamic, even with the default everything will work, only a large number of collisions will cost performance). For optimal performance hashsize should always be a prime. This method can only be called directly after the creation of the TBuffer, before any writing is done. Globally this option can be changed using SetGlobalWriteParam(). ; Implements TBuffer.; Definition at line 117 of file TBufferIO.cxx. ◆ Streamer(). void TBufferIO::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TBuffer.; Reimplemented in TBufferJSON, TBufferText, TBufferSQL2, TBufferXML, TMessage, and TBufferSQL. ◆ StreamerNVirtual(). void TBufferIO::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 120 of file TBufferIO.h. ◆ TagStreamerInfo(). void TBufferIO::TagStreamerInfo ; (; TVirtualStreamerInfo * ; info). overridevirtual . Mark the classindex of the current file as using this TStreamerInfo. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferIO.html:40622,hash,hashtable,40622,doc/master/classTBufferIO.html,https://root.cern,https://root.cern/doc/master/classTBufferIO.html,1,['hash'],['hashtable']
Security,"ar *cs)Definition TString.h:673; TString::SwapTString & Swap(TString &other)Definition TString.h:716; TString::IsBinBool_t IsBin() constReturns true if all characters in string are binary digits (0,1).Definition TString.cxx:1908; TString::UnLinkvoid UnLink() constDefinition TString.h:263; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::BaseConvertstatic TString BaseConvert(const TString &s_in, Int_t base_in, Int_t base_out)Converts string from base base_in to base base_out.Definition TString.cxx:2194; TString::ULLtoastatic TString ULLtoa(ULong64_t value, Int_t base)Converts a ULong64_t (twice the range of an Long64_t) to a TString with respect to the base specified...Definition TString.cxx:2171; TString::CountCharInt_t CountChar(Int_t c) constReturn number of times character c occurs in the string.Definition TString.cxx:515; TString::operator==friend Bool_t operator==(const TString &s1, const TString &s2)Definition TString.h:767; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::WriteStringstatic void WriteString(TBuffer &b, const TString *a)Write TString object to buffer.Definition TString.cxx:1428; TString::FillBuffervirtual void FillBuffer(char *&buffer) constCopy string into I/O buffer.Definition TString.cxx:1310; TString::operator=TString & operator=(char s)Assign character c to TString.Definition TString.cxx:301; TString::ReadFilestd::istream & ReadFile(std::istream &str)Replace string with the contents of strm, stopping at an EOF.Definition Stringio.cxx:29; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::InitialCapacitystatic Ssiz_t InitialCapacity(Ssiz_t ic=15)Set default initial capacity for all TStrings. Default is 15.Definition TString.cxx:1593; TString::GetShortPointerchar * GetShortPointer()Definition TString.h:254; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::IsInBaseNBool_t IsInBaseN(Int_t base) constRet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8h_source.html:50758,hash,hash,50758,doc/master/TString_8h_source.html,https://root.cern,https://root.cern/doc/master/TString_8h_source.html,1,['hash'],['hash']
Security,"ar *details, const char *token, TDatime expdate=kROOTTZERO, void *ctx=nullptr, Int_t key=-1);  Create a Security context and add it to local list Return pointer to it to be stored in TAuthenticate. ;  ; void DeActivate ();  ; TList * Established () const;  ; const char * GetDetails (Int_t level);  Return authentication details for specified level or """" if the specified level does not exist for this host. ;  ; const char * GetDetailsByIdx (Int_t idx) const;  ; Int_t GetFailure (Int_t idx) const;  ; const char * GetHost () const;  ; Int_t GetMethod (Int_t idx) const;  ; Int_t GetServer () const;  ; Int_t GetSuccess (Int_t idx) const;  ; const char * GetUser () const;  ; Bool_t HasMethod (Int_t level, Int_t *pos=nullptr);  Return kTRUE if method 'level' is in the list. ;  ; TClass * IsA () const override;  ; Bool_t IsActive () const;  ; Int_t NumMethods () const;  ; void Print (Option_t *option="""") const override;  Print object content. ;  ; void PrintEstablished () const;  Print info about established authentication vis-a-vis of this Host. ;  ; void RemoveMethod (Int_t level);  Remove method 'meth' from the list, if there ... ;  ; void ReOrder (Int_t nmet, Int_t *fmet);  Reorder nmet methods according fmet[nmet]. ;  ; void Reset ();  Remove all methods, leaving Active status and list of associted TSceContexts unchanged. ;  ; void SetDetails (Int_t level, const char *details);  Set authentication details for specified level. ;  ; void SetEstablished (TList *nl);  ; void SetFirst (Int_t level);  Set 'method' to be the first used (if in the list ...). ;  ; void SetHost (const char *host);  ; void SetLast (Int_t level);  Set 'method' to be the last used (if in the list ...). ;  ; void SetServer (Int_t server);  ; void SetUser (const char *user);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Update (THostAuth *ha);  Update info with the one in ha Remaining methods, if an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHostAuth.html:2868,authenticat,authentication,2868,doc/master/classTHostAuth.html,https://root.cern,https://root.cern/doc/master/classTHostAuth.html,1,['authenticat'],['authentication']
Security,"ar *selExpr=nullptr, const char *wgtVarName=nullptr);  ;  RooTreeDataStore (RooStringView name, RooStringView title, const RooArgSet &vars, TTree &t, const char *selExpr=nullptr, const char *wgtVarName=nullptr);  ;  RooTreeDataStore (RooStringView name, RooStringView title, RooAbsDataStore &tds, const RooArgSet &vars, const RooFormulaVar *cutVar, const char *cutRange, Int_t nStart, Int_t nStop, const char *wgtVarName=nullptr);  ;  RooTreeDataStore (TTree *t, const RooArgSet &vars, const char *wgtVarName=nullptr);  Constructor to facilitate reading of legacy RooDataSets. ;  ;  ~RooTreeDataStore () override;  Destructor. ;  ; RooAbsArg * addColumn (RooAbsArg &var, bool adjustRange=true) override;  Add a new column to the data set which holds the pre-calculated values of 'newVar'. ;  ; void append (RooAbsDataStore &other) override;  ; void attachBuffers (const RooArgSet &extObs) override;  ; void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false) override;  Cache given RooAbsArgs with this tree: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ;  ; const RooAbsArg * cacheOwner () override;  ; bool changeObservableName (const char *from, const char *to) override;  Change name of internal observable named 'from' into 'to'. ;  ; void checkInit () const override;  ; RooAbsDataStore * clone (const char *newname=nullptr) const override;  ; RooAbsDataStore * clone (const RooArgSet &vars, const char *newname=nullptr) const override;  ; void Draw (Option_t *option="""") override;  Default Draw method for all objects. ;  ; Int_t Fill ();  Interface function to TTree::Fill. ;  ; Int_t fill () override;  Interface function to TTree::Fill. ;  ; virtual const RooArgSet * get () const;  ; const RooArgSet * get (Int_t index) const override;  Load the n-th data point (n='index') in memory and return a pointer to the internal RooArgSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:3243,access,access,3243,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['access'],['access']
Security,"ar xz, Scalar yx, Scalar yy, Scalar yz, Scalar zx, Scalar zy, Scalar zz);  Raw constructor from nine Scalar components (without any checking) ;  ; template<class ForeignVector > ; void GetComponents (ForeignVector &v1, ForeignVector &v2, ForeignVector &v3) const;  Get components into three vectors which will be the (orthonormal) columns of the rotation matrix. ;  ; template<class IT > ; void GetComponents (IT begin) const;  Get the 9 matrix components into data specified by an iterator begin. ;  ; template<class IT > ; void GetComponents (IT begin, IT end) const;  Get the 9 matrix components into data specified by an iterator begin and another to the end of the desired data (9 past start). ;  ; void GetComponents (Scalar &xx, Scalar &xy, Scalar &xz, Scalar &yx, Scalar &yy, Scalar &yz, Scalar &zx, Scalar &zy, Scalar &zz) const;  Get the nine components into nine scalars. ;  ; template<class ForeignMatrix > ; void GetRotationMatrix (ForeignMatrix &m) const;  Get components into a linear algebra matrix of size at least 3x3, which must support operator()(i,j) for write access to elements (0,0) thru (2,2). ;  ; Rotation3D Inverse () const;  Return inverse of a rotation. ;  ; void Invert ();  Invert a rotation in place. ;  ; bool operator!= (const Rotation3D &rhs) const;  ; template<class CoordSystem , class U > ; DisplacementVector3D< CoordSystem, U > operator() (const DisplacementVector3D< CoordSystem, U > &v) const;  Rotation operation on a displacement vector in any coordinate system. ;  ; template<class ForeignVector > ; ForeignVector operator() (const ForeignVector &v) const;  Rotation operation on an arbitrary vector v. ;  ; template<class CoordSystem > ; LorentzVector< CoordSystem > operator() (const LorentzVector< CoordSystem > &v) const;  Rotation operation on a Lorentz vector in any spatial coordinate system. ;  ; template<class CoordSystem , class U > ; PositionVector3D< CoordSystem, U > operator() (const PositionVector3D< CoordSystem, U > &v) const;  Rotation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Rotation3D.html:3698,access,access,3698,doc/master/classROOT_1_1Math_1_1Rotation3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Rotation3D.html,1,['access'],['access']
Security,"ar* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfGridtype of GRID (AliEn, Globus, ...); TStringfGridUrlthe GRID url used to create the grid connection; TStringfHostGRID portal to which we are connected; TStringfOptionsoptions specified; Int_tfPortport to which we are connected; TStringfPwuser passwd; TStringfUseruser name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGrid * Connect(const char* grid, const char* uid = 0, const char* pw = 0, const char* options = 0); The grid should be of the form: <grid>://<host>[:<port>],; e.g.: alien://alice.cern.ch, globus://glsrv1.cern.ch, ...; The uid is the username and pw the password that should be used for; the connection. Depending on the <grid> the shared library (plugin); for the selected system will be loaded. When the connection could not; be opened 0 is returned. For AliEn the supported options are:; -domain=<domain name>; -debug=<debug level from 1 to 10>; Example: ""-domain=cern.ch -debug=5"". TGrid(); { }. virtual ~TGrid(); { }. const char * GridUrl() const; { return fGridUrl; }. const char * GetGrid() const; { return fGrid; }. const char * GetHost() const; { return fHost; }. const char * GetUser() const; { return fUser; }. const char * GetPw() const; { return fPw; }. const char * GetOptions() const; { return fOptions; }. Int_t GetPort() const; { return fPort; }. Bool_t IsConnected() const; { return fPort == -1 ? kFALSE : kTRUE; }. void Shell(); { MayNotUse(""Shell""); }. void Stdout(); { MayNotUse(""Stdout""); }. void Stderr(); { MayNotUse(""Stderr""); }. TGridResult * Command(const char* , Bool_t = kFALSE, UInt_t = 2); { MayNotUse(""Command""); return 0; }. TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGrid.html:7557,password,password,7557,root/html528/TGrid.html,https://root.cern,https://root.cern/root/html528/TGrid.html,4,['password'],['password']
Security,"ar, RooRealIntegral, and RooRealVar.; Definition at line 453 of file RooAbsReal.cxx. ◆ printValue(). void RooAbsReal::printValue ; (; std::ostream & ; os); const. overridevirtual . Print object value. ; Reimplemented from RooPrintable.; Reimplemented in RooRealVar.; Definition at line 443 of file RooAbsReal.cxx. ◆ readFromStream(). bool RooAbsReal::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from stream (dummy for now) ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, RooErrorVar, RooFormulaVar, RooGenericPdf, RooLinearVar, and RooRealVar.; Definition at line 424 of file RooAbsReal.cxx. ◆ redirectServersHook(). bool RooAbsReal::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). overrideprotectedvirtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented from RooAbsArg.; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooAbsTestStatistic, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, and RooProjectedPdf.; Definition at line 4550 of file RooAbsReal.cxx. ◆ selectComp(). void RooAbsReal::selectComp ; (; bool ; flag). inline . Definition at line 384 of file RooAbsReal.h. ◆ selectNormalization(). void RooAbsReal::selectNormalization ; (; const RooArgSet * ; depSet = nullptr, . bool ; force = false . ). protectedvirtual . Interface function to force use of a given set of observables to interpret function value. ; Needed f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:144830,inject,inject,144830,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['inject'],['inject']
Security,"ar, RooRealIntegral, and RooRealVar.; Definition at line 455 of file RooAbsReal.cxx. ◆ printValue(). void RooAbsReal::printValue ; (; std::ostream & ; os); const. overridevirtual . Print object value. ; Reimplemented from RooPrintable.; Reimplemented in RooRealVar.; Definition at line 445 of file RooAbsReal.cxx. ◆ readFromStream(). bool RooAbsReal::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from stream (dummy for now) ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, RooErrorVar, RooFormulaVar, RooGenericPdf, RooLinearVar, and RooRealVar.; Definition at line 426 of file RooAbsReal.cxx. ◆ redirectServersHook(). bool RooAbsReal::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). overrideprotectedvirtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented from RooAbsArg.; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, RooAbsTestStatistic, and RooProjectedPdf.; Definition at line 4474 of file RooAbsReal.cxx. ◆ selectComp(). void RooAbsReal::selectComp ; (; bool ; flag). inline . Definition at line 377 of file RooAbsReal.h. ◆ selectNormalization(). void RooAbsReal::selectNormalization ; (; const RooArgSet * ; depSet = nullptr, . bool ; force = false . ). protectedvirtual . Interface function to force use of a given set of observables to interpret function value. ; Needed f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:142993,inject,inject,142993,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['inject'],['inject']
Security,"arFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();; ...; e#define e(i)Definition RSha256.hxx:103; TLinearFitter::Evalvirtual Int_t Eval()Perform the fit and evaluate the parameters Returns 0 if the fit is ok, 1 if there are errors.Definition TLinearFitter.cxx:874; TLinearFitter::AssignDatavirtual void AssignData(Int_t npoints, Int_t xncols, Double_t *x, Double_t *y, Double_t *e=nullptr)This function is to use when you already have all the data in arrays and don't want to copy them into...Definition TLinearFitter.cxx:583; 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; –GetParameters, GetCovarianceMatrix, etc –the t-values of parameters and their significance can be reached by GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points which do not appear to follow the characteristic distribution of the rest of the data. These may reflect genuine properties of the underlying phenomenon(variable), or be due to measurement errors or anomalies which shouldn't be modelled. (StatSoft electronic textbook); Even a single gross outlier can greatly influence the results of least- squares fitting procedure, and in this case use of robust(resistant) methods is recommended.; The method implemented here is based on the article and algorithm: ""Computing LTS Regression for Large Data Sets"" by P.J.Rousseeuw and Katrien Van Driessen The idea of the method is to find the fitting coefficients for a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearFitter.html:6363,access,access,6363,doc/master/classTLinearFitter.html,https://root.cern,https://root.cern/doc/master/classTLinearFitter.html,1,['access'],['access']
Security,"aram=(""p0"", ""c,d"")). Definition at line 38 of file RooSimWSTool.h. Classes; class  BuildConfig;  ; class  MultiBuildConfig;  ; class  ObjBuildConfig;  ; class  ObjSplitRule;  ; class  SplitRule;  . Public Member Functions;  RooSimWSTool (RooWorkspace &ws);  Constructor of SimWSTool on given workspace. ;  ;  ~RooSimWSTool ();  Destructor. ;  ; RooSimultaneous * build (const char *simPdfName, BuildConfig &bc, bool verbose=true);  Build a RooSimultaneous PDF with name simPdfName from cloning specializations of protytpe PDF protoPdfName. ;  ; RooSimultaneous * build (const char *simPdfName, const char *protoPdfName, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Build a RooSimultaneous PDF with name simPdfName from cloning specializations of protytpe PDF protoPdfName. ;  . Protected Member Functions;  RooSimWSTool (const RooSimWSTool &);  ; RooSimultaneous * executeBuild (const char *simPdfName, ObjBuildConfig &obc, bool verbose=true);  Internal build driver from validation ObjBuildConfig. ;  ; std::string makeSplitName (const RooArgSet &splitCatSet);  Construct name of composite split. ;  ; std::unique_ptr< ObjBuildConfig > validateConfig (BuildConfig &bc);  Validate build configuration. ;  . Protected Attributes; RooWorkspace * _ws;  . #include <RooSimWSTool.h>; Constructor & Destructor Documentation. ◆ RooSimWSTool() [1/2]. RooSimWSTool::RooSimWSTool ; (; RooWorkspace & ; ws). Constructor of SimWSTool on given workspace. ; All input is taken from the workspace All output is stored in the workspace ; Definition at line 146 of file RooSimWSTool.cxx. ◆ ~RooSimWSTool(). RooSimWSTool::~RooSimWSTool ; (; ). Destructor. ; Definition at line 155 of file RooSimWSTool.cxx. ◆ RooSimWSTool() [2/2]. RooSimWSTool::RooSimWSTool ; (; const RooSimWSTool & ; ). protected . Member Function Documentation. ◆ build() [1/2]. RooSimultaneous * RooSimWSTool::build ; (; const char * ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimWSTool.html:5551,validat,validation,5551,doc/master/classRooSimWSTool.html,https://root.cern,https://root.cern/doc/master/classRooSimWSTool.html,1,['validat'],['validation']
Security,"arameters:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. # ext. || name || type || value || error +/-. 0 || x || free ||-1.821e-05 || 2; 1 || y || free ||-1.208e-05 || 2.236; 2 || z || free || 6.224e-06 || 2.449; 3 || w || free ||-3.047e-05 || 1. MnUserCovariance:. 4 1 2 2.70022e-18; 1 5 3 1.87754e-17; 2 3 6 2.29467e-17; 2.70022e-18 1.87754e-17 2.29467e-17 1. MnUserCovariance parameter correlations:. 1 0.223607 0.408248 1.35011e-18; 0.223607 1 0.547723 8.39663e-18; 0.408248 0.547723 1 9.36796e-18; 1.35011e-18 8.39663e-18 9.36796e-18 1. MnGlobalCorrelationCoeff:. 0.408248; 0.547723; 0.621261; 0; 3.3 CVS code repository; How to check out (–in) code from the CVS code repository is described at the M homepage @bib-C++MINUIT. To get the source code from the CVS repository one needs to do:; Kerberos IV authorization:; $ setenv CVSROOT :kserver:SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs co MathLibs/Minuit; Anonymous read-only access (if it’s enabled by the librarian, see details):; $ setenv CVSROOT :pserver:anonymous@SEAL.cvs.cern.ch:/cvs/SEAL. $ cvs login; (Logging in to :pserver:anonymous@seal.cvs.cern.ch:2401/cvs/SEAL) CVS password:cvs; $ cvs co MathLibs/Minuit; (If you want to check out a tagged version SEAL_x_x_x of MINUIT, then do; $ cvs co -r SEAL\_x\_x\_x MathLibs/Minuit ); 3.4 Create a tar.gz from CVS; Once the sources are checked out from the CVS code repository,. change to the directory:; $ cd MathLibs/Minuit; run autogen:; $ ./autogen; create a new directory:; $ cd ..; $ mkdir Minuit-BUILD; $ cd Minuit-BUILD/; run configure:; $ ../Minuit/configure; create the tar.gz:; $ make dist. This will create a Minuit-x.x.x.tar.gz which can be distributed and used as described above.; 3.5 M versions; The version numbers of M follow the release numbers of the SEAL project @bib-SEAL at CERN @bib-CERN.; 3.5.1 From to; The program is entirely written in standard portable . M does not depend on any external library. In its minimal usage ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:29471,access,access,29471,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['access'],['access']
Security,"arationBase * ; qualityIndex . ). constructor ; Definition at line 104 of file CCTreeWrapper.cxx. ◆ ~CCTreeWrapper(). TMVA::CCTreeWrapper::~CCTreeWrapper ; (; ). destructor ; Definition at line 116 of file CCTreeWrapper.cxx. Member Function Documentation. ◆ CheckEvent(). Double_t TMVA::CCTreeWrapper::CheckEvent ; (; const TMVA::Event & ; e, . Bool_t ; useYesNoLeaf = false . ). return the decision tree output for an event ; Definition at line 226 of file CCTreeWrapper.cxx. ◆ GetRoot(). CCTreeNode * TMVA::CCTreeWrapper::GetRoot ; (; ). inline . Definition at line 148 of file CCTreeWrapper.h. ◆ InitTree(). void TMVA::CCTreeWrapper::InitTree ; (; CCTreeNode * ; t). initialize the node t and all its descendants ; Definition at line 123 of file CCTreeWrapper.cxx. ◆ PruneNode(). void TMVA::CCTreeWrapper::PruneNode ; (; CCTreeNode * ; t). remove the branch rooted at node t ; Definition at line 160 of file CCTreeWrapper.cxx. ◆ TestTreeQuality() [1/2]. Double_t TMVA::CCTreeWrapper::TestTreeQuality ; (; const DataSet * ; validationSample). return the misclassification rate of a pruned tree for a validation event sample using the DataSet ; Definition at line 203 of file CCTreeWrapper.cxx. ◆ TestTreeQuality() [2/2]. Double_t TMVA::CCTreeWrapper::TestTreeQuality ; (; const EventList * ; validationSample). return the misclassification rate of a pruned tree for a validation event sample using an EventList ; Definition at line 183 of file CCTreeWrapper.cxx. Member Data Documentation. ◆ fDTParent. DecisionTree* TMVA::CCTreeWrapper::fDTParent. private . ! pointer to underlying DecisionTree ; Definition at line 151 of file CCTreeWrapper.h. ◆ fQualityIndex. SeparationBase* TMVA::CCTreeWrapper::fQualityIndex. private . ! pointer to the used quality index calculator ; Definition at line 150 of file CCTreeWrapper.h. ◆ fRoot. CCTreeNode* TMVA::CCTreeWrapper::fRoot. private . ! the root node of the (wrapped) decision Tree ; Definition at line 152 of file CCTreeWrapper.h. Libraries for TMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CCTreeWrapper.html:2790,validat,validationSample,2790,doc/master/classTMVA_1_1CCTreeWrapper.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CCTreeWrapper.html,1,['validat'],['validationSample']
Security,"ard_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  CTFutureImpl;  CTRangeStaticCastTRangeStaticCast is an adaptater class that allows the typed iteration through a TCollection ;  ►CTSchemaRuleSet;  CTMatches;  ►CTStatusBitsChecker;  CRegistry;  CTTypedIterTTypedIter is a typed version of TIter ;  ►NExecutorUtilsThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CTArgsMenuItem;  CTCheckedMenuItem;  CTHistBinIterIterates over the bins of a THist or THistImpl ;  CTHistBinPtrPoints to a histogram bin (or actually a THistBinRef) ;  CTHistBinRefRepresents a bin reference ;  CTHistBinStatConst view on a bin's statistical data ;  CTHistDataA THistImplBase's data, provides accessors to all its statistics ;  CTHistImpl;  CTHistImplBaseInterface class for THistImpl ;  CTHistImplPrecisionAgnosticBaseBase class for THistImplBase that abstracts out the histogram's PRECISION ;  CTMenuArgument;  CTMenuItemClass contains info for producing menu item on the JS side ;  ►NHist;  CTCoordArray;  ►NInternal;  CAxisConfigToTypeConverts a TAxisConfig of whatever kind to the corresponding TAxisBase-derived object ;  CAxisConfigToType< TAxisConfig::kEquidistant >;  CAxisConfigToType< TAxisConfig::kGrow >;  CAxisConfigToType< TAxisConfig::kIrregular >;  CAxisConfigToType< TAxisConfig::kLabels >;  CTDirectoryEntry;  CTFillBinCoordFill coord with low bin edge or center or high bin edge of all axes ;  CTFillBinCoord<-1, COORD, AXES >;  CTFillIterRangeFill range with begin() and end() of all axes, including under/overflow as specified by over ;  CTFillIterRange<-1, AXES >;  CTGetBinCount;  CTGetBinCount< 0, AXES >;  CTGetBinIndex;  CTGetBinIndex<-1, HISTIMPL, AXES, GROW >;  CTHistB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:16148,access,accessors,16148,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['access'],['accessors']
Security,"are emitted by objects when they change their state in a way that may be interesting to the outside world. This is all the object does to communicate. It does not know if anything is receiving the signal at the other end.; Slots can be used for receiving signals. A slot does not know if it has any signal(s) connected to it.; This is true information encapsulation, and ensures that the object can be used as a true software component.; Signals and slots can take any number of arguments of any type.; It is possible to connect as many signals as you want to a single slot, and a signal can be connected to as many slots as you desire.; It is possible to make a single connection from all objects of the same class.; 26.3 A Small Example; A minimal C++ class declaration might read:; class A {; private:; Int_t fValue;; public:; A() { fValue = 0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t);; };; A small ROOT interpreted class might read:; class A {; RQ_OBJECT(""A""); private:; Int_t fValue;; public:; A() { fValue = 0; }; Int_t GetValue() const { return fValue; }; void SetValue(Int_t); //*SIGNAL*; };; This class has the same internal state, and public methods to access the state, but in addition it has support for component programming using signals. This class can tell the outside world that its state has changed by emitting a signal, SetValue(Int_t).; Here is a possible implementation of A::SetValue():; void A::SetValue(Int_t v); {; if (v != fValue) {; fValue = v;; Emit(""SetValue(Int_t)"", v);; }; }; The line Emit(""SetValue(Int_t)"", v) emits the signal SetValue(Int_t) with argument v from the object. As you can see, you emit a signal by using Emit(""full_method_name"",arguments).; Here is one of the ways to connect two of these objects together:; A *a = new A();; A *b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; b->SetValue(11);; a->SetValue(79);; b->GetValue(); // this would now be 79, why?; The statement a->Connect(""SetValue(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1233631,access,access,1233631,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"arget; 113 ; 114Bool_t TMVA::MethodDNN::HasAnalysisType(Types::EAnalysisType type,; 115 UInt_t numberClasses,; 116 UInt_t /*numberTargets*/ ); 117{; 118 if (type == Types::kClassification && numberClasses == 2 ) return kTRUE;; 119 if (type == Types::kMulticlass ) return kTRUE;; 120 if (type == Types::kRegression ) return kTRUE;; 121 ; 122 return kFALSE;; 123}; 124 ; 125////////////////////////////////////////////////////////////////////////////////; 126/// default initializations; 127 ; 128void TMVA::MethodDNN::Init() {; 129 Log() << kWARNING; 130 << ""MethodDNN is deprecated and it will be removed in future ROOT version. ""; 131 ""Please use MethodDL ( TMVA::kDL)""; 132 << Endl;; 133 ; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Options to be set in the option string:; 138///; 139/// - LearningRate <float> DNN learning rate parameter.; 140/// - DecayRate <float> Decay rate for learning parameter.; 141/// - TestRate <int> Period of validation set error computation.; 142/// - BatchSize <int> Number of event per batch.; 143///; 144/// - ValidationSize <string> How many events to use for validation. ""0.2""; 145/// or ""20%"" indicates that a fifth of the; 146/// training data should be used. ""100""; 147/// indicates that 100 events should be used.; 148 ; 149void TMVA::MethodDNN::DeclareOptions(); 150{; 151 ; 152 DeclareOptionRef(fLayoutString=""SOFTSIGN|(N+100)*2,LINEAR"",; 153 ""Layout"",; 154 ""Layout of the network."");; 155 ; 156 DeclareOptionRef(fValidationSize = ""20%"", ""ValidationSize"",; 157 ""Part of the training data to use for ""; 158 ""validation. Specify as 0.2 or 20% to use a ""; 159 ""fifth of the data set as validation set. ""; 160 ""Specify as 100 to use exactly 100 events. ""; 161 ""(Default: 20%)"");; 162 ; 163 DeclareOptionRef(fErrorStrategy=""CROSSENTROPY"",; 164 ""ErrorStrategy"",; 165 ""Loss function: Mean squared error (regression)""; 166 "" or cross entropy (binary classification)."");; 167 AddPreDefVal(TString(""CROSSEN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:4841,validat,validation,4841,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['validat'],['validation']
Security,"argetDefinition TGWin32VirtualXProxy.cxx:247; For example to set HepMC::GenVertex::m_event to not owned the object it is pointing to: HepMC::GenVertex m_event attributes=NotOwner; Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers among: Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. . Definition at line 1890 of file TClass.cxx. ◆ AdoptMemberStreamer(). void TClass::AdoptMemberStreamer ; (; const char * ; name, . TMemberStreamer * ; strm . ). Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name. ; Definition at line 6703 of file TClass.cxx. ◆ AdoptReferenceProxy(). void TClass::AdoptReferenceProxy ; (; TVirtualRefProxy * ; proxy). Adopt the Reference proxy pointer to indicate that this class represents a reference. ; When a new proxy is adopted, the old one is deleted. ; Definition at line 6685 of file TClass.cxx. ◆ AdoptSchemaRules(). void TClass::AdoptSchemaRules ; (; ROOT::Detail::TSchemaRuleSet * ; rules). Adopt a new set of Data Model Evolution rules. ; Definition at line 1920 of file TClass.cxx. ◆ AdoptStreamer(). void TClass::AdoptStreamer ; (; TClassStreamer * ; str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:56108,checksum,checksum,56108,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['checksum'],"['checksum', 'checksums']"
Security,"argetDefinition TGWin32VirtualXProxy.cxx:247; For example to set HepMC::GenVertex::m_event to not owned the object it is pointing to: HepMC::GenVertex m_event attributes=NotOwner; Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers among: Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. . Definition at line 1957 of file TClass.cxx. ◆ AdoptMemberStreamer(). void TClass::AdoptMemberStreamer ; (; const char * ; name, . TMemberStreamer * ; strm . ). Adopt the TMemberStreamer pointer to by p and use it to Stream non basic member name. ; Definition at line 6770 of file TClass.cxx. ◆ AdoptReferenceProxy(). void TClass::AdoptReferenceProxy ; (; TVirtualRefProxy * ; proxy). Adopt the Reference proxy pointer to indicate that this class represents a reference. ; When a new proxy is adopted, the old one is deleted. ; Definition at line 6752 of file TClass.cxx. ◆ AdoptSchemaRules(). void TClass::AdoptSchemaRules ; (; ROOT::Detail::TSchemaRuleSet * ; rules). Adopt a new set of Data Model Evolution rules. ; Definition at line 1987 of file TClass.cxx. ◆ AdoptStreamer(). void TClass::AdoptStreamer ; (; TClassStreamer * ; str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:56109,checksum,checksum,56109,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,2,['checksum'],"['checksum', 'checksums']"
Security,"ariable, UInt_t *variableMap, UInt_t &nVars);  ; virtual DecisionTreeNode * GetRoot () const;  ; Double_t GetSumWeights (const EventConstList *validationSample) const;  calculate the normalization factor for a pruning validation sample ;  ; Int_t GetTreeID ();  ; std::vector< Double_t > GetVariableImportance ();  Return the relative variable importance, normalized to all variables together having the importance 1. ;  ; Double_t GetVariableImportance (UInt_t ivar);  returns the relative importance of variable ivar ;  ; virtual TClass * IsA () const;  ; void PruneNode (TMVA::DecisionTreeNode *node);  prune away the subtree below the node ;  ; void PruneNodeInPlace (TMVA::DecisionTreeNode *node);  prune a node temporarily (without actually deleting its descendants which allows testing the pruned tree quality for many different pruning stages without ""touching"" the tree. ;  ; Double_t PruneTree (const EventConstList *validationSample=nullptr);  prune (get rid of internal nodes) the Decision tree to avoid overtraining several different pruning methods can be applied as selected by the variable ""fPruneMethod"". ;  ; void SetAnalysisType (Types::EAnalysisType t);  ; void SetMinLinCorrForFisher (Double_t min);  ; void SetNodePurityLimit (Double_t p);  ; void SetNVars (Int_t n);  ; void SetParentTreeInNodes (Node *n=nullptr);  descend a tree to find all its leaf nodes, fill max depth reached in the tree at the same time. ;  ; void SetPruneMethod (EPruneMethod m=kCostComplexityPruning);  ; void SetPruneStrength (Double_t p);  ; void SetTreeID (Int_t treeID);  ; void SetUseExclusiveVars (Bool_t t=kTRUE);  ; void SetUseFisherCuts (Bool_t t=kTRUE);  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Double_t TestPrunedTreeQuality (const DecisionTreeNode *dt=nullptr, Int_t mode=0) const;  return the misclassification rate of a pruned tree a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at any node, hence t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:6436,validat,validationSample,6436,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['validat'],['validationSample']
Security,"arning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static void AuthError (const char *where, Int_t error);  Print error string depending on error code. ;  ; static Bool_t CheckProofAuth (Int_t cSec, TString &det);  Check if the authentication method can be attempted for the client. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t DecodeRSAPublic (const char *rsapubexport, R__rsa_NUMBER &n, R__rsa_NUMBER &d, char **rsassl=nullptr);  Store RSA public keys from export string rsaPubExport. ;  ; static TList * GetAuthInfo ();  Static method returning the list with authentication details. ;  ; static const char * GetAuthMethod (Int_t idx);  Static method returning the method corresponding to idx. ;  ; static Int_t GetAuthMethodIdx (const char *meth);  Static method returning the method index (which can be used to find the method in GetAuthMethod()). ;  ; static Bool_t GetAuthReUse ();  Static method returning the authentication reuse settings. ;  ; static Int_t GetClientProtocol ();  Static method returning supported client protocol. ;  ; static char * GetDefaultDetails (Int_t method, Int_t opt, const char *user);  Determine default authentication details for method 'sec' and user 'usr'. ;  ; static const char * GetDefaultUser ();  Static method returning the default user information. ;  ; static TDatime GetGlobalExpDate ();  Static method returning default expiring date for new validity contexts. ;  ; static Bool_t GetGlobalPwHash ();  Static method returning the global password hash flag. ;  ; static Bool_t GetGlobalSR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:10827,authenticat,authentication,10827,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"arning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TFileInfo&operator=(const TFileInfo&); voidParseInput(const char* in). Data Members; public:. enum EStatusBits { kStaged; kCorrupted; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TUrl*fCurrentUrl! current URL to access the file, points to URL; TMD5*fMD5-> md5 digest of the file; TList*fMetaDataListgeneric list of file meta data object(s); Long64_tfSizefile size; TUUID*fUUID-> uuid of the referenced file; TList*fUrlListlist of file URLs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileInfo(const char* url = 0, Long64_t size = -1, const char* uuid = 0, const char* md5 = 0, TObject* meta = 0); Constructor. TFileInfo(const TFileInfo& ); Copy constructor. ~TFileInfo(); Destructor. void ParseInput(const char* in); Parse the input line to extract init information from 'in'; the input; string is tokenized on ' '; the tokens can be prefixed by the following; keys:. url:<url1>,<url2>,... URLs for the file; stored in the order given; sz:<size> size of the file in bytes; md5:<md5_ascii> MD5 sum of the file in ASCII form; uuid:<uuid> UUID of the file. tree:<name>,<entries>,<first>,<last>; meta-information about a tree in the file; the; should be in the form <subdir>/tree-name;'entries' is; the number of entries in the tree; 'first' and 'last'; define the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileInfo.html:6221,access,access,6221,root/html528/TFileInfo.html,https://root.cern,https://root.cern/root/html528/TFileInfo.html,3,['access'],['access']
Security,"arr3[2]"");; 4249/// ~~~; 4250/// will draw the sum arr3 for the index 0 to 2 only if the; 4251/// actual_size_of_arr3 is greater or equal to 3.; 4252/// Note that the array in 'primary' is flattened/linearized thus using; 4253/// `Alt$` with multi-dimensional arrays of different dimensions in unlikely; 4254/// to yield the expected results. To visualize a bit more what elements; 4255/// would be matched by TTree::Draw, TTree::Scan can be used:; 4256/// ~~~ {.cpp}; 4257/// tree->Scan(""arr1:Alt$(arr2,0)"");; 4258/// ~~~; 4259/// will print on one line the value of arr1 and (arr2,0) that will be; 4260/// matched by; 4261/// ~~~ {.cpp}; 4262/// tree->Draw(""arr1-Alt$(arr2,0)"");; 4263/// ~~~; 4264/// The ternary operator is not directly supported in TTree::Draw however, to plot the; 4265/// equivalent of `var2<20 ? -99 : var1`, you can use:; 4266/// ~~~ {.cpp}; 4267/// tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");; 4268/// ~~~; 4269///; 4270/// ### Drawing a user function accessing the TTree data directly; 4271///; 4272/// If the formula contains a file name, TTree::MakeProxy will be used; 4273/// to load and execute this file. In particular it will draw the; 4274/// result of a function with the same name as the file. The function; 4275/// will be executed in a context where the name of the branches can; 4276/// be used as a C++ variable.; 4277///; 4278/// For example draw px using the file hsimple.root (generated by the; 4279/// hsimple.C tutorial), we need a file named hsimple.cxx:; 4280/// ~~~ {.cpp}; 4281/// double hsimple() {; 4282/// return px;; 4283/// }; 4284/// ~~~; 4285/// MakeProxy can then be used indirectly via the TTree::Draw interface; 4286/// as follow:; 4287/// ~~~ {.cpp}; 4288/// new TFile(""hsimple.root""); 4289/// ntuple->Draw(""hsimple.cxx"");; 4290/// ~~~; 4291/// A more complete example is available in the tutorials directory:; 4292/// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; 4293/// which reimplement the selector found in `",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:171780,access,accessing,171780,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['accessing']
Security,"ars_time0[0] from array expression vars_time0 of size 30; : Using variable vars_time1[0] from array expression vars_time1 of size 30; : Using variable vars_time2[0] from array expression vars_time2 of size 30; : Using variable vars_time3[0] from array expression vars_time3 of size 30; : Using variable vars_time4[0] from array expression vars_time4 of size 30; : Using variable vars_time5[0] from array expression vars_time5 of size 30; : Using variable vars_time6[0] from array expression vars_time6 of size 30; : Using variable vars_time7[0] from array expression vars_time7 of size 30; : Using variable vars_time8[0] from array expression vars_time8 of size 30; : Using variable vars_time9[0] from array expression vars_time9 of size 30; DataSetFactory : [dataset] : Number of events in input trees; : ; : ; : Number of training and testing events; : ---------------------------------------------------------------------------; : Signal -- training events : 1600; : Signal -- testing events : 400; : Signal -- training and testing events: 2000; : Background -- training events : 1600; : Background -- testing events : 400; : Background -- training and testing events: 2000; : ; Factory : ␛[1mTrain all methods␛[0m; Factory : Train method: TMVA_LSTM for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 10, 1, 30 ) Batch size = 100 Loss function = C; Layer 0 LSTM Layer: (NInput = 30, NState = 10, NTime = 10 ) Output = ( 100 , 10 , 10 ); Layer 1 RESHAPE Layer Input = ( 1 , 10 , 10 ) Output = ( 1 , 100 , 100 ) ; Layer 2 DENSE Layer: ( Input = 100 , Width = 64 ) Output = ( 1 , 100 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:15120,validat,validation,15120,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,2,['validat'],['validation']
Security,"arsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source info elements (copyright, last changed, author); static set<std::string>fgKeywordsC++ keywords. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDocParser(TClassDocOutput& docOutput, TClass* cl); Constructor called for parsing class sources. TDocParser(TDocOutput& docOutput); constructor called for parsing text files with Convert(). ~TDocParser(); destructor, checking whether all methods have been found for gDebug > 3. void AddClassMethodsRecursively(TBaseClass* bc); Add accessible (i.e. non-private) methods of base class bc; and its base classes' methods to methodNames.; If bc==0, we add fCurrentClass's methods (and also private functions). void AddClassDataMembersRecursively(TBaseClass* bc); Add data members of fCurrentClass and of bc to datamembers, recursively.; Real data members are in idx 0..2 (public, protected, private access),; enum constants in idx 3..5. void AnchorFromLine(const TString& line, TString& anchor); Create an anchor from the given line, by hashing it and; convertig the hash into a custom base64 string. void Convert(ostream& out, istream& in, const char* relpath, Bool_t isCode, Bool_t interpretDirectives); Parse text file ""in"", add links etc, and write output to ""out"".; If ""isCode"", ""in"" is assumed to be C++ code. void DecorateKeywords(ostream& out, const char* text); Expand keywords in text, writing to out. void DecorateKeywords(TString& text); Find keywords in line and create URLs around them. Escape characters with a; special meaning for HTML. Protect ""Begin_Html""/""End_Html"" pairs, and set the; parsing context. Evaluate sequences like a::b->c.; Skip regions where directives are active. void DecrementMethodCount(const char* name); reduce method count for method called name,; removing it from fMethodCounts once the count reaches 0. void DeleteDirectiveOutput() const; Delete output genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocParser.html:11468,access,access,11468,root/html528/TDocParser.html,https://root.cern,https://root.cern/root/html528/TDocParser.html,3,['access'],['access']
Security,"ary ROOT files. One should always remember that all I/O operations are asynchronous in JSROOT. Therefore promises are used to retrieve results when the I/O operation is completed. For example, reading an object from a file and displaying it will look like:; import { openFile, draw } from 'https://root.cern/js/latest/modules/main.mjs';; let filename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; console.log('drawing completed');; Here is running example and source code; 1.11.5 TTree API; Simple TTree::Draw operation can be performed with following code:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; draw(""drawing"", tree, ""px:py::pz>5"");; To get access to selected branches, one should use TSelector class:; import { openFile } from 'https://root.cern/js/latest/modules/io.mjs';; import { draw } from 'https://root.cern/js/latest/modules/draw.mjs';; import { TSelector, treeProcess } from 'https://root.cern/js/latest/modules/tree.mjs';. let file = await openFile(""https://root.cern/js/files/hsimple.root"");; let tree = await file.readObject(""ntuple;1"");; let selector = new TSelector();. selector.AddBranch(""px"");; selector.AddBranch(""py"");. let cnt = 0, sumpx = 0, sumpy = 0;. selector.Begin = function() {; // function called before reading of TTree starts; }. selector.Process = function() {; // function called for every entry; sumpx += this.tgtobj.px;; sumpy += this.tgtobj.py;; cnt++;; }. selector.Terminate = function(res) {; if (!res || (cnt === 0)) return;; let meanpx = sumpx/cnt, meanpy = sumpy/cnt;; console.log(`Results meanpx = ${meanpx} meanpy = ${meanpy}`);; }. await treeProcess(tree, selector);; Here is running example and source code; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:28931,access,access,28931,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['access'],['access']
Security,"ary dependencies have different consequences; depending on whether you try to build a binary, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22307,access,access,22307,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"as TF1Old in memory ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:9940,hash,hash,9940,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['hash'],['hash']
Security,"as TF1Old in memory ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Update ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html:5946,hash,hash,5946,doc/master/structROOT_1_1v5_1_1TF1Data.html,https://root.cern,https://root.cern/doc/master/structROOT_1_1v5_1_1TF1Data.html,2,['hash'],['hash']
Security,"as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArray would look like this:. #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>;  ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h"";  ; #include <vector>; #include <iostream>;  ; bool CheckValue(ROOT::TTreeReaderValueBase* value) {; if (value->GetSetupStatus() < 0) {; std::cerr << ""Error "" << value->GetSetupStatus(); << ""setting up reader for "" << value->GetBranchName() << '\n';; return false;; }; return true;; };  ;  ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);;  ; // Read a single float value in each tree entries:; TTreeReaderValue<float> weight(reader, ""event.weight"");; if (!CheckValue(weight)) return false;;  ; // Read a TriggerInfo object from the tree entries:; TTreeReaderValue<TriggerInfo> triggerInfo(reader, ""triggerInfo"");; if (!CheckValue(triggerInfo)) return false;;  ; // Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; if (!CheckValue(muons)) return false;;  ; // Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; if (!CheckValue(jetPt)) return false;;  ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; if (!CheckValue(taus)) return false;;  ;  ; // Now iterate through the TTree entries and fill a histogram.;  ; TH1* hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeReader.html:2736,access,access,2736,root/html602/TTreeReader.html,https://root.cern,https://root.cern/root/html602/TTreeReader.html,2,['access'],['access']
Security,"as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static TEveElement::EDestructTEveElement::kAnnihilate; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveText(const char* txt = """"); Constructor. void SetFontSize(Int_t size, Bool_t validate = kTRUE); Set valid font size. void SetFontFile(const char* name); Set font file regarding to static TGLFontManager fgFontFileArray. void SetFontMode(Int_t mode); Set FTFont class ID. void SetPolygonOffset(Float_t factor, Float_t units); Set the scale and units used to calculate depth values.; See glPolygonOffset manual page. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. void ComputeBBox(); Fill bounding-box information. Virtual from TAttBBox.; If member 'TEveFrameBox* fFrame' is set, frame's corners are; used as bbox. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return TEveText icon. TEveText(const TEveText& ). TEveText& operator=(const TEveText& ). virtual ~TEveText(); {}. Int_t GetFontSize() const; { return fFontSize; }. Int_t GetFontFile() const; { return fFontFile; }. Int_t GetFontMode() const; { return fFontMode; }. void SetFontFile(Int_t file); { fFontFile = file; }. const char* GetText() const; { return fText.Data()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveText.html:20845,validat,validate,20845,root/html602/TEveText.html,https://root.cern,https://root.cern/root/html602/TEveText.html,2,['validat'],['validate']
Security,"as; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooLinkedList**_arr! Array of linked lists storing elements in each slot; Int_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name) const; Return the object with given name from the table. RooAbsArg* findArg(const RooAbsArg* arg) const. TObject* find(const TObject* arg) const; Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const; Return RooSetPair with given pointers in table. ~RooHashTable(); Destructor. Int_t size() const; { return _size ; }. Int_t entries() const; { return _entries ; }. ULong_t hash(const TObject* arg) const; Return hash v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHashTable.html:7349,hash,hashArg,7349,root/html602/RooHashTable.html,https://root.cern,https://root.cern/root/html602/RooHashTable.html,4,['hash'],"['hash', 'hashArg']"
Security,"asParameters) ? (argType + "" *x"").Data() : """"),; 2312 (hasParameters ? "","" : """"), (hasParameters ? ""Double_t *p"" : """"));; 2313 ; 2314 // set the name for Cling using the hash_function; 2315 fClingName = gNamePrefix;; 2316 ; 2317 // check if formula exist already in the map; 2318 R__LOCKGUARD(gROOTMutex);; 2319 ; 2320 // std::cout << ""gClingFunctions list"" << std::endl;; 2321 // for (auto thing : gClingFunctions); 2322 // std::cout << ""gClingFunctions : "" << thing.first << std::endl;; 2323 ; 2324 auto funcit = gClingFunctions.find(inputFormulaVecFlag);; 2325 ; 2326 if (funcit != gClingFunctions.end()) {; 2327 fFuncPtr = (TFormula::CallFuncSignature)funcit->second;; 2328 fClingInitialized = true;; 2329 inputIntoCling = false;; 2330 }; 2331 ; 2332 ; 2333 ; 2334 // set the cling name using hash of the static formulae map; 2335 auto hasher = gClingFunctions.hash_function();; 2336 fClingName = TString::Format(""%s__id%zu"", gNamePrefix.Data(), hasher(inputFormulaVecFlag));; 2337 ; 2338 fClingInput = TString::Format(""%s %s(%s){ return %s ; }"", argType.Data(), fClingName.Data(),; 2339 argumentsPrototype.Data(), inputFormula.c_str());; 2340 ; 2341 ; 2342 // std::cout << ""Input Formula "" << inputFormula << "" \t vec formula : "" << inputFormulaVecFlag << std::endl;; 2343 // std::cout << ""Cling functions existing "" << std::endl;; 2344 // for (auto & ff : gClingFunctions); 2345 // std::cout << ff.first << std::endl;; 2346 // std::cout << ""\n"";; 2347 // std::cout << fClingName << std::endl;; 2348 ; 2349 // this is not needed (maybe can be re-added in case of recompilation of identical expressions; 2350 // // check in case of a change if need to re-initialize; 2351 // if (fClingInitialized) {; 2352 // if (oldClingInput == fClingInput); 2353 // inputIntoCling = false;; 2354 // else; 2355 // fClingInitialized = false;; 2356 // }; 2357 ; 2358 if (inputIntoCling) {; 2359 if (!fLazyInitialization) {; 2360 InputFormulaIntoCling();; 2361 if (fClingInitialized) {; 2362 // if Cling has been su",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:89722,hash,hasher,89722,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['hash'],['hasher']
Security,"ase should return to initial state. void SetUseIndexes(Int_t use_type = kIndexesBasic); Specify usage of indexes for data tables; kIndexesNone = 0 - no indexes are used; kIndexesBasic = 1 - indexes used only for keys list and; objects list tables (default); kIndexesClass = 2 - index also created for every normal class table; kIndexesAll = 3 - index created for every table, including _streamer_ tables; Indexes in general should increase speed of access to objects data,; but they required more operations and more disk space on server side. const char* GetDataBaseName() const; Return name of data base on the host; For Oracle always return 0. void Close(Option_t* option = """"); Close a SQL file; For more comments see TFile::Close() function. ~TSQLFile(); destructor of TSQLFile object. void operator=(const TSQLFile& ); make private to exclude copy operator. Bool_t IsOpen() const; return kTRUE if file is opened and can be accessed. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; See TFile::Open() for details. TKey* CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); create SQL key, which will store object in data base. TKey* CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); create SQL key, which will store object in data base. void WriteHeader(); Write file info like configurations, title, UUID and other. void WriteStreamerInfo(); Store all TVirtualStreamerInfo, used in file, in sql database. Bool_t WriteSpecialObject(Long64_t keyid, TObject* obj, const char* name, const char* title); write special kind of object like streamer infos or file itself; keys for that objects should exist in tables but not indicated in list of keys,; therefore users can not get them with TDirectoryFile::Get() method. TObject* ReadSpecialObject(Long64_t keyid, TObject* obj = 0); Read data of special kind of objects. TList* GetStreamerInfoList(); Read back streamer infos fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:37805,access,access,37805,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,5,['access'],['access']
Security,"ase::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 114 of file MethodCompositeBase.h. ◆ GetCurrentMethod() [1/2]. MethodBase * TMVA::MethodCompositeBase::GetCurrentMethod ; (; ). inlineprotected . Definition at line 104 of file MethodCompositeBase.h. ◆ GetCurrentMethod() [2/2]. MethodBase * TMVA::MethodCompositeBase::GetCurrentMethod ; (; UInt_t ; idx). inlineprotected . Definition at line 105 of file MethodCompositeBase.h. ◆ GetCurrentMethodIndex(). UInt_t TMVA::MethodCompositeBase::GetCurrentMethodIndex ; (; ). inlineprotected . Definition at line 98 of file MethodCompositeBase.h. ◆ GetLastMethod(). IMethod * TMVA::MethodCompositeBase::GetLastMethod ; (; ). inlineprotected . Definition at line 100 of file MethodCompositeBase.h. ◆ GetMethod() [1/2]. TMVA::IMethod * TMVA::MethodCompositeBase::GetMethod ; (; const Int_t ; index); const. protected . accessor by index in vector ; returns pointer to MVA that corresponds to given method index ; Definition at line 104 of file MethodCompositeBase.cxx. ◆ GetMethod() [2/2]. TMVA::IMethod * TMVA::MethodCompositeBase::GetMethod ; (; const TString & ; title); const. protected . accessor by name ; returns pointer to MVA that corresponds to given method title ; Definition at line 89 of file MethodCompositeBase.cxx. ◆ GetMvaValue() [1/3]. Double_t TMVA::MethodBase::GetMvaValue ; (; const TMVA::Event *const ; ev, . Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). Definition at line 201 of file MethodBase.cxx. ◆ GetMvaValue() [2/3]. Double_t TMVA::MethodCompositeBase::GetMvaValue ; (; Double_t * ; err = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . return composite MVA response ; Implements TMVA::MethodBase.; Definition at line 271 of file MethodCompositeBase.cxx. ◆ GetMvaValue() [3/3]. virtual Double_t TMVA::MethodBase::GetMvaValue ; (; Double_t * ; errLower = nullptr, . Double_t * ; errUpper = nullptr . ). virtual . Implements TMVA::M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCompositeBase.html:31335,access,accessor,31335,doc/master/classTMVA_1_1MethodCompositeBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCompositeBase.html,1,['access'],['accessor']
Security,"ase::fNbinsMVAoutputnumber of bins in MVA output histograms; TObjArray*fNetworkTObjArray of TObjArrays representing network; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses. private:. TObjArray*fInputLayercache this for fast access; TStringfLayerSpeclayout specification option; Int_tfNcyclesnumber of epochs to train; TStringfNeuronInputTypename of neuron input calculator class; TStringfNeuronTypename of neuron activation function class; vector<TNeuron*>fOutputNeuronscache this for fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each entry; containing the number of neurons to go in each successive layer. void InitANNBase(); initialize ANNBase object. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodANNBase.html:18278,access,access,18278,root/html530/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodANNBase.html,4,['access'],['access']
Security,"ased on TMinuit ;  CTLineEditor;  CTLinkSpecial TText object used to show hyperlinks ;  CTListA doubly linked list ;  CTListIterIterator of linked list ;  CTListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of TDataMember that were described unloaded data member ;  CTListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum that were described unloaded enum ;  CTListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum that were described unloaded enum ;  CTListOfEnumsWithLockIterIterator for TListOfEnumsWithLock ;  CTListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFunction that were described unloaded function ;  CTListOfFunctionsIterIterator for TListOfFunctions ;  CTListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFunction that were described unloaded function ;  CTListOfTypesA collection of TDataType designed to hold the typedef information and numerical type information ;  CTLockFileA scoped lock based on files ;  CTLockGuard;  CTLockPathPath locking class allowing shared and exclusive locks ;  CTLockPathGuard;  ►CTLorentzRotationDescribes Lorentz transformations including Lorentz boosts and rotations (see TRotation) ;  CTLorentzRotationRow;  CTLorentzVectorTLorentzVector is a general four-vector class, which can be used either for the description of position and time (x,y,z,t) or momentum and energy (px,py,pz,E) ;  CTMacOSXSystem;  CTMacroClass supporting a collection of lines with C++ code ;  CTMakeProject;  CTMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries) ;  CTMapFileThis class implements a shared memory region mapped to a file ;  CT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:167803,access,access,167803,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,5,['access'],['access']
Security,"ased on TMinuit ;  CTLineEditor;  CTLinkSpecial TText object used to show hyperlinks ;  CTListA doubly linked list ;  CTListIterIterator of linked list ;  CTListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of TDataMember that were described unloaded data member ;  CTListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum that were described unloaded enum ;  CTListOfEnumsWithLockA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum that were described unloaded enum ;  CTListOfEnumsWithLockIterIterator for TListOfEnumsWithLock ;  CTListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFunction that were described unloaded function ;  CTListOfFunctionsIterIterator for TListOfFunctions ;  CTListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFunction that were described unloaded function ;  CTListOfTypesA collection of TDataType designed to hold the typedef information and numerical type information ;  CTLockFileA scoped lock based on files ;  CTLockGuard;  ►CTLorentzRotation;  CTLorentzRotationRow;  CTLorentzVector;  CTMacOSXSystem;  CTMacroClass supporting a collection of lines with C++ code ;  CTMakeProject;  CTMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries) ;  CTMapFileThis class implements a shared memory region mapped to a file ;  CTMapIterIterator of map ;  CTMapRecKeep track of an object in the mapped file ;  CTMarkerManages Markers ;  CTMarker3DBoxA special 3-D marker designed for event display ;  CTMaterialManages a detector material ;  CTMathTextTo draw TeX Mathematical Formula ;  CTMatrixDEigen;  CTMatrixDSymEigen;  CTMatrixT;  CTMatrixTBase;  CTMatrixTCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:140866,access,access,140866,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['access'],['access']
Security,"asets ; Definition at line 717 of file DataLoader.cxx. ◆ GetDataSetInfo(). TMVA::DataSetInfo & TMVA::DataLoader::GetDataSetInfo ; (; ). Definition at line 137 of file DataLoader.cxx. ◆ GetDefaultDataSetInfo(). const DataSetInfo & TMVA::DataLoader::GetDefaultDataSetInfo ; (; ). inline . Definition at line 165 of file DataLoader.h. ◆ IsA(). virtual TClass * TMVA::DataLoader::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::Configurable.; Definition at line 214 of file DataLoader.h. ◆ MakeCopy(). TMVA::DataLoader * TMVA::DataLoader::MakeCopy ; (; TString ; name). Copy method use in VI and CV. ; Definition at line 691 of file DataLoader.cxx. ◆ MakeKFoldDataSet(). void TMVA::DataLoader::MakeKFoldDataSet ; (; CvSplit & ; s). Function required to split the training and testing datasets into a number of folds. ; Required by the CrossValidation and HyperParameterOptimisation classes. The option to split the training dataset into a training set and a validation set is implemented but not currently used. ; Definition at line 662 of file DataLoader.cxx. ◆ PrepareFoldDataSet(). void TMVA::DataLoader::PrepareFoldDataSet ; (; CvSplit & ; s, . UInt_t ; foldNumber, . Types::ETreeType ; tt = Types::kTraining . ). Function for assigning the correct folds to the testing or training set. ; Definition at line 670 of file DataLoader.cxx. ◆ PrepareTrainingAndTestTree() [1/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut & ; cut, . const TString & ; splitOpt . ). prepare the training and test trees -> same cuts for signal and background ; Definition at line 632 of file DataLoader.cxx. ◆ PrepareTrainingAndTestTree() [2/4]. void TMVA::DataLoader::PrepareTrainingAndTestTree ; (; const TCut & ; cut, . Int_t ; NsigTrain, . Int_t ; NbkgTrain, . Int_t ; NsigTest, . Int_t ; NbkgTest, . const TString & ; otherOpt = ""SplitMode=Random:!V"" . ). prepare the training and test trees ; Definition at line 602 of file DataLoader.cxx. ◆ ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataLoader.html:30465,validat,validation,30465,doc/master/classTMVA_1_1DataLoader.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataLoader.html,1,['validat'],['validation']
Security,"ashTableIter& rhs); Bool_tTIterator::operator==(const TIterator& other) const; virtual voidReset(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. THashTableIter(); Int_tNextSlot(). Data Members; private:. Int_tfCursorcurrent position in table; Bool_tfDirectioniteration direction; TListIter*fListCursorcurrent position in collision list; const THashTable*fTablehash table being iterated. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTableIter(const THashTable* ht, Bool_t dir = kIterForward); Create a hashtable iterator. By default the iteration direction; is kIterForward. To go backward use kIterBackward. THashTableIter(const THashTableIter& iter); Copy ctor. TIterator & operator=(const TIterator& rhs); Overridden assignment operator. THashTableIter & operator=(const THashTableIter& rhs); Overloaded assignment operator. ~THashTableIter(); Delete hashtable iterator. TObject * Next(); Return next object in hashtable. Returns 0 when no more objects in table. Int_t NextSlot(); Returns index of next slot in table containing list to be iterated. void Reset(); Reset the hashtable iterator. Either to beginning or end, depending on; the initial iteration direction. Bool_t operator!=(const TIterator& aIter) const; This operator compares two TIterator objects. Bool_t operator!=(const THashTableIter& aIter) const; This operator compares two THashTableIter objects. TObject * operator*() const; Return pointer to current object or nullptr. THashTableIter(); { }. const TCollection * GetCollection() const; { return fTable; }. » Author: Fons Rademakers 27/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-05-28 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTableIter.html:2014,hash,hashtable,2014,root/html534/THashTableIter.html,https://root.cern,https://root.cern/root/html534/THashTableIter.html,2,['hash'],['hashtable']
Security,"ass ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; virtual void InitializeContext ();  Initialize parser parameters, such as, disactivate non-standards libxml1 features, on/off validation, clear error and warning messages. ;  ; virtual void OnValidateError (const TString &message);  This function is called when an error from the parser has occurred. ;  ; virtual void OnValidateWarning (const TString &message);  This function is called when a warning from the parser has occurred. ;  ; virtual void ReleaseUnderlying ();  To release any existing document. ;  ; virtual void SetParseCode (Int_t code);  Set the parse code: ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; _xmlParserCtxt * fContext;  Parse the xml file. ;  ; Int_t fParseCode;  To keep track of the errorcodes. ;  ; Bool_t fRep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLParser.html:13391,validat,validation,13391,doc/master/classTXMLParser.html,https://root.cern,https://root.cern/doc/master/classTXMLParser.html,1,['validat'],['validation']
Security,"ass ; Definition at line 87 of file TListOfFunctionTemplates.h. ◆ Clear(). void TListOfFunctionTemplates::Clear ; (; Option_t * ; option = """"). overridevirtual . Remove all objects from the list. ; Does not delete the objects unless the THashList is the owner (set via SetOwner()). ; Reimplemented from THashList.; Definition at line 154 of file TListOfFunctionTemplates.cxx. ◆ DeclFileName(). static const char * TListOfFunctionTemplates::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 87 of file TListOfFunctionTemplates.h. ◆ Delete(). void TListOfFunctionTemplates::Delete ; (; Option_t * ; option = """"). overridevirtual . Delete all TFunction object files. ; Reimplemented from THashList.; Definition at line 164 of file TListOfFunctionTemplates.cxx. ◆ FindObject() [1/3]. TObject * THashList::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from THashList.; Definition at line 51 of file THashList.cxx. ◆ FindObject() [2/3]. TObject * TListOfFunctionTemplates::FindObject ; (; const char * ; name); const. overridevirtual . Specialize FindObject to do search for the a function just by name or create it if its not already in the list. ; Reimplemented from THashList.; Definition at line 175 of file TListOfFunctionTemplates.cxx. ◆ FindObject() [3/3]. TObject * THashList::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from THashList.; Definition at line 52 of file THashList.cxx. ◆ Get(). TFunctionTemplate * TListOfFunctionTemplates::Get ; (; DeclId_t ; id). Return (after creating it if necessary) the TMethod or TFunction describing the function corresponding to the Decl 'id'. ; Definition at line 253 of file TListOfFunctionTemplates.cxx. ◆ GetListForObject() [1/2]. TList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:27664,hash,hash,27664,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,1,['hash'],['hash']
Security,"ass = 0, . Double_t ; span = 0, . Bool_t ; isPeriodic = kFALSE, . Double_t * ; w = nullptr . ). Smooth data with Super smoother. ; Smooth the (x, y) values by Friedman's `‘super smoother’'.; Parameters. [in]gringraph for smoothing ; [in]optionspecific options ; [in]spanthe fraction of the observations in the span of the running lines smoother, or 0 to choose this by leave-one-out cross-validation. ; [in]basscontrols the smoothness of the fitted curve. Values of up to 10 indicate increasing smoothness. ; [in]isPeriodicif TRUE, the x values are assumed to be in [0, 1] and of period 1. ; [in]wcase weights. Details:; supsmu is a running lines smoother which chooses between three spans for the lines. The running lines smoothers are symmetric, with k/2 data points each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and 0.05 * n, where n is the number of data points. If span is specified, a single smoother with span span * n is used.; The best of the three smoothers is chosen by cross-validation for each prediction. The best spans are then smoothed by a running lines smoother and the final prediction chosen by linear interpolation.; The FORTRAN code says: `‘For small samples (n < 40) or if there are substantial serial correlations between observations close in x - value, then a prespecified fixed span smoother (span > 0) should be used. Reasonable span values are 0.2 to 0.4.’'; References:; Friedman, J. H. (1984) SMART User's Guide. Laboratory for Computational Statistics, Stanford University Technical Report No. 1.; Friedman, J. H. (1984) A variable span scatterplot smoother. Laboratory for Computational Statistics, Stanford University Technical Report No. 5. . Definition at line 479 of file TGraphSmooth.cxx. ◆ Streamer(). void TGraphSmooth::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TGraphSmooth::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphSmooth.html:26354,validat,validation,26354,doc/master/classTGraphSmooth.html,https://root.cern,https://root.cern/doc/master/classTGraphSmooth.html,1,['validat'],['validation']
Security,"ass Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; Static Private Member Functions |; Private Attributes |; Friends |; List of all members ; RooSimultaneous Class ReferenceRooFit » RooFit Core. ; Facilitates simultaneous fitting of multiple PDFs to subsets of a given dataset. ; The class takes an index category, which is used as a selector for PDFs, and a list of PDFs, each associated with a state of the index category. RooSimultaneous always returns the value of the PDF that is associated with the current value of the index category.; Extended likelihood fitting is supported if all components support extended likelihood mode. The expected number of events by a RooSimultaneous is that of the component p.d.f. selected by the index category.; The index category can be accessed using indexCategory(). Generating events; When generating events from a RooSimultaneous, the index category has to be added to the dataset. Further, the PDF needs to know the relative probabilities of each category, i.e., how many events are in which category. This can be achieved in two ways:; Generating with proto data that have category entries: An event from the same category as in the proto data is created for each event in the proto data. See RooAbsPdf::generate(const RooArgSet&,const RooDataSet&,Int_t,bool,bool,bool) const.; No proto data: A category is chosen randomly. NoteThis requires that the PDFs building the simultaneous are extended. In this way, the relative probability of each category can be calculated from the number of events in each category. PyROOT; Some member functions of RooSimultaneous that take a RooCmdArg as argument also support keyword arguments. So far, this applies to RooSimultaneous::plotOn. For example, the following code is equivalent in PyROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooSimultaneous.html:1025,access,accessed,1025,doc/master/classRooSimultaneous.html,https://root.cern,https://root.cern/doc/master/classRooSimultaneous.html,1,['access'],['accessed']
Security,"ass ReferenceRooFit » RooFit Core. ; Internally uses ROOT's TFormula to compute user-defined expressions of RooAbsArgs. ; The string expression can be any valid TFormula expression referring to the listed servers either by name or by their ordinal list position. These three are forms equivalent: RooFormula(""formula"", ""x*y"", RooArgList(x,y)) or; RooFormula(""formula"", ""@0*@1"", RooArgList(x,y)); RooFormula(""formula"", ""x[0]*x[1]"", RooArgList(x,y)); RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooFormulaInternally uses ROOT's TFormula to compute user-defined expressions of RooAbsArgs.Definition RooFormula.h:27; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; Note that x[i] is an expression reserved for TFormula. If a variable with the name x is given, the RooFormula interprets x as a variable name, but x[i] as an index in the list of variables. Category expressions; State information of RooAbsCategories can be accessed using the '::' operator, i.e.*, tagCat::Kaon will resolve to the numerical value of the Kaon state of the RooAbsCategory object named tagCat.; A formula to switch between lepton categories could look like this: RooFormula(""formulaWithCat"",; ""x * (leptonMulti == leptonMulti::one) + y * (leptonMulti == leptonMulti::two)"",; RooArgList(x, y, leptonMulti));. Debugging a formula that won't compile; When the formula is preprocessed, RooFit can print information in the debug stream. These can be retrieved by activating the RooFit::MsgLevel RooFit::DEBUG and the RooFit::MsgTopic RooFit::InputArguments. Check the tutorial rf506_msgservice.C for details. ; Definition at line 27 of file RooFormula.h. Public Member Functions;  RooFormula (const char *name, const char *formula, const RooArgList &varList, bool checkVariables=true);  Construct a new formula. ;  ;  RooFormula (const RooFormula &other, const char *name=nullptr);  Copy constructor. ;  ; RooArgSet actualDependents",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormula.html:1268,access,accessed,1268,doc/master/classRooFormula.html,https://root.cern,https://root.cern/doc/master/classRooFormula.html,1,['access'],['accessed']
Security,"ass TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Verbose (Bool_t);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualMonitoringWriter.html:2387,hash,hash,2387,doc/master/classTVirtualMonitoringWriter.html,https://root.cern,https://root.cern/doc/master/classTVirtualMonitoringWriter.html,1,['hash'],['hash']
Security,"ass();; 4305 }; 4306 // Build the signature of the method; 4307 TString sig;; 4308 TList* margsList = method->GetListOfMethodArgs();; 4309 TIter nextarg(margsList);; 4310 while ((methodArg = (TMethodArg*)nextarg())) {; 4311 sig = sig+"",""+methodArg->GetFullTypeName();; 4312 }; 4313 if (sig.Length()!=0) sig.Remove(0,1); // remove first comma; 4314 menuItem = new TClassMenuItem(TClassMenuItem::kPopupUserFunction, this,; 4315 method->GetName(), method->GetName(),nullptr,; 4316 sig.Data(),-1,TClassMenuItem::kIsSelf);; 4317 if (method->IsMenuItem() == kMenuToggle) menuItem->SetToggle();; 4318 fClassMenuList->Add(menuItem);; 4319 }; 4320 delete methodList;; 4321}; 4322 ; 4323////////////////////////////////////////////////////////////////////////////////; 4324/// Register the fact that an object was moved from the memory location; 4325/// 'arenaFrom' to the memory location 'arenaTo'.; 4326 ; 4327void TClass::Move(void *arenaFrom, void *arenaTo) const; 4328{; 4329 // If/when we have access to a copy constructor (or better to a move; 4330 // constructor), this function should also perform the data move.; 4331 // For now we just information the repository.; 4332 ; 4333 if ((GetState() <= kEmulated) && !fCollectionProxy) {; 4334 MoveAddressInRepository(""TClass::Move"",arenaFrom,arenaTo,this);; 4335 }; 4336}; 4337 ; 4338////////////////////////////////////////////////////////////////////////////////; 4339/// Return the list of menu items associated with the class.; 4340 ; 4341TList *TClass::GetMenuList() const {; 4342 if (!fClassMenuList) {; 4343 fClassMenuList = new TList();; 4344 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4345 }; 4346 return fClassMenuList;; 4347}; 4348 ; 4349////////////////////////////////////////////////////////////////////////////////; 4350/// Return (create an empty one if needed) the list of functions.; 4351/// The major difference with GetListOfMethod is that this returns; 4352/// the interna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:163643,access,access,163643,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['access']
Security,"ass();; 4372 }; 4373 // Build the signature of the method; 4374 TString sig;; 4375 TList* margsList = method->GetListOfMethodArgs();; 4376 TIter nextarg(margsList);; 4377 while ((methodArg = (TMethodArg*)nextarg())) {; 4378 sig = sig+"",""+methodArg->GetFullTypeName();; 4379 }; 4380 if (sig.Length()!=0) sig.Remove(0,1); // remove first comma; 4381 menuItem = new TClassMenuItem(TClassMenuItem::kPopupUserFunction, this,; 4382 method->GetName(), method->GetName(),nullptr,; 4383 sig.Data(),-1,TClassMenuItem::kIsSelf);; 4384 if (method->IsMenuItem() == kMenuToggle) menuItem->SetToggle();; 4385 fClassMenuList->Add(menuItem);; 4386 }; 4387 delete methodList;; 4388}; 4389 ; 4390////////////////////////////////////////////////////////////////////////////////; 4391/// Register the fact that an object was moved from the memory location; 4392/// 'arenaFrom' to the memory location 'arenaTo'.; 4393 ; 4394void TClass::Move(void *arenaFrom, void *arenaTo) const; 4395{; 4396 // If/when we have access to a copy constructor (or better to a move; 4397 // constructor), this function should also perform the data move.; 4398 // For now we just information the repository.; 4399 ; 4400 if ((GetState() <= kEmulated) && !fCollectionProxy) {; 4401 MoveAddressInRepository(""TClass::Move"",arenaFrom,arenaTo,this);; 4402 }; 4403}; 4404 ; 4405////////////////////////////////////////////////////////////////////////////////; 4406/// Return the list of menu items associated with the class.; 4407 ; 4408TList *TClass::GetMenuList() const {; 4409 if (!fClassMenuList) {; 4410 fClassMenuList = new TList();; 4411 fClassMenuList->Add(new TClassMenuItem(TClassMenuItem::kPopupStandardList, const_cast<TClass*>(this)));; 4412 }; 4413 return fClassMenuList;; 4414}; 4415 ; 4416////////////////////////////////////////////////////////////////////////////////; 4417/// Return (create an empty one if needed) the list of functions.; 4418/// The major difference with GetListOfMethod is that this returns; 4419/// the interna",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:166394,access,access,166394,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['access']
Security,"ass* onfile_class); Case of instrumented class with a library. void ConvStreamerInstrumented(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of instrumented class with a library. void StreamerStreamerInfo(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Case of where we should directly use the StreamerInfo.; case kForeign:; case kForeign|kEmulatedStreamer:; case kInstrumented|kEmulatedStreamer:; case kEmulatedStreamer:. void StreamerDefault(const TClass* pThis, void* object, TBuffer& b, const TClass* onfile_class); Default streaming in cases where either we have no way to know what to do; or if Property() has not yet been called. void AdoptStreamer(TClassStreamer* strm); Adopt a TClassStreamer object. Ownership is transfered to this TClass; object. void SetStreamerFunc(ClassStreamerFunc_t strm); Set a wrapper/accessor function around this class custom streamer. void SetConvStreamerFunc(ClassConvStreamerFunc_t strm); Set a wrapper/accessor function around this class custom conversion streamer. void SetMerge(ROOT::MergeFunc_t mergeFunc); Install a new wrapper around 'Merge'. void SetResetAfterMerge(ROOT::ResetAfterMergeFunc_t resetFunc); Install a new wrapper around 'ResetAfterMerge'. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:61181,access,accessor,61181,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['access'],['accessor']
Security,"ass::GetClass(""TAttLine"")->GetStreamerInfo()->ls(); produces;; 4293/// StreamerInfo for class: TAttLine, version=1; 4294/// short fLineColor offset= 4 type= 2 line color; 4295/// short fLineStyle offset= 6 type= 2 line style; 4296/// short fLineWidth offset= 8 type= 2 line width; 4297/// i= 0, fLineColor type= 22, offset= 4, len=3, method=0; 4298/// ~~~; 4299/// For I/O implementations (eg. XML) , one has to know the original name; 4300/// of the data member. This function can be used to return a pointer; 4301/// to the original TStreamerElement object corresponding to the j-th; 4302/// element of a compressed array in fElems.; 4303/// Parameters description:; 4304/// - i: the serial number in array fElem; 4305/// - j: the element number in the array of consecutive types; 4306/// In the above example the class TAttLine has 3 consecutive data members; 4307/// of the same type ""short"". Compile makes one single array of 3 elements.; 4308/// To access the TStreamerElement for the second element; 4309/// of this array, one can call:; 4310/// ~~~{.cpp}; 4311/// auto el = GetStreamerElementReal(0,1);; 4312/// auto membername = el->GetName();; 4313/// ~~~; 4314/// This function is typically called from TBuffer, TXmlBuffer.; 4315 ; 4316TStreamerElement* TStreamerInfo::GetStreamerElementReal(Int_t i, Int_t j) const; 4317{; 4318 ::Obsolete(""TStreamerInfo::GetStreamerElementReal"", ""v5-34-20"", ""v6-00-02"");; 4319 ; 4320 if (i < 0 || i >= fNdata) return 0;; 4321 if (j < 0) return 0;; 4322 if (!fElements) return 0;; 4323 TStreamerElement *se = (TStreamerElement*)fCompOpt[i]->fElem;; 4324 if (!se) return 0;; 4325 Int_t nelems = fElements->GetEntriesFast();; 4326 for (Int_t ise=0;ise < nelems;ise++) {; 4327 if (se != (TStreamerElement*)fElements->UncheckedAt(ise)) continue;; 4328 if (ise+j >= nelems) return 0;; 4329 return (TStreamerElement*)fElements->UncheckedAt(ise+j);; 4330 }; 4331 return 0;; 4332}; 4333 ; 4334//////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:172755,access,access,172755,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['access'],['access']
Security,"ass; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. UInt_t GetCheckSum(UInt_t code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Algorithm from Victor Perevovchikov (perev@bnl.gov). if code==1 data members of type enum are not counted in the checksum; if code==2 return the checksum of data members and base classes, not including the ranges and array size found in comments.; This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void GenerateDeclaration(FILE* fp, FILE* sfp, const TList* subClasses, Bool_t top = kTRUE); Write the Declaration of class. UInt_t GenerateIncludes(FILE* fp, char* inclist, const TList* extrainfos); Add to the header file, the #include need for this class. Int_t GenerateHeaderFile(const char* dirname, const TList* subClasses = 0, const TList* extrainfos = 0); Generate header file for the class described by this TStreamerInfo; the function is called by TFile::MakeProject for each class in the file. TStreamerElement * GetCurrentElement();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerInfo.html:17012,checksum,checksum,17012,root/html528/TStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TStreamerInfo.html,6,['checksum'],['checksum']
Security,"assVersion()==0)) {; 920 // We must match on the same checksum, an existing TStreamerInfo; 921 // for one of the 'unversioned' class layout (i.e. version was 1).; 922 fClassVersion = i;; 923 break;; 924 }; 925 info = 0;; 926 }; 927 if (info==0) {; 928 // Find an empty slot.; 929 ninfos = array->GetEntriesFast() - 1;; 930 Int_t slot = 1; // Start of Class version 1.; 931 while ((slot < ninfos) && (array->UncheckedAt(slot) != 0)) {; 932 ++slot;; 933 }; 934 fClassVersion = slot;; 935 }; 936 }; 937 ; 938 // NOTE: Should we check if the already existing info is the same as; 939 // the current one? Yes; 940 // In case a class (eg Event.h) has a TClonesArray of Tracks, it could be; 941 // that the old info does not have the class name (Track) in the data; 942 // member title. Set old title to new title; 943 if (info) {; 944 // We found an existing TStreamerInfo for our ClassVersion; 945 Bool_t match = kTRUE;; 946 Bool_t done = kFALSE;; 947 Bool_t oldIsNonVersioned = kFALSE;; 948 if (fClassVersion!=0 && !fClass->TestBit(TClass::kWarned) && (fClassVersion == info->GetClassVersion()) && (fCheckSum != info->GetCheckSum())) {; 949 // The TStreamerInfo's checksum is different from the checksum for the compile class.; 950 ; 951 match = kFALSE;; 952 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 953 ; 954 if (fClass->IsLoaded() && (fClassVersion == fClass->GetClassVersion()) && fClass->HasDataMemberInfo()) {; 955 // In the case where the read-in TStreamerInfo does not; 956 // match in the 'current' in memory TStreamerInfo for; 957 // a non foreign class (we can not get here if this is; 958 // a foreign class so we do not need to test it),; 959 // we need to add this one more test since the CINT behaviour; 960 // with enums changed over time, so verify the checksum ignoring; 961 // members of type enum. We also used to not count the //[xyz] comment; 962 // in the checksum, so test for that too.; 963 if ( (fCheckSum == fClass->GetCheckSu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:34687,checksum,checksum,34687,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,2,['checksum'],['checksum']
Security,asses that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:348; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a pers,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:82053,access,access,82053,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['access'],['access']
Security,asses that contain diction...Definition TDictionary.h:168; TDictionary::EMemberSelectionEMemberSelectionKinds of members to include in lists.Definition TDictionary.h:216; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TListA doubly linked list.Definition TList.h:38; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TMethodCallMethod or function calling interface.Definition TMethodCall.h:37; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Dumpvirtual void Dump() constDump contents of object on stdout.Definition TObject.cxx:353; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TStreamerInfoDescribes a pers,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:81881,access,access,81881,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['access'],['access']
Security,"associted TSceContexts unchanged. ~THostAuth(); The dtor. const char * GetDetails(Int_t level); Return authentication details for specified level; or """" if the specified level does not exist for this host. Bool_t HasMethod(Int_t level, Int_t* pos = 0); Return kTRUE if method 'level' is in the list. void SetDetails(Int_t level, const char* details); Set authentication details for specified level. void Print(Option_t* option = """") const; Print object content. void PrintEstablished() const; Print info about established authentication vis-a-vis of this Host. void ReOrder(Int_t nmet, Int_t* fmet); Reorder nmet methods according fmet[nmet]. void Update(THostAuth* ha); Update info with the one in ha; Remaining methods, if any, get lower priority. void SetFirst(Int_t level); Set 'method' to be the first used (if in the list ...). void SetLast(Int_t level); Set 'method' to be the last used (if in the list ...). void AddFirst(Int_t level, const char* details = 0); Add new method in first position; If already in the list, set as first method 'level' with; authentication 'details'.; Faster then AddMethod(method,details)+SetFirst(method). void CountSuccess(Int_t level); Count successes for 'method'. void CountFailure(Int_t level); Count failures for 'method'. TRootSecContext * CreateSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* details, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = -1); Create a Security context and add it to local list; Return pointer to it to be stored in TAuthenticate. void AsString(TString& out) const; Return a static string with all info in a serialized form. Int_t NumMethods() const; { return fNumMethods; }. Int_t GetMethod(Int_t idx) const; { return fMethods[idx]; }. Int_t GetFailure(Int_t idx) const; { return fFailure[idx]; }. Int_t GetSuccess(Int_t idx) const; { return fSuccess[idx]; }. Bool_t IsActive() const; { return fActive; }. void DeActivate(); { fActive = kFALSE; }. void Activate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THostAuth.html:10507,authenticat,authentication,10507,root/html528/THostAuth.html,https://root.cern,https://root.cern/root/html528/THostAuth.html,6,['authenticat'],['authentication']
Security,"at = 0, RooAbsArg* client = 0); Print tree structure of expression tree on given ostream.; If namePat is not ""*"", only nodes with names matching the pattern will be printed.; The client argument is used in recursive calls to properly display the value or shape nature; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:34285,hash,hash,34285,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,3,['hash'],['hash']
Security,"at line 369 of file TFileInfo.cxx. ◆ SetIndex(). void TFileInfo::SetIndex ; (; Int_t ; idx). inline . Definition at line 100 of file TFileInfo.h. ◆ SetSize(). void TFileInfo::SetSize ; (; Long64_t ; size). inline . Definition at line 86 of file TFileInfo.h. ◆ SetUUID(). void TFileInfo::SetUUID ; (; const char * ; uuid). Set the UUID to the value associated to the string 'uuid'. ; This is useful to set the UUID to the one of the ROOT file during verification.; NB: we do not change the name in here, because this would screw up lists of these objects hashed on the name. Those lists need to be rebuild. TFileCollection does that in RemoveDuplicates. ; Definition at line 238 of file TFileInfo.cxx. ◆ Streamer(). void TFileInfo::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFileInfo::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 104 of file TFileInfo.h. Member Data Documentation. ◆ fCurrentUrl. TUrl* TFileInfo::fCurrentUrl. private . Definition at line 42 of file TFileInfo.h. ◆ fIndex. Int_t TFileInfo::fIndex. private . Definition at line 50 of file TFileInfo.h. ◆ fMD5. TMD5* TFileInfo::fMD5. private . Definition at line 47 of file TFileInfo.h. ◆ fMetaDataList. TList* TFileInfo::fMetaDataList. private . Definition at line 48 of file TFileInfo.h. ◆ fSize. Long64_t TFileInfo::fSize. private . Definition at line 45 of file TFileInfo.h. ◆ fUrlList. TList* TFileInfo::fUrlList. private . current URL to access the file, points to URL ; Definition at line 44 of file TFileInfo.h. ◆ fUUID. TUUID* TFileInfo::fUUID. private . Definition at line 46 of file TFileInfo.h. Libraries for TFileInfo:. [legend]; The documentation for this class was generated from the following files:; core/base/inc/TFileInfo.h; core/base/src/TFileInfo.cxx. TFileInfo. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileInfo.html:22694,access,access,22694,doc/master/classTFileInfo.html,https://root.cern,https://root.cern/doc/master/classTFileInfo.html,1,['access'],['access']
Security,"at line 700 of file TRootSniffer.cxx. ◆ ScanRoot(). void TRootSniffer::ScanRoot ; (; TRootSnifferScanRec & ; rec). protectedvirtual . scan complete ROOT objects hierarchy For the moment it includes objects in gROOT directory and list of canvases and files Also all registered objects are included. ; One could re-implement this method to provide alternative scan methods or to extend some collection kinds ; Definition at line 965 of file TRootSniffer.cxx. ◆ SetAutoLoad(). void TRootSniffer::SetAutoLoad ; (; const char * ; scripts = """"). When specified, _autoload attribute will be always add to top element of h.json/h.hml requests Used to instruct browser automatically load special code. ; Definition at line 482 of file TRootSniffer.cxx. ◆ SetCurrentCallArg(). THttpCallArg * TRootSniffer::SetCurrentCallArg ; (; THttpCallArg * ; arg). set current http arguments, which then used in different process methods For instance, if user authorized with some user name, depending from restrictions some objects will be invisible or user get full access to the element Returns previous argument which was set before ; Definition at line 435 of file TRootSniffer.cxx. ◆ SetItemField(). Bool_t TRootSniffer::SetItemField ; (; const char * ; fullname, . const char * ; name, . const char * ; value . ). Set field for specified item. ; Definition at line 1795 of file TRootSniffer.cxx. ◆ SetReadOnly(). void TRootSniffer::SetReadOnly ; (; Bool_t ; on = kTRUE). inline . When readonly on (default), sniffer is not allowed to change ROOT structures For instance, it is not allowed to read new objects from files. ; Definition at line 190 of file TRootSniffer.h. ◆ SetScanGlobalDir(). void TRootSniffer::SetScanGlobalDir ; (; Bool_t ; on = kTRUE). inline . When enabled (default), sniffer scans gROOT for files, canvases, histograms. ; Definition at line 206 of file TRootSniffer.h. ◆ Streamer(). void TRootSniffer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:39204,authoriz,authorized,39204,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,2,"['access', 'authoriz']","['access', 'authorized']"
Security,"at_t>& values, const vector<Float_t>& targetValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1., Double_t boostweight = 1.); constructor. Event(const vector<Float_t*>*& , UInt_t nvar); constructor for single events. Event(const TMVA::Event& ); copy constructor. ~Event(); Event destructor. void SetVariableArrangement(vector<UInt_t>*const m) const; set the variable arrangement. void CopyVarValues(const TMVA::Event& other); copies only the variable values. Float_t GetValue(UInt_t ivar) const; return value of i'th variable. Float_t GetSpectator(UInt_t ivar) const; return spectator content. const std::vector<Float_t>& GetValues() const; return value vector. UInt_t GetNVariables() const; accessor to the number of variables. UInt_t GetNTargets() const; accessor to the number of targets. UInt_t GetNSpectators() const; accessor to the number of spectators. void SetVal(UInt_t ivar, Float_t val); set variable ivar to val. void Print(ostream& o) const; print method. void SetTarget(UInt_t itgt, Float_t value); set the target value (dimension itgt) to value. void SetSpectator(UInt_t ivar, Float_t value); set spectator value (dimension ivar) to value. Double_t GetWeight() const; return the event weight - depending on whether the flag; *IgnoreNegWeightsInTraining* is or not. If it is set AND it is; used for training, then negetive event weights are set to zero !; NOTE! For events used in Testing, the ORIGINAL possibly negative; event weight is used no matter what. void SetIsTraining(Bool_t ); when this static function is called, it sets the flag whether; events with negative event weight should be ignored in the; training, or not. void SetIgnoreNegWeightsInTraining(Bool_t ); when t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Event.html:4258,access,accessor,4258,root/html602/TMVA__Event.html,https://root.cern,https://root.cern/root/html602/TMVA__Event.html,2,['access'],['accessor']
Security,"ata set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::SetBackgroundWeightExpressionvoid SetBackgroundWeightExpression(const TString &variable)Definition DataLoader.cxx:556; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::Envelope::BookMethodvirtual void BookMethod(TString methodname, TString methodtitle, TString options="""")Method to book the machine learning method to perform the algorithm.Definition Envelope.cxx:163; TMVA::Experimental::ClassificationDefinition Classification.h:162; TMVA::Experimental::Classification::GetResultsstd::vector< ClassificationResult > & GetResults()Return the vector of TMVA::Experimental::ClassificationResult objects.Definition Classification.cxx:945; TMVA::Experimental::Classification::Evaluatevirtual void Evaluate()Method to perform Train/Test over all ml method booked.Definition Classification.cxx:248; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kSVM@ kSVMDefinition Types.h:89; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; classificationvoid classification(UInt_t jobs=4)Definition classification.C:14; unsigned int; ; #include <TMVA/Classification.h>; The documentation for this class was generated from the following file:; tmva/tmva/inc/TMVA/Classification.h. Classification. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Classification.html:6181,access,access,6181,doc/master/classTMVA_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Classification.html,2,['access'],['access']
Security,"ata.entries != NULL) {; 9709 qsort(data.entries,; 9710 data.num_entries,; 9711 sizeof(data.entries[0]),; 9712 compare_dir_entries);; 9713 for (i = 0; i < data.num_entries; i++) {; 9714 print_dir_entry(&data.entries[i]);; 9715 mg_free(data.entries[i].file_name);; 9716 }; 9717 mg_free(data.entries);; 9718 }; 9719 ; 9720 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9721 conn->status_code = 200;; 9722}; 9723#endif /* NO_FILESYSTEMS */; 9724 ; 9725 ; 9726/* Send len bytes from the opened file to the client. */; 9727static void; 9728send_file_data(struct mg_connection *conn,; 9729 struct mg_file *filep,; 9730 int64_t offset,; 9731 int64_t len); 9732{; 9733 char buf[MG_BUF_LEN];; 9734 int to_read, num_read, num_written;; 9735 int64_t size;; 9736 ; 9737 if (!filep || !conn) {; 9738 return;; 9739 }; 9740 ; 9741 /* Sanity check the offset */; 9742 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9743 : (int64_t)(filep->stat.size);; 9744 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9745 ; 9746 if (len > 0 && filep->access.fp != NULL) {; 9747 /* file stored on disk */; 9748#if defined(__linux__); 9749 /* sendfile is only available for Linux */; 9750 if ((conn->ssl == 0) && (conn->throttle == 0); 9751 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9752 ""yes""))) {; 9753 off_t sf_offs = (off_t)offset;; 9754 ssize_t sf_sent;; 9755 int sf_file = fileno(filep->access.fp);; 9756 int loop_cnt = 0;; 9757 ; 9758 do {; 9759 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9760 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9761 size_t sf_tosend =; 9762 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9763 sf_sent =; 9764 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9765 if (sf_sent > 0) {; 9766 len -= sf_sent;; 9767 offset += sf_sent;; 9768 } else if (loop_cnt == 0) {; 9769 /* This file can not be sent using sendfile.; 9770 * This might be the case for pseudo-files in the; 9771 * /sys/ and /proc/ file s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:279046,access,access,279046,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"ata.entries != NULL) {; 9710 qsort(data.entries,; 9711 data.num_entries,; 9712 sizeof(data.entries[0]),; 9713 compare_dir_entries);; 9714 for (i = 0; i < data.num_entries; i++) {; 9715 print_dir_entry(&data.entries[i]);; 9716 mg_free(data.entries[i].file_name);; 9717 }; 9718 mg_free(data.entries);; 9719 }; 9720 ; 9721 mg_printf(conn, ""%s"", ""</table></pre></body></html>"");; 9722 conn->status_code = 200;; 9723}; 9724#endif /* NO_FILESYSTEMS */; 9725 ; 9726 ; 9727/* Send len bytes from the opened file to the client. */; 9728static void; 9729send_file_data(struct mg_connection *conn,; 9730 struct mg_file *filep,; 9731 int64_t offset,; 9732 int64_t len); 9733{; 9734 char buf[MG_BUF_LEN];; 9735 int to_read, num_read, num_written;; 9736 int64_t size;; 9737 ; 9738 if (!filep || !conn) {; 9739 return;; 9740 }; 9741 ; 9742 /* Sanity check the offset */; 9743 size = (filep->stat.size > INT64_MAX) ? INT64_MAX; 9744 : (int64_t)(filep->stat.size);; 9745 offset = (offset < 0) ? 0 : ((offset > size) ? size : offset);; 9746 ; 9747 if (len > 0 && filep->access.fp != NULL) {; 9748 /* file stored on disk */; 9749#if defined(__linux__); 9750 /* sendfile is only available for Linux */; 9751 if ((conn->ssl == 0) && (conn->throttle == 0); 9752 && (!mg_strcasecmp(conn->dom_ctx->config[ALLOW_SENDFILE_CALL],; 9753 ""yes""))) {; 9754 off_t sf_offs = (off_t)offset;; 9755 ssize_t sf_sent;; 9756 int sf_file = fileno(filep->access.fp);; 9757 int loop_cnt = 0;; 9758 ; 9759 do {; 9760 /* 2147479552 (0x7FFFF000) is a limit found by experiment on; 9761 * 64 bit Linux (2^31 minus one memory page of 4k?). */; 9762 size_t sf_tosend =; 9763 (size_t)((len < 0x7FFFF000) ? len : 0x7FFFF000);; 9764 sf_sent =; 9765 sendfile(conn->client.sock, sf_file, &sf_offs, sf_tosend);; 9766 if (sf_sent > 0) {; 9767 len -= sf_sent;; 9768 offset += sf_sent;; 9769 } else if (loop_cnt == 0) {; 9770 /* This file can not be sent using sendfile.; 9771 * This might be the case for pseudo-files in the; 9772 * /sys/ and /proc/ file s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:279078,access,access,279078,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"ata::Poisson) const =0;  ; virtual double weightError (RooAbsData::ErrorType etype=RooAbsData::Poisson) const =0;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:5468,hash,hash,5468,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,1,['hash'],['hash']
Security,"ataSetManager::ParseInitOpts for the available; base options.; The base options are already initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDataSetManagerFile.html:13891,checksum,checksum,13891,root/html534/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html534/TDataSetManagerFile.html,3,['checksum'],['checksum']
Security,"ataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to the list in target.; If dsName is defined, only the information about the specified dataset; is processed. The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming; kList get a list of dataset names. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuotaUpdate"" return is null. TMap * GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:13269,checksum,checksum,13269,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,3,['checksum'],['checksum']
Security,"ataSetsTSeqCollection * fDataSetsList of data sets (TDSet or TChain)Definition TROOT.h:164; TROOT::fConfigOptionsTString fConfigOptionsROOT ./configure set build options.Definition TROOT.h:111; TROOT::GetStyleTStyle * GetStyle(const char *name) constReturn pointer to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFALSE)Return list containing the TGlobals currently defined.Definition TROOT.cxx:1788; TROOT::SetDirLevelstatic void SetDirLevel(Int_t level=0)Return Indentation level for ls().Definition TROOT.cxx:2914; TROOT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3211; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:153305,secur,security,153305,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['secur'],['security']
Security,"ataSetsTSeqCollection * fDataSetsList of data sets (TDSet or TChain)Definition TROOT.h:164; TROOT::fConfigOptionsTString fConfigOptionsROOT ./configure set build options.Definition TROOT.h:111; TROOT::GetStyleTStyle * GetStyle(const char *name) constReturn pointer to style with name.Definition TROOT.cxx:1579; TROOT::GetListOfEnumsTCollection * GetListOfEnums(Bool_t load=kFALSE)Definition TROOT.cxx:1754; TROOT::ProcessLineSyncLongptr_t ProcessLineSync(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2390; TROOT::InitInterpretervoid InitInterpreter()Initialize interpreter (cling)Definition TROOT.cxx:2064; TROOT::GetListOfGlobalsTCollection * GetListOfGlobals(Bool_t load=kFALSE)Return list containing the TGlobals currently defined.Definition TROOT.cxx:1788; TROOT::SetDirLevelstatic void SetDirLevel(Int_t level=0)Return Indentation level for ls().Definition TROOT.cxx:2918; TROOT::fSecContextsTSeqCollection * fSecContextsList of security contexts (TSecContext)Definition TROOT.h:161; TROOT::fWebDisplayTString fWebDisplayIf not empty it defines where web graphics should be rendered (cef, qt5, browser.....Definition TROOT.h:127; TROOT::GetTutorialsDirstatic const char * GetTutorialsDir()Get the tutorials directory in the installation.Definition TROOT.cxx:3215; TROOT::GetListOfFunctionOverloadsTCollection * GetListOfFunctionOverloads(const char *name) constReturn the collection of functions named ""name"".Definition TROOT.cxx:1672; TROOT::fCleanupsTSeqCollection * fCleanupsList of recursiveRemove collections.Definition TROOT.h:157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:153481,secur,security,153481,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['secur'],['security']
Security,"atabase side. Bool_t Rollback(); Rollback all operations, done after StartTransaction() call.; Database should return to initial state. void SetUseIndexes(Int_t use_type = kIndexesBasic); Specify usage of indexes for data tables; kIndexesNone = 0 - no indexes are used; kIndexesBasic = 1 - indexes used only for keys list and; objects list tables (default); kIndexesClass = 2 - index also created for every normal class table; kIndexesAll = 3 - index created for every table, including _streamer_ tables; Indexes in general should increase speed of access to objects data,; but they required more operations and more disk space on server side. const char* GetDataBaseName() const; Return name of data base on the host; For Oracle always return 0. void Close(Option_t* option = """"); Close a SQL file; For more comments see TFile::Close() function. ~TSQLFile(); destructor of TSQLFile object. void operator=(const TSQLFile& ); make private to exclude copy operator. Bool_t IsOpen() const; return kTRUE if file is opened and can be accessed. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; See TFile::Open() for details. TKey* CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); create SQL key, which will store object in data base. TKey* CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); create SQL key, which will store object in data base. void WriteHeader(); Write file info like configurations, title, UUID and other. void WriteStreamerInfo(); Store all TVirtualStreamerInfo, used in file, in sql database. Bool_t WriteSpecialObject(Long64_t keyid, TObject* obj, const char* name, const char* title); write special kind of object like streamer infos or file itself; keys for that objects should exist in tables but not indicated in list of keys,; therefore users can not get them with TDirectoryFile::Get() method. TObject* ReadSpecialObject(Long64_t keyid, TObject* obj = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:37734,access,accessed,37734,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,5,['access'],['accessed']
Security,"ate ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. RooCmdArg_conflProtocol; RooCategory*_masterCat; map<RooAbsPdf*,ObjSplitRule>_pdfmap; map<RooAbsCategory*,std::list<const RooCatType*> >_restr; RooArgSet_usedSplitCats. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void print(); Print details of a validated build configuration. ObjBuildConfig(); {}. virtual ~ObjBuildConfig(); {}. » Last changed: Mon Jul 4 15:24:01 2011 » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooSimWSTool__ObjBuildConfig.html:4382,validat,validated,4382,root/html530/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html530/RooSimWSTool__ObjBuildConfig.html,1,['validat'],['validated']
Security,"ate ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. RooCmdArg_conflProtocol; RooCategory*_masterCat; map<RooAbsPdf*,ObjSplitRule>_pdfmap; map<RooAbsCategory*,std::list<const RooCatType*> >_restr; RooArgSet_usedSplitCats. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void print(); Print details of a validated build configuration. ObjBuildConfig(); {}. virtual ~ObjBuildConfig(); {}. » Last changed: Sat Oct 9 22:38:49 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSimWSTool__ObjBuildConfig.html:4382,validat,validated,4382,root/html528/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html528/RooSimWSTool__ObjBuildConfig.html,1,['validat'],['validated']
Security,"ate ""I"" of master split category; mc and prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. RooCmdArg_conflProtocol; RooCategory*_masterCat; map<RooAbsPdf*,ObjSplitRule>_pdfmap; map<RooAbsCategory*,std::list<const RooCatType*> >_restr; RooArgSet_usedSplitCats. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void print(); Print details of a validated build configuration. ObjBuildConfig(); {}. virtual ~ObjBuildConfig(); {}. » Last changed: Thu Nov 3 20:09:17 2011 » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSimWSTool__ObjBuildConfig.html:4382,validat,validated,4382,root/html532/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html532/RooSimWSTool__ObjBuildConfig.html,1,['validat'],['validated']
Security,"ate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegration operation mode; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; RooSetProxy_jacListSet of lvalue observables over which is analytically integration that have a non-unit Jacobia",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:35529,access,access,35529,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,2,['access'],['access']
Security,"ate:. Int_tfRSAKeyType of RSA key used. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootSecContext.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-11-02 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootSecContext.html:7246,secur,security,7246,root/html528/TRootSecContext.html,https://root.cern,https://root.cern/root/html528/TRootSecContext.html,1,['secur'],['security']
Security,"ate:. Int_tfRSAKeyType of RSA key used. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootSecContext.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRootSecContext.html:7315,secur,security,7315,root/html530/TRootSecContext.html,https://root.cern,https://root.cern/root/html530/TRootSecContext.html,1,['secur'],['security']
Security,"ate:. Int_tfRSAKeyType of RSA key used. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootSecContext.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootSecContext.html:7315,secur,security,7315,root/html532/TRootSecContext.html,https://root.cern,https://root.cern/root/html532/TRootSecContext.html,1,['secur'],['security']
Security,"ategory() [3/4]. RooCategory::RooCategory ; (; const char * ; name, . const char * ; title, . const std::map< std::string, int > & ; allowedStates . ). Create a new category and define allowed states. ; Parameters. [in]nameName used to refer to this object. ; [in]titleTitle for e.g. plotting. ; [in]allowedStatesMap of allowed states. Pass e.g. { {""0Lep"", 0}, {""1Lep:, 1} } . Definition at line 128 of file RooCategory.cxx. ◆ RooCategory() [4/4]. RooCategory::RooCategory ; (; const RooCategory & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 140 of file RooCategory.cxx. ◆ ~RooCategory(). RooCategory::~RooCategory ; (; ). override . Destructor. ; Definition at line 151 of file RooCategory.cxx. Member Function Documentation. ◆ addToRange() [1/2]. void RooCategory::addToRange ; (; const char * ; name, . const char * ; stateNameList . ). Add the list of state names to the given range. ; State names can be separated with ','. NoteThis creates or accesses a shared map with allowed ranges. All copies of this category will share this range such that a category inside a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 372 of file RooCategory.cxx. ◆ addToRange() [2/2]. void RooCategory::addToRange ; (; const char * ; name, . RooAbsCategory::value_type ; stateIndex . ). Add the given state to the given range. ; NoteThis creates or accesses a shared map with allowed ranges. All copies of this category will share this range such that a category inside a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 348 of file RooCategory.cxx. ◆ Class(). static TClass * RooCategory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCategory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCategory::Class_Version ; (; ). inlinestaticconstexp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:53931,access,accesses,53931,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['access'],['accesses']
Security,"ates(const ROOT::Math::Cylindrical3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar& rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar& zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar& phi) const. get internal data into 3 Scalar numbers ( rho, z , phi). {rho=fRho; zz=fZ; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Rho() const; accessors. { return fRho; }. Scalar Z() const; { return fZ; }. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fRho*std::cos(fPhi); }. Scalar Y() const; { return fRho*std::sin(fPhi); }. Scalar Mag2() const; { return fRho*fRho + fZ*fZ; }. Scalar R() const; { return std::sqrt( Mag2()); }. Scalar Perp2() const; { return fRho*fRho; }. Scalar Theta() const; { return (fRho==0 && fZ==0 ) ? 0 : atan2(fRho,fZ); }. Scalar Eta() const; pseudorapidity - use same implementation as in Cartesian3D. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping z and phi constant. void SetZ(Double32_t zz). set the z coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and z constant. void SetXYZ(ROOT::Math::Cylindrical3D<Double32_t>::Scalar xx, ROOT::Math::Cylindrical3D<Double32_t>::Scalar yy, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz). set all values using cartesian coordin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Cylindrical3D_Double32_t_.html:4651,access,accessors,4651,root/html526/ROOT__Math__Cylindrical3D_Double32_t_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Cylindrical3D_Double32_t_.html,5,['access'],['accessors']
Security,"ath::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::LocalCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const Scalar[] src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::LocalCoor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:11202,access,access,11202,root/html602/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,2,['access'],['access']
Security,"ath::IBaseFunctionMultiDim,ROOT::Fit::UnBinData>(const shared_ptr<ROOT::Fit::UnBinData>& data, const shared_ptr<ROOT::Fit::BasicFCN<ROOT::Math::IGradientFunctionMultiDim,ROOT::Fit::UnBinData>::IModelFunction>& func); voidSetData(const shared_ptr<ROOT::Fit::UnBinData>& data); voidSetModelFunction(const shared_ptr<ROOT::Fit::BasicFCN<ROOT::Math::IGradientFunctionMultiDim,ROOT::Fit::UnBinData>::IModelFunction>& func). Data Members; public:. static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::kLeastSquare; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::kLogLikelihood; static ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::kUndefined. protected:. shared_ptr<ROOT::Fit::UnBinData>fData; shared_ptr<ROOT::Fit::BasicFCN<ROOT::Math::IGradientFunctionMultiDim,ROOT::Fit::UnBinData>::IModelFunction>fFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; std::shared_ptr<DataType> DataPtr() const; access to data pointer. { return fData; }. std::shared_ptr<IModelFunction> ModelFunctionPtr() const; access to function pointer. { return fFunc; }. void SetData(const shared_ptr<ROOT::Fit::UnBinData>& data); Set the data pointer. { fData = data; }. void SetModelFunction(const shared_ptr<ROOT::Fit::BasicFCN<ROOT::Math::IGradientFunctionMultiDim,ROOT::Fit::UnBinData>::IModelFunction>& func); Set the function pointer. { fFunc = func; }. » Author: L. Moneta 25 Nov 2014 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__BasicFCN_-p0Math__IBaseFunctionMultiDim_-p1UnBinData_.html:4832,access,access,4832,root/html604/ROOT__Fit__BasicFCN_-p0Math__IBaseFunctionMultiDim_-p1UnBinData_.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__BasicFCN_-p0Math__IBaseFunctionMultiDim_-p1UnBinData_.html,2,['access'],['access']
Security,"ath::SVector<Double32_t,3*(3+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5561,access,access,5561,root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,1,['access'],['access']
Security,"ath::SVector<Double32_t,4*(4+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5561,access,access,5561,root/html526/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,1,['access'],['access']
Security,"ath::SVector<Double32_t,5*(5+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5561,access,access,5561,root/html526/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,1,['access'],['access']
Security,"ath::SVector<Double32_t,6*(6+1)/2>& v, bool lower = true); Double32_tTrace() const; ROOT::Math::SVector<Double32_t,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepSym<Double32_t,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array(); return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5561,access,access,5561,root/html526/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,1,['access'],['access']
Security,"atic Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; THashTable Class ReferenceCore ROOT classes » Containers. ; THashTable implements a hash table to store TObject's. ; The hash value is calculated using the value returned by the TObject's Hash() function. Each class inheriting from TObject can override Hash() as it sees fit.; THashTable does not preserve the insertion order of the objects. If the insertion order is important AND fast retrieval is needed use THashList instead. ; Definition at line 35 of file THashTable.h. Public Member Functions;  THashTable (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashTable object. ;  ; virtual ~THashTable ();  Delete a hashtable. ;  ; void Add (TObject *obj) override;  Add object to the hash table. ;  ; void AddAll (const TCollection *col) override;  Add all objects from collection col to this collection. ;  ; void AddBefore (const TObject *before, TObject *obj);  Add object to the hash table. ;  ; Float_t AverageCollisions () const;  ; void Clear (Option_t *option="""") override;  Remove all objects from the table. ;  ; Int_t Collisions (const char *name) const;  Returns the number of collisions for an object with a certain name (i.e. ;  ; Int_t Collisions (TObject *obj) const;  Returns the number of collisions for an object (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the table AND delete all heap based objects. ;  ; Bool_t Empty () const;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; const TList * GetListForObject (const char *name) const;  Return the TList corresponding to object's name based hash value. ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the TList corresponding to object's hash valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:1203,hash,hash,1203,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hash']
Security,"atic TList * GetProofAuthInfo ();  Static method returning the list with authentication directives to be sent to proof. ;  ; static Int_t GetRSAInit ();  Static method returning the RSA initialization flag. ;  ; static const char * GetRSAPubExport (Int_t key=0);  Static method returning the RSA public keys. ;  ; static THostAuth * HasHostAuth (const char *host, const char *user, Option_t *opt=""R"");  Checks if a THostAuth with exact match for {host,user} exists in the fgAuthInfo list If opt = ""P"" use ProofAuthInfo list instead Returns pointer to it or 0. ;  ; static void InitRandom ();  Initialize random machine using seed from /dev/urandom (or current time if /dev/urandom not available). ;  ; static void MergeHostAuthList (TList *Std, TList *New, Option_t *Opt="""");  Tool for updating fgAuthInfo or fgProofAuthInfo 'nin' contains list of last input information through (re)reading of a rootauthrc-alike file. ;  ; static char * PromptPasswd (const char *prompt=""Password: "");  Static method to prompt for the user's passwd to be used for authentication to rootd or proofd. ;  ; static char * PromptUser (const char *remote);  Static method to prompt for the user name to be used for authentication to rootd or proofd. ;  ; static Int_t ReadRootAuthrc ();  Read authentication directives from $ROOTAUTHRC, $HOME/.rootauthrc or <Root_etc_dir>/system.rootauthrc and create related THostAuth objects. ;  ; static void RemoveHostAuth (THostAuth *ha, Option_t *opt="""");  Remove THostAuth instance from the list. ;  ; static Int_t SecureRecv (TSocket *Socket, Int_t dec, Int_t KeyType, char **Out);  Receive str from sock and decode it using key indicated by key type Return number of received bytes or -1 in case of error. ;  ; static Int_t SecureSend (TSocket *Socket, Int_t enc, Int_t KeyType, const char *In);  Encode null terminated str using the session private key indicated by enc and sends it over the network Returns number of bytes sent, or -1 in case of error. ;  ; static Int_t SendRS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:13564,authenticat,authentication,13564,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"atic TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfArchiveNameArchive file name; TArchiveMember*fCurMemberCurrent archive member; TFile*fFileFile stream used to access the archive; Int_tfMemberIndexIndex of sub-file in archive; TStringfMemberNameSub-file name; TObjArray*fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TArchiveFile(const char* archive, const char* member, TFile* file); Specify the archive name and member name. The member can be a decimal; number which allows to access the n-th sub-file. This method is; normally only called via TFile. ~TArchiveFile(); Dtor. Long64_t GetMemberFilePosition() const; Return position in archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TArchiveFile.html:6932,access,access,6932,root/html602/TArchiveFile.html,https://root.cern,https://root.cern/root/html602/TArchiveFile.html,2,['access'],['access']
Security,"atic const char * THashTable::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 82 of file THashTable.h. ◆ Delete(). void THashTable::Delete ; (; Option_t * ; option = """"). overridevirtual . Remove all objects from the table AND delete all heap based objects. ; Implements TCollection.; Definition at line 220 of file THashTable.cxx. ◆ Empty(). Bool_t THashTable::Empty ; (; ); const. inline . Definition at line 66 of file THashTable.h. ◆ FindObject() [1/2]. TObject * THashTable::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from TCollection.; Reimplemented in TListOfTypes, and TListOfTypes.; Definition at line 238 of file THashTable.cxx. ◆ FindObject() [2/2]. TObject * THashTable::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from TCollection.; Reimplemented in TListOfTypes.; Definition at line 251 of file THashTable.cxx. ◆ GetCheckedHashValue(). Int_t THashTable::GetCheckedHashValue ; (; TObject * ; obj); const. inlineprivate . Definition at line 93 of file THashTable.h. ◆ GetHashValue() [1/3]. Int_t THashTable::GetHashValue ; (; const char * ; str); const. inlineprivate . Definition at line 48 of file THashTable.h. ◆ GetHashValue() [2/3]. Int_t THashTable::GetHashValue ; (; const TObject * ; obj); const. inlineprivate . Definition at line 99 of file THashTable.h. ◆ GetHashValue() [3/3]. Int_t THashTable::GetHashValue ; (; TString & ; s); const. inlineprivate . Definition at line 47 of file THashTable.h. ◆ GetListForObject() [1/2]. const TList * THashTable::GetListForObject ; (; const char * ; name); const. Return the TList corresponding to object's name based hash value. ; One can iterate this list ""manually"" to find, e.g. objects with the same name. ; Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:20760,hash,hash,20760,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hash']
Security,"atic constexpr Version_t TPair::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 124 of file TMap.h. ◆ DeclFileName(). static const char * TPair::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 124 of file TMap.h. ◆ GetName(). const char * TPair::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 116 of file TMap.h. ◆ GetTitle(). const char * TPair::GetTitle ; (; ); const. inlineoverridevirtual . Returns title of object. ; This default method returns the class title (i.e. description). Classes that give objects a title should override this method. ; Reimplemented from TObject.; Definition at line 117 of file TMap.h. ◆ Hash(). ULong_t TPair::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPair.html:12019,hash,hash,12019,doc/master/classTPair.html,https://root.cern,https://root.cern/doc/master/classTPair.html,1,['hash'],['hash']
Security,"atic function.; The color palette is used by the histogram classes; (see TH1::Draw options).; For example TH1::Draw(""col"") draws a 2-D histogram with cells; represented by a box filled with a color CI function of the cell content.; if the cell content is N, the color CI used will be the color number; in colors[N],etc. If the maximum cell content is > ncolors, all; cell contents are scaled to ncolors.; ; if ncolors <= 0 a default palette (see below) of 50 colors is; defined. The colors defined in this palette are OK for coloring pads, labels.; . index 0->9 : grey colors from light to dark grey; index 10->19 : ""brown"" colors; index 20->29 : ""blueish"" colors; index 30->39 : ""redish"" colors; index 40->49 : basic colors; . if ncolors == 1 && colors == 0, a Rainbow Color map is created; with 50 colors. It is kept for backward compatibility. Better palettes like; kBird are recommended.; ; High quality predefined palettes with 255 colors are available when colors == 0.; The following value of ncolors give access to:; . if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a Two-Color Hue palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an Inverted Dark Body Radiator palette is used.; if ncolors = 57 and colors=0, a monotonically increasing L value palette is used.; if ncolors = 58 and colors=0, a Cubehelix palette is used; (Cf. Dave Green's ""cubehelix"" colour scheme at http://www.mrao.cam.ac.uk/~dag/CUBEHELIX/); if ncolors = 59 and colors=0, a Green Red Violet palette is used.; if ncolors = 60 and colors=0, a Blue Red Yellow palette is used.; if ncolors = 61 and colors=0, an Ocean palette is used.; if ncolors = 62 and colors=0, a Color Printable On Grey palette is used.; if ncolors = 63 and colors=0, an Alpi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TColor.html:28325,access,access,28325,root/html604/TColor.html,https://root.cern,https://root.cern/root/html604/TColor.html,1,['access'],['access']
Security,"atic void * next(void *iter_loc, const void *end_loc)Definition TCollectionProxyInfo.h:108; ROOT::Detail::TCollectionProxyInfo::Iterators::copystatic void * copy(void *dest_arena, const void *source_ptr)Definition TCollectionProxyInfo.h:103; ROOT::Detail::TCollectionProxyInfo::Iterators::destruct2static void destruct2(void *begin_ptr, void *end_ptr)Definition TCollectionProxyInfo.h:122; ROOT::Detail::TCollectionProxyInfo::Iterators::createstatic void create(void *coll, void **begin_arena, void **end_arena, TVirtualCollectionProxy *)Definition TCollectionProxyInfo.h:98; ROOT::Detail::TCollectionProxyInfo::Iterators::PCont_tCont_t * PCont_tDefinition TCollectionProxyInfo.h:95; ROOT::Detail::TCollectionProxyInfo::Iterators::iteratorCont_t::iterator iteratorDefinition TCollectionProxyInfo.h:96; ROOT::Detail::TCollectionProxyInfo::Iterators::destruct1static void destruct1(void *iter_ptr)Definition TCollectionProxyInfo.h:118; ROOT::Detail::TCollectionProxyInfo::MapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc.Definition TCollectionProxyInfo.h:474; ROOT::Detail::TCollectionProxyInfo::MapInsert::Iter_tT::iterator Iter_tDefinition TCollectionProxyInfo.h:476; ROOT::Detail::TCollectionProxyInfo::MapInsert::Cont_tT Cont_tDefinition TCollectionProxyInfo.h:475; ROOT::Detail::TCollectionProxyInfo::MapInsert::resizestatic void resize(void *, size_t)Definition TCollectionProxyInfo.h:489; ROOT::Detail::TCollectionProxyInfo::MapInsert::PValue_tValue_t * PValue_tDefinition TCollectionProxyInfo.h:481; ROOT::Detail::TCollectionProxyInfo::MapInsert::PEnv_tEnv_t * PEnv_tDefinition TCollectionProxyInfo.h:479; ROOT::Detail::TCollectionProxyInfo::MapInsert::value_offsetstatic int value_offset()Definition TCollectionProxyInfo.h:492; ROOT::Detail::TCollectionProxyInfo::MapInsert::Value_tT::value_type Value_tDefinition TCollectionProxyInfo.h:477; ROOT::Detail::TCollectionProxyInfo::MapInsert::Env_tEnviron< Iter_t > Env_tDefinition TCollection",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:42859,access,accesses,42859,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['access'],['accesses']
Security,"atimefgExpDateExpiring date for new security contexts; static GlobusAuth_tfgGlobusAuthHook; static Krb5Auth_tfgKrb5AuthHook; static TStringfgKrb5PrincipalPrincipal for Krb5 ticket; static TDatimefgLastAuthrcTime of last reading of fgRootAuthrc; static Int_tfgLastErrorLast error code processed by AuthError(); static TStringfgPasswd; static TPluginHandler*fgPasswdDialogPasswd dialog GUI plugin; static Int_tfgProcessIDID of the main thread as unique identifier; static Bool_tfgPromptUserkTRUE if user prompt required; static TList*fgProofAuthInfoSpecific lists of THostAuth fro proof; static Bool_tfgPwHashkTRUE if fgPasswd is a passwd hash; static Int_tfgRSAInit; static Int_tfgRSAKeyDefault type of RSA key to be tried; static rsa_KEYfgRSAPriKey; static rsa_KEY_exportfgRSAPubExport[2]; static rsa_KEYfgRSAPubKey; static Bool_tfgReadHomeAuthrckTRUE to look for $HOME/.rootauthrc; static TStringfgRootAuthrcPath to last rootauthrc-like file read; static Bool_tfgSRPPwdkTRUE if fgPasswd is a SRP passwd; static SecureAuth_tfgSecAuthHook; static TStringfgUser; static Bool_tfgUsrPwdCryptkTRUE if encryption for UsrPwd is required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAuthenticate(TSocket* sock, const char* remote, const char* proto, const char* user = """"); Create authentication object. void CatchTimeOut(); Called in connection with a timer timeout. Bool_t Authenticate(); Authenticate to remote rootd or proofd server. Return kTRUE if; authentication succeeded. void SetEnvironment(); Set default authentication environment. The values are inferred; from fSecurity and fDetails. Bool_t GetUserPasswd(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from several sources. Bool_t CheckNetrc(TString& user, TString& passwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. For more info see the version with 4 arguments.; This version is maintained for backward compatabil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:10970,encrypt,encryption,10970,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['encrypt'],['encryption']
Security,"ation, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. UChar_tParseStagePriority(Option_t* opt). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TNetXNGSystem*fSystemUsed to access filesystem interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFileStager(const char* url = """"); Constructor. param url: the URL of the entry-point server. ~TNetXNGFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if a file is staged. param path: the URL of the file. Int_t Locate(const char* path, TString& endpath); Get actual endpoint URL. param path: the entry-point URL; param endpath: the actual endpoint URL; returns: 0 in the case of success and 1 if any error occurred. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. param fc: collection of files to be located; param addDummyUrl: append a dummy noop URL if the file is not staged or; redirector == endpoint; returns: < 0 in case of errors, number of files processed; otherwise. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager. Avoids; mult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGFileStager.html:6739,access,access,6739,root/html602/TNetXNGFileStager.html,https://root.cern,https://root.cern/root/html602/TNetXNGFileStager.html,2,['access'],['access']
Security,"ation->HandleTermInput();; 134}; 135 ; 136 ; 137ClassImp(TRint);; 138 ; 139 ; 140namespace {; 141static int SetExtraClingArgsBeforeTAppCtor(Int_t *argc, char **argv); 142{; 143 bool forcePtrCheck = false;; 144 if (argc != nullptr) {; 145 for (int iarg = 1; iarg < *argc; ++iarg) {; 146 if (!strcmp(argv[iarg], ""--ptrcheck"")) {; 147 // Hide this, by moving all other args one down...; 148 for (int jarg = iarg + 1; jarg < *argc; ++jarg); 149 argv[jarg - 1] = argv[jarg];; 150 // ... and updating argc accordingly.; 151 --*argc;; 152 forcePtrCheck = true;; 153 break;; 154 }; 155 }; 156 }; 157#ifdef R__UNIX; 158 if (forcePtrCheck || isatty(0) || isatty(1)); 159#endif; 160 TROOT::AddExtraInterpreterArgs({""--ptrcheck""});; 161 return 0;; 162}; 163}; 164 ; 165////////////////////////////////////////////////////////////////////////////////; 166/// Create an application environment. The TRint environment provides an; 167/// interface to the WM manager functionality and eventloop via inheritance; 168/// of TApplication and in addition provides interactive access to; 169/// the Cling C++ interpreter via the command line.; 170 ; 171TRint::TRint(const char *appClassName, Int_t *argc, char **argv, void *options, Int_t numOptions, Bool_t noLogo,; 172 Bool_t exitOnUnknownArgs); 173 : TApplication(appClassName, argc, argv, options, numOptions + SetExtraClingArgsBeforeTAppCtor(argc, argv)),; 174 fCaughtSignal(-1); 175{; 176 ; 177 if (exitOnUnknownArgs && argc != nullptr && *argc > 1) {; 178 // Early exit if there are remaining unrecognized options; 179 // This branch supposes that TRint is created as a result of using the `root` command; 180 for (auto n = 1; n < *argc; n++) {; 181 std::cerr << ""root: unrecognized option '"" << argv[n] << ""'\n"";; 182 }; 183 std::cerr << ""Try 'root --help' for more information.\n"";; 184 TApplication::Terminate(0);; 185 }; 186 ; 187 fNcmd = 0;; 188 fDefaultPrompt = ""root [%d] "";; 189 fInterrupt = kFALSE;; 190 ; 191 gBenchmark = new TBenchmark();; 192 ; 193 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:5127,access,access,5127,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['access'],['access']
Security,"ation. ◆ TExMap() [1/2]. TExMap::TExMap ; (; Int_t ; mapSize = 100). Create a TExMap. ; Definition at line 32 of file TExMap.cxx. ◆ TExMap() [2/2]. TExMap::TExMap ; (; const TExMap & ; map). Copy constructor. ; Definition at line 53 of file TExMap.cxx. ◆ ~TExMap(). TExMap::~TExMap ; (; ). Delete TExMap. ; Definition at line 80 of file TExMap.cxx. Member Function Documentation. ◆ Add() [1/2]. void TExMap::Add ; (; Long64_t ; key, . Long64_t ; value . ). inline . Definition at line 66 of file TExMap.h. ◆ Add() [2/2]. void TExMap::Add ; (; ULong64_t ; hash, . Long64_t ; key, . Long64_t ; value . ). Add an (key,value) pair to the table. The key should be unique. ; Definition at line 88 of file TExMap.cxx. ◆ AddAt(). void TExMap::AddAt ; (; UInt_t ; slot, . ULong64_t ; hash, . Long64_t ; key, . Long64_t ; value . ). Add an (key,value) pair to the table. ; The key should be unique. If the 'slot' is open, use it to store the value, otherwise revert to Add(hash,key,value) This is usually used in conjunction with GetValue with 3 parameters: if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {; ...; } else {; fMap->AddAt(slot,hash,key,value);; }; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142. Definition at line 117 of file TExMap.cxx. ◆ Capacity(). Int_t TExMap::Capacity ; (; ); const. inline . Definition at line 69 of file TExMap.h. ◆ Class(). static TClass * TExMap::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TExMap::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TExMap::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file TExMap.h. ◆ DeclFileName(). static const char * TExMap::DeclFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:12781,hash,hash,12781,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,2,['hash'],['hash']
Security,"atistic::GetN ; (; ); const. inline . Definition at line 55 of file TStatistic.h. ◆ GetName(). const char * TStatistic::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 52 of file TStatistic.h. ◆ GetNeff(). Long64_t TStatistic::GetNeff ; (; ); const. inline . Definition at line 56 of file TStatistic.h. ◆ GetRMS(). Double_t TStatistic::GetRMS ; (; ); const. inline . Definition at line 60 of file TStatistic.h. ◆ GetVar(). Double_t TStatistic::GetVar ; (; ); const. inline . Definition at line 61 of file TStatistic.h. ◆ GetW(). Double_t TStatistic::GetW ; (; ); const. inline . Definition at line 62 of file TStatistic.h. ◆ GetW2(). Double_t TStatistic::GetW2 ; (; ); const. inline . Definition at line 63 of file TStatistic.h. ◆ Hash(). ULong_t TStatistic::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatistic.html:15007,hash,hash,15007,doc/master/classTStatistic.html,https://root.cern,https://root.cern/doc/master/classTStatistic.html,1,['hash'],['hash']
Security,"ative event weights; Bool_tfDynamicis set when the dynamic values are taken; vector<Float_t>fSpectators""visisting"" variables not used in MVAs; vector<Float_t>fTargetstarget values for regression; vector<Float_t>fValuesthe event values; vector<Float_t*>*fValuesDynamicthe event values; Double_tfWeightevent weight (product of global and individual weights). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); Create an Event object.; When the constructor is invoked for the first time, the class static; variable fgTracks is 0 and the TClonesArray fgTracks is created. ~Event(). Event(); constructors. Event(const TMVA::Event& ). explicit Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1.0, Double_t boostweight = 1.0). explicit Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1.0, Double_t boostweight = 1.0). Bool_t IsDynamic() const; accessors. {return fDynamic; }. Double_t GetWeight() const; { return fWeight*fBoostWeight; }. Double_t GetOriginalWeight() const; { return fWeight; }. Double_t GetBoostWeight() const; { return TMath::Max(Double_t(0.0001),fBoostWeight); }. UInt_t GetClass() const; { return fClass; }. UInt_t GetNVariables() const. UInt_t GetNTargets() const. UInt_t GetNSpectators() const. Float_t GetValue(UInt_t ivar) const. const std::vector<Float_t>& GetValues() const. Float_t GetTarget(UInt_t itgt) const; { return fTargets.at(itgt); }. std::vector<Float_t>& GetTargets() const; { return fTargets; }. Float_t GetSpectator(UInt_t ivar) const. std::vector<Float_t>& GetSpectators() const; { return fSpectators; }. void ScaleWeight(Double_t s); { fWeight*=s; }. void SetWeight(Double_t w); { fWeight=w; }. void SetBoostWeight(Double_t w); { fDoNotBoost ? fDoNotBoost = kFALSE : fBoostWeight=w; }. void ScaleBoostWeight(Double_t s); { fDoNotBoost ? fDoNotBoost = kFALSE : fBoostWeight *= s; }. void SetClass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__Event.html:5866,access,accessors,5866,root/html530/TMVA__Event.html,https://root.cern,https://root.cern/root/html530/TMVA__Event.html,2,['access'],['accessors']
Security,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last chan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_3_.html:6214,access,access,6214,root/html528/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_Double32_t_3_.html,12,['access'],['access']
Security,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const Double32_t& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const Double32_t& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const Double32_t* p) const. Function to check if a vector is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_Double32_t_3_.html:6256,access,access,6256,root/html534/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_Double32_t_3_.html,4,['access'],['access']
Security,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_double_2_.html:5694,access,access,5694,root/html528/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_double_2_.html,18,['access'],['access']
Security,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const double* p) const. Function to check if a vector is sharing sam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html:5732,access,access,5732,root/html534/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_double_2_.html,26,['access'],['access']
Security,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html:5564,access,access,5564,root/html528/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SVector_float_2_.html,18,['access'],['access']
Security,"ator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i) const; read-only access of vector elements. Index starts from 0. const T& At(unsigned int i) const; read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const float& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const float& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of length 1. bool IsInUse(const float* p) const. Function to check if a vector is sharing same m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SVector_float_2_.html:5601,access,access,5601,root/html534/ROOT__Math__SVector_float_2_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SVector_float_2_.html,18,['access'],['access']
Security,"ator bool() { return !empty(); }; 32 const TSchemaRule* GetRuleWithSource( const TString& name ) const;; 33 const TSchemaRule* GetRuleWithTarget( const TString& name ) const;; 34 Bool_t HasRuleWithSource( const TString& name, Bool_t needingAlloc ) const;; 35 Bool_t HasRuleWithTarget( const TString& name, Bool_t willset ) const;; 36 };; 37 ; 38 enum EConsistencyCheck {; 39 kNoCheck = 0,; 40 kCheckAll = 1,; 41 kCheckConflict = 2; 42 };; 43 ; 44 TSchemaRuleSet();; 45 virtual ~TSchemaRuleSet();; 46 ; 47 Bool_t AddRule(TSchemaRule *rule, EConsistencyCheck checkConsistency = kCheckAll, TString *errmsg = nullptr);; 48 Bool_t AddRules(TSchemaRuleSet *rules, EConsistencyCheck checkConsistency = kCheckAll, TString *errmsg = nullptr);; 49 Bool_t HasRuleWithSourceClass( const TString &source) const;; 50 const TMatches FindRules( const TString &source ) const;; 51 const TMatches FindRules( const TString &source, Int_t version ) const;; 52 const TMatches FindRules( const TString &source, UInt_t checksum ) const;; 53 const TMatches FindRules( const TString &source, Int_t version, UInt_t checksum ) const;; 54 TClass* GetClass();; 55 UInt_t GetClassCheckSum() const;; 56 TString GetClassName() const;; 57 Int_t GetClassVersion() const;; 58 const TObjArray* GetRules() const;; 59 const TObjArray* GetPersistentRules() const;; 60 void RemoveRule( TSchemaRule* rule );; 61 void RemoveRules( TObjArray* rules );; 62 void SetClass( TClass* cls );; 63 ; 64 void ls(Option_t *option="""") const override;; 65 void AsString(TString &out) const;; 66 ; 67 private:; 68 TObjArray* fPersistentRules; // Array of the rules that will be embeded in the file; 69 TObjArray* fRemainingRules; //! Array of non-persistent rules - just for cleanup purposes - owns the elements; 70 TObjArray* fAllRules; //! Array of all rules; 71 TClassRef fClass; //! Target class pointer (for consistency checking); 72 TString fClassName; // Target class name; 73 Int_t fVersion; // Target class version; 74 UInt_t fCheckSum; // Target c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRuleSet_8h_source.html:1743,checksum,checksum,1743,doc/master/TSchemaRuleSet_8h_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRuleSet_8h_source.html,1,['checksum'],['checksum']
Security,"ator end(); STL iterator interface. . const_iterator begin(); STL const_iterator interface. . const_iterator end(); STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j). read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](int j); { return (*fMat)(fRow,j); }. const T & operator[](int j); { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfull.; The method used for general square matrices is the LU factorization taken from Dinv routine; from the CERNLIB (written in C++ from CLHEP authors); In case of symmetric matrices Bunch-Kaufman diagonal pivoting method is used; (The implementation is the one written by the CLHEP authors). SMatri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7420,access,access,7420,root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,8,['access'],['access']
Security,"ator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const float& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const float& rhs) const; element wise comparison. bool operator<(const float& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const float& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const float& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const float& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const float& rhs). division with a scalar. bool Invert(); @name --- Linear Algebra Functions --- . Invert a square Matrix ( this method changes the current matrix).; Return true if inversion is successfu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:6750,access,access,6750,root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,90,['access'],['access']
Security,"atrix (double *hMat) const;  Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. ;  ; virtual bool GetMinosError (unsigned int ivar, double &errLow, double &errUp, int option=0);  minos error for variable i, return false if Minos failed or not supported and the lower and upper errors are returned in errLow and errUp An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run ;  ; virtual double GlobalCC (unsigned int ivar) const;  return global correlation coefficient for variable i This is a number between zero and one which gives the correlation between the i-th parameter and that linear combination of all other parameters which is most strongly correlated with i. ;  ; virtual bool Hesse ();  perform a full calculation of the Hessian matrix for error calculation ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual const double * MinGradient () const;  return pointer to gradient values at the minimum ;  ; virtual int MinosStatus () const;  status code of Minos (to be re-implemented by the minimizers supporting Minos) ;  ; virtual unsigned int NCalls () const;  number of function calls to reach the minimum ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 correspon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BasicMinimizer.html:7156,validat,validation,7156,doc/master/classROOT_1_1Math_1_1BasicMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BasicMinimizer.html,1,['validat'],['validation']
Security,"atrix (double *hMat) const;  Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. ;  ; virtual bool GetMinosError (unsigned int ivar, double &errLow, double &errUp, int option=0);  minos error for variable i, return false if Minos failed or not supported and the lower and upper errors are returned in errLow and errUp An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run ;  ; virtual double GlobalCC (unsigned int ivar) const;  return global correlation coefficient for variable i This is a number between zero and one which gives the correlation between the i-th parameter and that linear combination of all other parameters which is most strongly correlated with i. ;  ; virtual bool Hesse ();  perform a full calculation of the Hessian matrix for error calculation ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual const double * MinGradient () const;  return pointer to gradient values at the minimum ;  ; virtual int MinosStatus () const;  status code of Minos (to be re-implemented by the minimizers supporting Minos) ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html:8547,validat,validation,8547,doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLSimAnMinimizer.html,2,['validat'],['validation']
Security,"atrix (double *hMat) const;  Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. ;  ; virtual bool GetMinosError (unsigned int ivar, double &errLow, double &errUp, int option=0);  minos error for variable i, return false if Minos failed or not supported and the lower and upper errors are returned in errLow and errUp An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run ;  ; virtual double GlobalCC (unsigned int ivar) const;  return global correlation coefficient for variable i This is a number between zero and one which gives the correlation between the i-th parameter and that linear combination of all other parameters which is most strongly correlated with i. ;  ; virtual bool Hesse ();  perform a full calculation of the Hessian matrix for error calculation ;  ; bool IsValidError () const;  return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit) ;  ; unsigned int MaxFunctionCalls () const;  max number of function calls ;  ; unsigned int MaxIterations () const;  max iterations ;  ; virtual int MinosStatus () const;  status code of Minos (to be re-implemented by the minimizers supporting Minos) ;  ; virtual unsigned int NIterations () const;  number of iterations to reach the minimum ;  ; Minimizer & operator= (Minimizer &&)=delete;  ; Minimizer & operator= (Minimizer const &)=delete;  ; virtual MinimizerOptions Options () const;  retrieve the minimizer options (implement derived class if needed) ;  ; double Precision () const;  precision of minimizer in the evaluation of the objective function ( a value <=0 corresponds to the let the minimizer choose its default one) ;  ; int PrintLevel () const;  minimizer configuration parameters ;  ; virtual void PrintResults ();  return reference to the objective fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMinimizer.html:7793,validat,validation,7793,doc/master/classROOT_1_1Math_1_1GSLMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMinimizer.html,2,['validat'],['validation']
Security,"atrix::SubColSubVector SubCol(unsigned int thecol, unsigned int row0=0) constreturn a slice of the column as a vector starting at the row value row0 until row0+Dsub.Definition SMatrix.icc:728; ROOT::Math::SMatrix::operator>bool operator>(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:347; ROOT::Math::SMatrix::Printstd::ostream & Print(std::ostream &os) constPrint: used by operator<<()Definition SMatrix.icc:603; ROOT::Math::SMatrix::operator=SMatrix< T, D1, D2, R > & operator=(const M &rhs)Assign from another compatible matrix.Definition SMatrix.icc:155; ROOT::Math::SMatrix::Place_atSMatrix< T, D1, D2, R > & Place_at(const SMatrix< T, D3, D4, R2 > &rhs, unsigned int row, unsigned int col)place a matrix in this matrixDefinition SMatrix.icc:552; ROOT::Math::SMatrix::InverseSMatrix< T, D1, D2, R > Inverse(int &ifail) constInvert a square Matrix and returns a new matrix.Definition SMatrix.icc:419; ROOT::Math::SMatrix::operator[]SMatrixRow operator[](unsigned int i)read/write access to matrix element with indices starting from 0 : m[i][j]Definition SMatrix.h:402; ROOT::Math::SMatrix::SubSubMatrix Sub(unsigned int row0, unsigned int col0) constreturn a submatrix with the upper left corner at the values (row0, col0) and with sizes N1,...Definition SMatrix.icc:745; ROOT::Math::SMatrix::operator*=SMatrix< T, D1, D2, R > & operator*=(const T &rhs)multiplication with a scalarDefinition SMatrix.icc:258; ROOT::Math::SMatrix::operator<bool operator<(const T &rhs) constelement wise comparisonDefinition SMatrix.icc:379; ROOT::Math::SMatrix::beginiterator begin()STL iterator interface.Definition SMatrix.icc:670; ROOT::Math::SMatrix::SetElementsvoid SetElements(InputIterator begin, InputIterator end, bool triang=false, bool lower=true)Set matrix elements with STL iterator interface.Definition SMatrix.icc:692; ROOT::Math::SMatrix::fRepR fRepMatrix Storage Object containing matrix data.Definition SMatrix.h:683; ROOT::Math::SMatrix::SMatrixSMatrix(SMatrixNoInit)construc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SMatrix_8h_source.html:27869,access,access,27869,doc/master/SMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/SMatrix_8h_source.html,1,['access'],['access']
Security,"ats SamplingDistributions ;  CToyMCImportanceSamplerToyMCImportanceSampler is an extension of the ToyMCSampler for Importance Sampling ;  CToyMCPayload;  CToyMCSamplerToyMCSampler is an implementation of the TestStatSampler interface ;  CToyMCStudyToyMCStudy is an implementation of RooAbsStudy for toy Monte Carlo sampling ;  CUniformProposalUniformProposal is a concrete implementation of the ProposalFunction interface for use with a Markov Chain Monte Carlo algorithm ;  CUpperLimitMCSModuleThis class allow to compute in the ToyMcStudy framework the ProfileLikelihood upper limit for each toy-MC sample generated ;  ►NROOTThis namespace contains pre-defined functions to be used in conjuction with TExecutor::Map and TExecutor::MapReduce ;  ►NDetail;  CTBranchProxyBase class for all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CEnvironSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CIteratorsSmall helper to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< bool > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  ►",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:10455,access,accesses,10455,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['access'],['accesses']
Security,"atsDefinition TVirtualPerfStats.h:96; R__WRITE_LOCKGUARD#define R__WRITE_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:157; R__READ_LOCKGUARD#define R__READ_LOCKGUARD(mutex)Definition TVirtualRWMutex.h:154; O_BINARY#define O_BINARYDefinition civetweb.c:912; snprintf#define snprintfDefinition civetweb.c:1540; ROOT::Detail::TSchemaRuleSet::TMatchesDefinition TSchemaRuleSet.h:29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFile.h:56; TArchiveFile::SetCurrentMembervirtual Int_t SetCurrentMember()=0; TArchiveFile::GetArchiveNameconst char * GetArchiveName() constDefinition TArchiveFile.h:55; TArchiveFi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:199431,hash,hash,199431,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['hash'],['hash']
Security,"attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:42272,access,access,42272,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,1,['access'],['access']
Security,"attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide other implementations of errno. With respect to ROOT, a thread specific data is for example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the kernel scheduler). All threads share the same address space. This means that two pointers having the same value in two threads refer to the same data. Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. This thread is called the initial thread or the main thread. The initial thread executes the main routine in multi-threaded programs.; Note: At the end of this chapter is a glossary of thread specific terms; 23.2 Implementation of Threads in ROOT; The TThread class has been developed to provide a platform indepen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1102757,access,accessed,1102757,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessed']
Security,"ault);  Open function for TDavixFile. ;  ;  ~TDavixFile ();  ; std::string DiscoverToken ();  ; void enableGridMode ();  Enable the grid mode The grid Mode configure automatically all grid-CA path, VOMS authentication and grid related extension for a grid analysis usage. ;  ; virtual TString GetNewUrl ();  ; virtual Long64_t GetSize () const;  Returns the current file size. ;  ; virtual TClass * IsA () const;  ; virtual Bool_t ReadBuffer (char *buf, Int_t len);  Read specified byte range from remote file via HTTP. ;  ; virtual Bool_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Read a buffer from the file at the offset 'pos' in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read the nbuf blocks described in arrays pos and len. ;  ; virtual void Seek (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; void setCACheck (Bool_t check);  Enable or disable certificate authority check. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Bool_t WriteBuffer (const char *buffer, Int_t bufferLength);  Write a buffer to the file. ;  ;  Public Member Functions inherited from TFile;  TFile ();  File default Constructor. ;  ;  TFile (const char *fname, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Opens or creates a local ROOT file. ;  ;  ~TFile () override;  File destructor. ;  ; void Close (Option_t *option="""") override;  Close a file. ;  ; void Copy (TObject &) const override;  Copy this to obj. ;  ; virtual Bool_t Cp (const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy this file to the dst URL. ;  ; virtual TKey * CreateKey (TDirectory *mother, const TObject *obj, const char *name, Int_t bufsize);  Creates key for object ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:1529,certificate,certificate,1529,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['certificate'],['certificate']
Security,"aultConstructor() const; virtual ULong_tTNamed::Hash() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tIsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); Bool_tMatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:8506,checksum,checksum,8506,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['checksum'],['checksum']
Security,"automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:4761,access,accessed,4761,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['access'],['accessed']
Security,"available -1 is returned. Opt can be used to require client authentication; valid options are. kSrvAuth = require client authentication; kSrvNoAuth = force no client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ); Check authentication request from the client on new; open connection. TServerSocket(); { }. TServerSocket(const TServerSocket& ). void operator=(const TServerSocket& ). Int_t Send(const TMessage& ); { MayNotUse(""Send(const TMessage &)""); return 0; }. Int_t Send(Int_t ); { MayNotUse(""Send(Int_t)""); return 0; }. Int_t Send(Int_t , Int_t ); { MayNotUse(""Send(Int_t, Int_t)""); return 0; }. Int_t Send(const char* , Int_t = kMESS_STRING); { MayNotUse(""Send(const char *, Int_t)""); return 0; }. Int_t SendObject(const TObject* , Int_t = kMESS_OBJECT); { MayNotUse(""SendObject(const TObject *, Int_t)""); return 0; }. Int_t SendRaw(const void* , Int_t , ESendRecvOptions = kDefault); { MayNotUse(""SendRaw(const void *, Int_t, ESendRecvOptions)""); return 0; }. Int_t Recv(TMessage*& ); { MayNotUse(""Recv(TMessage *&)""); return 0; }. Int_t Recv(Int_t& , Int_t& ); { M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:13982,authenticat,authentication,13982,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,2,['authenticat'],['authentication']
Security,"ave to call this method to let RWebWindowsManager correctly recognize such situation. ;  ; static std::shared_ptr< RWebWindowsManager > & Instance ();  Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel. ;  ; static bool IsLoopbackMode ();  Returns true if loopback mode used by THttpServer for web widgets. ;  ; static bool IsMainThrd ();  Returns true when called from main process Main process recognized at the moment when library is loaded It supposed to be a thread where gApplication->Run() will be called If application runs in separate thread, one have to use AssignMainThrd() method to let RWebWindowsManager correctly recognize such situation. ;  ; static void SetLoopbackMode (bool on=true);  Set loopback mode for THttpServer used for web widgets By default is on. ;  ; static void SetUseConnectionKey (bool on=true);  Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection) to widget requires unique key Connection key used together with session key to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  ; static void SetUseSessionKey (bool on=true);  Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ;  . Private Member Functions; bool CreateServer (bool with_http=false);  Creates http server, if required - with real http engine (civetweb) One could configure concrete HTTP port, which should be used for the server, provide following entry in rootrc file: ;  ; float GetLaunchTmout () const;  Returns timeout for launching new browser process. ;  ; std::string GetUrl (RWebWindow &win, bool remote=false, std::string *produced_key=nullptr);  Provide URL address to access specified window from inside or from remote. ;  ; bool InformListener (const std::string &msg)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:2818,hash,hash,2818,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['hash'],['hash']
Security,"avior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGSystem.html:17311,access,access,17311,root/html534/TNetXNGSystem.html,https://root.cern,https://root.cern/root/html534/TNetXNGSystem.html,9,['access'],['access']
Security,"aw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetCurrentClass() const; voidGetCurrentModule(TString& out_module) const; const TList*GetDataMembers(TDocParser::EAccess access) const; TDocOutput*GetDocOutput() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*GetEnums(TDocParser::EAccess access) const; virtual const char*TObject::GetIconName() const; Long_tGetLineNumber() const; const TList*GetMethods(TDocParser::EAccess access) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetSourceInfo(TDocParser::ESourceInfo type) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; UInt_tInContext(Int_t context) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocParser.html:3155,access,access,3155,root/html528/TDocParser.html,https://root.cern,https://root.cern/root/html528/TDocParser.html,5,['access'],['access']
Security,"awFuncPtr! Conversion function pointer for readraw rule; ROOT::TSchemaRule::RuleType_tfRuleTypeType of the rule; TStringfSourceSource data member string; TStringfSourceClassSource class; TObjArray*fSourceVect! Source data member vector (for searching purposes); TStringfTargetTarget data mamber string; TStringfTargetClassTarget class, this is the owner of this rule object.; TObjArray*fTargetVect! Target data member vector (for searching purposes); TStringfVersionSource version string; vector<pair<Int_t,Int_t> >*fVersionVect! Source version vector (for searching purposes). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRule(). virtual ~TSchemaRule(). TSchemaRule(const ROOT::TSchemaRule& rhs). void Clear(Option_t* = """"). Bool_t SetFromRule(const char* rule). const char * GetVersion() const. Bool_t SetVersion(const TString& version). Bool_t TestVersion(Int_t version) const. Bool_t SetChecksum(const TString& checksum). Bool_t TestChecksum(UInt_t checksum) const. void SetSourceClass(const TString& classname). const char * GetSourceClass() const. void SetTargetClass(const TString& classname). const char * GetTargetClass() const. void SetTarget(const TString& target). const TObjArray* GetTarget() const. const char * GetTargetString() const. void SetSource(const TString& source). const TObjArray* GetSource() const. void SetEmbed(Bool_t embed). Bool_t GetEmbed() const. Bool_t IsAliasRule() const. Bool_t IsRenameRule() const. Bool_t IsValid() const. void SetCode(const TString& code). const char * GetCode() const. void SetAttributes(const TString& attributes). const char * GetAttributes() const. Bool_t HasTarget(const TString& target) const. Bool_t HasSource(const TString& source) const. void SetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr). ReadFuncPtr_t GetReadFunctionPointer() const. void SetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr). ReadRawFuncPtr_t GetReadRawFunctionPointer() const. void S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TSchemaRule.html:9137,checksum,checksum,9137,root/html602/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html602/ROOT__TSchemaRule.html,2,['checksum'],['checksum']
Security,"ax to define systematic variations. This is done in two steps: a) register variations for one or more existing columns using Vary() and b) extract variations of normal RDataFrame results using VariationsFor(). In between these steps, no other change to the analysis code is required: the presence of systematic variations for certain columns is automatically propagated through filters, defines and actions, and RDataFrame will take these dependencies into account when producing varied results. VariationsFor() is included in header ROOT/RDFHelpers.hxx. The compiled C++ programs must include this header explicitly, this is not required for ROOT macros.; An example usage of Vary() and VariationsFor() in C++:; auto nominal_hx =; df.Vary(""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); .Filter(""pt > pt_cut""); .Define(""x"", someFunc, {""pt""}); .Histo1D<float>(""x"");; ; // request the generation of varied results from the nominal_hx; ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; ; // the event loop runs here, upon first access to any of the results or varied results:; hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; ROOT::RDF::Experimental::RResultMapDefinition RResultMap.hxx:98; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second to the tag ""up""). The full variation name will be composed of the varied column name and the variation tags (e.g. ""pt:down"", ""pt:up"" in this exampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:53825,access,access,53825,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['access'],['access']
Security,"axMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; RooRealVar*_yvarY v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooXYChi2Var.html:37018,access,access,37018,root/html532/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html532/RooXYChi2Var.html,1,['access'],['access']
Security,"axisTAxis fXaxisX axis descriptor.Definition TH1.h:90; TH1::fSumw2TArrayD fSumw2Array of sum of squares of weights.Definition TH1.h:104; TH1::GetStatOverflowsBehaviourBool_t GetStatOverflowsBehaviour() constDefinition TH1.h:152; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752; TH1::Sumw2virtual void Sumw2(Bool_t flag=kTRUE)Create structure to store sum of squares of weights.Definition TH1.cxx:9020; TH1::SetEntriesvirtual void SetEntries(Double_t n)Definition TH1.h:391; TH1::fTsumwxDouble_t fTsumwxTotal Sum of weight*X.Definition TH1.h:98; THLimitsFinder::GetLimitsFinderstatic THLimitsFinder * GetLimitsFinder()Return pointer to the current finder.Definition THLimitsFinder.cxx:153; THLimitsFinder::FindGoodLimitsvirtual Int_t FindGoodLimits(TH1 *h, Double_t xmin, Double_t xmax)Compute the best axis limits for the X axis.Definition THLimitsFinder.cxx:53; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition THashList.cxx:189; TIterDefinition TCollection.h:235; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::GetUniqueIDvirtual UInt_t GetUniqueID() constReturn the unique obje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:76183,hash,hash,76183,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['hash'],['hash']
Security,"ay(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(UInt_t code = 0) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Version_tGetClassVersion() const; TVirtualCollectionProxy*GetCollectionProxy() const; const char*GetContextMenuTitle() const; TVirtualStreamerInfo*GetConversionStreamerInfo(const char* onfile_classname, Int_t version)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:3580,checksum,checksum,3580,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,4,['checksum'],['checksum']
Security,"ay(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; static TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*GetClassInfo() const; Int_tGetClassSize() const; Version_tGetClassVersion() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:3617,checksum,checksum,3617,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,1,['checksum'],['checksum']
Security,"ayer) const; print a single layer, for debugging. void PrintNeuron(TMVA::TNeuron* neuron) const; print a neuron, for debugging. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); get the mva value generated by the NN. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ranking of input variables by summing function of weights. void CreateWeightMonitoringHists(const TString& bulkname, vector<TH1*>* hv = 0) const. void WriteMonitoringHistosToFile() const; write histograms to file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. Bool_t Debug() const; who the hell makes such strange Debug flags that even use ""global pointers"".. void SetActivation(TMVA::TActivation* activation); setters for subclasses. void SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator). void Train(); this will have to be overridden by every subclass. Double_t GetNetworkOutput(); { return GetOutputNeuron()->GetActivationValue(); }. Int_t NumCycles(); accessors. { return fNcycles; }. TNeuron* GetInputNeuron(Int_t index); { return (TNeuron*)fInputLayer->At(index); }. TNeuron* GetOutputNeuron(Int_t index = 0); { return fOutputNeurons.at(index); }. » Author: Andreas Hoecker, Peter Speckmayer, Matt Jachowski, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodANNBase.html:22322,access,accessors,22322,root/html534/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodANNBase.html,1,['access'],['accessors']
Security,ays validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*_dataPointer to original input dataset; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_t_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_evalCarry! carry of Kahan sum in evaluatePartition; Int_t_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*_funcPointer to original input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpMode_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! Is object initialized ; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:35283,access,access,35283,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['access'],['access']
Security,"ay}{cccc}; xx & xy & xz & xt \\; yx & yy & yz & yt \\; zx & zy & zz & zt \\; tx & ty & tz & tt; \end{array}; \right|; \]; 17.5.1 Declaration; By default it is initialized to the identity matrix, but it may also be initialized by other TLorentzRotation, by a pure TRotation or by a boost:; TLorentzRotation l; // l is initialized as identity; TLorentzRotation m(l);// m = l; TRotation r;; TLorentzRotation lr(r);; TLorentzRotation lb1(bx,by,bz);; TVector3 b;; TLorentzRotation lb2(b);; The Matrix for a Lorentz boosts is:; \[; \left|; \begin{array}{cccc}; 1+gamma'*bx*bx & gamma'*bx*by & gamma'*bx*bz & gamma*bx \\; gamma'*bx*bz & 1+gamma'*by*by & gamma'*by*by & gamma*by \\; gamma'*bz*bx & gamma'*bz*by & 1+gamma'*bz*bz & gamma*bz \\; gamma*bx & gamma*by & gamma*bz & gamma; \end{array}; \right|; \]; with the boost vector b=(bx,by,bz); gamma=1/Sqrt(1-beta*beta);gamma'=(gamma-1)/beta*beta.; 17.5.2 Access to the Matrix Components/Comparisons; The access to the matrix components is possible with the methods XX(), XY() … TT(), and with the operator(int,int):; Double_t xx;; TLorentzRotation l;; xx = l.XX(); // gets the xx component; xx = l(0,0); // gets the xx component; if (l == m) {...} // test for equality; if (l != m) {...} // test for inequality; if (l.IsIdentity()) {...} // test for identity; 17.5.3 Transformations of a Lorentz Rotation; There are four possibilities to find the product of two TLorentzRotation transformations:; TLorentzRotation a,b,c;; c = b*a; // product; c = a.MatrixMultiplication(b); // a is unchanged; a *= b; // a=a*b; c = a.Transform(b) // a=b*a then c=a; Lorentz boosts:; Double_t bx, by, bz;; TVector3 v(bx,by,bz);; TLorentzRotation l;; l.Boost(v);; l.Boost(bx,by,bz);; Rotations:; TVector3 axis;; l.RotateX(TMath::Pi()); // rotation around x-axis; l.Rotate(.5,axis); // rotation around specified vector; Inverse transformation: use the method Inverse()to return the inverse transformation keeping the current one unchanged. The method Invert() inverts the curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:872397,access,access,872397,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"b) const; voidTObject::MakeZombie(); TS3HTTPRequest&SetTimeStamp(). Data Members; public:. enum EHTTPVerb { kGET; kPOST; kPUT; kDELETE; kHEAD; kCOPY; };; enum EAuthType { kNoAuth; kAmazon; kGoogle; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfAccessKeyAccess key (for authentication); TS3HTTPRequest::EAuthTypefAuthTypeAuthentication type; TStringfBucketBucket name; TStringfHostHost name; TStringfObjectKeyObject key; TStringfSecretKeySecret key (for authentication); TStringfTimeStampRequest time stamp; TS3HTTPRequest::EHTTPVerbfVerbHTTP Verb. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TS3HTTPRequest(). TS3HTTPRequest(TS3HTTPRequest::EHTTPVerb httpVerb, const TString& host, const TString& bucket, const TString& objectKey, TS3HTTPRequest::EAuthType authType, const TString& accessKey, const TString& secretKey); Default constructor. TS3HTTPRequest(const TS3HTTPRequest& m); Copy constructor. TString ComputeSignature(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns this request's signature. TString HTTPVerbToTString(TS3HTTPRequest::EHTTPVerb httpVerb) const. TS3HTTPRequest& SetTimeStamp(); Sets this request's time stamp according to:; http://code.google.com/apis/storage/docs/reference-headers.html#date. TString MakeRequestLine(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the first line of a HTTP request for this object. Note that since; we don't use the virtual host syntax which is supported by Amazon, we; must include the bucket name in thr resource. For example, we don't use; http://mybucket.s3.amazonaws.com/path/to/my/file but instead; http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request; will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1""; Also note that the path mu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3HTTPRequest.html:7967,access,accessKey,7967,root/html534/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html534/TS3HTTPRequest.html,1,['access'],['accessKey']
Security,"b);  ;  Protected Member Functions inherited from TGenCollectionProxy; void CheckFunctions () const;  Check existence of function pointers. ;  ; virtual void DeleteItem (Bool_t force, void *ptr) const;  Call to delete/destruct individual item. ;  ; TGenCollectionProxy * Initialize (Bool_t silent) const;  Proxy initializer. ;  ; virtual TGenCollectionProxy * InitializeEx (Bool_t silent);  Proxy initializer. ;  . Protected Attributes; ReadBuffer_t fReadBufferFunc;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:10340,access,accessors,10340,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['access'],['accessors']
Security,"bGlobusAuth is loaded. Int_t SshError(const char* errfile); SSH error parsing: returns; 0 : no error or fatal; 1 : should retry (eg 'connection closed by remote host'). Int_t SshAuth(TString& user); SSH client authentication code. const char * GetSshUser(TString user) const; Method returning the user to be used for the ssh login.; Looks first at SSH.Login and finally at env USER.; If SSH.LoginPrompt is set to 'yes' it prompts for the 'login name'. Bool_t CheckHost(const char* Host, const char* host); Check if 'host' matches 'href':; this means either equal or ""containing"" it, even with wild cards *; in the first field (in the case 'href' is a name, ie not IP address); Returns kTRUE if the two matches. Int_t RfioAuth(TString& user); UidGid client authentication code.; Returns 0 in case authentication failed; 1 in case of success; <0 in case of system error. Int_t ClearAuth(TString& user, TString& passwd, Bool_t& pwhash); UsrPwd client authentication code.; Returns 0 in case authentication failed; 1 in case of success. THostAuth * GetHostAuth(const char* host, const char* user = """", Option_t* opt = ""R"", Int_t* Exact = 0); Sets fUser=user and search fgAuthInfo for the entry pertaining to; (host,user), setting fHostAuth accordingly.; If opt = ""P"" use fgProofAuthInfo list instead; If no entry is found fHostAuth is not changed. THostAuth * HasHostAuth(const char* host, const char* user, Option_t* opt = ""R""); Checks if a THostAuth with exact match for {host,user} exists; in the fgAuthInfo list; If opt = ""P"" use ProofAuthInfo list instead; Returns pointer to it or 0. void FileExpand(const char* fin, FILE* ftmp); Expands include directives found in fexp files; The expanded, temporary file, is pointed to by 'ftmp'; and should be already open. To be called recursively. char * GetDefaultDetails(Int_t method, Int_t opt, const char* user); Determine default authentication details for method 'sec' and user 'usr'.; Checks .rootrc family files. Returned string must be deleted by the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:17613,authenticat,authentication,17613,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"bWhatever at parse time. This allows ROOT to resolve symbols from this library very early on. It is a work-around for the following code from ROOT 5:; // ROOT 5:; void func() {; gSystem->Load(""libEvent"");; Event* e = new Event;; }; Instead, write:; // ROOT 6:; R__LOAD_LIBRARY(libEvent); #include ""Event.h"". void func() {; Event* e = new Event;; }; TClass; Introduced new overload for calculating the TClass CheckSum:; UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; which indicates via the ‘isvalid’ boolean whether the checksum could be calculated correctly or not.; TROOT; Implemented new gROOT->GetTutorialsDir() static method to return the actual location of the tutorials directory. This is $ROOTSYS/tutorials when not configuring with –prefix or -Dgnuinstall for CMake.; TColor; Add an enum to access the palette by name.; Add new palettes with 255 colors. Names and colors’ definitions have been taken from here. Except for the kBird palette. These palettes can be accessed with gStyle->SetPalette(num). num can be taken within the following enum:. kDeepSea = 51; kGreyScale = 52; kDarkBodyRadiator = 53; kBlueYellow = 54; kRainBow = 55; kInvertedDarkBodyRadiator = 56; kBird = 57; kCubehelix = 58; kGreenRedViolet = 59; kBlueRedYellow = 60; kOcean = 61; kColorPrintableOnGrey = 62; kAlpine = 63; kAquamarine = 64; kArmy = 65; kAtlantic = 66; kAurora = 67; kAvocado = 68; kBeach = 69; kBlackBody = 70; kBlueGreenYellow = 71; kBrownCyan = 72; kCMYK = 73; kCandy = 74; kCherry = 75; kCoffee = 76; kDarkRainBow = 77; kDarkTerrain = 78; kFall = 79; kFruitPunch = 80; kFuchsia = 81; kGreyYellow = 82; kGreenBrownTerrain = 83; kGreenPink = 84; kIsland = 85; kLake = 86; kLightTemperature = 87; kLightTerrain = 88; kMint = 89; kNeon = 90; kPastel = 91; kPearl = 92; kPigeon = 93; kPlum = 94; kRedBlue = 95; kRose = 96; kRust = 97; kSandyTerrain = 98; kSienna = 99; kSolar = 100; kSouthWest = 101; kStarryNight = 102; kSunset = 103; kTemperatureMap = 104; kThermometer = 105; kVale",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:5448,access,accessed,5448,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['access'],['accessed']
Security,"back which can catch window showing, used by RBrowser. ; Definition at line 98 of file RWebWindowsManager.hxx. ◆ SetLoopbackMode(). void RWebWindowsManager::SetLoopbackMode ; (; bool ; on = true). static . Set loopback mode for THttpServer used for web widgets By default is on. ; Only local communication via localhost address is possible Disable it only if really necessary - it may open unauthorized access to your application from external nodes!! ; Definition at line 129 of file RWebWindowsManager.cxx. ◆ SetShowCallback(). void ROOT::RWebWindowsManager::SetShowCallback ; (; WebWindowShowCallback_t ; func). inline . Assign show callback which can catch window showing, used by RBrowser. ; Definition at line 95 of file RWebWindowsManager.hxx. ◆ SetUseConnectionKey(). void RWebWindowsManager::SetUseConnectionKey ; (; bool ; on = true). static . Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection) to widget requires unique key Connection key used together with session key to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ; Definition at line 168 of file RWebWindowsManager.cxx. ◆ SetUseSessionKey(). void RWebWindowsManager::SetUseSessionKey ; (; bool ; on = true). static . Enable or disable usage of session key (default on) If enabled, secrete session key used to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ; Definition at line 157 of file RWebWindowsManager.cxx. ◆ ShowWindow(). unsigned RWebWindowsManager::ShowWindow ; (; RWebWindow & ; win, . const RWebDisplayArgs & ; user_args . ). private . Show window in specified location, see Show() method for more details. ; Show web window in specified location.; Parameters. [in,out]winweb window by reference ; user_argsspecifies where and how display web window. As display args one can use string like ""firefox"" or ""chrome"" - these are two main supp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:16878,hash,hash,16878,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['hash'],['hash']
Security,"background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general ar NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (0); GetEmatrix() (0)+(d)+(e); GetEmatrixTotal() (0)+(a)+(b)+(c)+(d)+(e). Example:. TH2D *histA,*histAsys1,*histAsys2,*histBgr1,*histBgr2;; TH1D *data;; assume the above histograms are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:1876,access,accessed,1876,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,3,['access'],['accessed']
Security,"bar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. TRootCanvas(const TRootCanvas& ). TRootCanvas& operator=(const TRootCanvas& ). void ForceUpdate(); { Layout(); }. void Iconify(); { IconifyWindow(); }. void Show(); { MapRaised(); }. TGMenuBar * GetMenuBar() const; { return fMenuBar; }. TGLayoutHints * GetMenuBarItemLayout() const; { return fMenuBarItemLayout; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGDockableFrame * GetToolDock() const; { return fToolDock; }. » Author: Fons Rademakers 15/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootCanvas.html:28275,expose,expose,28275,root/html528/TRootCanvas.html,https://root.cern,https://root.cern/root/html528/TRootCanvas.html,3,['expose'],['expose']
Security,"bar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. void Activated(Int_t id); Slot handling tab switching in the browser, to properly set the canvas; and the model to the editor. TRootCanvas(const TRootCanvas& ). TRootCanvas& operator=(const TRootCanvas& ). void ForceUpdate(); { Layout(); }. void Iconify(); { IconifyWindow(); }. void Show(); { MapRaised(); }. TGMenuBar * GetMenuBar() const; { return fMenuBar; }. TGLayoutHints * GetMenuBarItemLayout() const; { return fMenuBarItemLayout; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGDockableFrame * GetToolDock() const; { return fToolDock; }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootCanvas.html:28546,expose,expose,28546,root/html534/TRootCanvas.html,https://root.cern,https://root.cern/root/html534/TRootCanvas.html,3,['expose'],['expose']
Security,"be found below: it histograms a function of the px and py branches.; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F(""h1"", ""ntuple"", 100, -4, 4);; ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");; ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }; TFile.h; TH1F.h; TTreeReaderValue.h; TTreeReader.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; A more complete example including error handling and a few combinations of TTreeReaderValue and TTreeReaderArray would look like this:; #include <TFile.h>; #include <TH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:1991,access,access,1991,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['access'],['access']
Security,"be generated in the file: fileprefix.h; located in the current directory or in 'path/' if it is specified. The class generated will be named 'fileprefix'. If the fileprefix contains a period, the right side of the period will be used as the extension (instead of 'h') and the left side will be used as the classname.; ""macrofilename"" and optionally ""cutfilename"" are expected to point to source file which will be included in by the generated skeletong. Method of the same name as the file(minus the extension and path) will be called by the generated skeleton's Process method as follow: [if (cutfilename())] htemp->Fill(macrofilename());; ""option"" can be used select some of the optional features during the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the system 'unroll' class that are not split. 'unrolling' a class will allow direct access to its data members a class (this emulates the behavior of TTreeFormula).; The main features of this skeleton are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). For example with Event.root, if Double_t somepx = fTracks.fPx[2];; double; is executed by one of the method of the skeleton, somepx will be updated with the current value of fPx of the 3rd track.; Both macrofilename and the optional cutfilename are expected to be the name of source files which contain at least a free standing function with the signature: x_t macrofilename(); // i.e function with the same name as the file; and y_t cutfilename(); // i.e function with the same name as the file; x_t and y_t needs to be types that can convert respectively to a double and a bool (because the skeleton uses: if (cutfilename()) htemp->Fill(macrofilename());; This 2 functions are run in a cont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:32380,access,access,32380,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['access'],['access']
Security,be that connection(s) not yet fully established - but also not timed out Batch jobs will be ignored here Returns 0 if connection not exists. ;  ; unsigned GetHeight () const;  returns configured window height (0 - default) ;  ; unsigned GetId () const;  Returns ID for the window - unique inside window manager. ;  ; std::shared_ptr< RWebWindowsManager > GetManager () const;  Returns window manager. ;  ; unsigned GetMaxQueueLength () const;  Return maximal queue length of data which can be held by window. ;  ; float GetOperationTmout () const;  Returns timeout for synchronous WebWindow operations. ;  ; std::string GetRelativeAddr (const RWebWindow &win) const;  Returns relative URL address for the specified window Address can be required if one needs to access data from one window into another window Used for instance when inserting panel into canvas. ;  ; std::string GetRelativeAddr (const std::shared_ptr< RWebWindow > &win) const;  Returns relative URL address for the specified window Address can be required if one needs to access data from one window into another window Used for instance when inserting panel into canvas. ;  ; int GetSendQueueLength (unsigned connid) const;  Returns send queue length for specified connection. ;  ; THttpServer * GetServer ();  Return THttpServer instance serving requests to the window. ;  ; std::string GetUrl (bool remote=true);  Return URL string to connect web window URL typically includes extra parameters required for connection with the window like http://localhost:9635/win1/?key=<connection_key>#<session_key> When. ;  ; std::string GetUserArgs () const;  Returns configured user arguments for web window See SetUserArgs method for more details. ;  ; unsigned GetWidth () const;  returns configured window width (0 - default) actual window width can be different ;  ; int GetX () const;  returns configured window X position (-1 - default) ;  ; int GetY () const;  returns configured window Y position (-1 - default) ;  ; bool HasConnect,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:4252,access,access,4252,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['access'],['access']
Security,"be used for the pattern recognition problem of extracting the valid combinations of coordinates describing a true trajectory from the set of all possible wrong combinations.; The program described here performs this principal components analysis on a sample of data provided by the user. It computes the covariance matrix, its eigenvalues ands corresponding eigenvectors and exhibits the behavior of the principal components \(a_{m_i}\), thus providing to the user all the means of understanding their data. Principal Components Method; Let's consider a sample of \(M\) prototypes each being characterized by \(P\) variables \(x_0, x_1, \ldots, x_{P-1}\). Each prototype is a point, or a column vector, in a \(P\)-dimensional Pattern space. ; \[; \mathbf{x} = \left[\begin{array}{c}; x_0\\x_1\\\vdots\\x_{P-1}\end{array}\right]\,,; \]. where each \(x_n\) represents the particular value associated with the \(n\)-dimension.; Those \(P\) variables are the quantities accessible to the experimentalist, but are not necessarily the most significant for the classification purpose.; The Principal Components Method consists of applying a linear* transformation to the original variables. This transformation is described by an orthogonal matrix and is equivalent to a rotation of the original pattern space into a new set of coordinate vectors, which hopefully provide easier feature identification and dimensionality reduction.; Let's define the covariance matrix: ; \[; \mathsf{C} = \left\langle\mathbf{y}\mathbf{y}^T\right\rangle; \quad\mbox{where}\quad; \mathbf{y} = \mathbf{x} - \left\langle\mathbf{x}\right\rangle\,,; \]. and the brackets indicate mean value over the sample of \(M\) prototypes.; This matrix \(\mathsf{C}\) is real, positive definite, symmetric, and will have all its eigenvalues greater then zero. It will now be show that among the family of all the complete orthonormal bases of the pattern space, the base formed by the eigenvectors of the covariance matrix and belonging to th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPrincipal.html:3632,access,accessible,3632,doc/master/classTPrincipal.html,https://root.cern,https://root.cern/doc/master/classTPrincipal.html,1,['access'],['accessible']
Security,"before the rest of the function body. ; Definition at line 175 of file CodeSquashContext.h. ◆ _loopLevel. int RooFit::Detail::CodeSquashContext::_loopLevel = 0. private . The current number of for loops the started. ; Definition at line 183 of file CodeSquashContext.h. ◆ _nodeNames. std::unordered_map<const TNamed *, std::string> RooFit::Detail::CodeSquashContext::_nodeNames. private . Map of node names to their result strings. ; Definition at line 173 of file CodeSquashContext.h. ◆ _nodeOutputSizes. std::map<RooFit::Detail::DataKey, std::size_t> RooFit::Detail::CodeSquashContext::_nodeOutputSizes. private . Map of node output sizes. ; Definition at line 179 of file CodeSquashContext.h. ◆ _scopePtr. int RooFit::Detail::CodeSquashContext::_scopePtr = -1. private . Keeps track of the position to go back and insert code to. ; Definition at line 187 of file CodeSquashContext.h. ◆ _tempScope. std::string RooFit::Detail::CodeSquashContext::_tempScope. private . Stores code that eventually gets injected into main code body. ; Mainly used for placing decls outside of loops. ; Definition at line 190 of file CodeSquashContext.h. ◆ _tmpVarIdx. int RooFit::Detail::CodeSquashContext::_tmpVarIdx = 0. mutableprivate . Index to get unique names for temporary variables. ; Definition at line 185 of file CodeSquashContext.h. ◆ _vecObsIndices. std::unordered_map<const TNamed *, int> RooFit::Detail::CodeSquashContext::_vecObsIndices. private . A map to keep track of the observable indices if they are non scalar. ; Definition at line 177 of file CodeSquashContext.h. ◆ _wrapper. Experimental::RooFuncWrapper* RooFit::Detail::CodeSquashContext::_wrapper = nullptr. Definition at line 118 of file CodeSquashContext.h. ◆ _xlArr. std::vector<double>& RooFit::Detail::CodeSquashContext::_xlArr. private . Definition at line 193 of file CodeSquashContext.h. ◆ listNames. std::unordered_map<RooFit::UniqueId<RooAbsCollection>::Value_t, std::string> RooFit::Detail::CodeSquashContext::listNames. private .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFit_1_1Detail_1_1CodeSquashContext.html:16522,inject,injected,16522,doc/master/classRooFit_1_1Detail_1_1CodeSquashContext.html,https://root.cern,https://root.cern/doc/master/classRooFit_1_1Detail_1_1CodeSquashContext.html,1,['inject'],['injected']
Security,"ber Functions |; Static Public Member Functions |; Private Attributes |; List of all members ; TStatistic Class ReferenceMath » MathCore. ; Statistical variable, defined by its mean and variance (RMS). ; Named, streamable, storable and mergeable. ; Definition at line 33 of file TStatistic.h. Public Member Functions;  TStatistic (const char *name, Int_t n, const Double_t *val, const Double_t *w=nullptr);  Constructor from a vector of values. ;  ;  TStatistic (const char *name="""");  ;  ~TStatistic () override;  TStatistic destructor. ;  ; void Fill (Double_t val, Double_t w=1.);  Increment the entries in the object by one value-weight pair. ;  ; Double_t GetM2 () const;  ; Double_t GetMax () const;  ; Double_t GetMean () const;  ; Double_t GetMeanErr () const;  ; Double_t GetMin () const;  ; Long64_t GetN () const;  ; const char * GetName () const override;  Returns name of object. ;  ; Long64_t GetNeff () const;  ; Double_t GetRMS () const;  ; Double_t GetVar () const;  ; Double_t GetW () const;  ; Double_t GetW2 () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; void ls (Option_t *opt="""") const override;  The ls function lists the contents of a class on stdout. ;  ; Int_t Merge (TCollection *in);  Merge implementation of TStatistic. ;  ; void Print (Option_t *="""") const override;  Print the content of the object. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatistic.html:1231,hash,hash,1231,doc/master/classTStatistic.html,https://root.cern,https://root.cern/doc/master/classTStatistic.html,1,['hash'],['hash']
Security,"ber Functions |; Static Public Member Functions |; Protected Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; TGeoGlobalMagField Class ReferenceThe Geometry Package » Geometry classes. ; Global magnetic field manager. ; Provides access to and owns the actual magnetic field set via SetField(). The field is deleted upon destruction of the field manager at the end of ROOT session or by calling:; TGeoGlobalMagField::Instance()->SetField(0).; TGeoGlobalMagField::SetFieldvoid SetField(TVirtualMagField *field)Field setter. Deletes previous field if any. Acts only if fLock=kFALSE.Definition TGeoGlobalMagField.cxx:86; TGeoGlobalMagField::Instancestatic TGeoGlobalMagField * Instance()Returns always a valid static pointer to the field manager.Definition TGeoGlobalMagField.cxx:118; The previous global field is deleted upon replacement with notification.; The global field manager provides access to the global field via:; TGeoGlobalMagField::Instance()->GetField(); TGeoGlobalMagField::GetFieldTVirtualMagField * GetField() constDefinition TGeoGlobalMagField.h:34; One can directly call the Field() method of a field via the global field manager:; TGeoGlobalMagField::Instance()->Field(x,B); TGeoGlobalMagField::Fieldvoid Field(const Double_t *x, Double_t *B)Definition TGeoGlobalMagField.h:44; xDouble_t x[n]Definition legend1.C:17. Definition at line 18 of file TGeoGlobalMagField.h. Public Member Functions;  TGeoGlobalMagField ();  Global field default constructor. ;  ;  ~TGeoGlobalMagField () override;  Global field destructor. ;  ; void Field (const Double_t *x, Double_t *B);  ; TVirtualMagField * GetField () const;  ; TClass * IsA () const override;  ; Bool_t IsLocked ();  ; void Lock ();  Locks the global magnetic field if this is set. Cannot be unlocked. ;  ; void SetField (TVirtualMagField *field);  Field setter. Deletes previous field if any. Acts only if fLock=kFALSE. ;  ; void Streamer (TBuffer &) override;  Stream an object of class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoGlobalMagField.html:1091,access,access,1091,doc/master/classTGeoGlobalMagField.html,https://root.cern,https://root.cern/doc/master/classTGeoGlobalMagField.html,1,['access'],['access']
Security,"ber is negative it is set to 0.; If the color number is greater than the current number of colors; it is set to the highest color number.; The default number of colors is 50.; see TStyle::SetPalette for setting a new color palette. Note that the variables e1, e2 or e3 may contain a selection.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. The expressions can use all the operations and build-in functions; supported by TFormula (See TFormula::Analyze), including free; standing function taking numerical arguments (TMath::Bessel).; In addition, you can call member functions taking numerical; arguments. For example:; - ""TMath::BreitWigner(fPx,3,2)""; - ""event.GetHistogram().GetXaxis().GetXmax()""; Note: You can only pass expression that depend on the TTree's data; to static functions and you can only call non-static member function; with 'fixed' parameters. The selection is an expression with a combination of the columns.; In a selection all the C++ operators are authorized.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:; value*(boolean expression); if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection1 returns a weight = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>3.2; returns a weight = 0 otherwise. option is the drawing option; see TH1::Draw for the list of all drawing options.; If option contains the string ""goff"", no graphics is generated. nentries is the number of entries to process (default is all); first is the first entry to process (default is 0). Drawing expressions using arrays and array elements. Let assume, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; or",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:20682,authoriz,authorized,20682,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['authoriz'],['authorized']
Security,"ber when reading; TBranch::ReadLeaves_tTBranch::fReadLeaves! Pointer to the ReadLeaves implementation to use.; Bool_tTBranch::fSkipZip! After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter; static TBranch::EStatusBitsTBranch::kAutoDelete; static TBranch::EStatusBitsTBranch::kDoNotUseBufferMap. private:. TBranchSTL::BranchMap_tfBranchMap! Branch map; vector<TBranchSTL::ElementBranchHelper_t>fBranchVector! Branch vector; UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBranchSTL.html:13993,checksum,checksum,13993,root/html602/TBranchSTL.html,https://root.cern,https://root.cern/root/html602/TBranchSTL.html,2,['checksum'],['checksum']
Security,"bers. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result in binary form. cmd.json; command execution. item.json; item (object) properties, specified on the server. multi.json; perform several requests at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will be excluded. If compact=‘20’, similar values or large zero gaps in-between will be compressed. Such array compression support in JSROOT from version 4.8.2.; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:15247,access,access,15247,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['access'],['access']
Security,"better to access the values in a script, one by one. There is a traditional way of doing this (TTree::SetBranchAddress() etc) and a new, recommended one: the TTreeReader. That's what we will use later and introduce here.; The TTreeReader Concept; The TTree loads entry by entry into memory. You and the TTree need to agree what data the TTree should make available (i.e. for which branches) and what data these branches contain. First, we set up a TTreeReader object that connects our data requests to the TTree:; // Access a TTree called ""MyTree"" in the file:; TTreeReader reader(""MyTree"", file);. The TTreeReader Values and Arrays; This reader object can now be used by the data accessors. There are two types: TTreeReaderArray can iterate through collections (std::vector, TClonesArray, TList, MyType[12] - whatever) and TTreeReaderValue that doesn't. You can choose how you access the values - for our tree, all of these might make sense in different contexts:; TTreeReaderValue<float> rvMissingET(reader, ""missingET"");; // The following needs the definition of the Muon class - which is why accessing; // data member branches is much simpler.; TTreeReaderValue<std::vector<Muon>> rvMuons(reader, ""muons"");. TTreeReaderArray<float> raMuonPt(reader, ""muons.fPt"");; // Here, too we would need the definition of the Muon class.; TTreeReaderArray<Muon> raMuons(reader, ""muons"");. Accessing Data; The TTreeReader checks whether the type you specify is the type that's stored in the branch, i.e. whether it can actually access the data through the reader object. The TTreeReaderValue gets its values like so:; // Loop through all the TTree's entries; while (reader.Next()) {; // behaves like an iterator; float missingET = *rvMissingET;; ...; }. A TTreeReaderArray allows you to get the size and access the n-th element:; while (reader.Next()) {; for (int iMuon = 0, nMuons = raMuonPt.GetSize(); iMuon < nMuons; ++iMuon) {; hist->Fill(raMuonPt[iMuon]);; }; }. Of course in C++11 you could also just do; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/7-using-ttreereader.html:2937,access,access,2937,d/7-using-ttreereader.html,https://root.cern,https://root.cern/d/7-using-ttreereader.html,2,['access'],"['access', 'accessing']"
Security,"bility of this class:; 5653/// - -1: Use the default calculation; 5654/// - 0: Disallow splitting; 5655/// - 1: Always allow splitting.; 5656/// - 2: Disallow splitting of the class and splitting of any it's derived classes.; 5657 ; 5658void TClass::SetCanSplit(Int_t splitmode); 5659{; 5660 fCanSplit = splitmode;; 5661}; 5662 ; 5663////////////////////////////////////////////////////////////////////////////////; 5664/// Private function. Set the class version for the 'class' represented by; 5665/// this TClass object. See the public interface:; 5666/// ROOT::ResetClassVersion; 5667/// defined in TClassTable.cxx; 5668///; 5669/// Note on class version numbers:; 5670/// - If no class number has been specified, TClass::GetVersion will return -1; 5671/// - The Class Version 0 request the whole object to be transient; 5672/// - The Class Version 1, unless specified via ClassDef indicates that the; 5673/// I/O should use the TClass checksum to distinguish the layout of the class; 5674 ; 5675void TClass::SetClassVersion(Version_t version); 5676{; 5677 fClassVersion = version;; 5678 fCurrentInfo = nullptr;; 5679}; 5680 ; 5681////////////////////////////////////////////////////////////////////////////////; 5682/// Determine and set pointer to current TVirtualStreamerInfo; 5683 ; 5684TVirtualStreamerInfo* TClass::DetermineCurrentStreamerInfo(); 5685{; 5686 if(!fCurrentInfo.load()) {; 5687 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 5688 fCurrentInfo = (TVirtualStreamerInfo *)(fStreamerInfo->At(fClassVersion));; 5689 }; 5690 return fCurrentInfo;; 5691}; 5692 ; 5693////////////////////////////////////////////////////////////////////////////////; 5694/// Set pointer to current TVirtualStreamerInfo; 5695 ; 5696void TClass::SetCurrentStreamerInfo(TVirtualStreamerInfo *info); 5697{; 5698 fCurrentInfo = info;; 5699}; 5700 ; 5701////////////////////////////////////////////////////////////////////////////////; 5702/// Return size of object of this class.; 5703 ; 5704Int_t TClass::Size() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:217481,checksum,checksum,217481,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"bility of this class:; 5720/// - -1: Use the default calculation; 5721/// - 0: Disallow splitting; 5722/// - 1: Always allow splitting.; 5723/// - 2: Disallow splitting of the class and splitting of any it's derived classes.; 5724 ; 5725void TClass::SetCanSplit(Int_t splitmode); 5726{; 5727 fCanSplit = splitmode;; 5728}; 5729 ; 5730////////////////////////////////////////////////////////////////////////////////; 5731/// Private function. Set the class version for the 'class' represented by; 5732/// this TClass object. See the public interface:; 5733/// ROOT::ResetClassVersion; 5734/// defined in TClassTable.cxx; 5735///; 5736/// Note on class version numbers:; 5737/// - If no class number has been specified, TClass::GetVersion will return -1; 5738/// - The Class Version 0 request the whole object to be transient; 5739/// - The Class Version 1, unless specified via ClassDef indicates that the; 5740/// I/O should use the TClass checksum to distinguish the layout of the class; 5741 ; 5742void TClass::SetClassVersion(Version_t version); 5743{; 5744 fClassVersion = version;; 5745 fCurrentInfo = nullptr;; 5746}; 5747 ; 5748////////////////////////////////////////////////////////////////////////////////; 5749/// Determine and set pointer to current TVirtualStreamerInfo; 5750 ; 5751TVirtualStreamerInfo* TClass::DetermineCurrentStreamerInfo(); 5752{; 5753 if(!fCurrentInfo.load()) {; 5754 R__READ_LOCKGUARD(ROOT::gCoreMutex);; 5755 fCurrentInfo = (TVirtualStreamerInfo *)(fStreamerInfo->At(fClassVersion));; 5756 }; 5757 return fCurrentInfo;; 5758}; 5759 ; 5760////////////////////////////////////////////////////////////////////////////////; 5761/// Set pointer to current TVirtualStreamerInfo; 5762 ; 5763void TClass::SetCurrentStreamerInfo(TVirtualStreamerInfo *info); 5764{; 5765 fCurrentInfo = info;; 5766}; 5767 ; 5768////////////////////////////////////////////////////////////////////////////////; 5769/// Return size of object of this class.; 5770 ; 5771Int_t TClass::Size() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:220232,checksum,checksum,220232,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"bin with the maximum content of each individual violin is; 1558set to a constant value using SetBarWidth(). The static function will affect all violin-charts; 1559in the running program. Default is true. Scaling between multiple violin-charts; 1560(using ""same"" or THStack) is not supported, yet.; 1561 ; 1562##### The zero indicator line; 1563Typical for violin charts is a line in the background over the whole histogram indicating; 1564the bins with zero entries. The zero indicator line can be activated with z=1. The line color; 1565will always be the same as the fill-color of the histogram.; 1566 ; 1567##### The Mean; 1568The Mean is illustrated with the same mechanism as used for candle plots. Usually a circle is used.; 1569 ; 1570##### Whiskers; 1571The whiskers are illustrated by the same mechanism as used for candle plots. There is only one; 1572difference. When using the simple whisker definition (w=1) and the zero indicator line (z=1), then; 1573the whiskers will be forced to be solid (usually hashed); 1574 ; 1575##### Points; 1576The points are illustrated by the same mechanism as used for candle plots. E.g. VIOLIN2 uses; 1577better whisker definition (w=2) and outliers (p=1).; 1578 ; 1579##### Other options; 1580It is possible to combine all options of candle or violin plots with each other. E.g. a violin plot; 1581including a box-plot.; 1582 ; 1583#### How to use the violin-plots drawing option; 1584 ; 1585There are two predefined violin-plot representations:; 1586 - ""VIOLINX1"": Standard violin (histogram, mean, whisker over full distribution,; 1587 zero indicator line); 1588 - ""VIOLINX2"": Line VIOLINX1 both with better whisker definition + outliers.; 1589 ; 1590A solid fill style is recommended for this plot (as opposed to a hollow or; 1591hashed style).; 1592 ; 1593Begin_Macro(source); 1594{; 1595 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 1596 Int_t nx(6), ny(40);; 1597 double xmin(0.0), xmax(+6.0), ymin(0.0), ymax(+4.0);; 1598 auto hviolin = new TH2F(""h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:67457,hash,hashed,67457,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['hash'],['hashed']
Security,"bj);  Unregister object. ;  ; void UnregisterWS (std::shared_ptr< THttpWSHandler > ws);  Unregister WS handler. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:6868,hash,hash,6868,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['hash'],['hash']
Security,"bj, Option_t *opt) override;  Add object at the beginning of the list and also store option. ;  ; void AddLast (TObject *obj) override;  Add object at the end of the list. ;  ; void AddLast (TObject *obj, Option_t *opt) override;  Add object at the end of the list and also store option. ;  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * Before (const TObject *obj) const override;  Returns the object before object obj. ;  ; void Clear (Option_t *option) override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Delete all TDataMember object files. ;  ; TObject * FindObject (const char *name) const override;  Specialize FindObject to do search for the a enum just by name or create it if its not already in the list. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; TObject * First () const override;  Return the first object in the list. Returns 0 when list is empty. ;  ; TObjLink * FirstLink () const override;  ; Int_t GetLast () const override;  Returns index of last object in collection. ;  ; TEnum * GetObject (const char *) const override;  Return an object from the list of enums if and only if is has already been loaded in the list. ;  ; TObject ** GetObjectRef (const TObject *obj) const override;  Return address of pointer to obj. ;  ; Int_t GetSize () const override;  Return the capacity of the collection, i.e. ;  ; Int_t IndexOf (const TObject *obj) const override;  Return index of object in collection. ;  ; TClass * IsA () const override;  ; TObject * Last () const override;  Return the last object in the list. Returns 0 when list is empty. ;  ; TObjLink * LastLink () const override;  ; TIterator * MakeIterator (Bool_t dir=kIterForward) const override;  Return a list i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnumsWithLock.html:2314,hash,hash,2314,doc/master/classTListOfEnumsWithLock.html,https://root.cern,https://root.cern/doc/master/classTListOfEnumsWithLock.html,1,['hash'],['hash']
Security,"bjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo( const char* classname, Int_t version ); Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo( const TClass* cl, Int_t version ); Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo( const char* classname, UInt_t checksum ); Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ); Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetClassVersion() const; { fVersionUsed = kTRUE; return fClassVersion; }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:41375,access,access,41375,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,1,['access'],['access']
Security,"bject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static Int_tTDataSetManager::FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTDataSetManager::GetAvgFileSize() const; virtual TFileCollection*GetDataSet(const char* uri, const char* srv = 0); TFileCollection*GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0); virtual TMap*GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport); TMap*GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); static TList*TDataSetManager::GetDataSetSrvMaps(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTDataSetManager::GetGroupQuota(const char* group); virtual TMap*TDataSetManager::GetGroupQuotaMap(); virtual Long64_tTDataSetManager::GetGroupUsed(const char* group); virtual const char*TObject::GetIconName() const; Long_tGetModTime(const char* uri); const char*GetMSSUrl() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetStageOpts() const; virtual TMap*TDataSetManager::GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDataSetManagerFile.html:2826,checksum,checksum,2826,root/html534/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html534/TDataSetManagerFile.html,3,['checksum'],['checksum']
Security,"bject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static Int_tTDataSetManager::FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTDataSetManager::GetAvgFileSize() const; virtual TFileCollection*GetDataSet(const char* uri, const char* srv = 0); TFileCollection*GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0); virtual TMap*GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport); TMap*GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); static TList*TDataSetManager::GetDataSetSrvMaps(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTDataSetManager::GetGroupQuota(const char* group); virtual TMap*TDataSetManager::GetGroupQuotaMap(); virtual Long64_tTDataSetManager::GetGroupUsed(const char* group); virtual const char*TObject::GetIconName() const; const char*GetMSSUrl() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetStageOpts() const; virtual TMap*TDataSetManager::GetSubDataSets(const char* uri, const char* excludeservers); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:2597,checksum,checksum,2597,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,3,['checksum'],['checksum']
Security,"bject::SetUniqueID(UInt_t uid); voidSetUnloaded(); virtual voidShowMembers(TMemberInspector& insp, char* parent); Int_tSize() const; virtual Int_tTNamed::Sizeof() const; voidStore(TBuffer& b) const; virtual voidStreamer(TBuffer& b); voidStreamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteBuffer(TBuffer& b, void* pointer, const char* info = """"). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TVirtualStreamerInfo*FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; static THashTable*GetClassShortTypedefHash(); voidTObject::MakeZombie(). private:. TClass(const TClass& tc); voidForceReload(TClass* oldcl); Int_tGetBaseClassOffsetRecurse(const TClass* base); TMethod*GetClassMethod(Long_t faddr); TMethod*GetClassMethod(const char* name, const char* signature); voidInit(const char* name, Version_t cversion, const type_info* info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmember, const char* dfil, const char* ifil, Int_t dl, Int_t il, Bool_t silent); TClass&operator=(const TClass&); voidSetClassSize(Int_t sizof); voidSetClassVersion(Version_t version). Data Members; public:. enum { kClassSaved; kIgnoreTObjectStreamer; kUnloaded; kIsTObject; kIsForeign; kIsEmulation; kStartWithTObject; kWarned; kHasNameMapNode; };; enum ENewType { kRealNew; kClassNew; kDummyNew; };; enum { kLoading; kDefault; kEmulated; kTObject; kInstrumented; kForeign; kExternal; };; enum TDictionary::ESTLType { kNone; kVector; kLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:11622,checksum,checksum,11622,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,1,['checksum'],['checksum']
Security,"bject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. RooLinkedListElem*RooLinkedList::_first! Link to first element of list; Int_tRooLinkedList::_hashThreshSize threshold for hashing; RooHashTable*RooLinkedList::_htableLink! Hash table by link pointer; RooHashTable*RooLinkedList::_htableName! Hash table by name; RooLinkedListElem*RooLinkedList::_last! Link to last element of list; TStringRooLinkedList::_name; Int_tRooLinkedList::_sizeCurrent size of list; Bool_tRooLinkedList::_useNptr!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRefCountList(); Default constructor construct lists with initial hash table size of 17. void Add(TObject* obj, Int_t count); Add object to list with given reference count increment; List takes ownership of object. Bool_t Remove(TObject* obj); Remove object from list and if reference count; reaches zero delete object itself as well. Bool_t RemoveAll(TObject* obj); Remove object from list and delete object itself; regardless of reference count. Int_t refCount(TObject* obj); Return reference count associated with 'obj'. RooRefCountList(). virtual ~RooRefCountList(); {}. void Add(TObject* arg); { Add(arg,1) ; }. » Last changed: Tue Jun 2 15:33:35 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooRefCountList.html:7717,hash,hash,7717,root/html604/RooRefCountList.html,https://root.cern,https://root.cern/root/html604/RooRefCountList.html,1,['hash'],['hash']
Security,"bject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsRealLValue.html:38097,validat,validate,38097,root/html602/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsRealLValue.html,108,"['access', 'validat']","['access', 'validate']"
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <ROOT/TBufferMerger.hxx>. Inheritance diagram for ROOT::TBufferMergerFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TBufferMergerFile() [1/3]. ROOT::TBufferMergerFile::TBufferMergerFile ; (; TBufferMerger & ; m). private . Constructor. ; Can only be called by TBufferMerger. Parameters. mMerger this file is attached to. . Definition at line 18 of file TBufferMergerFile.cxx. ◆ TBufferMergerFile() [2/3]. ROOT::TBufferMergerFile::TBufferMergerFile ; (; ). private . TBufferMergerFile has no default constructor. . ◆ TBufferMergerFile() [3/3]. ROOT::TBufferMergerFile::TBufferMergerFile ; (; const TBufferMergerFile & ; ). private . TBufferMergerFile has no copy constructor. . ◆ ~TBufferMergerFile(). ROOT::T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html:44470,hash,hashes,44470,doc/v632/classROOT_1_1TBufferMergerFile.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html,2,['hash'],['hashes']
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TDCacheFile.h>. Inheritance diagram for TDCacheFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EOnErrorAction. enum TDCacheFile::EOnErrorAction. Note: This must be kept in sync with values #defined in dcap.h. . EnumeratorkOnErrorRetry ; kOnErrorFail ; kOnErrorDefault . Definition at line 61 of file TDCacheFile.h. Constructor & Destructor Documentation. ◆ TDCacheFile() [1/2]. TDCacheFile::TDCacheFile ; (; ). inlineprivate . Definition at line 31 of file TDCacheFile.h. ◆ TDCacheFile() [2/2]. TDCacheFile::TDCacheFile ; (; const char * ; path, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault . ). Create a dCache file objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:42170,hash,hashes,42170,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['hash'],['hashes']
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TDavixFile.h>. Inheritance diagram for TDavixFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TDavixFile(). TDavixFile::TDavixFile ; (; const char * ; url, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault . ). Open function for TDavixFile. ; TDavixFile supports several options :. GRID_MODE=yes : enable the grid authentication and CA support; CA_CHECK=no : remove all the certificate authority check, this option can create a security vulnerability; S3SECKEY=string : Amazon S3 secret token; S3ACCKEY=string : Amazon S3 access token; S3REGION=string : Amazon S3 region. Optional, if provided, davix will use v4 signature",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:41284,hash,hashes,41284,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['hash'],['hashes']
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TNetFile.h>. Inheritance diagram for TNetFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TNetFile() [1/4]. TNetFile::TNetFile ; (; const TNetFile & ; ). protected . ◆ TNetFile() [2/4]. TNetFile::TNetFile ; (; const char * ; url, . const char * ; ftitle, . Int_t ; compress, . Bool_t ;  . ). protected . Create a TNetFile object. ; To be used by derived classes, that need to initialize the TFile base class but not open a connection at this moment. ; Definition at line 89 of file TNetFile.cxx. ◆ TNetFile() [3/4]. TNetFile::TNetFile ; (; const char * ; url, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, . Int_t ; n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:42817,hash,hashes,42817,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['hash'],['hashes']
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TNetXNGFile.h>. Inheritance diagram for TNetXNGFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TNetXNGFile() [1/4]. TNetXNGFile::TNetXNGFile ; (; ). Definition at line 123 of file TNetXNGFile.cxx. ◆ TNetXNGFile() [2/4]. TNetXNGFile::TNetXNGFile ; (; const char * ; url, . const char * ; lurl, . Option_t * ; mode, . const char * ; title, . Int_t ; compress, . Int_t ; netopt, . Bool_t ; parallelopen . ). Definition at line 152 of file TNetXNGFile.cxx. ◆ TNetXNGFile() [3/4]. TNetXNGFile::TNetXNGFile ; (; const char * ; url, . Option_t * ; mode = """", . const char * ; title = """", . Int_t ; compress = 1, . Int_t ; netopt = 0, . Bool_t ; parallelopen = kFALSE . ). Constructor. ; param url: URL of the entry-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:41089,hash,hashes,41089,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,1,['hash'],['hashes']
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TParallelMergingFile.h>. Inheritance diagram for TParallelMergingFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TParallelMergingFile(). TParallelMergingFile::TParallelMergingFile ; (; const char * ; filename, . Option_t * ; option = """", . const char * ; ftitle = """", . Int_t ; compress = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault . ). Constructor. ; We do no yet open any connection to the server. This will be done at the time the first upload will be requested. ; Definition at line 35 of file TParallelMergingFile.cxx. ◆ ~TParallelMergingFile(). TParallelMergingFile::~TParallelMergingFile ; (; ). Destructor. ; Definition at line 49 of file TParallelMergingFile.cxx. Member Function Docu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelMergingFile.html:43875,hash,hashes,43875,doc/master/classTParallelMergingFile.html,https://root.cern,https://root.cern/doc/master/classTParallelMergingFile.html,1,['hash'],['hashes']
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TS3WebFile.h>. Inheritance diagram for TS3WebFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TS3WebFile() [1/2]. TS3WebFile::TS3WebFile ; (; ). private . ◆ TS3WebFile() [2/2]. TS3WebFile::TS3WebFile ; (; const char * ; path, . Option_t * ; options = """" . ). Construct a TS3WebFile object. ; The path argument is a URL of one of the following forms:; s3://host.example.com/bucket/path/to/my/file; s3http://host.example.com/bucket/path/to/my/file; s3https://host.example.com/bucket/path/to/my/file; as3://host.example.com/bucket/path/to/my/file; For files hosted by Google Storage, use the following forms:; gs://storage.googleapis.com/bucket/path/to/my/file; gshttp://storage.googleapis.com/bucket/path/to/my/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:46974,hash,hashes,46974,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['hash'],['hashes']
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . #include <TSQLFile.h>. Inheritance diagram for TSQLFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EIndexesKinds. enum TSQLFile::EIndexesKinds. EnumeratorkIndexesNone ; kIndexesBasic ; kIndexesClass ; kIndexesAll . Definition at line 177 of file TSQLFile.h. ◆ ELockingKinds. enum TSQLFile::ELockingKinds. protected . EnumeratorkLockFree ; kLockBusy . Definition at line 41 of file TSQLFile.h. ◆ ETransactionKinds. enum TSQLFile::ETransactionKinds. EnumeratorkTransactionsOff ; kTransactionsAuto ; kTransactionsUser . Definition at line 175 of file TSQLFile.h. Constructor & Destructor Documentation. ◆ TSQLFile() [1/3]. TSQLFile::TSQLFile ; (; const TSQLFile & ; ). privatedelete . ◆ TSQLFile() [2/3]. TSQLFile::TSQLFile ; (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:59393,hash,hashes,59393,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['hash'],['hashes']
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . Additional Inherited Members;  Static Protected Member Functions inherited from TDirectory; static Bool_t Cd1 (const char *path);  Change current directory to ""path"". ;  ; static SharedGDirectory_t & GetSharedLocalCurrentDirectory ();  Return the (address of) a shared pointer to the struct holding the actual thread local gDirectory pointer and the atomic_flag for its lock. ;  . #include <TMemFile.h>. Inheritance diagram for TMemFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ ExternalDataPtr_t. using TMemFile::ExternalDataPtr_t = std::shared_ptr<const std::vector<char> >. Definition at line 21 of file TMemFile.h. Member Enumeration Documentation. ◆ EMode. enum class TMemFile::EMode. strongprotected . EnumeratorkCreate ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTMemFile.html:42932,hash,hashes,42932,doc/v632/classTMemFile.html,https://root.cern,https://root.cern/doc/v632/classTMemFile.html,2,['hash'],['hashes']
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . Private Member Functions;  TFile (const TFile &)=delete;  ; void operator= (const TFile &)=delete;  . Static Private Member Functions; static void CpProgress (Long64_t bytesread, Long64_t size, TStopwatch &watch);  Print file copy progress. ;  ; static TFile * OpenFromCache (const char *name, Option_t *="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Open a file for reading through the file cache. ;  . Friends; class TBasket;  ; class TDirectoryFile;  ; class TFilePrefetch;  . Additional Inherited Members;  Protected Types inherited from TDirectory; using SharedGDirectory_t = std::shared_ptr< std::atomic< TDirectory * > >;  Pointer to a list of TContext object pointing to this TDirectory. ;  ;  Protected Types inherited from TObject; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:44282,hash,hashes,44282,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['hash'],['hashes']
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  . Private Member Functions;  TWebFile ();  . Friends; class TWebSocket;  ; class TWebSystem;  . Additional Inherited Members;  Public Types inherited from TFile; enum  { kStartBigFile = 2000000000; };  ; enum  EAsyncOpenStatus { kAOSNotAsync = -1; , kAOSFailure = 0; , kAOSInProgress = 1; , kAOSSuccess = 2; };  Asynchronous open request status. More...;  ; enum  ECacheAction { kDisconnect = 0; , kDoNotDisconnect = 1; };  TTreeCache flushing semantics. More...;  ; enum  EFileType { ;   kDefault = 0; , kLocal = 1; , kNet = 2; , kWeb = 3; , ;   kFile = 4; , kMerge = 5. };  File type. More...;  ; enum  EOpenTimeOut { kInstantTimeout = 0; , kEternalTimeout = 999999999; };  Open timeout constants. More...;  ; enum  ERelativeTo { kBeg = 0; , kCur = 1; , kEnd = 2; };  ; enum  EStatusBits { ;   k630forwardCompatibil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:40670,hash,hashes,40670,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['hash'],['hashes']
Security,"bjects. ;  ; static TString fgCacheFileDir;  Directory where to locally stage files. ;  ; static Bool_t fgCacheFileDisconnected = kTRUE;  Indicates, we trust in the files in the cache dir without stat on the cached file. ;  ; static Bool_t fgCacheFileForce = kFALSE;  Indicates, to force all READ to CACHEREAD. ;  ; static std::atomic< Long64_t > fgFileCounter {0};  Counter for all opened files. ;  ; static Bool_t fgOnlyStaged = kFALSE;  Before the file is opened, it is checked, that the file is staged, if not, the open fails. ;  ; static UInt_t fgOpenTimeout = TFile::kEternalTimeout;  Timeout for open operations in ms - 0 corresponds to blocking i/o. ;  ; static Int_t fgReadaheadSize = 256000;  Readahead buffer size. ;  ; static std::atomic< Int_t > fgReadCalls {0};  Number of bytes read from all TFile objects. ;  ; static Bool_t fgReadInfo = kTRUE;  if true (default) ReadStreamerInfo is called when opening a file ;  ; static ROOT::Internal::RConcurrentHashColl fgTsSIHashes;  !TS Set of hashes built from read streamer infos ;  ;  Static Protected Attributes inherited from TDirectory; static Bool_t fgAddDirectory = kTRUE;  MSVC doesn't support = ATOMIC_FLAG_INIT;. ;  ;  Static Protected Attributes inherited from TXMLSetup; static TString fgNameSpaceBase = fgROOTDocNameSpaceBase;  buffer, used in XmlDefineClass() function ;  . #include <TXMLFile.h>. Inheritance diagram for TXMLFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TXMLFile() [1/3]. TXMLFile::TXMLFile ; (; const TXMLFile & ; ). privatedelete . ◆ TXMLFile() [2/3]. TXMLFile::TXMLFile ; (; ). inline . Definition at line 51 of file TXMLFile.h. ◆ TXMLFile() [3/3]. TXMLFile::TXMLFile ; (; const char * ; filename, . Option_t * ; option = ""read"", . const char * ; title = ""title"", . Int_t ; compression = ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault . ). Open or creates local XML file with name filename. ; It is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:46780,hash,hashes,46780,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['hash'],['hashes']
Security,"ble::FindElement ; (; const char * ; cname, . Bool_t ; insert . ). staticprivate . Find a class by name in the class table (using hash of name). ; Returns 0 if the class is not in the table. Unless arguments insert is true in which case a new entry is created and returned. cname must be the normalized name of the class. ; Definition at line 625 of file TClassTable.cxx. ◆ GetDict() [1/2]. DictFuncPtr_t TClassTable::GetDict ; (; const char * ; cname). static . Given the class name returns the Dictionary() function of a class (uses hash of name). ; Definition at line 674 of file TClassTable.cxx. ◆ GetDict() [2/2]. DictFuncPtr_t TClassTable::GetDict ; (; const std::type_info & ; info). static . Given the std::type_info returns the Dictionary() function of a class (uses hash of std::type_info::name()). ; Definition at line 692 of file TClassTable.cxx. ◆ GetDictNorm(). DictFuncPtr_t TClassTable::GetDictNorm ; (; const char * ; cname). static . Given the normalized class name returns the Dictionary() function of a class (uses hash of name). ; Definition at line 717 of file TClassTable.cxx. ◆ GetID(). Version_t TClassTable::GetID ; (; const char * ; cname). static . Returns the ID of a class. ; Definition at line 647 of file TClassTable.cxx. ◆ GetPragmaBits(). Int_t TClassTable::GetPragmaBits ; (; const char * ; name). static . Returns the pragma bits as specified in the LinkDef.h file. ; Definition at line 660 of file TClassTable.cxx. ◆ GetProto(). TProtoClass * TClassTable::GetProto ; (; const char * ; cname). static . Given the class name returns the TClassProto object for the class. ; (uses hash of name). ; Definition at line 742 of file TClassTable.cxx. ◆ GetProtoNorm(). TProtoClass * TClassTable::GetProtoNorm ; (; const char * ; cname). static . Given the class normalized name returns the TClassProto object for the class. ; (uses hash of name). ; Definition at line 770 of file TClassTable.cxx. ◆ Init(). void TClassTable::Init ; (; ). static . Definition at line 390 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTable.html:17487,hash,hash,17487,doc/master/classTClassTable.html,https://root.cern,https://root.cern/doc/master/classTClassTable.html,1,['hash'],['hash']
Security,"bleUpperLimit(unsigned int ivar, double upper); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector& insp) const; intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLinearMinimizer(int type = 0); TLinearMinimizer(const char* type); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. private:. TLinearMinimizer&operator=(const TLinearMinimizer& rhs); TLinearMinimizer(const TLinearMinimizer&). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IMultiGradFunction*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(const RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLinearMinimizer.html:5741,validat,validated,5741,root/html602/TLinearMinimizer.html,https://root.cern,https://root.cern/root/html602/TLinearMinimizer.html,2,['validat'],['validated']
Security,"ble_t ApplyKernelFunction(Double_t normalized_distance); from the normalized euclidean distance calculate the distance; for a certain kernel. Double_t KernelNormalization(Double_t pdf); Calculating the normalization factor only once (might need a reset at some point.; Can the method be restarted with different params?). Double_t GetNormalizedDistance(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Yair Mahalalel, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodPDERS.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodPDERS.html:25192,access,accessors,25192,root/html532/TMVA__MethodPDERS.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodPDERS.html,1,['access'],['accessors']
Security,"blic Member Functions inherited from TDocDirective; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDocLatexDirective.html:2232,hash,hash,2232,doc/master/classTDocLatexDirective.html,https://root.cern,https://root.cern/doc/master/classTDocLatexDirective.html,2,['hash'],['hash']
Security,"blic:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newArg'.; If 'oldArg' is not found in collection kFALSE is returned. TObject* FindObject(const char* name); Return pointer to obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj); Find object in list. If list contains object return; (same) pointer to object",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinkedList.html:6740,hash,hash-table,6740,root/html526/RooLinkedList.html,https://root.cern,https://root.cern/root/html526/RooLinkedList.html,1,['hash'],['hash-table']
Security,"bool nameIsNormalized);  ; template<typename List , typename Object > ; static void RemoveAndInvalidateObject (List &L, Object *O);  ; static Int_t ShallowAutoLoadImpl (const char *cls);  . Private Attributes; void * fAutoLoadCallBack;  ; std::vector< std::string > fAutoLoadLibStorage;  ; std::map< size_t, std::vector< const char * > > fClassesHeadersMap;  ; std::vector< std::pair< TClass *, DictFuncPtr_t > > fClassesToUpdate;  ; TClingCallbacks * fClingCallbacks;  ; std::vector< const char * > fCurExecutingMacros;  ; Bool_t fCxxModulesEnabled;  ; Int_t fExitCode;  ; Int_t fGlobalsListSerial;  ; Bool_t fHeaderParsingOnDemand;  ; TString fIncludePath;  ; MutexStateAndRecurseCount fInitialMutex;  ; std::unique_ptr< cling::Interpreter > fInterpreter;  ; Bool_t fIsAutoParsingSuspended;  ; bool fIsShuttingDown = false;  ; Bool_t fLockProcessLine;  ; std::set< size_t > fLookedUpClasses;  ; ROOT::TMetaUtils::TClingLookupHelper * fLookupHelper;  ; TEnv * fMapfile;  ; std::unique_ptr< cling::MetaProcessor > fMetaProcessor;  ; std::set< TClass * > fModTClasses;  ; ROOT::TMetaUtils::TNormalizedCtxt * fNormalizedCtxt;  ; std::unordered_set< const clang::NamespaceDecl * > fNSFromRootmaps;  ; std::set< const char * > fParsedPayloadsAddresses;  ; std::set< size_t > fPayloads;  ; std::map< std::string, llvm::StringRef > fPendingRdicts;  ; void * fPrevLoadedDynLibInfo;  ; char fPrompt [64];  ; std::vector< void * > fRegisterModuleDyLibs;  ; TObjArray * fRootmapFiles;  ; TString fRootmapLoadPath;  ; TString fSharedLibs;  ; std::map< SpecialObjectLookupCtx_t, SpecialObjectMap_t > fSpecialObjectMaps;  ; std::hash< std::string > fStringHashFunction;  ; std::vector< cling::Value > * fTemporaries;  ; ULong64_t fTransactionCount;  ; std::map< const cling::Transaction *, size_t > fTransactionHeadersMap;  . Static Private Attributes; static void * fgSetOfSpecials = nullptr;  ; static constexpr const char * kNullArgv [] = {nullptr};  . Friends; cling::Interpreter * TCling__GetInterpreter ();  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:50288,hash,hash,50288,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['hash'],['hash']
Security,"bool on);  flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit) ;  ; virtual bool SetVariableInitialRange (unsigned int, double, double);  set the initial range of an existing variable ;  ; template<class VariableIterator > ; int SetVariables (const VariableIterator &begin, const VariableIterator &end);  add variables . Return number of variables successfully added ;  ; int Status () const;  status code of minimizer ;  ; int Strategy () const;  strategy ;  ; double Tolerance () const;  absolute tolerance ;  . Private Attributes; ROOT::Math::GSLMultiMinimizer * fGSLMultiMin;  ; double fLSTolerance;  . Additional Inherited Members;  Protected Member Functions inherited from ROOT::Math::BasicMinimizer; bool CheckDimension () const;  ; bool CheckObjFunction () const;  ; MinimTransformFunction * CreateTransformation (std::vector< double > &startValues, const ROOT::Math::IMultiGradFunction *func=nullptr);  ; void SetFinalValues (const double *x, const MinimTransformFunction *func=nullptr);  ; void SetMinValue (double val);  ;  Protected Attributes inherited from ROOT::Math::Minimizer; MinimizerOptions fOptions;  minimizer options ;  ; int fStatus = -1;  status of minimizer ;  ; bool fValidError = false;  flag to control if errors have been validated (Hesse has been run in case of Minuit) ;  . #include <Math/GSLMinimizer.h>. Inheritance diagram for ROOT::Math::GSLMinimizer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ GSLMinimizer() [1/2]. ROOT::Math::GSLMinimizer::GSLMinimizer ; (; ROOT::Math::EGSLMinimizerType ; type = ROOT::Math::kConjugateFR). Default constructor. ; Definition at line 51 of file GSLMinimizer.cxx. ◆ GSLMinimizer() [2/2]. ROOT::Math::GSLMinimizer::GSLMinimizer ; (; const char * ; type). Constructor with a string giving name of algorithm. ; Definition at line 65 of file GSLMinimizer.cxx. ◆ ~GSLMinimizer(). ROOT::Math::GS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMinimizer.html:11562,validat,validated,11562,doc/master/classROOT_1_1Math_1_1GSLMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMinimizer.html,1,['validat'],['validated']
Security,"boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_t_errorCountNumber of errors remaining to print; static Bool_t_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:44852,access,access,44852,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,2,['access'],['access']
Security,"boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int, double); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string&) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int) const; virtual const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; TMVA::IFitterTarget*fFitness; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; ROOT::Math::GeneticMinimizerParametersfParameters; doubleROOT::Math::Minimizer::fPrecprecision; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int = 0). virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__GeneticMinimizer.html:4390,validat,validated,4390,root/html528/ROOT__Math__GeneticMinimizer.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__GeneticMinimizer.html,3,['validat'],['validated']
Security,"boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet! Current normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TVectorD*_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMomentMorph.html:40611,access,access,40611,root/html534/RooMomentMorph.html,https://root.cern,https://root.cern/root/html534/RooMomentMorph.html,1,['access'],['access']
Security,"boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Double_t_interpBoundary; vector<int>_interpCode; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Bool_t_logInit! flag used for chaching polynomial coefficients; vector<double>_low; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html:34179,access,access,34179,root/html534/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html,1,['access'],['access']
Security,"boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooResolutionModel.html:44128,access,access,44128,root/html602/RooResolutionModel.html,https://root.cern,https://root.cern/root/html602/RooResolutionModel.html,2,['access'],['access']
Security,"boxes. The expression can be dragged and dropped into any of the boxes (X, Y, Z, Cut, or Scan). To scan one or more variables, drop them into the Scan box, then double click on the box. You can also redirect the result of the scan to a file by checking the Scan box on top. When the “Rec” box is checked, the Draw and Scan commands are recorded in the history file and echoed on the command line. The “Histogram” text box contains the name of the resulting histogram. By default it is htemp. You can type any name, if the histogram does not exist it will create one. The Option text box contains the list of Draw options. See “Draw Options”. You can select the options with the Options menu. The Command box lets you enter any command that you could also enter on the command line. The vertical slider on the far left side can be used to select the minimum and maximum of an event range. The actual start and end index are shown in on the bottom in the status window.; There is an extensive help utility accessible with the Help menu. The IList and OList are to specify an input list of entry indices and a name for the output list respectively. Both need to be of type TList and contain integers of entry indices. These lists are described below in the paragraph “Error! Reference source not found.”. A couple of graphs. The first one is a plot of the age distribution, the second a scatter plot of the cost vs. age. The second one was generated by dragging the age leaf into the Y-box and the cost leaf into the X-box, and pressing the Draw button. By default, this will generate a scatter plot. Select a different option, for example ""lego"" to create a 2D histogram.; 12.7 Creating and Saving Trees; This picture shows the TTree class:. The TTree class. To create a TTree we use its constructor. Then we design our data layout and add the branches. A tree can be created by giving a name and title:; TTree t(""MyTree"",""Example Tree"");; 12.7.1 Creating a Tree from a Folder Hierarchy; An alternative ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:529869,access,accessible,529869,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessible']
Security,"brary name association can be set up using the rootmap facility.; For the library in the example above, which contains a dictionary; generated from the linkdef MyLinkdef.h, the command to generate the; rootmap file is; $ rlibmap -f -r rootmap -l mylib/libMyLib.so -d libCore.so -c MyLinkdef.h; Here, -r specifies that the entries for libMyLib should be updated,; -l specifies the library we're dealing with, -d its; dependencies, and -c its linkdef. The rootmap file must be within; one of the LD_LIBRARY_PATH (or PATH for Windows) directories; when ROOT is started, otherwise ROOT will not use it.; II.4 Recognizing class documentation; The class documentation has to appear in the header file containing the; class, right in front of its declaration. It is introduced by a string; defined by Root.Html.Description or SetClassDocTag(). See the section on; documentation syntax for further details.; Example:; Root.Html.Description: //____________________; The class documentation will show which include statement is to be used; and which library needs to be linked to access it.; The include file name is determined via. TClass::GetDeclFileName();; leading parts are removed if they match any of the ':' separated entries in; THtml::GetIncludePath().; II.5 Author, copyright, etc.; During the conversion,; THtml will look for; some strings (""tags"") in the source file, which have to appear right in; front of e.g. the author's name, copyright notice, etc. These tags can be; defined with the following environment variables: Root.Html.Author,; Root.Html.LastUpdate and Root.Html.Copyright, or with; SetAuthorTag(), SetLastUpdateTag(), SetCopyrightTag().; If the LastUpdate tag is not found, the current date and time are used.; This is useful when using; THtml::MakeAll()'s; default option force=kFALSE, in which case; THtml generates; documentation only for changed classes.; Authors can be a comma separated list of author entries. Each entry has; one of the following two formats; Name (non-alph",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THtml.html:4339,access,access,4339,root/html528/THtml.html,https://root.cern,https://root.cern/root/html528/THtml.html,10,['access'],['access']
Security,"brary only to be familiar with the semantic content of the objects in use. Locking access to objects that are being shared due to extra-semantic details of implementation (for example, copy-on-write) should remain the responsibility of the library.; All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within the library. The preferred way of providing this protection is to use mutex locks. The library also locks an object before writing to it. The developer is not required to explicitly lock or unlock a class object (static, global or local) to perform a single operation on the object. Note that even multithread safe level II hardly relieves the user of the library from the burden of locking. A thread suffers from deadlock if it is blocked waiting for a condition that will never occur. Typically, this occurs when one thread needs to access a resource that is already locked by another thread, and that other thread is trying to access a resource that has already been locked by the first thread. In this situation, neither thread is able to progress; they are deadlocked.; A multiprocessor is a hardware system with multiple processors or multiple, simultaneous execution units. Examples can be found at http://www-linux.gsi.de/~go4/HOWTOthreads/howtothreadsbody.html (the thread authors’ web site - Jörn Adamczewski and Marc Hemberger). 24 PROOF: Parallel Processing; ; The Parallel ROOT Facility, PROOF, is an extension of ROOT allowing transparent analysis of large sets of ROOT files in parallel on remote computer clusters or multi-core computers. The main design goals for the PROOF system are:; Transparency : there should be as little difference as possible between a local ROOT based analysis session and a remote parallel PROOF session, both being interactive and giving the same results.; Scalability : the basic architecture should not put any implicit limitations on the number",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1124491,access,access,1124491,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['access'],['access']
Security,"brary separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter()loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: “The picture is strangely rotated; where are the coordinate axes?”; A: If drawn in a new canvas, any view has some default viewpoint, center of view and size. One can then perform mouse/keyboard actions to change them:. Mouse left-click and drag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1005444,validat,validation,1005444,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['validat'],['validation']
Security,"bsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Int_t_coefIdxIndex code of the coefficient; RooRealProxy_convPdfRooAbsAnaConv object implementing our coefficient; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooConvCoefVar.html:33401,access,access,33401,root/html534/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html534/RooConvCoefVar.html,1,['access'],['access']
Security,"bsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooChangeTracker(); Default constructor. RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); Constructor. The set trackSet contains the observables to be; tracked for changes. If checkValues is true an additional; validation step is activated where the numeric values of the; tracked arguments are compared with reference values ensuring; that values have actually changed. RooChangeTracker(const RooChangeTracker& other, const char* name = 0); Copy constructor. Bool_t hasChanged(Bool_t clearState); Returns true if state has changes since last call with clearState=kTRUE; If clearState is true, changeState flag will be cleared. ~RooChangeTracker(); Destructor. RooArgSet parameters() const. TObject* clone(const char* newname) const; { return new RooChangeTracker(*this, newname); }. Double_t evaluate() const; { return 1 ; }. » Last changed: Tue Mar 10 17:15:55 2015 » Last generated: 2015-03-10 17:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChangeTracker.html:36768,validat,validation,36768,root/html534/RooChangeTracker.html,https://root.cern,https://root.cern/root/html534/RooChangeTracker.html,1,['validat'],['validation']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsCachedReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsCachedReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; Bool_tgetCdfBoundaries() const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDepende",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:12106,hash,hash,12106,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsCachedReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsCachedReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:12509,hash,hash,12509,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,9,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&RooAbsOptTestStatistic::function(); const RooAbsReal&RooAbsOptTestStatistic::function() const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:14078,hash,hash,14078,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,12,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&function(); const RooAbsReal&function() const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDepen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:12922,hash,hash,12922,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo1DMomentMorphFunction.html:11973,hash,hash,11973,root/html534/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo1DMomentMorphFunction.html,147,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; static Int_tgetCacheAllNumeric(); Bool_tgetCacheNumeric(); RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDepe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:11617,hash,hash,11617,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tgetAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PiecewiseInterpolation.html:11974,hash,hash,11974,root/html534/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html534/PiecewiseInterpolation.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tgetAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; Bool_tgetCdfBoundaries() const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:12197,hash,hash,12197,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tgetAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooConvCoefVar.html:12111,hash,hash,12111,root/html534/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html534/RooConvCoefVar.html,12,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooPlot*RooAbsRealLValue::frame() const; RooPlot*RooAbsRealLValue::frame(const RooLinkedList& cmdList) const; RooPlot*RooAbsRealLValue::frame(Int_t nbins) const; RooPlot*RooAbsRealLValue::frame(Double_t lo, Double_t hi) const; RooPlot*RooAbsRealLValue::frame(Double_t lo, Double_t hi, Int_t nbins) const; RooPlot*RooAbsRealLValue::frame(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooFunctor*RooAbsReal::functor(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooErrorVar.html:13262,hash,hash,13262,root/html534/RooErrorVar.html,https://root.cern,https://root.cern/root/html534/RooErrorVar.html,6,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooPlot*frame() const; RooPlot*frame(const RooLinkedList& cmdList) const; RooPlot*frame(Int_t nbins) const; RooPlot*frame(Double_t lo, Double_t hi) const; RooPlot*frame(Double_t lo, Double_t hi, Int_t nbins) const; RooPlot*frame(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsRealLValue.html:13412,hash,hash,13412,root/html534/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsRealLValue.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); TString*format(const RooCmdArg& formatArg) const; TString*format(Int_t sigDigits, const char* options) const; RooPlot*RooAbsRealLValue::frame() const; RooPlot*RooAbsRealLValue::frame(const RooLinkedList& cmdList) const; RooPlot*RooAbsRealLValue::frame(Int_t nbins) const; RooPlot*RooAbsRealLValue::frame(Double_t lo, Double_t hi) const; RooPlot*RooAbsRealLValue::frame(Double_t lo, Double_t hi, Int_t nbins) const; RooPlot*RooAbsRealLValue::frame(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealVar.html:13487,hash,hash,13487,root/html534/RooRealVar.html,https://root.cern,https://root.cern/root/html534/RooRealVar.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tgetAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:11865,hash,hash,11865,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; Double_tgetActual(Int_t ibin); virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tgetAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooParamHistFunc.html:12063,hash,hash,12063,root/html534/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html534/RooParamHistFunc.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; const RooArgSet*get(Int_t masterIdx) const; const RooArgSet*get(const RooArgSet& coord) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tgetAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:12207,hash,hash,12207,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tgetAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:12594,hash,hash,12594,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tgetAnalyticalIntegral(RooArgSet& allVars, RooArgSet& numVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:12160,hash,hash,12160,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,3,['hash'],['hash']
Security,"bsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); voidfollowAsSlave(RooRealMPFE& master); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; virtual Int_tRooAbsReal::getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealMPFE.html:12672,hash,hash,12672,root/html534/RooRealMPFE.html,https://root.cern,https://root.cern/root/html534/RooRealMPFE.html,3,['hash'],['hash']
Security,"bsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_flatSFInt; Bool_t_flip; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGExpModel.html:45619,access,access,45619,root/html602/RooGExpModel.html,https://root.cern,https://root.cern/root/html602/RooGExpModel.html,2,['access'],['access']
Security,"bsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood ; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:42046,access,access,42046,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,2,['access'],['access']
Security,"bsolute tolerance ;  . Protected Member Functions; template<class Func > ; bool DoMinimize (const Func &f);  Internal method to perform minimization template on the type of method function. ;  ;  Protected Member Functions inherited from ROOT::Math::BasicMinimizer; bool CheckDimension () const;  ; bool CheckObjFunction () const;  ; MinimTransformFunction * CreateTransformation (std::vector< double > &startValues, const ROOT::Math::IMultiGradFunction *func=nullptr);  ; void SetFinalValues (const double *x, const MinimTransformFunction *func=nullptr);  ; void SetMinValue (double val);  . Private Attributes; std::vector< double > fCovMatrix;  ; double fEdm;  ; std::vector< double > fErrors;  ; ROOT::Math::GSLMultiFit * fGSLMultiFit;  ; double fLSTolerance;  ; unsigned int fNCalls;  ; unsigned int fNFree;  ; bool fUseGradFunction = false;  . Additional Inherited Members;  Protected Attributes inherited from ROOT::Math::Minimizer; MinimizerOptions fOptions;  minimizer options ;  ; int fStatus = -1;  status of minimizer ;  ; bool fValidError = false;  flag to control if errors have been validated (Hesse has been run in case of Minuit) ;  . #include <Math/GSLNLSMinimizer.h>. Inheritance diagram for ROOT::Math::GSLNLSMinimizer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ GSLNLSMinimizer(). ROOT::Math::GSLNLSMinimizer::GSLNLSMinimizer ; (; int ; type = 0). Default constructor. ; Definition at line 206 of file GSLNLSMinimizer.cxx. ◆ ~GSLNLSMinimizer(). ROOT::Math::GSLNLSMinimizer::~GSLNLSMinimizer ; (; ). override . Destructor (no operations) ; Definition at line 228 of file GSLNLSMinimizer.cxx. Member Function Documentation. ◆ CovMatrix(). double ROOT::Math::GSLNLSMinimizer::CovMatrix ; (; unsigned int ; i, . unsigned int ; j . ); const. overridevirtual . return covariance matrices elements if the variable is fixed the matrix is zero The ordering of the variables is the same as in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLNLSMinimizer.html:11296,validat,validated,11296,doc/master/classROOT_1_1Math_1_1GSLNLSMinimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLNLSMinimizer.html,1,['validat'],['validated']
Security,"builds. chirp; ON; Chirp support (Condor remote I/O), requires libchirp_client. cling; ON; Enable new CLING C++ interpreter. cocoa; *; Use native Cocoa/Quartz graphics backend (MacOS X only). davix; *; DavIx library for HTTP/WEBDAV access. dcache; ON; dCache support, requires libdcap from DESY. exceptions; ON; Turn on compiler exception handling capability. explicit link; *; Explicitly link with all dependent libraries. fail-on-missing; OFF; Fail the configure step if a required external package is missing. fftw3; ON; Fast Fourier Transform support, requires libfftw3. fitsio; ON; Read images and data from FITS files, requires cfitsio. fortran; *; Enable the Fortran components of ROOT. gdml; *; GDML writer and reader. geocad; OFF; ROOT-CAD Interface. genvector; ON; Build the new libGenVector library. gfal; ON; GFAL support, requires libgfal. glite; ON; gLite support, requires libglite-api-wrapper v.3 from GSI (https://subversion.gsi.de/trac/dgrid/wiki). globus; OFF; Globus authentication support, requires Globus toolkit. gminimal; OFF; Do not automatically search for support libraries, but include X11. gnuinstall; OFF; Perform installation following the GNU guidelines. gsl_shared; OFF; Enable linking against shared libraries for GSL (default no). gviz; ON; Graphs visualization support, requires graphviz. hdfs; ON; HDFS support; requires libhdfs from HDFS >= 0.19.1. http; *; HTTP Server support. imt; ON; Enable ROOT Multithreading Capabilities (default ON from version 6.10). jemalloc; OFF; Using the jemalloc allocator. krb5; ON; Kerberos5 support, requires Kerberos libs. ldap; ON; LDAP support, requires (Open)LDAP libs. mathmore; ON; Build the new libMathMore extended math library, requires GSL (vers. >= 1.8). memstat; *; A memory statistics utility, helps to detect memory leaks. minimal; OFF; Do not automatically search for support libraries. minuit2; *; Build the new libMinuit2 minimizer library. monalisa; ON; Monalisa monitoring support, requires libapmoncpp. mt; OF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:9854,authenticat,authentication,9854,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['authenticat'],['authentication']
Security,"but the client should not see; 8436 * that, so the server should accept nonces from previous starts. */; 8437 /* However, the reasonable default is to not accept a nonce from a; 8438 * previous start, so if anyone changed the access rights between; 8439 * two restarts, a new login is required. */; 8440 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8441 /* nonce is from a previous start of the server and no longer valid; 8442 * (replay attack?) */; 8443 return 0;; 8444 }; 8445 /* Check if the nonce is too high, so it has not (yet) been used by the; 8446 * server. */; 8447 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8448 + conn->dom_ctx->nonce_count)) {; 8449 return 0;; 8450 }; 8451#else; 8452 (void)nonce;; 8453#endif; 8454 ; 8455 /* CGI needs it as REMOTE_USER */; 8456 if (ah->user != NULL) {; 8457 conn->request_info.remote_user =; 8458 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8459 } else {; 8460 return 0;; 8461 }; 8462 ; 8463 return 1;; 8464}; 8465 ; 8466 ; 8467static const char *; 8468mg_fgets(char *buf, size_t size, struct mg_file *filep); 8469{; 8470 if (!filep) {; 8471 return NULL;; 8472 }; 8473 ; 8474 if (filep->access.fp != NULL) {; 8475 return fgets(buf, (int)size, filep->access.fp);; 8476 } else {; 8477 return NULL;; 8478 }; 8479}; 8480 ; 8481/* Define the initial recursion depth for procesesing htpasswd files that; 8482 * include other htpasswd; 8483 * (or even the same) files. It is not difficult to provide a file or files; 8484 * s.t. they force civetweb; 8485 * to infinitely recurse and then crash.; 8486 */; 8487#define INITIAL_DEPTH 9; 8488#if INITIAL_DEPTH <= 0; 8489#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8490#endif; 8491 ; 8492#if !defined(NO_FILESYSTEMS); 8493struct read_auth_file_struct {; 8494 struct mg_connection *conn;; 8495 struct ah ah;; 8496 const char *domain;; 8497 char buf[256 + 256 + 40];; 8498 const char *f_user;; 8499 const char *f_domain;; 8500 const char *f_ha1;; 8501};; 8502 ; 8503 ; 8504static int; 8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:244529,access,access,244529,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"but the client should not see; 8437 * that, so the server should accept nonces from previous starts. */; 8438 /* However, the reasonable default is to not accept a nonce from a; 8439 * previous start, so if anyone changed the access rights between; 8440 * two restarts, a new login is required. */; 8441 if (nonce < (uint64_t)conn->phys_ctx->start_time) {; 8442 /* nonce is from a previous start of the server and no longer valid; 8443 * (replay attack?) */; 8444 return 0;; 8445 }; 8446 /* Check if the nonce is too high, so it has not (yet) been used by the; 8447 * server. */; 8448 if (nonce >= ((uint64_t)conn->phys_ctx->start_time; 8449 + conn->dom_ctx->nonce_count)) {; 8450 return 0;; 8451 }; 8452#else; 8453 (void)nonce;; 8454#endif; 8455 ; 8456 /* CGI needs it as REMOTE_USER */; 8457 if (ah->user != NULL) {; 8458 conn->request_info.remote_user =; 8459 mg_strdup_ctx(ah->user, conn->phys_ctx);; 8460 } else {; 8461 return 0;; 8462 }; 8463 ; 8464 return 1;; 8465}; 8466 ; 8467 ; 8468static const char *; 8469mg_fgets(char *buf, size_t size, struct mg_file *filep); 8470{; 8471 if (!filep) {; 8472 return NULL;; 8473 }; 8474 ; 8475 if (filep->access.fp != NULL) {; 8476 return fgets(buf, (int)size, filep->access.fp);; 8477 } else {; 8478 return NULL;; 8479 }; 8480}; 8481 ; 8482/* Define the initial recursion depth for procesesing htpasswd files that; 8483 * include other htpasswd; 8484 * (or even the same) files. It is not difficult to provide a file or files; 8485 * s.t. they force civetweb; 8486 * to infinitely recurse and then crash.; 8487 */; 8488#define INITIAL_DEPTH 9; 8489#if INITIAL_DEPTH <= 0; 8490#error Bad INITIAL_DEPTH for recursion, set to at least 1; 8491#endif; 8492 ; 8493#if !defined(NO_FILESYSTEMS); 8494struct read_auth_file_struct {; 8495 struct mg_connection *conn;; 8496 struct ah ah;; 8497 const char *domain;; 8498 char buf[256 + 256 + 40];; 8499 const char *f_user;; 8500 const char *f_domain;; 8501 const char *f_ha1;; 8502};; 8503 ; 8504 ; 8505static int; 8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:244561,access,access,244561,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"but we can't find the offset; because it's virtual.; Takes care of multiple inheritance. Int_t GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); Return data member offset to the base class ""cl"".; Returns -1 in case ""cl"" is not a base class.; Takes care of multiple inheritance. TClass * GetBaseDataMember(const char* datamember); Return pointer to (base) class that contains datamember. ROOT::ESTLType GetCollectionType() const; Return the 'type' of the STL the TClass is representing.; and return ROOT::kNotSTL if it is not representing an STL collection. TVirtualCollectionProxy * GetCollectionProxy() const; Return the proxy describing the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). ClassConvStreamerFunc_t GetConvStreamerFunc() const; Get a wrapper/accessor function around this class custom conversion streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. TClass * GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified ClassInfo.; If load is true an attempt is made to obtain the class by loading; the appropriate shar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClass.html:35966,access,accessor,35966,root/html604/TClass.html,https://root.cern,https://root.cern/root/html604/TClass.html,1,['access'],['accessor']
Security,"buted according the histogram bin contents.; This function checks if the bins integral exists. If not, the integral; is evaluated, normalized to one.; The integral is automatically recomputed if the number of entries; is not the same then when the integral was computed.; NB Only valid for 1-d histograms. Use GetRandom2 or 3 otherwise.; If the histogram has a bin with negative content a NaN is returned. Double_t GetBinContent(Int_t bin) const; Return content of bin number bin. Implemented in TH1C,S,F,D. Convention for numbering bins. For all histogram types: nbins, xlow, xup; bin = 0; underflow bin; bin = 1; first bin with low-edge xlow INCLUDED; bin = nbins; last bin with upper-edge xup EXCLUDED; bin = nbins+1; overflow bin; In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; For example, assuming a 3-D histogram with binx,biny,binz, the function; Int_t bin = h->GetBin(binx,biny,binz);; returns a global/linearized bin number. This global bin is useful; to access the bin information independently of the dimension. Double_t GetBinWithContent(Double_t c, Int_t& binx, Int_t firstx = 0, Int_t lastx = 0, Double_t maxdiff = 0) const; compute first binx in the range [firstx,lastx] for which; diff = abs(bin_content-c) <= maxdiff; In case several bins in the specified range with diff=0 are found; the first bin found is returned in binx.; In case several bins in the specified range satisfy diff <=maxdiff; the bin with the smallest difference is returned in binx.; In all cases the function returns the smallest difference. NOTE1: if firstx <= 0, firstx is set to bin 1; if (lastx < firstx then firstx is set to the number of bins; ie if firstx=0 and lastx=0 (default) the search is on all bins.; NOTE2: if maxdiff=0 (default), the first bin with content=c is returned. Double_t Interpolate(Double_t x); Given a point x, approximates the value via linear interpolation; based on the two nearest bin centers; Andy Mastbaum 10/21/08. Double_t Interpolate(Double_t x, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:97211,access,access,97211,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['access'],['access']
Security,"by branch; put its dictionary into dict, return its type name. ;  ; static std::string GetElementTypeName (const std::type_info &ti);  Stringify the template argument. ;  ;  Protected Attributes inherited from ROOT::Internal::TTreeReaderValueBase; TString fBranchName;  Name of the branch to read data from. ;  ; TDictionary * fDict;  Type that the branch should contain. ;  ; bool fHaveLeaf: 1;  Whether the data is in a leaf. ;  ; bool fHaveStaticClassOffsets: 1;  Whether !fStaticClassOffsets.empty() ;  ; TLeaf * fLeaf = nullptr;  ; TString fLeafName;  ; bool fOpaqueRead {false};  If true, the reader will not do any type-checking against the actual type held by the branch. ;  ; Detail::TBranchProxy * fProxy = nullptr;  Proxy for this branch, owned by TTreeReader. ;  ; Read_t fProxyReadFunc = &TTreeReaderValueBase::ProxyReadDefaultImpl;  ! Pointer to the Read implementation to use. ;  ; EReadStatus fReadStatus: 2;  Read status of this data access. ;  ; ESetupStatus fSetupStatus = kSetupNotSetup;  Setup status of this data access. ;  ; std::vector< Long64_t > fStaticClassOffsets;  ; TTreeReader * fTreeReader;  Tree reader we belong to. ;  . #include <TTreeReaderValue.h>. Inheritance diagram for TTreeReaderValue< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ NonConstT_t. template<typename T > . using TTreeReaderValue< T >::NonConstT_t = typename std::remove_const<T>::type. Definition at line 178 of file TTreeReaderValue.h. Constructor & Destructor Documentation. ◆ TTreeReaderValue() [1/2]. template<typename T > . TTreeReaderValue< T >::TTreeReaderValue ; (; ). delete . ◆ TTreeReaderValue() [2/2]. template<typename T > . TTreeReaderValue< T >::TTreeReaderValue ; (; TTreeReader & ; tr, . const char * ; branchname . ). inline . Definition at line 180 of file TTreeReaderValue.h. Member Function Documentation. ◆ Get(). template<typename T > . T * TTreeReaderValue< T >::Get ; (; ). inline .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReaderValue.html:5339,access,access,5339,doc/master/classTTreeReaderValue.html,https://root.cern,https://root.cern/doc/master/classTTreeReaderValue.html,1,['access'],['access']
Security,"by default START TRANSACTION/COMMIT; SQL commands are used before and after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hopefully, this should be straigthforward. Known problems and open questions.; 1) TTree is not supported by TSQLFile. There is independent development; of TTreeSQL class, which allows to store trees directly in SQL database; 2) TClonesArray is store objects in raw format,; which can not be accessed outside ROOT.; This will be changed later.; 3) TDirectory cannot work. Hopefully, will (changes in ROOT basic I/O is required); 4) Streamer infos are not written to file, therefore schema evolution; is not yet supported. All eforts are done to enable this feature in; the near future. Example how TSQLFile can be used:. example of a session saving data to a SQL data base. const char* dbname = ""mysql://host.domain:3306/dbname"";; const char* username = ""username"";; const char* userpass = ""userpass"";. // Clean data base and create primary tables; TSQLFile* f = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:5276,access,access,5276,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,5,['access'],['access']
Security,"by used web display (like CEF or Chromium) ;  ; void SetMaxQueueLength (unsigned len=10);  configures maximal queue length of data which can be held by window ;  ; void SetNativeOnlyConn (bool on=true);  configures that only native (own-created) connections are allowed ;  ; void SetOperationTmout (float tm=50.);  Set timeout for synchronous WebWindow operations. ;  ; void SetPanelName (const std::string &name);  Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel.html"" as default HTML page At the moment only FitPanel is existing. ;  ; void SetPosition (unsigned x, unsigned y);  Set window position. Will be applied if supported by used web display (like CEF or Chromium) ;  ; void SetRequireAuthKey (bool on);  Configure if authentication key in connection string is required. ;  ; void SetUseCurrentDir (bool on=true);  Configure if window can access local files via currentdir/ path of http server. ;  ; void SetUserArgs (const std::string &args);  Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into connectWebWindow({}) Must be set before RWebWindow::Show() method is called. ;  ; unsigned Show (const RWebDisplayArgs &args="""");  Show window in specified location. ;  ; void StartThread ();  Start special thread which will be used by the window to handle all callbacks One has to be sure, that access to global ROOT structures are minimized and protected with ROOT::EnableThreadSafety(); call. ;  ; void StopThread ();  Stop special thread. ;  ; void Sync ();  Special method to process all internal activity when window runs in separate thread. ;  ; void TerminateROOT ();  Terminate ROOT session Tries to correctly close THttpServer, associated with RWebWindowsManager After that exit from process. ;  ; void UseServerThreads ();  Let use THttpServer threads to process requests WARNING!!! only for expert use Should be only used when application provides ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:9552,access,accessible,9552,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['access'],['accessible']
Security,"byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager; RooSetProxy_cacheObsNon-convolution observables that are also cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFFTConvPdf.html:48603,access,access,48603,root/html602/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html602/RooFFTConvPdf.html,2,['access'],['access']
Security,"bytes (treated as unsigned char values,; so that `\200' is greater than `\0', for example). Zero-length; strings are always identical. Int_t CountChar(Int_t c) const; Return number of times character c occurs in the string. TString Copy() const; Copy a string. Ssiz_t First(char c) const; Find first occurrence of a character c. Ssiz_t First(const char* cs) const; Find first occurrence of a character in cs. UInt_t HashCase() const; Return a case-sensitive hash value (endian independent). UInt_t HashFoldCase() const; Return a case-insensitive hash value (endian independent). UInt_t Hash(TString::ECaseCompare cmp = kExact) const; Return hash value. UInt_t Hash(const void* txt, Int_t ntxt); Calculates hash index from any char string. (static function); For string: i = TString::Hash(string,nstring);; For int: i = TString::Hash(&intword,sizeof(int));; For pointer: i = TString::Hash(&pointer,sizeof(void*));. This employs two different hash functions, depending on ntxt:; ntxt == sizeof(void*): a simple bitwise xor to get fast pointer hashes; else: MurmurHash3_x64_128 http://code.google.com/p/smhasher. Ssiz_t Index(const char* pat, Ssiz_t patlen, Ssiz_t i, TString::ECaseCompare cmp) const; Search for a string in the TString. Plen is the length of pattern,; startIndex is the index from which to start and cmp selects the type; of case-comparison. Ssiz_t Last(char c) const; Find last occurrence of a character c. TString MD5() const; Return the MD5 digest for this string, in a string representation. Bool_t MaybeRegexp() const; Returns true if string contains one of the regexp characters ""^$.[]*+?"". Bool_t MaybeWildcard() const; Returns true if string contains one of the wildcard characters ""[]*?"". TString& Prepend(char c, Ssiz_t rep = 1); Prepend character c rep times to string. TString & Replace(Ssiz_t pos, Ssiz_t n, const char* s, Ssiz_t ns); Remove at most n1 characters from self beginning at pos,; and replace them with the first n2 characters of cs. TString& ReplaceAll(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TString.html:11636,hash,hash,11636,root/html534/TString.html,https://root.cern,https://root.cern/root/html534/TString.html,6,['hash'],"['hash', 'hashes']"
Security,"bytes Output string will be hex formatted and includes ""-"" separator after every 4 bytes Example for 16 bytes: ""fca45856-41bee066-ff74cc96-9154d405"". ; Definition at line 178 of file RWebWindowsManager.cxx. ◆ GetLaunchTmout(). float ROOT::RWebWindowsManager::GetLaunchTmout ; (; ); const. inlineprivate . Returns timeout for launching new browser process. ; Definition at line 61 of file RWebWindowsManager.hxx. ◆ GetServer(). THttpServer * ROOT::RWebWindowsManager::GetServer ; (; ); const. inline . Returns THttpServer instance. ; Definition at line 84 of file RWebWindowsManager.hxx. ◆ GetServerAddr(). std::string ROOT::RWebWindowsManager::GetServerAddr ; (; ); const. inline . Returns http address of the server, empty string when not available. ; Definition at line 87 of file RWebWindowsManager.hxx. ◆ GetUrl(). std::string RWebWindowsManager::GetUrl ; (; RWebWindow & ; win, . bool ; remote = false, . std::string * ; produced_key = nullptr . ). private . Provide URL address to access specified window from inside or from remote. ; Definition at line 600 of file RWebWindowsManager.cxx. ◆ InformListener(). bool RWebWindowsManager::InformListener ; (; const std::string & ; msg). private . If ROOT_LISTENER_SOCKET variable is configured, message will be sent to that unix socket. ; Definition at line 227 of file RWebWindowsManager.cxx. ◆ Instance(). std::shared_ptr< RWebWindowsManager > & RWebWindowsManager::Instance ; (; ). static . Returns default window manager Used to display all standard ROOT elements like TCanvas or TFitPanel. ; Definition at line 78 of file RWebWindowsManager.cxx. ◆ IsLoopbackMode(). bool RWebWindowsManager::IsLoopbackMode ; (; ). static . Returns true if loopback mode used by THttpServer for web widgets. ; Definition at line 146 of file RWebWindowsManager.cxx. ◆ IsMainThrd(). bool RWebWindowsManager::IsMainThrd ; (; ). static . Returns true when called from main process Main process recognized at the moment when library is loaded It supposed to be a thre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:11762,access,access,11762,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['access'],['access']
Security,"c Member Functions |; Static Public Member Functions |; Protected Attributes |; List of all members ; THtml::TFileSysDir Class Reference. . Definition at line 138 of file THtml.h. Public Member Functions;  TFileSysDir (const char *name, TFileSysDir *parent);  ; const TList * GetFiles () const;  ; const TList * GetSubDirs () const;  ; TClass * IsA () const override;  ; void Recurse (TFileSysDB *db, const char *path);  Recursively fill entries by parsing the contents of path. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THtml::TFileSysEntry;  TFileSysEntry (const char *name, TFileSysDir *parent);  ;  ~TFileSysEntry () override;  ; virtual void GetFullName (TString &fullname, Bool_t asIncluded) const;  ; Int_t GetLevel () const;  ; const char * GetName () const override;  Returns name of object. ;  ; TFileSysDir * GetParent () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml_1_1TFileSysDir.html:1181,hash,hash,1181,doc/master/classTHtml_1_1TFileSysDir.html,https://root.cern,https://root.cern/doc/master/classTHtml_1_1TFileSysDir.html,1,['hash'],['hash']
Security,"c TColorGradient::ECoordinateModekObjectBoundingMode; static TObject::(anonymous)TObject::kOverwrite; static TColorGradient::ECoordinateModekPadMode; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; Int_tTColor::fNumberColor number identifier; TStringTNamed::fTitleobject title. private:. vector<Double_t>fColorPositions; vector<Double_t>fColorsRGBA values.; TColorGradient::ECoordinateModefCoordinateMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TColorGradient(). TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); I have no way to validate parameters here, so it's up to user; to pass correct arguments. TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Double_t* colors, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); I have no way to validate parameters here, so it's up to user; to pass correct arguments. void ResetColor(UInt_t nPoints, const Double_t* points, const Color_t* colorIndices). void ResetColor(UInt_t nPoints, const Double_t* points, const Double_t* colorIndices). void SetCoordinateMode(TColorGradient::ECoordinateMode mode). const Double_t * GetColorPositions() const. const Double_t * GetColors() const. void RegisterColor(Color_t colorIndex). TColorGradient(). TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode). ECoordinateMode GetCoordinateMode() const. SizeType_t GetNumberOfSteps() const. » Last changed: root/base:$Id$ » Last generated: 2015-06-02 15:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TColorGradient.html:10980,validat,validate,10980,root/html604/TColorGradient.html,https://root.cern,https://root.cern/root/html604/TColorGradient.html,1,['validat'],['validate']
Security,"c TColorGradient::ECoordinateModekObjectBoundingMode; static TObject::(anonymous)TObject::kOverwrite; static TColorGradient::ECoordinateModekPadMode; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; Int_tTColor::fNumberColor number identifier; TStringTNamed::fTitleobject title. private:. vector<Double_t>fColorPositions; vector<Double_t>fColorsRGBA values.; TColorGradient::ECoordinateModefCoordinateMode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TColorGradient(). TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); I have no way to validate parameters here, so it's up to user; to pass correct arguments. TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Double_t* colors, TColorGradient::ECoordinateMode mode = kObjectBoundingMode); I have no way to validate parameters here, so it's up to user; to pass correct arguments. void ResetColor(UInt_t nPoints, const Double_t* points, const Color_t* colorIndices). void ResetColor(UInt_t nPoints, const Double_t* points, const Double_t* colorIndices). void SetCoordinateMode(TColorGradient::ECoordinateMode mode). const Double_t * GetColorPositions() const. const Double_t * GetColors() const. void RegisterColor(Color_t colorIndex). TColorGradient(). TColorGradient(Color_t newColor, UInt_t nPoints, const Double_t* points, const Color_t* colorIndices, TColorGradient::ECoordinateMode mode = kObjectBoundingMode). ECoordinateMode GetCoordinateMode() const. SizeType_t GetNumberOfSteps() const. » Last changed: root/base:$Id$ » Last generated: 2015-06-30 14:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TColorGradient.html:10980,validat,validate,10980,root/html602/TColorGradient.html,https://root.cern,https://root.cern/root/html602/TColorGradient.html,1,['validat'],['validate']
Security,"c TDatime GetGlobalExpDate ();  Static method returning default expiring date for new validity contexts. ;  ; static Bool_t GetGlobalPwHash ();  Static method returning the global password hash flag. ;  ; static Bool_t GetGlobalSRPPwd ();  Static method returning the global SRP password flag. ;  ; static const char * GetGlobalUser ();  Static method returning the global user. ;  ; static GlobusAuth_t GetGlobusAuthHook ();  Static method returning the globus authorization hook (no longer supported) ;  ; static THostAuth * GetHostAuth (const char *host, const char *user="""", Option_t *opt=""R"", Int_t *Exact=nullptr);  Sets fUser=user and search fgAuthInfo for the entry pertaining to (host,user), setting fHostAuth accordingly. ;  ; static const char * GetKrb5Principal ();  Static method returning the principal to be used to init Krb5 tickets. ;  ; static Bool_t GetPromptUser ();  Static method returning the prompt user settings. ;  ; static TList * GetProofAuthInfo ();  Static method returning the list with authentication directives to be sent to proof. ;  ; static Int_t GetRSAInit ();  Static method returning the RSA initialization flag. ;  ; static const char * GetRSAPubExport (Int_t key=0);  Static method returning the RSA public keys. ;  ; static THostAuth * HasHostAuth (const char *host, const char *user, Option_t *opt=""R"");  Checks if a THostAuth with exact match for {host,user} exists in the fgAuthInfo list If opt = ""P"" use ProofAuthInfo list instead Returns pointer to it or 0. ;  ; static void InitRandom ();  Initialize random machine using seed from /dev/urandom (or current time if /dev/urandom not available). ;  ; static void MergeHostAuthList (TList *Std, TList *New, Option_t *Opt="""");  Tool for updating fgAuthInfo or fgProofAuthInfo 'nin' contains list of last input information through (re)reading of a rootauthrc-alike file. ;  ; static char * PromptPasswd (const char *prompt=""Password: "");  Static method to prompt for the user's passwd to be used for authenti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:12589,authenticat,authentication,12589,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"c TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TRecGuiEvent::ERootAtomskROOT_MESSAGE; static TObject::(anonymous)TObject::kSingleKey; static TRecGuiEvent::ERootAtomskWM_DELETE_WINDOW; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance Chart:. TObject. ←; TRecEvent. ←; TRecGuiEvent. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. TRecorder & operator=(const TRecorder&). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 16:31; This page has been automatically generated. For comment",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRecGuiEvent.html:8796,expose,exposes,8796,root/html604/TRecGuiEvent.html,https://root.cern,https://root.cern/root/html604/TRecGuiEvent.html,3,['expose'],"['exposed', 'exposes']"
Security,"c TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TRecGuiEvent::ERootAtomskROOT_MESSAGE; static TObject::(anonymous)TObject::kSingleKey; static TRecGuiEvent::ERootAtomskWM_DELETE_WINDOW; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance Chart:. TObject. ←; TRecEvent. ←; TRecGuiEvent. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. TRecorder & operator=(const TRecorder&). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comment",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRecGuiEvent.html:8796,expose,exposes,8796,root/html602/TRecGuiEvent.html,https://root.cern,https://root.cern/root/html602/TRecGuiEvent.html,3,['expose'],"['exposed', 'exposes']"
Security,"c const char * TMVA::CvSplitKFolds::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 117 of file CvSplit.h. ◆ GetEventIndexToFoldMapping(). std::vector< UInt_t > TMVA::CvSplitKFolds::GetEventIndexToFoldMapping ; (; UInt_t ; nEntries, . UInt_t ; numFolds, . UInt_t ; seed = 100 . ). private . Generates a vector of fold assignments. ; Parameters. [in]nEntriesNumber of events in range ; [in]numFoldsNumber of folds to split data into ; [in]seedRandom seed. Randomly assigns events to numFolds folds. Each fold will hold at most nEntries / numFolds + 1 events. ; Definition at line 293 of file CvSplit.cxx. ◆ IsA(). TClass * TMVA::CvSplitKFolds::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TMVA::CvSplit.; Definition at line 117 of file CvSplit.h. ◆ MakeKFoldDataSet(). void TMVA::CvSplitKFolds::MakeKFoldDataSet ; (; DataSetInfo & ; dsi). overridevirtual . Prepares a DataSet for cross validation. ; Implements TMVA::CvSplit.; Definition at line 255 of file CvSplit.cxx. ◆ SplitSets(). std::vector< std::vector< TMVA::Event * > > TMVA::CvSplitKFolds::SplitSets ; (; std::vector< TMVA::Event * > & ; oldSet, . UInt_t ; numFolds, . UInt_t ; numClasses . ). private . Split sets for into k-folds. ; Parameters. [in]oldSetOriginal, unsplit, events ; [in]numFoldsNumber of folds to split data into ; [in]numClassesnumber of classes to stratify into . Definition at line 320 of file CvSplit.cxx. ◆ Streamer(). void TMVA::CvSplitKFolds::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TMVA::CvSplit. ◆ StreamerNVirtual(). void TMVA::CvSplitKFolds::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 117 of file CvSplit.h. Member Data Documentation. ◆ CrossValidation. friend TMVA::CvSplitKFolds::CrossValidation. private . Definition at line 94 of file CvSplit.h. ◆ fEventToFoldMappin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CvSplitKFolds.html:18136,validat,validation,18136,doc/master/classTMVA_1_1CvSplitKFolds.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CvSplitKFolds.html,1,['validat'],['validation']
Security,"c keys from export string rsaPubExport. ;  ; static void SetSecureAuthHook (SecureAuth_t func);  Set secure authorization function. ;  ; static void SetTimeOut (Int_t to);  Set timeout (active if > 0) ;  ; static void Show (Option_t *opt=""S"");  Print info about the authentication sector. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; Int_t ClearAuth (TString &user, TString &passwd, Bool_t &pwhash);  UsrPwd client authentication code. ;  ; Int_t GenRSAKeys ();  Generate a valid pair of private/public RSA keys to protect for authentication token exchange. ;  ; Bool_t GetPwHash () const;  ; char * GetRandString (Int_t Opt, Int_t Len);  Allocates and fills a 0 terminated buffer of length len+1 with len random characters. ;  ; Int_t GetRSAKey () const;  ; ESecurity GetSecurity () const;  ; Bool_t GetSRPPwd () const;  ; const char * GetSshUser (TString user) const;  Method returning the user to be used for the ssh login (no longer supported) ;  ; Bool_t GetUserPasswd (TString &user, TString &passwd, Bool_t &pwhash, Bool_t srppwd);  Try to get user name and passwd from several sources. ;  ; Int_t GetVersion () const;  ; Int_t ProofAuthSetup ();  Authentication related stuff setup in TProofServ. ;  ; Int_t RfioAuth (TString &user);  RFIO authentication (no longer supported) ;  ; void SetEnvironment ();  Set default authentication environment. ;  ; Int_t SshAuth (TString &user);  SSH client authentication code (no longer supported) ;  ; Int_t SshError (const char *errfile);  . Stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:17092,authenticat,authentication,17092,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['authenticat'],['authentication']
Security,"c'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t[4] col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t[4] col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t[4] col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj, const char* varname); Find address of Color_t data-member with name varname in object; obj. This is used to access color information for TGListTreeItem; coloration from visualization macros that wrap TObjects into; TEveElementObjectPtr instances. void SetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); Tweak all ROOT colors to become brighter (if value > 0) or; darker (value < 0). Reasonable values for the value argument are; from -2.5 to 2.5 (error will be printed otherwise).; If value is zero, the original colors are restored. You should call TEveManager::FullRedraw3D() afterwards or set; the argument full_redraw to true (default is false). Bool_t IsU1IntervalContainedByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is contained within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] interval and; minM <= maxM & minQ <= maxQ. Bool_t IsU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); Return true if interval Q is overlapping within interval M for U1 variables.; It is assumed that all values are within the [-2pi, 2pi] inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveUtil.html:3405,access,access,3405,root/html602/TEveUtil.html,https://root.cern,https://root.cern/root/html602/TEveUtil.html,2,['access'],['access']
Security,"c.; These files will only be used when their access masks are 0600.; Returns kTRUE if user and passwd were found for the machine; specified in the URL. If kFALSE, user and passwd are """".; If srppwd == kTRUE then a SRP ('secure') pwd is searched for in; the files.; The boolean pwhash is set to kTRUE if the returned passwd is to; be understood as password hash, i.e. if the 'password-hash' keyword; is found in the 'machine' lines; not implemented for 'secure'; and the .netrc file.; The format of these files are:. # this is a comment line; machine <machine fqdn> login <user> password <passwd>; machine <machine fqdn> login <user> password-hash <passwd>. and in addition ~/.rootnetrc also supports:. secure <machine fqdn> login <user> password <passwd>. <machine fqdn> may be a domain name or contain the wild card '*'. for the secure protocols. All lines must start in the first column. const char * GetGlobalUser(); Static method returning the global user. Bool_t GetGlobalPwHash(); Static method returning the global password hash flag. Bool_t GetGlobalSRPPwd(); Static method returning the global SRP password flag. TDatime GetGlobalExpDate(); Static method returning default expiring date for new validity contexts. const char * GetDefaultUser(); Static method returning the default user information. const char * GetKrb5Principal(); Static method returning the principal to be used to init Krb5 tickets. Bool_t GetAuthReUse(); Static method returning the authentication reuse settings. Bool_t GetPromptUser(); Static method returning the prompt user settings. const char * GetAuthMethod(Int_t idx); Static method returning the method corresponding to idx. Int_t GetAuthMethodIdx(const char* meth); Static method returning the method index (which can be used to find; the method in GetAuthMethod()). Returns -1 in case meth is not found. char * PromptUser(const char* remote); Static method to prompt for the user name to be used for authentication; to rootd or proofd. User is asked to type us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:13113,password,password,13113,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,14,"['hash', 'password']","['hash', 'password']"
Security,"cal TTree query interface. 1.6.2.1 Library Dependencies. ROOT libraries dependencies. The libraries are designed and organized to minimize dependencies, such that you can load just enough code for the task at hand rather than having to load all libraries or one monolithic chunk. The core library (libCore.so) contains the essentials; it is a part of all ROOT applications. In the Figure 1-2 you see that libCore.so is made up of base classes, container classes, meta information classes, operating system specific classes, and the ZIP algorithm used for compression of the ROOT files.; The Cling library (libCling.so) is also needed in all ROOT applications, and even by libCore. A program referencing only TObject only needs libCore; libCling will be opened automatically. To add the ability to read and write ROOT objects one also has to load libRIO. As one would expect, none of that depends on graphics or the GUI.; Library dependencies have different consequences; depending on whether you try to build a binary, or you just try to access a class that is defined in a library.; 1.6.2.2 Linktime Library Dependencies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:21439,access,access,21439,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"cal);; 909 ; 910 if (!fLists){; 911 //there are no sublists; 912 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))){; 913 return this;; 914 } else {; 915 //if the file is local, try the full name, unless ""ne"" option was specified; 916 if (!nexp && local){; 917 gSystem->ExpandPathName(fn);; 918 if (!gSystem->IsAbsoluteFileName(fn)); 919 gSystem->PrependPathName(gSystem->pwd(), fn);; 920 fn = gSystem->UnixPathName(fn);; 921 if (!strcmp(treename, fTreeName.Data()) && !(strcmp(fn.Data(), fFileName.Data()))); 922 return this;; 923 }; 924 return nullptr;; 925 }; 926 }; 927 ; 928 TString stotal = treename;; 929 stotal.Append(fn);; 930 ULong_t newhash = stotal.Hash();; 931 ; 932 TIter next(fLists);; 933 TEntryList *templist;; 934 while ((templist = (TEntryList*)next())){; 935 if (templist->fStringHash==0){; 936 stotal = templist->fTreeName + templist->fFileName;; 937 templist->fStringHash = stotal.Hash();; 938 }; 939 if (gDebug > 1); 940 Info(""GetEntryList"", ""file: %s (fn: %s), hash: %lu, element hash: %lu"",; 941 filename, fn.Data(), newhash, templist->fStringHash);; 942 if (newhash == templist->fStringHash){; 943 if (!strcmp(templist->GetTreeName(), treename) && !strcmp(templist->GetFileName(), fn.Data())){; 944 return templist;; 945 }; 946 }; 947 }; 948 ; 949 //didn't find anything for this filename, try the full name too; 950 if (!nexp && local){; 951 TString longname = fn;; 952 gSystem->ExpandPathName(longname);; 953 if (!gSystem->IsAbsoluteFileName(longname)); 954 gSystem->PrependPathName(gSystem->pwd(), longname);; 955 longname = gSystem->UnixPathName(longname);; 956 stotal = treename;; 957 stotal.Append(longname);; 958 newhash = stotal.Hash();; 959 next.Reset();; 960 while ((templist = (TEntryList*)next())){; 961 if (templist->fStringHash==0){; 962 stotal = templist->fTreeName + templist->fFileName;; 963 templist->fStringHash = stotal.Hash();; 964 }; 965 if (gDebug > 1); 966 Info(""GetEntryList"", ""file: %s (longname: %s), hash: %lu, elem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:31736,hash,hash,31736,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,2,['hash'],['hash']
Security,"calar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:13809,access,access,13809,root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"cale factor histograms: ""nominal"", ""weight:up"" and ""weight:down"".; auto histos_mc = VariationsFor(df_with_variations_mc);; ; // Evaluate the total MC uncertainty based on the variations. Note, in this case the uncertainties are symmetric.; for (unsigned int i = 0; i < histos_mc[""nominal""].GetXaxis()->GetNbins(); i++) {; histos_mc[""nominal""].SetBinError(; i, (histos_mc[""weight:up""].GetBinContent(i) - histos_mc[""nominal""].GetBinContent(i)));; }; ; // Make the plot of the data, individual MC contributions and the total MC scale factor systematic variations.; gROOT->SetStyle(""ATLAS"");; ; // Create canvas with pad; auto c = new TCanvas(""c"", "" "", 600, 600);; auto pad = new TPad(""upper_pad"", """", 0, 0, 1, 1);; pad->SetTickx(0);; pad->SetTicky(0);; pad->Draw();; pad->cd();; ; // Draw stack with MC contributions; // Draw cloned histograms to preserve graphics when original objects goes out of scope; df_other->SetFillColor(kViolet - 9);; df_zz->SetFillColor(kAzure - 9);; df_higgs->SetFillColor(kRed + 2);; ; auto stack = new THStack(""stack"", """");; auto h_other = static_cast<TH1 *>(df_other->Clone());; stack->Add(h_other);; auto h_zz = static_cast<TH1 *>(df_zz->Clone());; stack->Add(h_zz);; auto h_higgs = static_cast<TH1 *>(df_higgs->Clone());; stack->Add(h_higgs);; stack->Draw(""HIST"");; ; // stack histogram can be accessed only after drawing; stack->GetHistogram()->SetTitle("""");; stack->GetHistogram()->GetXaxis()->SetLabelSize(0.035);; stack->GetHistogram()->GetXaxis()->SetTitleSize(0.045);; stack->GetHistogram()->GetXaxis()->SetTitleOffset(1.3);; stack->GetHistogram()->GetXaxis()->SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]"");; stack->GetHistogram()->GetYaxis()->SetLabelSize(0.035);; stack->GetHistogram()->GetYaxis()->SetTitleSize(0.045);; stack->GetHistogram()->GetYaxis()->SetTitle(""Events"");; stack->SetMaximum(35);; stack->GetHistogram()->GetYaxis()->ChangeLabel(1, -1, 0);; ; // Draw MC scale factor and variations; histos_mc[""nominal""].SetFillColor(kBlack);; histos_mc[""nominal""]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html:10640,access,accessed,10640,doc/master/df106__HiggsToFourLeptons_8C.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html,1,['access'],['accessed']
Security,"cally opens the friend file. If no file name is given,; the tree called ft1 is assumed to be in the same file as the original tree. tree.AddFriend(""ft1"",""friendfile1.root"");; If the friend tree has the same name as the original tree, you can give it; an alias sin the context of the friendship:. tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; Once the tree has friends, we can use TTree::Draw as if the friend's; variables were in the original tree. To specify which tree to use in; the Draw method, use the syntax:. <treeName>.<branchname>.<varname>; If the variablename is enough to uniquely identify the variable, you can; leave out the tree and/or branch name.; For example, these commands generate a 3-d scatter plot of variable ""var""; in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; TTree ft2. tree.AddFriend(""ft1"",""friendfile1.root"");; tree.AddFriend(""ft2"",""friendfile2.root"");; tree.Draw(""var:ft1.v1:ft2.v2"");. /*; ; */. The picture illustrates the access of the tree and its friends with a; Draw command.; When AddFriend is called, the ROOT file is automatically opened and the; friend tree (ft1) is read into memory. The new friend (ft1) is added to; the list of friends of tree.; The number of entries in the friend must be equal or greater to the number; of entries of the original tree. If the friend tree has fewer entries a; warning is given and the missing entries are not included in the histogram.; To retrieve the list of friends from a tree use TTree::GetListOfFriends.; When the tree is written to file (TTree::Write), the friends list is saved; with it. And when the tree is retrieved, the trees on the friends list are; also retrieved and the friendship restored.; When a tree is deleted, the elements of the friend list are also deleted.; It is possible to declare a friend tree that has the same internal; structure (same branches and leaves) as the original tree, and compare the; same values by specifying the tree. tree.Draw(""var:ft1.var:ft2.v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:35916,access,access,35916,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['access'],['access']
Security,"cast the value or use any intermediary variable: fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);; Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file `hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx:; double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Implements TVirtualTreePlayer.; Definition at line 1925 of file TTreePlayer.cxx. ◆ MakeReader(). Int_t TTreePlayer::MakeReader ; (; const char * ; classname, . Option_t * ; option . ). overridevirtual . Generate skeleton selector class for this tree. ; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:35675,access,accessible,35675,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['access'],['accessible']
Security,"cated threadDefinition RWebWindow.hxx:144; ROOT::RWebWindow::fProtocolCntint fProtocolCnt! counter for protocol recordingDefinition RWebWindow.hxx:171; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client version, used as prefix in scripts URL When changed, web browser will reload all related J...Definition RWebWindow.cxx:1289; ROOT::RWebWindow::RemoveMasterConnectionvoid RemoveMasterConnection(unsigned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:343; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1867; ROOT::RWebWindow::SetCallBacksvoid SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1772; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWindow.hxx:316; ROOT::RWebWindow::GenerateKeystd::string GenerateKey() constGenerate new unique key for the window.Definition RWebWindow.cxx:611; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:324; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:159; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:304; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:124; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:43758,authenticat,authentication,43758,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['authenticat'],['authentication']
Security,"cation.h""; 138#include ""TInterpreter.h""; 139#include ""TGuiFactory.h""; 140#include ""TMessageHandler.h""; 141#include ""TFolder.h""; 142#include ""TQObject.h""; 143#include ""TProcessUUID.h""; 144#include ""TPluginManager.h""; 145#include ""TVirtualMutex.h""; 146#include ""TListOfTypes.h""; 147#include ""TListOfDataMembers.h""; 148#include ""TListOfEnumsWithLock.h""; 149#include ""TListOfFunctions.h""; 150#include ""TListOfFunctionTemplates.h""; 151#include ""TFunctionTemplate.h""; 152#include ""ThreadLocalStorage.h""; 153#include ""TVirtualMapFile.h""; 154#include ""TVirtualRWMutex.h""; 155#include ""TVirtualX.h""; 156 ; 157#if defined(R__UNIX); 158#if defined(R__HAS_COCOA); 159#include ""TMacOSXSystem.h""; 160#include ""TUrl.h""; 161#else; 162#include ""TUnixSystem.h""; 163#endif; 164#elif defined(R__WIN32); 165#include ""TWinNTSystem.h""; 166#endif; 167 ; 168extern ""C"" void R__SetZipMode(int);; 169 ; 170static DestroyInterpreter_t *gDestroyInterpreter = nullptr;; 171static void *gInterpreterLib = nullptr;; 172 ; 173// Mutex for protection of concurrent gROOT access; 174TVirtualMutex* gROOTMutex = nullptr;; 175ROOT::TVirtualRWMutex *ROOT::gCoreMutex = nullptr;; 176 ; 177// For accessing TThread::Tsd indirectly.; 178void **(*gThreadTsd)(void*,Int_t) = nullptr;; 179 ; 180//-------- Names of next three routines are a small homage to CMZ --------------; 181////////////////////////////////////////////////////////////////////////////////; 182/// Return version id as an integer, i.e. ""2.22/04"" -> 22204.; 183 ; 184static Int_t IVERSQ(); 185{; 186 Int_t maj, min, cycle;; 187 sscanf(ROOT_RELEASE, ""%d.%d.%d"", &maj, &min, &cycle);; 188 return 10000*maj + 100*min + cycle;; 189}; 190 ; 191////////////////////////////////////////////////////////////////////////////////; 192/// Return built date as integer, i.e. ""Apr 28 2000"" -> 20000428.; 193 ; 194static Int_t IDATQQ(const char *date); 195{; 196 if (!date) {; 197 Error(""TSystem::IDATQQ"", ""nullptr date string, expected e.g. 'Dec 21 2022'"");; 198 return -1;; 199 }; 200 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:5323,access,access,5323,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['access'],"['access', 'accessing']"
Security,"cceeded but object should not be usedDefinition TObject.h:72; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TProtoClassPersistent version of a TClass.Definition TProtoClass.h:38; TROOT::GetIncludeDirstatic const TString & GetIncludeDir()Get the include directory in the installation. Static utility function.Definition TROOT.cxx:3046; TROOT::GetMacroPathstatic const char * GetMacroPath()Get macro search path. Static utility function.Definition TROOT.cxx:2762; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the interpreter construction.Definition TROOT.cxx:2956; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT::GetSharedLibDirstatic const TString & GetSharedLibDir()Get the shared libraries directory in the installation. Static utility function.Definition TROOT.cxx:3035; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::LastIndexInt_t LastIndex() constDefinition TSeqCollection.h:55; TSeqCollection::Addvoid Add(TObject *obj) overrideDefinition TSeqCollection.h:38; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & Repla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:478008,inject,inject,478008,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['inject'],['inject']
Security,"ccesses for containers like set, multiset etc. More...;  ; class  Iterators;  Small helper to implement the function to create,access and destroy iterators. More...;  ; struct  Iterators< Cont_t, true >;  ; struct  Iterators< std::vector< T >, false >;  ; class  IteratorValue;  Small helper to encapsulate whether to return the value pointed to by the iterator or its address. More...;  ; struct  IteratorValue< Cont_t, value_ptr * >;  ; class  MapInsert;  Small helper to encapsulate all necessary data accesses for containers like set, multiset etc. More...;  ; struct  PairHolder;  ; class  Pushback;  Small helper to encapsulate all necessary data accesses for containers like vector, list, deque. More...;  ; struct  Pushback< Internal::TStdBitsetHelper< Bitset_t > >;  ; struct  Pushback< std::vector< Bool_t, A > >;  ; class  Pushfront;  Small helper to encapsulate all necessary data accesses for containers like forward_list. More...;  ; struct  SfinaeHelper;  ; class  Type;  Small helper to encapsulate basic data accesses for all STL continers. More...;  ; struct  Type< Internal::TStdBitsetHelper< Bitset_t > >;  ; struct  Type< std::vector< Bool_t, A > >;  . Public Member Functions;  TCollectionProxyInfo (const std::type_info &info, size_t iter_size, size_t value_diff, int value_offset, void *(*size_func)(void *), void(*resize_func)(void *, size_t), void *(*clear_func)(void *), void *(*first_func)(void *), void *(*next_func)(void *), void *(*construct_func)(void *, size_t), void(*destruct_func)(void *, size_t), void *(*feed_func)(void *, void *, size_t), void *(*collect_func)(void *, void *), void *(*create_env)(), void(*getIterators)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)=nullptr, void *(*copyIterator)(void *dest, const void *source)=nullptr, void *(*next)(void *iter, const void *end)=nullptr, void(*deleteSingleIterator)(void *iter)=nullptr, void(*deleteTwoIterators)(void *begin, void *end)=nullptr);  . Static Public Me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1TCollectionProxyInfo.html:1707,access,accesses,1707,doc/master/classROOT_1_1Detail_1_1TCollectionProxyInfo.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1TCollectionProxyInfo.html,1,['access'],['accesses']
Security,"ce ;  ►NDetail;  CTBranchProxyBase class for all the proxy object ;  ►CTCollectionProxyInfo;  CAddress;  CEnvironSmall helper to save proxy environment in the event of recursive calls ;  CEnvironBase;  CInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CIteratorsSmall helper to implement the function to create,access and destroy iterators ;  CIterators< Cont_t, true >;  CIterators< std::vector< T >, false >;  CIteratorValueSmall helper to encapsulate whether to return the value pointed to by the iterator or its address ;  CIteratorValue< Cont_t, value_ptr * >;  CMapInsertSmall helper to encapsulate all necessary data accesses for containers like set, multiset etc ;  CPairHolder;  CPushbackSmall helper to encapsulate all necessary data accesses for containers like vector, list, deque ;  CPushback< Internal::TStdBitsetHelper< Bitset_t > >;  CPushback< std::vector< bool > >;  CPushfrontSmall helper to encapsulate all necessary data accesses for containers like forward_list ;  CSfinaeHelper;  CTypeSmall helper to encapsulate basic data accesses for all STL continers ;  ►CType< Internal::TStdBitsetHelper< Bitset_t > >;  ►CIterators;  CPtrSize_t;  ►CType< std::vector< Bool_t > >;  CIterators;  ►CTSchemaRuleSet;  CTMatches;  ►NExecutorUtils;  CReduceObjectsMerge collection of TObjects ;  ►NExperimental;  ►NDetail;  CTHistBinIterIterates over the bins of a THist or THistImpl ;  CTHistBinPtrPoints to a histogram bin (or actually a THistBinRef) ;  CTHistBinRefRepresents a bin reference ;  CTHistBinStatConst view on a bin's statistical data ;  CTHistDataA THistImplBase's data, provides accessors to all its statistics ;  CTHistImpl;  CTHistImplBaseInterface class for THistImpl ;  CTHistImplPrecisionAgnosticBaseBase class for THistImplBase that abstracts out the histogram's PRECISION ;  ►NInternal;  CAxisConfigToTypeConverts a TAxisConfig of whatever kind to the corresponding TAxisBase-derived object ;  CAxisConfigToType< TAxis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:11195,access,accesses,11195,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['access'],['accesses']
Security,"ce Guide ; .  . Loading...; Searching...; No Matches. df027_SQliteDependencyOverVersion.C. Go to the documentation of this file. 1/// \file; 2/// \ingroup tutorial_dataframe; 3/// \notebook -js; 4/// Plot the ROOT downloads based on the version reading a remote sqlite3 file.; 5///; 6/// This tutorial uses the Reduce method which allows to extract the minimum time; 7/// stored in the SQlite3 database.; 8/// The next step is to create a TH1F Histogram, which will be filled with the values stored in; 9/// two different columns from the database. This procedure is simplified with a lambda; 10/// expression that takes as parameters the values stored in the ""Time"" and ""Version"" columns.; 11///; 12/// \macro_code; 13/// \macro_image; 14///; 15/// \date August 2018; 16/// \authors Alexandra-Maria Dobrescu, Sergey Linev; 17 ; 18 ; 19void df027_SQliteDependencyOverVersion (); 20{; 21 auto rdfb = ROOT::RDF::FromSqlite(""http://root.cern/files/root_download_stats.sqlite"", ""SELECT * FROM accesslog;"");; 22 ; 23 auto minTimeStr = *rdfb.Reduce([](std::string a, std::string b) {return std::min(a, b);}, ""Time"", std::string(""Z""));; 24 ; 25 std::cout << ""Minimum time is '"" << minTimeStr << ""'"" << std::endl;; 26 ; 27 double minTime = TDatime(minTimeStr.c_str()).Convert();; 28 double maxTime = minTime + 3600.*24*365.25*4; // cover approx 4 years from minimal time; 29 ; 30 auto rdf = rdfb.Define(""datime"", [](const std::string &time){return TDatime(time.c_str()).Convert();}, {""Time""});; 31 ; 32 auto h614 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.14"");}, {""Version""}); 33 .Histo1D({""h614"", ""Download time for version 6.14"", 64, minTime, maxTime}, {""datime""});; 34 ; 35 auto h616 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.16"");}, {""Version""}); 36 .Histo1D({""h616"", ""Download time for version 6.16"", 64, minTime, maxTime}, {""datime""});; 37 ; 38 auto h618 = rdf.Filter([](const std::string &v){ return 0 == v.find(""6.18"");}, {""Version""}); 39 .Histo1D({""h618"", ""Downl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C_source.html:1093,access,accesslog,1093,doc/master/df027__SQliteDependencyOverVersion_8C_source.html,https://root.cern,https://root.cern/doc/master/df027__SQliteDependencyOverVersion_8C_source.html,1,['access'],['accesslog']
Security,"ce commit 90047b0cba6fd295f5c5722749a0d043fbc11ea5.; Do not insert macro definition of ROOTCLING into the pch. TTree. Properly handle the last element of arrays in the TTreeFormula functions MinIf and MaxIf ROOT-7258; Fix detection of errors that appears in nested TTreeFormula ROOT-8218; Avoid autoparse looking for default constructor in TTreeCloner::CopyStreamerInfos(). Bugs fixed in this release. [ROOT-6753] - PROOF-Lite doesn’t find TSelector type from an already loaded library; [ROOT-7258] - MinIf and MaxIf TTreeFormula functions ignore last element; [ROOT-8038] - [patch] “for e in getSTLLikeCollection()” crashes pyroot; [ROOT-8166] - Update INSTALL to reflect CMake; [ROOT-8184] - Error building XrdSysPthread with GCC 6.1; [ROOT-8197] - rootcp not preserving kSingleKey; [ROOT-8205] - TSystem::ExpandPathName is not thread safe; [ROOT-8207] - tmva/tmva/CMakeLists.txt unnecessarily includes TreeViewer; [ROOT-8217] - TMinuit::TMinuit data race; [ROOT-8218] - Detection of TTreeFormula without breaking formula; [ROOT-8221] - Enum value kKey_Shift not accessible from python with ROOT 6; [ROOT-8226] - CMake 3.5.2: circular dependency libMathMore; [ROOT-8231] - _GLIBCXX_USE_CXX11_ABI=0 should be propagated into root-config –cflags. Release 6.06/08; Released on September 1, 2016; Core. Prevent race condition in the creation of the list of base classes (but avoiding to publish the list too early). Hist. Resolved issues with inconsistent handling of the ‘gaus’ function in TFormula [[ROT-8105]]. Bugs fixed in this release. [ROOT-8105] - TFormula does not always handle ‘gaus’ correctly.; [ROOT-8239] - “python: free(): invalid next size (fast)” in PyROOT 6.06.02 and patches; [ROOT-8270] - C++14; [ROOT-8293] - CMake does not find Castor libraries; [ROOT-8328] - patches used by art; [ROOT-8307] - Crash when leaving ROOT from GUI menu item.; [ROOT-8332] - support linked libraries paths with spaces in aclic. HEAD of the v6-06-00-patches branch; Changes will be part of the future 6.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:32475,access,accessible,32475,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['access'],['accessible']
Security,"cementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=( const ForeignVector & v). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:8551,access,access,8551,root/html602/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,2,['access'],['access']
Security,"ch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1635 of file TTree.cxx. ◆ BranchImpRef() [2/2]. TBranch * TTree::BranchImpRef ; (; const char * ; branchname, . TClass * ; ptrClass, . EDataType ; datatype, . void * ; addobj, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Same as TTree::Branch but automatic detection of the class name. ; See alsoTTree::Branch for other details. ; Definition at line 1695 of file TTree.cxx. ◆ BranchOld(). TBranch * TTree::BranchOld ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 1 . ). virtual . Create a new TTree BranchObject. ; Build a TBranchObject for an object of class classname. addobj is the address of a pointer to an object of class classname. IMPORTANT: classname must derive from TObject. The class dictionary must be available (ClassDef in class header).; This option requires access to the library where the corresponding class is defined. Accessing one single data member in the object implies reading the full object. See the next Branch constructor for a more efficient storage in case the entry consists of arrays of identical objects.; By default the branch buffers are stored in the same file as the Tree. use TBranch::SetFile to specify a different file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:92853,access,access,92853,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['access']
Security,"ch can be used either for the description of position and time (x,y,z,t) or momentum and energy (px,py,pz,E) ;  CTMacOSXSystem;  CTMacroClass supporting a collection of lines with C++ code ;  CTMakeProject;  CTMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries) ;  CTMapFileThis class implements a shared memory region mapped to a file ;  CTMapIterIterator of map ;  CTMapRecKeep track of an object in the mapped file ;  CTMarkerManages Markers ;  CTMarker3DBoxA special 3-D marker designed for event display ;  CTMaterialManages a detector material ;  CTMathTextTo draw TeX Mathematical Formula ;  CTMatrixDEigenTMatrixDEigen ;  CTMatrixDSymEigenTMatrixDSymEigen ;  CTMatrixTTMatrixT ;  CTMatrixTBaseLinear Algebra Package ;  CTMatrixTColumn;  CTMatrixTColumn_const;  CTMatrixTDiag;  CTMatrixTDiag_const;  CTMatrixTFlat;  CTMatrixTFlat_const;  CTMatrixTLazyTemplates of Lazy Matrix classes ;  CTMatrixTRow;  CTMatrixTRow_const;  CTMatrixTSparseTMatrixTSparse ;  CTMatrixTSparseDiag;  CTMatrixTSparseDiag_const;  CTMatrixTSparseRow;  CTMatrixTSparseRow_const;  CTMatrixTSub;  CTMatrixTSub_const;  CTMatrixTSymTMatrixTSym ;  CTMatrixTSymLazy;  CTMCImpMutexAutoLockRealization of TMCTemplateAutoLock with TMCMutex ;  CTMCParticleThis class serves as a data storage for description of one particle ;  CTMCTemplateAutoLockTemplate classe which provides a mechanism to create a mutex and locks/unlocks it ;  CTMCVerboseClass for printing a detailed information from MC application ;  CTMD5This code implements the MD5 message-digest algorithm ;  CTMehrotraSolver;  CTMemberInspectorAbstract base class for accessing the data-members of a class ;  CTMemberStreamer;  ►CTMemFileA TMemFile is like a normal TFile except that it reads and writes only from memory ;  CTMemBlock;  CTMemStat;  CTMemStatHook;  CTMemStatShowUtility class post-processing the file generated by TMemStat (default memstat.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:178592,access,accessing,178592,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,4,['access'],['accessing']
Security,"ch is necessary to ROOT to perform I/O of instances of the class/struct it represents. The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all the three are triggered, modifying the state of the TClass instance.; In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static TClass::GetClass method:; auto myClassTClass_0 = TClass::GetClass(""myClass"");; auto myClassTClass_1 = TClass::GetClass<myClass>();; auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; The name of classes is crucial for ROOT. A careful procedure of name normalization is carried out for each and every class. A normalized name is a valid C++ class name. In order to access the name of a class within the ROOT type system, the method TClass::GetName() can be used. ; Definition at line 81 of file TClass.h. Classes; class  InsertTClassInRegistryRAII;  ; struct  ObjectPtr;  ; class  TDeclNameRegistry;  . Public Types; enum  ECheckSum { ;   kCurrentCheckSum = 0; , kNoEnum = 1; , kReflexNoComment = 2; , kNoRange = 3; , ;   kWithTypeDef = 4; , kReflex = 5; , kNoRangeCheck = 6; , kNoBaseCheckSum = 7; , ;   kLatestCheckSum = 8. };  ; enum  ENewType { kRealNew = 0; , kClassNew; , kDummyNew; };  ; enum  EState { ;   kNoInfo; , kForwardDeclared; , kEmulated; , kInterpreted; , ;   kHasTClassInit; , kLoaded = kHasTClassInit; , kNamespaceForMeta. };  ; enum  EStatusBits { ;   kReservedLoading = (1ULL << ( 7 )); , kHasLocalHashMember = (1ULL << ( 14 )); , kIgnoreTObjectStreamer = (1ULL << ( 15 )); , kUnloaded = (1ULL << ( 16 )); , ;   kIsTObject = (1ULL << ( 17 )); , kIsForeign = (1ULL << ( 18 )); , kStartWithTObject = (1ULL << ( 20 )); , kWarned = (1ULL << ( 21 )); , ;   kHasNameMapNode = (1ULL << ( 22 )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:2061,access,access,2061,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['access']
Security,"ch is necessary to ROOT to perform I/O of instances of the class/struct it represents. The mechanisms 1., 2. and 3. are not mutually exclusive: it can happen that during the execution of the program, all the three are triggered, modifying the state of the TClass instance.; In order to retrieve a TClass instance from the type system, a query can be executed as follows through the static TClass::GetClass method:; auto myClassTClass_0 = TClass::GetClass(""myClass"");; auto myClassTClass_1 = TClass::GetClass<myClass>();; auto myClassTClass_2 = TClass::GetClass(myClassTypeInfo);; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; The name of classes is crucial for ROOT. A careful procedure of name normalization is carried out for each and every class. A normalized name is a valid C++ class name. In order to access the name of a class within the ROOT type system, the method TClass::GetName() can be used. ; Definition at line 81 of file TClass.h. Classes; class  InsertTClassInRegistryRAII;  ; struct  ObjectPtr;  ; class  TDeclNameRegistry;  . Public Types; enum  ECheckSum { ;   kCurrentCheckSum = 0; , kNoEnum = 1; , kReflexNoComment = 2; , kNoRange = 3; , ;   kWithTypeDef = 4; , kReflex = 5; , kNoRangeCheck = 6; , kNoBaseCheckSum = 7; , ;   kLatestCheckSum = 8. };  ; enum  ENewType { kRealNew = 0; , kClassNew; , kDummyNew; };  ; enum  EState { ;   kNoInfo; , kForwardDeclared; , kEmulated; , kInterpreted; , ;   kHasTClassInit; , kLoaded = kHasTClassInit; , kNamespaceForMeta. };  ; enum  EStatusBits { ;   kReservedLoading = (1ULL << ( 7 )); , kHasLocalHashMember = (1ULL << ( 14 )); , kIgnoreTObjectStreamer = (1ULL << ( 15 )); , kUnloaded = (1ULL << ( 16 )); , ;   kIsTObject = (1ULL << ( 17 )); , kIsForeign = (1ULL << ( 18 )); , kStartWithTObject = (1ULL << ( 20 )); , kWarned = (1ULL << ( 21 )); , ;   kHasNameMapNode = (1ULL << ( 22 )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:2062,access,access,2062,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['access']
Security,ch outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TMatrixDSym*_corrMat; TMatrixDSym*_covMat; Double_t_d; RooDataSet&_data; vector<std::vector<Double_t> >_dataPts; vector<TVectorD>_dataPtsR; RooArgSet_dataVars; Bool_t_debug; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; TVectorD*_dx; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_fixedShape; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooNDKeysPdf::BoxInfo_fullBoxInfo; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<Int_t>_idx; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Double_t_maxWeight; vector<Double_t>_mean; Double_t_minWeight; Bool_t_mirror; Double_t_n; Int_t_nDim; Int_t_nEvents; Double_t_nEventsBMSW; Double_t_nEventsBW; Int_t_,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNDKeysPdf.html:42489,access,access,42489,root/html534/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooNDKeysPdf.html,1,['access'],['access']
Security,"ch(TObject,Draw)();. Using the TList iterator TListIter (via the wrapper class TIter):. TIter next(GetListOfTracks());; while ((TTrack *obj = (TTrack *)next())); obj->Draw();. Using the TObjLink list entries (that wrap the TObject*):. TObjLink *lnk = GetListOfPrimitives()->FirstLink();; while (lnk) {; lnk->GetObject()->Draw();; lnk = lnk->Next();; }. Using the TList’s After() and Before() member functions:. TFree *idcur = this;; while (idcur) {; ...; idcur = (TFree*)GetListOfFree()->After(idcur);; }; Method 1 uses internally method 2.; Method 2 works for all collection classes. TIter overloads operator().; Methods 3 and 4 are specific for TList.; Methods 2, 3 and 4 can also easily iterate backwards using either a backward TIter (using argument kIterBackward) or by using LastLink() and lnk>Prev() or by using the Before() method.; 16.7 The TObjArray Collection; A TObjArray is a collection which supports traditional array semantics via the overloading of operator[]. Objects can be directly accessed via an index. The array expands automatically when objects are added. At creation time one specifies the default array size (default = 16) and lower bound (default = 0). Resizing involves a re-allocation and a copy of the old array to the new. This can be costly if done too often. If possible, set initial size close to expected final size. Index validity is always checked (if you are 100% sure and maximum performance is needed you can use UnCheckedAt() instead of At() or operator[]). If the stored objects are sort able the array can be sorted using Sort(). Once sorted, efficient searching is possible via the BinarySearch() method. The figure shows the internal data structure of a TObjArray:. The internal data structure of a TObjArray. Iterating can be done using a TIter iterator or via a simple for loop:; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; Main features of TObjArray are simple, well-known array semantic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:852706,access,accessed,852706,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessed']
Security,"chOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if the class can not be split. TBranch* BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:47691,access,access,47691,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,6,['access'],['access']
Security,"char * GetObjectAt(UInt_t ind) constDefinition TVirtualArray.h:41; TVirtualArray::fClassTClassRef fClassDefinition TVirtualArray.h:31; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualCollectionProxy::Commitvirtual void Commit(void *)=0Commits pending elements in a staging area (see Allocate() for more information).; TVirtualCollectionProxy::Allocatevirtual void * Allocate(UInt_t n, Bool_t forceDelete)=0Allocates space for storing at least n elements.; TVirtualObjectWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualObject.h:26; TVirtualObject::fObjectvoid * fObjectDefinition TVirtualObject.h:34; TVirtualObject::fClassTClassRef fClassDefinition TVirtualObject.h:33; TVirtualStreamerInfo::kStreamer@ kStreamerDefinition TVirtualStreamerInfo.h:130; TVirtualStreamerInfo::kULong64@ kULong64Definition TVirtualStreamerInfo.h:122; TVirtualStreamerInfo::kObjectp@ kObjectpDefinition TVirtualStreamerInfo.h:123; TVirtualStreamerInfo::kSkip@ kSkipDefinition TVirtualStreamerInfo.h:126; TVirtualStreamerInfo::kLong@ kLongDefinition TVirtualStreamerInfo.h:118; TVirtualStreamerInfo::kObjectP@ kObjectPDefinition TVirtualStreamerInfo.h:123; TVirtualStreamerInfo::kCacheDelete@ kCacheDeleteDefinition TVirtualStreamerInfo.h:134; TVirtualStreamerInfo::kFloat16@ kFloat16Definition TVirtualStreamerInfo.h:122; TVirtualStreamerInfo::kArtificial@ kArtificialDefinition TVirtualStreamerInfo.h:132; TVirtualStreamerInfo::kCache@ kCacheDefinition TVirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoReadBuffer_8cxx_source.html:87737,access,access,87737,doc/master/TStreamerInfoReadBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoReadBuffer_8cxx_source.html,1,['access'],['access']
Security,"char * ; fontname, . Int_t ; max, . Int_t & ; count . ). overridevirtual . Returns list of font names matching fontname regexp, like ""-*-times-*"". ; The pattern string can contain any characters, but each asterisk (*) is a wildcard for any number of characters, and each question mark (?) is a wildcard for a single character. If the pattern string is not in the Host Portable Character Encoding, the result is implementation dependent. Use of uppercase or lowercase does not matter. Each returned string is null-terminated.; Parameters. [in]fontnamespecifies the null-terminated pattern string that can contain wildcard characters ; [in]maxspecifies the maximum number of names to be returned ; [in]countreturns the actual number of font names . Reimplemented from TVirtualX.; Definition at line 2882 of file TGCocoa.mm. ◆ LoadQueryFont(). FontStruct_t TGCocoa::LoadQueryFont ; (; const char * ; font_name). overridevirtual . Provides the most common way for accessing a font: opens (loads) the specified font and returns a pointer to the appropriate FontStruct_t structure. ; If the font does not exist, it returns NULL. ; Reimplemented from TVirtualX.; Definition at line 2809 of file TGCocoa.mm. ◆ LookupString(). void TGCocoa::LookupString ; (; Event_t * ; event, . char * ; buf, . Int_t ; buflen, . UInt_t & ; keysym . ). overridevirtual . Converts the keycode from the event structure to a key symbol (according to the modifiers specified in the event structure and the current keyboard mapping). ; In ""buf"" a null terminated ASCII string is returned representing the string that is currently mapped to the key code.; Parameters. [in]eventspecifies the event structure to be used ; [in]bufreturns the translated characters ; [in]buflenthe length of the buffer ; [in]keysymreturns the ""keysym"" computed from the event if this argument is not NULL . Reimplemented from TVirtualX.; Definition at line 2788 of file TGCocoa.mm. ◆ LowerWindow(). void TGCocoa::LowerWindow ; (; Window_t ; id). overrid",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:96381,access,accessing,96381,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['access'],['accessing']
Security,"char* axisSteering = 0) const. TH2D * CreateErrorMatrixHistogram(const char* histogramName, Bool_t originalAxisBinning, Int_t** binMap = 0, const char* histogramTitle = 0, const char* axisSteering = 0) const. TH2D * CreateHistogramOfMigrations(TUnfoldBinning *const xAxis, TUnfoldBinning *const yAxis, char *const histogramName, Bool_t originalXAxisBinning = kFALSE, Bool_t originalYAxisBinning = kFALSE, char *const histogramTitle = 0); Calculate global bin number . Int_t GetGlobalBinNumber(Double_t x) const. Int_t GetGlobalBinNumber(Double_t x, Double_t y) const. Int_t GetStartBin(void); { return fFirstBin; }. Int_t GetEndBin(void); { return fLastBin; }. void GetBinUnderflowOverflowStatus(Int_t iBin, Int_t* uStatus, Int_t* oStatus) const. void GetBinNeighbours(Int_t globalBin, Int_t axis, Int_t* prev, Double_t* distPrev, Int_t* next, Double_t* distNext) const; access by bin number, given an axis steering . { MAXDIM=32 }. const TUnfoldBinning * GetBinLocation(Int_t binTHxx, const char* axisSteering, Int_t* axisBins) const; access distribution properties . Int_t GetDistributionNumberOfBins(void); { return fDistributionSize; }. Int_t GetDistributionDimension(void); { return fAxisList->GetEntriesFast(); }. Double_t GetDistributionAverageBinSize(Int_t axis, Bool_t includeUnderflow, Bool_t includeOverflow) const. TVectorD const * GetDistributionBinning(Int_t axis) const. TString GetDistributionAxisLabel(Int_t axis) const. Double_t GetDistributionBinCenter(Int_t axis, Int_t bin) const. TUnfoldBinning const * ToAxisBins(Int_t globalBin, Int_t* axisBins) const. TString BuildHistogramTitle(const char* histogramName, const char* histogramTitle, Int_t *const axisList) const. Int_t GetTHxxBinning(Int_t maxDim, Int_t* axisBins, Int_t* axisList, const char* axisSteering) const. Int_t GetTHxxBinningSingleNode(Int_t maxDim, Int_t* axisBins, Int_t* axisList, const char* axisSteering) const. const TUnfoldBinning * GetBinLocationRecursive(Int_t& offset, const char* axisSteering, Int_t* a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldBinning.html:16720,access,access,16720,root/html534/TUnfoldBinning.html,https://root.cern,https://root.cern/root/html534/TUnfoldBinning.html,1,['access'],['access']
Security,"che for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedPdf.html:42080,access,access,42080,root/html534/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedPdf.html,1,['access'],['access']
Security,"check (see section: ""Checking the; Geometry""). If tracking is performed using TGeo, the folder Tracks might contain user-defined tracks that can be visualized/animated in the geometry context (see section: ""Creating and; Visualizing Tracks""). Since for the time being we are interested more in the geometrical hierarchy, we will focus on the last two displayed items TOPand TOP_1. These are the top volume and the corresponding top node in the hierarchy.; Double clicking on the TOP volume will unfold all different volumes contained by the top volume. In the right panel, we will see all the volumes contained by TOP (if the same is positioned 4 times we will get 4 identical items). This rule will apply to any clicked volume in the hierarchy. Note that right clicking a volume item activates the volume context menu containing several specific methods. We will call the volume hierarchy developed in this way as the logical geometry graph. The volume objects are nodes inside this graph and the same volume can be accessed starting from different branches.; On the other hand, the real geometrical objects that are seen when visualizing or tracking the geometry are depicted in the TOP_1 branch. These are the nodes of the physical tree of positioned volumes represented by TGeoNode objects. This hierarchy is a tree since a node can have only one parent and several daughters. For a better understanding of the hierarchy, have a look at TGeoManage.; Just close now the X3D window and focus at the wire frame picture drawn in a pad. Activate Options/Event Status. Moving the mouse in the pad, you will notice that objects are sometimes changing color to red. Volumes are highlighted in this way whenever the mouse pointer is close enough to one of its vertices. When this happens, the corresponding volume is selected and you will see in the bottom right size of the ROOT canvas its name, shape type and corresponding path in the physical tree. Right clicking on the screen when a volume is selecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:13211,access,accessed,13211,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['access'],['accessed']
Security,"checks.; 8770 */; 8771int; 8772mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8773 const char *realm); 8774{; 8775 if (conn && conn->dom_ctx) {; 8776 send_authorization_request(conn, realm);; 8777 return 0;; 8778 }; 8779 return -1;; 8780}; 8781 ; 8782 ; 8783#if !defined(NO_FILES); 8784static int; 8785is_authorized_for_put(struct mg_connection *conn); 8786{; 8787 if (conn) {; 8788 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8789 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8790 int ret = 0;; 8791 ; 8792 if (passfile != NULL; 8793 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8794 ret = authorize(conn, &file, NULL);; 8795 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8796 }; 8797 ; 8798 return ret;; 8799 }; 8800 return 0;; 8801}; 8802#endif; 8803 ; 8804 ; 8805static int; 8806modify_passwords_file(const char *fname,; 8807 const char *domain,; 8808 const char *user,; 8809 const char *pass,; 8810 const char *ha1); 8811{; 8812 int found, i;; 8813 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8814 tmp[UTF8_PATH_MAX + 8];; 8815 FILE *fp, *fp2;; 8816 ; 8817 found = 0;; 8818 fp = fp2 = NULL;; 8819 ; 8820 /* Regard empty password as no password - remove user record. */; 8821 if ((pass != NULL) && (pass[0] == '\0')) {; 8822 pass = NULL;; 8823 }; 8824 ; 8825 /* Other arguments must not be empty */; 8826 if ((fname == NULL) || (domain == NULL) || (user == NULL)) {; 8827 return 0;; 8828 }; 8829 ; 8830 /* Using the given file format, user name and domain must not contain; 8831 * ':'; 8832 */; 8833 if (strchr(user, ':') != NULL) {; 8834 return 0;; 8835 }; 8836 if (strchr(domain, ':') != NULL) {; 8837 return 0;; 8838 }; 8839 ; 8840 /* Do not allow control characters like newline in user name and domain.; 8841 * Do not allow excessively long names either. */; 8842 for (i = 0; ((i < 255) && (user[i] != 0)); i++) {; 8843 if (iscntrl((unsigned char)user[i])) {; 8844 return 0;; 8845 }; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:253298,access,access,253298,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,3,"['access', 'password']","['access', 'password']"
Security,"checks.; 8771 */; 8772int; 8773mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8774 const char *realm); 8775{; 8776 if (conn && conn->dom_ctx) {; 8777 send_authorization_request(conn, realm);; 8778 return 0;; 8779 }; 8780 return -1;; 8781}; 8782 ; 8783 ; 8784#if !defined(NO_FILES); 8785static int; 8786is_authorized_for_put(struct mg_connection *conn); 8787{; 8788 if (conn) {; 8789 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8790 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8791 int ret = 0;; 8792 ; 8793 if (passfile != NULL; 8794 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8795 ret = authorize(conn, &file, NULL);; 8796 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8797 }; 8798 ; 8799 return ret;; 8800 }; 8801 return 0;; 8802}; 8803#endif; 8804 ; 8805 ; 8806static int; 8807modify_passwords_file(const char *fname,; 8808 const char *domain,; 8809 const char *user,; 8810 const char *pass,; 8811 const char *ha1); 8812{; 8813 int found, i;; 8814 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8815 tmp[UTF8_PATH_MAX + 8];; 8816 FILE *fp, *fp2;; 8817 ; 8818 found = 0;; 8819 fp = fp2 = NULL;; 8820 ; 8821 /* Regard empty password as no password - remove user record. */; 8822 if ((pass != NULL) && (pass[0] == '\0')) {; 8823 pass = NULL;; 8824 }; 8825 ; 8826 /* Other arguments must not be empty */; 8827 if ((fname == NULL) || (domain == NULL) || (user == NULL)) {; 8828 return 0;; 8829 }; 8830 ; 8831 /* Using the given file format, user name and domain must not contain; 8832 * ':'; 8833 */; 8834 if (strchr(user, ':') != NULL) {; 8835 return 0;; 8836 }; 8837 if (strchr(domain, ':') != NULL) {; 8838 return 0;; 8839 }; 8840 ; 8841 /* Do not allow control characters like newline in user name and domain.; 8842 * Do not allow excessively long names either. */; 8843 for (i = 0; ((i < 255) && (user[i] != 0)); i++) {; 8844 if (iscntrl((unsigned char)user[i])) {; 8845 return 0;; 8846 }; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:253330,access,access,253330,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,3,"['access', 'password']","['access', 'password']"
Security,"checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TClass object. void Browse(TBrowser* b); This method is called by a browser to get the class information. void BuildRealData(void* pointer = 0, Bool_t isTra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:21953,checksum,checksum,21953,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,6,['checksum'],"['checksum', 'checksums']"
Security,"checksum=...] [code={...}|functionname]. For example to set HepMC::GenVertex::m_event to _not_ owned the object it is pointing to:; HepMC::GenVertex m_event attributes=NotOwner. Semantic of the tags:; type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; sourceClass : the name of the class as it is on the rule file; targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; oldtype: in the short form only, indicates the type on disk of the data member.; target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; attributes : list of possible qualifiers amongs:; Owner, NotOwner; version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; checksum : comma delimited list of the checksums of the class layout that this rule applies to.; code={...} : code to be executed for the rule or name of the function implementing it. void AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); Adopt a new set of Data Model Evolution rules. const ROOT::TSchemaRuleSet* GetSchemaRules() const; Return the set of the schema rules if any. ROOT::TSchemaRuleSet* GetSchemaRules(Bool_t create = kFALSE); Return the set of the schema rules if any.; If create is true, create an empty set. void AddImplFile(const char* filename, int line). void AddRef(TClassRef* ref); Register a TClassRef object which points to this TClass object.; When this TClass object is deleted, 'ref' will be 'Reset'. Int_t AutoBrowse(TObject* obj, TBrowser* browser); Browse external object inherited from TObject.; It passes through inheritance tree and calls TBrowser::Add; in appropriate cases. Static function. Int_t Browse(void* obj, TBrowser* b) const; Browse objects of of the class described by this TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:20584,checksum,checksum,20584,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,6,['checksum'],"['checksum', 'checksums']"
Security,ches; TH2*_callHist! Histogram recording number of calls per convolution integral calculation; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsReal*_cloneModelPointer to cloned model; RooAbsReal*_clonePdfPointer to cloned PDF; RooAbsReal*_cloneVarPointer to cloned convolution variable; RooNumIntConfig_convIntConfigConfiguration of numeric convolution integral ;; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_t_doProfSwitch to activate profiling option; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; RooConvIntegrandBinding*_integrand! Binding of Convolution Integrand function; RooAbsIntegrator*_integrator! Numeric integrator of convolution integrand; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvolution.html:37752,access,access,37752,root/html602/RooNumConvolution.html,https://root.cern,https://root.cern/root/html602/RooNumConvolution.html,2,['access'],['access']
Security,"cial streamer for the class.Definition TClass.cxx:6788; TClass::operator&friend bool operator&(UChar_t l, ERuntimeProperties r)Definition TClass.h:270; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6814; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6845; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:6945; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7066; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4087; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4283; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4772; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:75129,access,accessor,75129,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['access'],['accessor']
Security,"cial streamer for the class.Definition TClass.cxx:6855; TClass::operator&friend bool operator&(UChar_t l, ERuntimeProperties r)Definition TClass.h:270; TClass::fClassPropertyLong_t fClassPropertyProperty See TClass::Property() for details.Definition TClass.h:256; TClass::fContextMenuTitleTString fContextMenuTitleDefinition TClass.h:223; TClass::StreamerTObjectInitializedstatic void StreamerTObjectInitialized(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of TObjects when fIsOffsetStreamerSet is known to have been set.Definition TClass.cxx:6881; TClass::ConvStreamerInstrumentedstatic void ConvStreamerInstrumented(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)Case of instrumented class with a library.Definition TClass.cxx:6912; TClass::fCanLoadClassInfostd::atomic< Bool_t > fCanLoadClassInfoWhether info was loaded from a root pcm.Definition TClass.h:260; TClass::SetConvStreamerFuncvoid SetConvStreamerFunc(ClassConvStreamerFunc_t strm)Set a wrapper/accessor function around this class custom conversion streamer.Definition TClass.cxx:7012; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetMissingDictionariesvoid GetMissingDictionaries(THashTable &result, bool recurse=false)Get the classes that have a missing dictionary starting from this one.Definition TClass.cxx:4154; TClass::MakeCustomMenuListvoid MakeCustomMenuList()Makes a customizable version of the popup menu list, i.e.Definition TClass.cxx:4350; TClass::FindStreamerInfoAbstractEmulatedTVirtualStreamerInfo * FindStreamerInfoAbstractEmulated(UInt_t checksum) constFor the case where the requestor class is emulated and this class is abstract, returns a pointer to t...Definition TClass.cxx:4839; TClass::GetMethodAnyTMethod * GetMethodAny(const char *method)Return pointer to method without looking",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:74957,access,accessor,74957,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['access'],['accessor']
Security,"cisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = NULL); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = NULL); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patterns stored in the ""long-integer"" (i.e. 0:left ; 1:right. void GetRandomisedVariables(Bool_t* useVariable, UInt_t* variableMap, UInt_t& nVars). Double_t TrainNodeFast(const TMVA::DecisionTree:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__DecisionTree.html:12218,validat,validationSample,12218,root/html534/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html534/TMVA__DecisionTree.html,2,['validat'],"['validation', 'validationSample']"
Security,"cket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. friend class TProofServ; // to be able to call SetDescrip",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:22501,authenticat,authentication,22501,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['authenticat'],['authentication']
Security,"cks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:2763,access,accessed,2763,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['access'],['accessed']
Security,"cksum value %x for this base class (%s)."",; 2986 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 2987 GetClassVersion(), GetName(), otherClass.Data(), otherBaseClass->GetCheckSum(),; 2988 GetClassVersion(), localBase->GetBaseCheckSum(), localClass.Data());; 2989 TStreamerBase *otherBase = (TStreamerBase*)cl->GetStreamerInfo()->GetElements()->FindObject(otherClass);; 2990 otherBase->SetErrorMessage(msg);; 2991 }; 2992 } else {; 2993 TStreamerBase *localBase = dynamic_cast<TStreamerBase*>(el);; 2994 TStreamerBase *otherBase = dynamic_cast<TStreamerBase*>(infoel);; 2995 if (!localBase || !otherBase) continue;; 2996 ; 2997 // We already have localBaseClass == otherBaseClass; 2998 TClass *otherBaseClass = localBase->GetClassPointer();; 2999 if (otherBaseClass->IsVersioned() && localBase->GetBaseVersion() != otherBase->GetBaseVersion()) {; 3000 TString msg;; 3001 msg.Form("" The StreamerInfo of class %s read from %s%s\n""; 3002 "" has the same version (=%d) as the active class but a different checksum.\n""; 3003 "" You should update the version to ClassDef(%s,%d).\n""; 3004 "" The objects on this file might not be readable because:\n""; 3005 "" The in-memory layout version %d for class '%s' has a base class (%s) with version %d but the on-file layout version %d recorded the version number %d for this base class (%s)."",; 3006 GetName(), file ? ""file "" : """", file ? file->GetName() : """", fClassVersion, GetName(), fClassVersion + 1,; 3007 GetClassVersion(), GetName(), otherClass.Data(), otherBase->GetBaseVersion(),; 3008 GetClassVersion(), localBase->GetBaseVersion(), localClass.Data());; 3009 otherBase->SetErrorMessage(msg);; 3010 ; 3011 } else if (!otherBaseClass->IsVersioned() && localBase->GetBaseCheckSum() != otherBase->GetBaseCheckSum()); 3012 {; 3013 TVirtualStreamerInfo *localBaseInfo = otherBaseClass->FindStreamerInfo(localBase->GetBaseCheckSum());; 3014 TVirtualStreamerInfo *otherBaseInfo = otherBaseClass->FindStream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:120359,checksum,checksum,120359,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['checksum'],['checksum']
Security,"class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; RooDataSet * summaryData ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsStudy.html:2223,hash,hash,2223,doc/master/classRooAbsStudy.html,https://root.cern,https://root.cern/doc/master/classRooAbsStudy.html,1,['hash'],['hash']
Security,"class is defined dynamically for demonstration; # purposes, but it could also be a C++ class defined in some library or header.; # For more information about loading C++ user code to be used from Python with; # PyROOT, please see:; # https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; ROOT.gInterpreter.Declare('''; class MyClass {};; '''); ; # Next, we define a pythonizor function: the function that will be responsible; # for injecting new behaviour in our C++ class `MyClass`.; #; # To convert a given Python function into a pythonizor, we need to decorate it; # with the @pythonization decorator. Such decorator allows us to define which; # which class we want to pythonize by providing its class name and its; # namespace (if the latter is not specified, it defaults to the global; # namespace, i.e. '::').; #; # The decorated function - the pythonizor - must accept either one or two; # parameters:; # 1. The class to be pythonized (proxy object where new behaviour can be; # injected); # 2. The fully-qualified name of that class (optional).; #; # Let's see all this with a simple example. Suppose I would like to define how; # `MyClass` objects are represented as a string in Python (i.e. what would be; # shown when I print that object). For that purpose, I can define the following; # pythonizor function. There are two important things to be noted here:; # - The @pythonization decorator has one argument that specifies our target; # class is `MyClass`.; # - The pythonizor function `pythonizor_of_myclass` provides and injects a new; # implementation for `__str__`, the mechanism that Python provides to define; # how to represent objects as strings. This new implementation; # always returns the string ""This is a MyClass object"".; @pythonization('MyClass'); def pythonizor_of_myclass(klass):; klass.__str__ = lambda o : 'This is a MyClass object'; ; # Once we have defined our pythonizor function, let's see it in action.; # We will now use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html:1738,inject,injected,1738,doc/master/pyroot002__pythonizationDecorator_8py.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py.html,1,['inject'],['injected']
Security,"class that is the input for the rule. source. A semicolon-separated list of values defining the source class data members that need to be cached and accessible via object proxy when the rule is executed. The values are either the names of the data members or the type-name pairs (separated by a space). If types are specified then the ondisk structure can be generated and used in the code snippet defined by the user. version. A list of versions of the source class that can be an input for this rule. The list has to be enclosed in a square bracket and be a comma-separated list of versions or version ranges. The version is an integer number, whereas the version range is one of the following:; “a-b”: a and b are integers and the expression means all the numbers between and including a and b; “-a”: a is an integer and the expression means all the version numbers smaller than or equal to a; “a-”: a is an integer and the expression means all the version numbers greater than or equal to a. checksum. A list of checksums of the source class that can be an input for this rule. The list has to be enclosed in a square brackets and is a comma-separated list of integers. targetClass. The field is obligatory and defines the name of the in-memory class that this rule can be applied to. target. A comma-separated list of target class data member names that this rule is capable of calculating. embed. This property tells the system if the rule should be written in the output file is some objects of this class are serialized. include. A list of header files that should be included in order to provide the functionality used in the code snippet; the list is comma delimited. code. An user specified code snippet. The user can assume that in the provided code snippet the following variables will be defined:; The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to facilita",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:501973,checksum,checksum,501973,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['checksum'],['checksum']
Security,"classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7193 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7204 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7066 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7036 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4772 of file TClass.cxx. ◆ ForceReload(). void TClass::ForceReload ; (; TClass * ; oldcl). we found at least one equivalent. ; let's force a reload ; Definition at line 1336 of file TClass.cxx. ◆ GetActualClass(). TClass * TClass::GetActualClass ; (; const void * ; object); const. Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:68034,checksum,checksum,68034,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['checksum'],['checksum']
Security,"classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7260 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7271 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7133 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7103 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4839 of file TClass.cxx. ◆ ForceReload(). void TClass::ForceReload ; (; TClass * ; oldcl). we found at least one equivalent. ; let's force a reload ; Definition at line 1403 of file TClass.cxx. ◆ GetActualClass(). TClass * TClass::GetActualClass ; (; const void * ; object); const. Re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:68035,checksum,checksum,68035,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['checksum'],['checksum']
Security,"client authentication. Example: use Opt = kSrvAuth to require client authentication. Default options are taken from fgAcceptOpt and are initially; equivalent to kSrvNoAuth; they can be changed with the static; method TServerSocket::SetAcceptOptions(Opt).; The active defaults can be visualized using the static method; TServerSocket::ShowAcceptOptions(). TInetAddress GetLocalInetAddress(); Return internet address of host to which the server socket is bound,; i.e. the local host. In case of error TInetAddress::IsValid() returns; kFALSE. Int_t GetLocalPort(); Get port # to which server socket is bound. In case of error returns -1. UChar_t GetAcceptOptions(); Return default options for Accept. void SetAcceptOptions(UChar_t Opt); Set default options for Accept according to modifier 'mod'.; Use:; kSrvAuth require client authentication; kSrvNoAuth do not require client authentication. void ShowAcceptOptions(); Print default options for Accept. Bool_t Authenticate(TSocket* ); Check authentication request from the client on new; open connection. TServerSocket(); { }. TServerSocket(const TServerSocket& ). void operator=(const TServerSocket& ). Int_t Send(const TMessage& ); { MayNotUse(""Send(const TMessage &)""); return 0; }. Int_t Send(Int_t ); { MayNotUse(""Send(Int_t)""); return 0; }. Int_t Send(Int_t , Int_t ); { MayNotUse(""Send(Int_t, Int_t)""); return 0; }. Int_t Send(const char* , Int_t = kMESS_STRING); { MayNotUse(""Send(const char *, Int_t)""); return 0; }. Int_t SendObject(const TObject* , Int_t = kMESS_OBJECT); { MayNotUse(""SendObject(const TObject *, Int_t)""); return 0; }. Int_t SendRaw(const void* , Int_t , ESendRecvOptions = kDefault); { MayNotUse(""SendRaw(const void *, Int_t, ESendRecvOptions)""); return 0; }. Int_t Recv(TMessage*& ); { MayNotUse(""Recv(TMessage *&)""); return 0; }. Int_t Recv(Int_t& , Int_t& ); { MayNotUse(""Recv(Int_t &, Int_t &)""); return 0; }. Int_t Recv(char* , Int_t ); { MayNotUse(""Recv(char *, Int_t)""); return 0; }. Int_t Recv(char* , Int_t , Int_t&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:14145,authenticat,authentication,14145,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,6,['authenticat'],['authentication']
Security,"client.rsa.sin);; 17322#endif; 17323 ; 17324 conn->client.sock = sock;; 17325 conn->client.lsa = sa;; 17326 ; 17327 if (getsockname(sock, psa, &len) != 0) {; 17328 mg_cry_internal(conn,; 17329 ""%s: getsockname() failed: %s"",; 17330 __func__,; 17331 strerror(ERRNO));; 17332 }; 17333 ; 17334 conn->client.is_ssl = use_ssl ? 1 : 0;; 17335 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 17336 mg_snprintf(NULL,; 17337 NULL, /* No truncation check for ebuf */; 17338 ebuf,; 17339 ebuf_len,; 17340 ""Can not create mutex"");; 17341#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17342 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17343#endif; 17344 closesocket(sock);; 17345 mg_free(conn);; 17346 return NULL;; 17347 }; 17348 ; 17349 ; 17350#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17351 if (use_ssl) {; 17352 /* TODO: Check ssl_verify_peer and ssl_ca_path here.; 17353 * SSL_CTX_set_verify call is needed to switch off server; 17354 * certificate checking, which is off by default in OpenSSL and; 17355 * on in yaSSL. */; 17356 /* TODO: SSL_CTX_set_verify(conn->dom_ctx,; 17357 * SSL_VERIFY_PEER, verify_ssl_server); */; 17358 ; 17359 if (client_options->client_cert) {; 17360 if (!ssl_use_pem_file(conn->phys_ctx,; 17361 conn->dom_ctx,; 17362 client_options->client_cert,; 17363 NULL)) {; 17364 mg_snprintf(NULL,; 17365 NULL, /* No truncation check for ebuf */; 17366 ebuf,; 17367 ebuf_len,; 17368 ""Can not use SSL client certificate"");; 17369 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17370 closesocket(sock);; 17371 mg_free(conn);; 17372 return NULL;; 17373 }; 17374 }; 17375 ; 17376 if (client_options->server_cert) {; 17377 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 17378 client_options->server_cert,; 17379 NULL); 17380 != 1) {; 17381 mg_cry_internal(conn,; 17382 ""SSL_CTX_load_verify_locations error: %s "",; 17383 ssl_error());; 17384 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17385 closesocket(sock);; 17386 mg_free(conn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:515614,certificate,certificate,515614,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['certificate'],['certificate']
Security,"client.rsa.sin);; 17323#endif; 17324 ; 17325 conn->client.sock = sock;; 17326 conn->client.lsa = sa;; 17327 ; 17328 if (getsockname(sock, psa, &len) != 0) {; 17329 mg_cry_internal(conn,; 17330 ""%s: getsockname() failed: %s"",; 17331 __func__,; 17332 strerror(ERRNO));; 17333 }; 17334 ; 17335 conn->client.is_ssl = use_ssl ? 1 : 0;; 17336 if (0 != pthread_mutex_init(&conn->mutex, &pthread_mutex_attr)) {; 17337 mg_snprintf(NULL,; 17338 NULL, /* No truncation check for ebuf */; 17339 ebuf,; 17340 ebuf_len,; 17341 ""Can not create mutex"");; 17342#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17343 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17344#endif; 17345 closesocket(sock);; 17346 mg_free(conn);; 17347 return NULL;; 17348 }; 17349 ; 17350 ; 17351#if !defined(NO_SSL) && !defined(USE_MBEDTLS) // TODO: mbedTLS client; 17352 if (use_ssl) {; 17353 /* TODO: Check ssl_verify_peer and ssl_ca_path here.; 17354 * SSL_CTX_set_verify call is needed to switch off server; 17355 * certificate checking, which is off by default in OpenSSL and; 17356 * on in yaSSL. */; 17357 /* TODO: SSL_CTX_set_verify(conn->dom_ctx,; 17358 * SSL_VERIFY_PEER, verify_ssl_server); */; 17359 ; 17360 if (client_options->client_cert) {; 17361 if (!ssl_use_pem_file(conn->phys_ctx,; 17362 conn->dom_ctx,; 17363 client_options->client_cert,; 17364 NULL)) {; 17365 mg_snprintf(NULL,; 17366 NULL, /* No truncation check for ebuf */; 17367 ebuf,; 17368 ebuf_len,; 17369 ""Can not use SSL client certificate"");; 17370 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17371 closesocket(sock);; 17372 mg_free(conn);; 17373 return NULL;; 17374 }; 17375 }; 17376 ; 17377 if (client_options->server_cert) {; 17378 if (SSL_CTX_load_verify_locations(conn->dom_ctx->ssl_ctx,; 17379 client_options->server_cert,; 17380 NULL); 17381 != 1) {; 17382 mg_cry_internal(conn,; 17383 ""SSL_CTX_load_verify_locations error: %s "",; 17384 ssl_error());; 17385 SSL_CTX_free(conn->dom_ctx->ssl_ctx);; 17386 closesocket(sock);; 17387 mg_free(conn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:515647,certificate,certificate,515647,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['certificate'],['certificate']
Security,clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:38644,access,access,38644,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,2,['access'],['access']
Security,"cloud of unbinned 2D or 3D points is drawn respectively.; if the expression has four fields ""e1:e2:e3:e4"" a cloud of unbinned 3D points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color palette. If option COL is specified when varexp has three fields: tree.Draw(""e1:e2:e3"","""",""col"");; a 2D scatter is produced with e1 vs e2, and e3 is mapped on the current color palette. The colors for e3 are evaluated once in linear scale before painting. Therefore changing the pad to log scale along Z as no effect on the colors.; if expression has more than four fields the option ""PARA""or ""CANDLE"" can be used.; If option contains the string ""goff"", no graphics is generated. . [in]nentriesThe number of entries to process (default is all) ; [in]firstentryThe first entry to process (default is 0). Drawing expressions using arrays and array elements; Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array, or a TClonesArray. In a TTree::Draw expression you can now access fMatrix using the following syntaxes:. String passed What is used for each entry of the tree . fMatrix the 9 elements of fMatrix . fMatrix[][] the 9 elements of fMatrix . fMatrix[2][2] only the elements fMatrix[2][2] . fMatrix[1] the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] . fMatrix[1][] the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] . fMatrix[][0] the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0] . ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!).; In summary, if a specific index is not specified for a dimension, TTree::Draw will loop through all the indices along this dimension. Leaving off the last (right most) dimension of specifying then with the two characters '[]' is equivalent. For variable size arrays (and TClonesArray) the range of the first dimension is recalculated for each entry of the tree. You can also specify the index as an expression of any other variables from the tree.; TT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:115521,access,access,115521,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['access']
Security,"code in EventSelector.h should look like this:; class EventSelector : public TSelector {; public :; Int_t fTotalDataSize; // Sum of data size (in bytes) of all events. // Variables used to access and store the data; TTreeReader fReader; // The tree reader ; TTreeReaderValue<Int_t> fCurrentEventSize; // Size of the current event. EventSelector(TTree * = 0):; fTotalDataSize(0),; fCurrentEventSize(fReader, ""fEventSize"") { }; virtual ~EventSelector() { }. virtual void Init(TTree *tree);; ... Connecting a Tree Branch with the Data Member; As already explained in the Using a Macro to Read a TTree tutorial, here again we have to ""connect"" the TTreeReader to the tree we want to read by calling TTreeReader::SetTree(). This has to be done in the TSelector::Init() method, as shown below:; void EventSelector::Init(TTree *tree); {; //... // Associate the TTreeReader with the tree we want to read; fReader.SetTree(tree);; }. Loading TTree's Data; For the analysis example we need to get the events' size, which is accessible through the selector's data member fCurrentEventSize. But the TTreeReader first needs know which TTree entry is the current one, i.e. which entry Process() is called on. So instead of looping yourself using TTreeReader::Next() you set an explicit entry number using TTreeReader::SetLocalEntry(entry) in your Process() method, passing the TTree entry number from the argument of Process() to SetLocalEntry(). (We call SetLocalEntry() and not SetEntry() because Process() hands us the entry number of the current tree.); Bool_t EventSelector::Process(Long64_t entry); {; //... // Tell the TTreeReader to get the data for; // the entry number ""entry"" in the current tree:; fReader.SetLocalEntry(entry);. ... Analyzing the TTree Entries; For each TTree entry, you will add the current event's size to the data member. This, too, happens in Process() - after you have set the current event from the TTree. After the TSelector has processed the tree it will thus contain the sum of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/accessing-ttree-tselector.html:6313,access,accessible,6313,d/accessing-ttree-tselector.html,https://root.cern,https://root.cern/d/accessing-ttree-tselector.html,1,['access'],['accessible']
Security,"communication variables for xrootd protocol. void* OpenDirectory(const char* dir); Open a directory. Returns a non-zero pointer (with no special; purpose) in case of success, 0 in case of error. void FreeDirectory(void* dirp); Free(Close) the directory referenced by dirp. Int_t MakeDirectory(const char* dir); Create a directory. Return 0 on success, -1 otherwise. const char* GetDirEntry(void* dirp); Get directory entry for directory referenced by dirp.; Returns 0 in case there are no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed.; NOTICE: Not all information is available with an xrootd server. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; NB: for the time being mode is ignored for XROOTD (just checks existence; of the file or directory).; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int Unlink(const char* path); Unlink 'path' on the remote server system.; Returns 0 on success, -1 otherwise. Bool_t IsOnline(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Prepare(const char* path, UChar_t opt = 8, UChar_t prio = 0); Issue a prepare request for file defined by 'path'. Int_t Prepare(TCollection* paths, UChar_t opt = 8, UChar_t prio = 0, TString* buf = 0); Issue a prepare request for a list of files defined by 'paths', which must; be of one of the following types: TFileInfo, TUrl, TObjString.; On output, bufout, if defined, points to a buffer form that can be used; with GetPathsInfo.; Return the number of paths found or -1 if any error occured. Bool_t GetPathsInfo(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetSystem.html:21618,access,access,21618,root/html528/TXNetSystem.html,https://root.cern,https://root.cern/root/html528/TXNetSystem.html,12,['access'],['access']
Security,"conf); ; # Point RDataFrame calls to the Spark specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # The Spark RDataFrame constructor accepts an optional ""sparkcontext"" parameter; # and it will distribute the application to the connected cluster; df = RDataFrame(""mytree"", ""myfile.root"", sparkcontext = sc); If an instance of SparkContext is not provided, the default behaviour is to create one in the background for you. Connecting to a Dask cluster; Similarly, you can connect to a Dask cluster by creating your own connection object which internally operates with one of the cluster schedulers supported by Dask (more information in the Dask distributed docs):; import ROOT; from dask.distributed import Client; ; # Point RDataFrame calls to the Dask specific RDataFrame; RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; ; # In a Python script the Dask client needs to be initalized in a context; # Jupyter notebooks / Python session don't need this; if __name__ == ""__main__"":; # With an already setup cluster that exposes a Dask scheduler endpoint; client = Client(""dask_scheduler.domain.com:8786""); ; # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); # Proceed as usual; df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); If an instance of distributed.Client is not provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine using all cores available. Choosing the number of distributed tasks; A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but generically tries to infer how many cores are available in the cluster through the connection object. The number of tasks will b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:37899,expose,exposes,37899,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['expose'],['exposes']
Security,"conify window ;  ; virtual Bool_t IsMapped ();  Returns kTRUE if window is mapped on screen, kFALSE otherwise. ;  ; virtual Bool_t IsMapSubwindows () const;  ; virtual void LowerWindow ();  lower window ;  ; virtual Int_t MustCleanup () const;  ; void Print (Option_t *option="""") const override;  Print window id. ;  ; virtual void RaiseWindow ();  raise window ;  ; virtual void RequestFocus ();  request focus ;  ; virtual void SetBackgroundPixmap (Pixmap_t pixmap);  set background pixmap ;  ; virtual void SetEditDisabled (UInt_t on=kEditDisable);  ; virtual void SetMapSubwindows (Bool_t);  ; virtual void SetName (const char *name);  ; virtual void SetWindowName (const char *name=nullptr);  Set window name. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootContextMenu.html:14188,hash,hash,14188,doc/master/classTRootContextMenu.html,https://root.cern,https://root.cern/doc/master/classTRootContextMenu.html,2,['hash'],['hash']
Security,"conn);; 8746 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8747 ; 8748 /* Content for ""WWW-Authenticate"" header */; 8749 mg_snprintf(conn,; 8750 &trunc,; 8751 buf,; 8752 sizeof(buf),; 8753 ""Digest qop=\""auth\"", realm=\""%s\"", ""; 8754 ""nonce=\""%"" UINT64_FMT ""\"""",; 8755 realm,; 8756 nonce);; 8757 ; 8758 if (!trunc) {; 8759 /* !trunc should always be true */; 8760 mg_response_header_add(conn, ""WWW-Authenticate"", buf, -1);; 8761 }; 8762 ; 8763 /* Send all headers */; 8764 mg_response_header_send(conn);; 8765}; 8766 ; 8767 ; 8768/* Interface function. Parameters are provided by the user, so do; 8769 * at least some basic checks.; 8770 */; 8771int; 8772mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8773 const char *realm); 8774{; 8775 if (conn && conn->dom_ctx) {; 8776 send_authorization_request(conn, realm);; 8777 return 0;; 8778 }; 8779 return -1;; 8780}; 8781 ; 8782 ; 8783#if !defined(NO_FILES); 8784static int; 8785is_authorized_for_put(struct mg_connection *conn); 8786{; 8787 if (conn) {; 8788 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8789 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8790 int ret = 0;; 8791 ; 8792 if (passfile != NULL; 8793 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8794 ret = authorize(conn, &file, NULL);; 8795 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8796 }; 8797 ; 8798 return ret;; 8799 }; 8800 return 0;; 8801}; 8802#endif; 8803 ; 8804 ; 8805static int; 8806modify_passwords_file(const char *fname,; 8807 const char *domain,; 8808 const char *user,; 8809 const char *pass,; 8810 const char *ha1); 8811{; 8812 int found, i;; 8813 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8814 tmp[UTF8_PATH_MAX + 8];; 8815 FILE *fp, *fp2;; 8816 ; 8817 found = 0;; 8818 fp = fp2 = NULL;; 8819 ; 8820 /* Regard empty password as no password - remove user record. */; 8821 if ((pass != NULL) && (pass[0] == '\0')) {; 8822 pass = NULL;; 8823 }; 8824 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:253240,authoriz,authorize,253240,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['authoriz'],['authorize']
Security,"conn);; 8747 mg_response_header_add(conn, ""Content-Length"", ""0"", -1);; 8748 ; 8749 /* Content for ""WWW-Authenticate"" header */; 8750 mg_snprintf(conn,; 8751 &trunc,; 8752 buf,; 8753 sizeof(buf),; 8754 ""Digest qop=\""auth\"", realm=\""%s\"", ""; 8755 ""nonce=\""%"" UINT64_FMT ""\"""",; 8756 realm,; 8757 nonce);; 8758 ; 8759 if (!trunc) {; 8760 /* !trunc should always be true */; 8761 mg_response_header_add(conn, ""WWW-Authenticate"", buf, -1);; 8762 }; 8763 ; 8764 /* Send all headers */; 8765 mg_response_header_send(conn);; 8766}; 8767 ; 8768 ; 8769/* Interface function. Parameters are provided by the user, so do; 8770 * at least some basic checks.; 8771 */; 8772int; 8773mg_send_digest_access_authentication_request(struct mg_connection *conn,; 8774 const char *realm); 8775{; 8776 if (conn && conn->dom_ctx) {; 8777 send_authorization_request(conn, realm);; 8778 return 0;; 8779 }; 8780 return -1;; 8781}; 8782 ; 8783 ; 8784#if !defined(NO_FILES); 8785static int; 8786is_authorized_for_put(struct mg_connection *conn); 8787{; 8788 if (conn) {; 8789 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8790 const char *passfile = conn->dom_ctx->config[PUT_DELETE_PASSWORDS_FILE];; 8791 int ret = 0;; 8792 ; 8793 if (passfile != NULL; 8794 && mg_fopen(conn, passfile, MG_FOPEN_MODE_READ, &file)) {; 8795 ret = authorize(conn, &file, NULL);; 8796 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8797 }; 8798 ; 8799 return ret;; 8800 }; 8801 return 0;; 8802}; 8803#endif; 8804 ; 8805 ; 8806static int; 8807modify_passwords_file(const char *fname,; 8808 const char *domain,; 8809 const char *user,; 8810 const char *pass,; 8811 const char *ha1); 8812{; 8813 int found, i;; 8814 char line[512], u[512] = """", d[512] = """", ha1buf[33],; 8815 tmp[UTF8_PATH_MAX + 8];; 8816 FILE *fp, *fp2;; 8817 ; 8818 found = 0;; 8819 fp = fp2 = NULL;; 8820 ; 8821 /* Regard empty password as no password - remove user record. */; 8822 if ((pass != NULL) && (pass[0] == '\0')) {; 8823 pass = NULL;; 8824 }; 8825 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:253272,authoriz,authorize,253272,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['authoriz'],['authorize']
Security,"conn, const char *path); 8669{; 8670#if !defined(NO_FILESYSTEMS); 8671 char fname[UTF8_PATH_MAX];; 8672 struct vec uri_vec, filename_vec;; 8673 const char *list;; 8674 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8675 int authorized = 1, truncated;; 8676 ; 8677 if (!conn || !conn->dom_ctx) {; 8678 return 0;; 8679 }; 8680 ; 8681 list = conn->dom_ctx->config[PROTECT_URI];; 8682 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8683 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8684 mg_snprintf(conn,; 8685 &truncated,; 8686 fname,; 8687 sizeof(fname),; 8688 ""%.*s"",; 8689 (int)filename_vec.len,; 8690 filename_vec.ptr);; 8691 ; 8692 if (truncated; 8693 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8694 mg_cry_internal(conn,; 8695 ""%s: cannot open %s: %s"",; 8696 __func__,; 8697 fname,; 8698 strerror(errno));; 8699 }; 8700 break;; 8701 }; 8702 }; 8703 ; 8704 if (!is_file_opened(&file.access)) {; 8705 open_auth_file(conn, path, &file);; 8706 }; 8707 ; 8708 if (is_file_opened(&file.access)) {; 8709 authorized = authorize(conn, &file, NULL);; 8710 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8711 }; 8712 ; 8713 return authorized;; 8714#else; 8715 (void)conn;; 8716 (void)path;; 8717 return 1;; 8718#endif /* NO_FILESYSTEMS */; 8719}; 8720 ; 8721 ; 8722/* Internal function. Assumes conn is valid */; 8723static void; 8724send_authorization_request(struct mg_connection *conn, const char *realm); 8725{; 8726 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8727 int trunc = 0;; 8728 char buf[128];; 8729 ; 8730 if (!realm) {; 8731 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8732 }; 8733 ; 8734 mg_lock_context(conn->phys_ctx);; 8735 nonce += conn->dom_ctx->nonce_count;; 8736 ++conn->dom_ctx->nonce_count;; 8737 mg_unlock_context(conn->phys_ctx);; 8738 ; 8739 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8740 conn->must_close = 1;; 8741 ; 8742 /* Create 401 response */; 8743 mg_response_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:250803,access,access,250803,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"conn, const char *path); 8670{; 8671#if !defined(NO_FILESYSTEMS); 8672 char fname[UTF8_PATH_MAX];; 8673 struct vec uri_vec, filename_vec;; 8674 const char *list;; 8675 struct mg_file file = STRUCT_FILE_INITIALIZER;; 8676 int authorized = 1, truncated;; 8677 ; 8678 if (!conn || !conn->dom_ctx) {; 8679 return 0;; 8680 }; 8681 ; 8682 list = conn->dom_ctx->config[PROTECT_URI];; 8683 while ((list = next_option(list, &uri_vec, &filename_vec)) != NULL) {; 8684 if (!memcmp(conn->request_info.local_uri, uri_vec.ptr, uri_vec.len)) {; 8685 mg_snprintf(conn,; 8686 &truncated,; 8687 fname,; 8688 sizeof(fname),; 8689 ""%.*s"",; 8690 (int)filename_vec.len,; 8691 filename_vec.ptr);; 8692 ; 8693 if (truncated; 8694 || !mg_fopen(conn, fname, MG_FOPEN_MODE_READ, &file)) {; 8695 mg_cry_internal(conn,; 8696 ""%s: cannot open %s: %s"",; 8697 __func__,; 8698 fname,; 8699 strerror(errno));; 8700 }; 8701 break;; 8702 }; 8703 }; 8704 ; 8705 if (!is_file_opened(&file.access)) {; 8706 open_auth_file(conn, path, &file);; 8707 }; 8708 ; 8709 if (is_file_opened(&file.access)) {; 8710 authorized = authorize(conn, &file, NULL);; 8711 (void)mg_fclose(&file.access); /* ignore error on read only file */; 8712 }; 8713 ; 8714 return authorized;; 8715#else; 8716 (void)conn;; 8717 (void)path;; 8718 return 1;; 8719#endif /* NO_FILESYSTEMS */; 8720}; 8721 ; 8722 ; 8723/* Internal function. Assumes conn is valid */; 8724static void; 8725send_authorization_request(struct mg_connection *conn, const char *realm); 8726{; 8727 uint64_t nonce = (uint64_t)(conn->phys_ctx->start_time);; 8728 int trunc = 0;; 8729 char buf[128];; 8730 ; 8731 if (!realm) {; 8732 realm = conn->dom_ctx->config[AUTHENTICATION_DOMAIN];; 8733 }; 8734 ; 8735 mg_lock_context(conn->phys_ctx);; 8736 nonce += conn->dom_ctx->nonce_count;; 8737 ++conn->dom_ctx->nonce_count;; 8738 mg_unlock_context(conn->phys_ctx);; 8739 ; 8740 nonce ^= conn->dom_ctx->auth_nonce_mask;; 8741 conn->must_close = 1;; 8742 ; 8743 /* Create 401 response */; 8744 mg_response_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:250835,access,access,250835,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"const =0;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default RooPrinable print options for given Print() flag string For inline printing only show value of objects, for default print show name,class name value and extras of each object. ;  ; void dump () const;  Base contents dumper for debugging purposes. ;  ; bool empty () const;  ; const_iterator end () const;  ; bool equals (const RooAbsCollection &otherColl) const;  Check if this and other collection have identically-named contents. ;  ; RooAbsArg * find (const char *name) const;  Find object with given name in list. ;  ; RooAbsArg * find (const RooAbsArg &) const;  Find object with given name in list. ;  ; TObject * FindObject (const char *name) const override;  Find object by name in the collection. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object in the collection, Note: matching by object name, like the find() method. ;  ; RooAbsArg * first () const;  ; Storage_t const & get () const;  Const access to the underlying stl container. ;  ; Int_t getCatIndex (const char *name, Int_t defVal=0, bool verbose=false) const;  Get index value of a RooAbsCategory stored in set with given name. ;  ; const char * getCatLabel (const char *name, const char *defVal="""", bool verbose=false) const;  Get state name of a RooAbsCategory stored in set with given name. ;  ; Int_t getHashTableSize () const;  Query the size at which the collection will automatically start using an extra lookup table instead of performing a linear search. ;  ; const char * GetName () const override;  Returns name of object. ;  ; double getRealValue (const char *name, double defVal=0.0, bool verbose=false) const;  Get value of a RooAbsReal stored in set with given name. ;  ; Int_t getSize () const;  Return the number of elements in the collection. ;  ; const char * getStringValue (const char *name, const char *defVal="""", bool verbose=false) const;  Get string value of a RooStringVar stored in set with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:6845,access,access,6845,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['access'],['access']
Security,"const Int_t nDefinition legend1.C:16; is more efficient than if (fEventNumber<10 || fEventNumber>10); Also, optionally, the generated selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Definition at line 6768 of file TTree.cxx. ◆ MakeSelector(). Int_t TTree::MakeSelector ; (; const char * ; selector = nullptr, . Option_t * ; option = """" . ). virtual . Generate skeleton selector class for this tree. ; The following files are produced: selector.h and selector.C. If selector is 0, the se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:178390,access,accessible,178390,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['accessible']
Security,"const SVector< T, D2 > &rhs, unsigned int row);  place a sub-vector starting from the given position ;  ; template<class A , unsigned int D2> ; SVector< T, D > & Place_at (const VecExpr< A, T, D2 > &rhs, unsigned int row);  place a sub-vector expression starting from the given position ;  ; template<class SubVector > ; SubVector Sub (unsigned int row) const;  return a subvector of size N starting at the value row where N is the size of the returned vector (SubVector::kSize) Condition row+N <= D ;  ; bool IsInUse (const T *p) const;  Function to check if a vector is sharing same memory location of the passed pointer This function is used by the expression templates to avoid the alias problem during expression evaluation. ;  ; std::ostream & Print (std::ostream &os) const;  used by operator<<() ;  . Private Attributes; — Data member —; T fArray [D];  SVector data. ;  . — Access functions —; enum  { kSize = D; };  Enumeration defining the Vector size. More...;  ; T apply (unsigned int i) const;  access the parse tree. Index starts from zero ;  ; const T * Array () const;  return read-only pointer to internal array ;  ; T * Array ();  return non-const pointer to internal array ;  ; static unsigned int Dim ();  return dimension \(D\) ;  . #include <Math/SVector.h>; Member Typedef Documentation. ◆ const_iterator. template<class T , unsigned int D> . typedef const T* ROOT::Math::SVector< T, D >::const_iterator. STL const_iterator interface. ; Definition at line 85 of file SVector.h. ◆ iterator. template<class T , unsigned int D> . typedef T* ROOT::Math::SVector< T, D >::iterator. STL iterator interface. ; Definition at line 82 of file SVector.h. ◆ value_type. template<class T , unsigned int D> . typedef T ROOT::Math::SVector< T, D >::value_type. contained scalar type ; Definition at line 79 of file SVector.h. Member Enumeration Documentation. ◆ anonymous enum. template<class T , unsigned int D> . anonymous enum. Enumeration defining the Vector size. . EnumeratorkSize retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:7317,access,access,7317,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['access'],['access']
Security,"const TEmulatedCollectionProxy &);  . Friends; class TCollectionProxy;  . Additional Inherited Members;  Static Public Attributes inherited from TVirtualCollectionProxy; static const Int_t fgIteratorArenaSize = 16;  The size of a small buffer that can be allocated on the stack to store iterator-specific information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:11262,access,accessors,11262,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,1,['access'],['accessors']
Security,"const TEveText & ; ). private . ◆ Paint(). void TEveText::Paint ; (; Option_t * ; option = """"). overridevirtual . Paint this object. Only direct rendering is supported. ; Reimplemented from TObject.; Definition at line 116 of file TEveText.cxx. ◆ SetAutoLighting(). void TEveText::SetAutoLighting ; (; Bool_t ; isOn). inline . Definition at line 64 of file TEveText.h. ◆ SetExtrude(). void TEveText::SetExtrude ; (; Float_t ; x). inline . Definition at line 67 of file TEveText.h. ◆ SetFontFile() [1/2]. void TEveText::SetFontFile ; (; const char * ; name). Set font file regarding to static TGLFontManager fgFontFileArray. ; Definition at line 75 of file TEveText.cxx. ◆ SetFontFile() [2/2]. void TEveText::SetFontFile ; (; Int_t ; file). inline . Definition at line 53 of file TEveText.h. ◆ SetFontMode(). void TEveText::SetFontMode ; (; Int_t ; mode). Set FTFont class ID. ; Definition at line 93 of file TEveText.cxx. ◆ SetFontSize(). void TEveText::SetFontSize ; (; Int_t ; size, . Bool_t ; validate = kTRUE . ). Set valid font size. ; Definition at line 60 of file TEveText.cxx. ◆ SetLighting(). void TEveText::SetLighting ; (; Bool_t ; isOn). inline . Definition at line 61 of file TEveText.h. ◆ SetPolygonOffset(). void TEveText::SetPolygonOffset ; (; Float_t ; factor, . Float_t ; units . ). Set the scale and units used to calculate depth values. ; See glPolygonOffset manual page. ; Definition at line 107 of file TEveText.cxx. ◆ SetText(). void TEveText::SetText ; (; const char * ; t). inline . Definition at line 58 of file TEveText.h. ◆ Streamer(). void TEveText::Streamer ; (; TBuffer & ; ). overridevirtual . Reimplemented from TEveElement. ◆ StreamerNVirtual(). void TEveText::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 77 of file TEveText.h. Member Data Documentation. ◆ fAutoLighting. Bool_t TEveText::fAutoLighting. protected . Definition at line 40 of file TEveText.h. ◆ fExtrude. Float_t TEveText::fExtrude. protected . Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveText.html:36832,validat,validate,36832,doc/master/classTEveText.html,https://root.cern,https://root.cern/doc/master/classTEveText.html,1,['validat'],['validate']
Security,"const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; AuthorAndreas Hoecker ; Definition in file TMVARegressionApplication.C. tutorialstmvaTMVARegressionApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegressionApplication_8C.html:12548,access,access,12548,doc/master/TMVARegressionApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegressionApplication_8C.html,2,['access'],['access']
Security,"const char * TClassDocInfo::GetHtmlFileName ; (; ); const. inline . Definition at line 60 of file TDocInfo.h. ◆ GetImplFileName(). const char * TClassDocInfo::GetImplFileName ; (; ); const. inline . Definition at line 62 of file TDocInfo.h. ◆ GetImplFileSysName(). const char * TClassDocInfo::GetImplFileSysName ; (; ); const. inline . Definition at line 64 of file TDocInfo.h. ◆ GetListOfTypedefs(). TList & TClassDocInfo::GetListOfTypedefs ; (; ). inline . Definition at line 82 of file TDocInfo.h. ◆ GetModule(). TModuleDocInfo * TClassDocInfo::GetModule ; (; ); const. inline . Definition at line 67 of file TDocInfo.h. ◆ GetName(). const char * TClassDocInfo::GetName ; (; ); const. overridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 25 of file TDocInfo.cxx. ◆ Hash(). ULong_t TClassDocInfo::Hash ; (; ); const. overridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TClassDocInfo::HashULong_t Hash() const overrideReturn hash value for this object.Definition TDocInfo.cxx:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassDocInfo.html:14458,hash,hash,14458,doc/master/classTClassDocInfo.html,https://root.cern,https://root.cern/doc/master/classTClassDocInfo.html,1,['hash'],['hash']
Security,"const char * TRootSniffer::GetAutoLoad ; (; ); const. return name of configured autoload scripts (or 0) ; Definition at line 490 of file TRootSniffer.cxx. ◆ GetItem(). TObject * TRootSniffer::GetItem ; (; const char * ; fullname, . TFolder *& ; parent, . Bool_t ; force = kFALSE, . Bool_t ; within_objects = kTRUE . ). protected . Return item from the subfolders structure. ; Definition at line 1571 of file TRootSniffer.cxx. ◆ GetItemField() [1/2]. const char * TRootSniffer::GetItemField ; (; const char * ; fullname, . const char * ; name . ). Return field for specified item. ; Definition at line 1836 of file TRootSniffer.cxx. ◆ GetItemField() [2/2]. const char * TRootSniffer::GetItemField ; (; TFolder * ; parent, . TObject * ; item, . const char * ; name . ). protected . Return field for specified item. ; Definition at line 1820 of file TRootSniffer.cxx. ◆ GetItemHash(). ULong_t TRootSniffer::GetItemHash ; (; const char * ; itemname). virtual . Get hash function for specified item used to detect any changes in the specified object. ; Reimplemented in TRootSnifferFull.; Definition at line 1099 of file TRootSniffer.cxx. ◆ GetStreamerInfoHash(). virtual ULong_t TRootSniffer::GetStreamerInfoHash ; (; ). inlinevirtual . Reimplemented in TRootSnifferFull.; Definition at line 243 of file TRootSniffer.h. ◆ GetSubFolder(). TFolder * TRootSniffer::GetSubFolder ; (; const char * ; foldername, . Bool_t ; force = kFALSE . ). protected . Creates subfolder where objects can be registered. ; Definition at line 1622 of file TRootSniffer.cxx. ◆ GetTopFolder(). TFolder * TRootSniffer::GetTopFolder ; (; Bool_t ; force = kFALSE). Returns top TFolder instance for the sniffer. ; Definition at line 932 of file TRootSniffer.cxx. ◆ HasRestriction(). Bool_t TRootSniffer::HasRestriction ; (; const char * ; item_name). Made fast check if item with specified name is in restriction list If returns true, requires precise check with CheckRestriction() method. ; Definition at line 499 of file TRootSnif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSniffer.html:25785,hash,hash,25785,doc/master/classTRootSniffer.html,https://root.cern,https://root.cern/doc/master/classTRootSniffer.html,1,['hash'],['hash']
Security,"const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE)Execute a file containing a C++ macro (static method).Definition TApplication.cxx:1729; TApplication::GetApplicationImpvirtual TApplicationImp * GetApplicationImp()Definition TApplication.h:136; TApplication::IsCmdThreadvirtual Bool_t IsCmdThread()Definition TApplication.h:135; TBaseClassEach class (see TClass) has a linked list of its base class(es).Definition TBaseClass.h:33; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTable::GetProtoNormstatic TProtoClass * GetProtoNorm(const char *cname)Given the class normalized name returns the TClassProto object for the class.Definition TClassTable.cxx:770; TClassTable::GetDictNormstatic DictFuncPtr_t GetDictNorm(const char *cname)Given the normalized class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:717; TClassTable::GetProtostatic TProtoClass * GetProto(const char *cname)Given the class name returns the TClassProto object for the class.Definition TClassTable.cxx:742; TClassTable::Checkstatic Bool_t Check(const char *cname, std::string &normname)Definition TClassTable.cxx:563; TClassTable::Addstatic void Add(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits)Add a class to the class table (this is a static function).Definition TClassTable.cxx:398; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLTy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:397753,hash,hash,397753,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['hash'],['hash']
Security,"const char *name, const char *classes="""");  TClassTree constructor. ;  ;  ~TClassTree () override;  TClassTree default destructor. ;  ; void Draw (const char *classes="""") override;  Draw the inheritance tree and relations for the list of classes see this class header for the syntax and examples. ;  ; virtual Int_t FindClass (const char *classname);  Find class number corresponding to classname in list of local classes. ;  ; const char * GetClasses () const;  ; virtual const char * GetSourceDir () const;  ; TClass * IsA () const override;  ; void ls (Option_t *option="""") const override;  list classes names and titles ;  ; void Paint (Option_t *option="""") override;  Draw the current class setting in fClasses and fStatus. ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  save current configuration in a Root file if filename is blank, the name of the file will be the current objectname.root all the current settings are preserved the Root file produced can be looked at by a another Root session with no access to the original classes. ;  ; virtual void SetClasses (const char *classes, Option_t *option=""ID"");  Set the list of classes for which the hierarchy is to be drawn See Paint for the syntax. ;  ; virtual void SetLabelDx (Float_t labeldx=0.15);  Set the size along x of the TPaveLabel showing the class name. ;  ; virtual void SetSourceDir (const char *dir=""src"");  ; virtual void SetYoffset (Float_t offset=0);  Set the offset at the top of the picture The default offset is computed automatically taking into account classes not inheriting from TObject. ;  ; virtual void ShowClassesUsedBy (const char *classes);  mark classes used by the list of classes in classes ;  ; virtual void ShowClassesUsing (const char *classes);  mark classes using any class in the list of classes in classes ;  ; virtual void ShowLinks (Option_t *option=""HMR"");  Set link options in the ClassTree object. ;  ; void Streamer (TBuffer &) override;  Stream an object of cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTree.html:6218,access,access,6218,doc/master/classTClassTree.html,https://root.cern,https://root.cern/doc/master/classTClassTree.html,1,['access'],['access']
Security,"const char* fmt, va_list va) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInitializeContext(); voidTObject::MakeZombie(); virtual voidOnValidateError(const TString& message); virtual voidOnValidateWarning(const TString& message); virtual voidReleaseUnderlying(); virtual voidSetParseCode(Int_t code). private:. TXMLParser&operator=(const TXMLParser&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfParseCodeto keep track of the errorcodes; Bool_tfReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tfStopErrorstop when parse error occurs; Bool_tfValidateto validate the parse context; TStringfValidateErrorparse error; TStringfValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TXMLParser(); Cleanup. void SetValidate(Bool_t val = kTRUE); The parser will validate the xml file if val = true. void SetReplaceEntities(Bool_t val = kTRUE); The parser will replace/expand entities. void ReleaseUnderlying(); To release any existing document. void OnValidateError(const TString& message); This function is called when an error from the parser has occured.; Message is the parse error. void OnValidateWarning(const TString& message); This function is called when a warning from the parser has occured.; Message is the parse error. const char * GetParseCodeMessage(Int_t parseCode) const; Returns t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLParser.html:9853,validat,validate,9853,root/html528/TXMLParser.html,https://root.cern,https://root.cern/root/html528/TXMLParser.html,4,['validat'],['validate']
Security,"const char* name1 = stmt->GetString(2);; const char* name2 = stmt->GetString(3);; cout << id1 << "" - "" << id2 << "" "" << name1 << "" "" << name2 << endl;; }; }. 4. Working with date/time parameters. Current implementation supports date, time, date&time and timestamp; data (all time intervals not supported yet). To set or get date/time values,; following methods should be used:; SetTime()/GetTime() - only time (hour:min:sec),; SetDate()/GetDate() - only date (year-month-day),; SetDatime()/GetDatime() - date and time; SetTimestamp()/GetTimestamp() - timestamp with seconds fraction; For some of these methods TDatime type can be used as parameter / return value.; Be aware, that TDatime supports only dates after 1995-01-01.; There are also methods to get separately year, month, day, hour, minutes and seconds. Different SQL databases has different treatement of date/time types.; For instance, MySQL has all correspondent types (TIME, DATE, DATETIME and TIMESTAMP),; Oracle native driver supports only DATE (which is actually date and time) and TIMESTAMP; ODBC interface provides access for time, date and timestamps.; Therefore, one should use correct methods to access such data.; For instance, in MySQL SQL type 'DATE' is only date (one should use GetDate() to; access such data), while in Oracle it is date and time. Therefore,; to get complete data from 'DATE' column in Oracle, one should use GetDatime() method. The only difference of timestamp from date/time, that it has fractional; seconds part. Be aware, that fractional part can has different meaning; (actual value) in different SQL plugins. 5. Binary data. Most of modern data bases support just binary data, which is; typically has SQL type name 'BLOB'. To access data in such; columns, GetBinary()/SetBinary() methods should be used.; Current implementation supposed, that complete content of the; column must be retrieved at once. Therefore very big data of; gigabytes size may cause a problem. Function Members (Methods);      Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLStatement.html:7789,access,access,7789,root/html528/TSQLStatement.html,https://root.cern,https://root.cern/root/html528/TSQLStatement.html,3,['access'],['access']
Security,"const char* remote, const char* proto, const char* user = """"); Create authentication object. void CatchTimeOut(); Called in connection with a timer timeout. Bool_t Authenticate(); Authenticate to remote rootd or proofd server. Return kTRUE if; authentication succeeded. void SetEnvironment(); Set default authentication environment. The values are inferred; from fSecurity and fDetails. Bool_t GetUserPasswd(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from several sources. Bool_t CheckNetrc(TString& user, TString& passwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. For more info see the version with 4 arguments.; This version is maintained for backward compatability reasons. Bool_t CheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); Try to get user name and passwd from the ~/.rootnetrc or; ~/.netrc files. First ~/.rootnetrc is tried, after that ~/.netrc.; These files will only be used when their access masks are 0600.; Returns kTRUE if user and passwd were found for the machine; specified in the URL. If kFALSE, user and passwd are """".; If srppwd == kTRUE then a SRP ('secure') pwd is searched for in; the files.; The boolean pwhash is set to kTRUE if the returned passwd is to; be understood as password hash, i.e. if the 'password-hash' keyword; is found in the 'machine' lines; not implemented for 'secure'; and the .netrc file.; The format of these files are:. # this is a comment line; machine <machine fqdn> login <user> password <passwd>; machine <machine fqdn> login <user> password-hash <passwd>. and in addition ~/.rootnetrc also supports:. secure <machine fqdn> login <user> password <passwd>. <machine fqdn> may be a domain name or contain the wild card '*'. for the secure protocols. All lines must start in the first column. const char * GetGlobalUser(); Static method returning the global user. Bool_t GetGlobalPwHash(); Static method returning the global password hash",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:12136,access,access,12136,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['access'],['access']
Security,"const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tTClass::GetCheckSum(Bool_t& isvalid) const; UInt_tTClass::GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tTClass::GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:6774,checksum,checksum,6774,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,2,['checksum'],['checksum']
Security,"const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE)=0; TBuffer::ClassEndvirtual void ClassEnd(const TClass *)=0; TBuffer::CheckByteCountvirtual Int_t CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass *clss)=0; TBuffer::ClassMembervirtual void ClassMember(const char *, const char *=nullptr, Int_t=-1, Int_t=-1)=0; TBuffer::GetVersionOwnervirtual Int_t GetVersionOwner() const =0; TBuffer::IsReadingBool_t IsReading() constDefinition TBuffer.h:86; TBuffer::SetBufferOffsetvoid SetBufferOffset(Int_t offset=0)Definition TBuffer.h:93; TBuffer::WriteVersionvirtual UInt_t WriteVersion(const TClass *cl, Bool_t useBcnt=kFALSE)=0; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassRef::Resetvoid Reset()Definition TClassRef.h:67; TClassStreamerDefinition TClassStreamer.h:26; TClassTable::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Given the class name returns the Dictionary() function of a class (uses hash of name).Definition TClassTable.cxx:674; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetCheckSumUInt_t GetCheckSum(ECheckSum code=kCurrentCheckSum) constCall GetCheckSum with validity check.Definition TClass.cxx:6572; TClass::IsSyntheticPairBool_t IsSyntheticPair() constDefinition TClass.h:521; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::RemoveStreamerInfovoid RemoveStreamerInfo(Int_t slot)Remove and delete the StreamerInfo in the given slot.Definition TClass.cxx:7387; TClass::GetStreamerInfoAbstractEmulat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:248720,hash,hash,248720,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['hash'],['hash']
Security,"const. inline . Definition at line 52 of file TGPicture.h. ◆ Hash(). ULong_t TGPicture::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TGPicture::HashULong_t Hash() const overrideReturn hash value for this object.Definition TGPicture.h:57; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 57 of file TGPicture.h. ◆ HashName(). const char * TGPicture::HashName ; (; const char * ; name, . Int_t ; width, . Int_t ; height . ). static . Static function returning a unique name used to look up a picture. ; The unique name has the form ""name__widthxheight"". ; Definition at line 375 of file TGPicture.cxx. ◆ IsA(). TClass * TGPicture::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TGSelectedPicture.; Definition at line 63 of file TGPicture.h. ◆ IsScaled(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGPicture.html:14770,hash,hash,14770,doc/master/classTGPicture.html,https://root.cern,https://root.cern/doc/master/classTGPicture.html,1,['hash'],['hash']
Security,"const. inline . Get the 9 matrix components into data specified by an iterator begin. ; Definition at line 291 of file Rotation3D.h. ◆ GetComponents() [3/4]. template<class IT > . void ROOT::Math::Rotation3D::GetComponents ; (; IT ; begin, . IT ; end . ); const. inline . Get the 9 matrix components into data specified by an iterator begin and another to the end of the desired data (9 past start). ; Definition at line 278 of file Rotation3D.h. ◆ GetComponents() [4/4]. void ROOT::Math::Rotation3D::GetComponents ; (; Scalar & ; xx, . Scalar & ; xy, . Scalar & ; xz, . Scalar & ; yx, . Scalar & ; yy, . Scalar & ; yz, . Scalar & ; zx, . Scalar & ; zy, . Scalar & ; zz . ); const. inline . Get the nine components into nine scalars. ; Definition at line 338 of file Rotation3D.h. ◆ GetRotationMatrix(). template<class ForeignMatrix > . void ROOT::Math::Rotation3D::GetRotationMatrix ; (; ForeignMatrix & ; m); const. inline . Get components into a linear algebra matrix of size at least 3x3, which must support operator()(i,j) for write access to elements (0,0) thru (2,2). ; Definition at line 316 of file Rotation3D.h. ◆ Inverse(). Rotation3D ROOT::Math::Rotation3D::Inverse ; (; ); const. inline . Return inverse of a rotation. ; Definition at line 416 of file Rotation3D.h. ◆ Invert(). void ROOT::Math::Rotation3D::Invert ; (; ). Invert a rotation in place. ; Definition at line 109 of file Rotation3D.cxx. ◆ operator!=(). bool ROOT::Math::Rotation3D::operator!= ; (; const Rotation3D & ; rhs); const. inline . Definition at line 474 of file Rotation3D.h. ◆ operator()() [1/4]. template<class CoordSystem , class U > . DisplacementVector3D< CoordSystem, U > ROOT::Math::Rotation3D::operator() ; (; const DisplacementVector3D< CoordSystem, U > & ; v); const. inline . Rotation operation on a displacement vector in any coordinate system. ; Definition at line 354 of file Rotation3D.h. ◆ operator()() [2/4]. template<class ForeignVector > . ForeignVector ROOT::Math::Rotation3D::operator() ; (; co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Rotation3D.html:12405,access,access,12405,doc/master/classROOT_1_1Math_1_1Rotation3D.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Rotation3D.html,1,['access'],['access']
Security,"const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const Scalar[] src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSyst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11022,access,access,11022,root/html602/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,2,['access'],['access']
Security,"const; const RooNameSet*nameSet2ByIndex(Int_t index) const; RooCacheManager<vector<double,allocator<double> > >&operator=(const RooCacheManager<vector<double,allocator<double> > >&); virtual voidoperModeHook(); virtual voidRooAbsCache::optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp, char* parent); voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; vector<double,allocator<double> >**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0). Int_t setObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCacheManager_vector_double___.html:3286,access,accessed,3286,root/html526/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html526/RooCacheManager_vector_double___.html,1,['access'],['accessed']
Security,"constPrint the collection entry.Definition TCollection.cxx:445; TCollection::GetCollectionEntryNamevirtual const char * GetCollectionEntryName(TObject *entry) constFor given collection entry return the string that is used to identify the object and,...Definition TCollection.cxx:437; TCollection::PrintCollectionHeadervirtual void PrintCollectionHeader(Option_t *option) constPrint the collection header.Definition TCollection.cxx:425; TObjectMother of all ROOT objects.Definition TObject.h:41; int; Otherwise override the Print(Option_t *option, Int_t) variant. Remember to declare: using TCollection::Print;; TCollection::Printvoid Print(Option_t *option="""") const overrideDefault print for collections, calls Print(option, 1).Definition TCollection.cxx:476; somewhere close to the method declaration. ; Reimplemented from TCollection.; Definition at line 197 of file TCollection.cxx. ◆ Rehash(). void THashTable::Rehash ; (; Int_t ; newCapacity, . Bool_t ; checkObjValidity = kTRUE . ). Rehash the hashtable. ; If the collision rate becomes too high (i.e. the average size of the linked lists become too long) then lookup efficiency decreases since relatively long lists have to be searched every time. To improve performance rehash the hashtable. This resizes the table to newCapacity slots and refills the table. Use AverageCollisions() to check if you need to rehash. Set checkObjValidity to kFALSE if you know that all objects in the table are still valid (i.e. have not been deleted from the system in the meanwhile). ; Definition at line 365 of file THashTable.cxx. ◆ Remove(). TObject * THashTable::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the hashtable. ; Implements TCollection.; Definition at line 417 of file THashTable.cxx. ◆ RemoveSlow(). TObject * THashTable::RemoveSlow ; (; TObject * ; obj). Remove object from the hashtable without using the hash value. ; Definition at line 442 of file THashTable.cxx. ◆ SetRehashLevel(). void THashTable::SetRehashLevel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:27080,hash,hashtable,27080,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hashtable']
Security,"constReturn the type of the rule.Definition TSchemaRule.cxx:764; ROOT::TSchemaRule::ConflictsBool_t Conflicts(const TSchemaRule *rule) constCheck if this rule conflicts with the given one.Definition TSchemaRule.cxx:772; ROOT::TSchemaRule::operator=TSchemaRule & operator=(const TSchemaRule &rhs)Copy operator.Definition TSchemaRule.cxx:125; ROOT::TSchemaRule::SetTargetClassvoid SetTargetClass(const TString &classname)Set the target class of this rule (i.e. the in memory class).Definition TSchemaRule.cxx:474; ROOT::TSchemaRule::ReadRawFuncPtr_tvoid(* ReadRawFuncPtr_t)(char *, TBuffer &)Definition TSchemaRule.h:41; ROOT::TSchemaRule::GetSourceClassconst char * GetSourceClass() constGet the source class of this rule (i.e. the onfile class).Definition TSchemaRule.cxx:466; ROOT::TSchemaRule::fTargetTString fTargetDefinition TSchemaRule.h:107; ROOT::TSchemaRule::~TSchemaRulevirtual ~TSchemaRule()Destructor.Definition TSchemaRule.cxx:100; ROOT::TSchemaRule::TestChecksumBool_t TestChecksum(UInt_t checksum) constCheck if given checksum is defined in this rule.Definition TSchemaRule.cxx:437; ROOT::TSchemaRule::SetVersionBool_t SetVersion(const TString &version)Set the version string - returns kFALSE if the format is incorrect.Definition TSchemaRule.cxx:381; ROOT::TSchemaRule::fIncludeTString fIncludeSource data member vector (for searching purposes)Definition TSchemaRule.h:111; ROOT::TSchemaRule::fTargetVectTObjArray * fTargetVectDefinition TSchemaRule.h:108; ROOT::TSchemaRule::fChecksumTString fChecksumSource version vector (for searching purposes)Definition TSchemaRule.h:103; ROOT::TSchemaRule::fTargetClassTString fTargetClassDefinition TSchemaRule.h:106; ROOT::TSchemaRule::SetSourcevoid SetSource(const TString &source)Set the list of source members.Definition TSchemaRule.cxx:538; ROOT::TSchemaRule::IsRenameRuleBool_t IsRenameRule() constReturn kTRUE if the rule is a strict renaming of the class to a new name.Definition TSchemaRule.cxx:756; ROOT::TSchemaRule::SetAttributesvoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:42256,checksum,checksum,42256,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,4,['checksum'],['checksum']
Security,"constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Function Members (Methods); public:. virtual~DecisionTree(); virtual void*TMVA::BinaryTree::AddXMLTo(void* parent) const; voidApplyValidationSample(const TMVA::DecisionTree::EventList* validationSample) const; UInt_tBuildTree(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node = NULL); Double_tCheckEvent(const TMVA::Event&, Bool_t UseYesNoLeaf = kFALSE) const; voidCheckEventWithPrunedTree(const TMVA::Event&) const; static TClass*Class(); virtual const char*ClassName() const; UInt_tCleanTree(TMVA::DecisionTreeNode* node = NULL); voidClearTree(); UInt_tCountLeafNodes(TMVA::Node* n = NULL); UInt_tTMVA::BinaryTree::CountNodes(TMVA::Node* n = NULL); static TMVA::DecisionTree*CreateFromXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual TMVA::DecisionTreeNode*CreateNode(UInt_t) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::DecisionTreeDecisionTree(); TMVA::DecisionTreeDecisionTree(const TMVA::DecisionTree& d); TMVA::DecisionTreeDecisionTree(TMVA::SeparationBase* sepType, Int_t minSize, Int_t nCuts, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNvars = kFALSE, UInt_t nNodesMax = 999999, UInt_t nMaxDepth = 9999999, Int_t iSeed = fgRandomSeed, Float_t purityLimit = 0.5, Int_t treeID = 0); voidDescendTree(TMVA::Node* n = NULL); Bool_tDoRegression() const; voidFillEvent(TMVA::Event& event, TMVA::DecisionTreeNode* node); voidFillTree(TMVA::DecisionTree::EventList& eventSample); TMVA::Types::EAnalysisTypeGetAnalysisType(); TMVA::DecisionTreeNode*GetEventNode(const TMVA::Event& e) const; vector<Double_t>GetFisherCoefficients(const TMVA::DecisionT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTree.html:1919,validat,validationSample,1919,root/html528/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html,3,['validat'],['validationSample']
Security,"contain also the server for whicb these directives are valid in the form 'host:server' or 'server://host' ; Definition at line 86 of file THostAuth.cxx. ◆ THostAuth() [6/7]. THostAuth::THostAuth ; (; const char * ; asstring). Create hostauth object from directives given as a compact string See THostAuth::AsString(). ; Used in proof context only; fServer not set; to be set by hand with SetServer() method if really needed ; Definition at line 194 of file THostAuth.cxx. ◆ THostAuth() [7/7]. THostAuth::THostAuth ; (; THostAuth & ; ha). Copy ctor ... ; Definition at line 256 of file THostAuth.cxx. ◆ ~THostAuth(). THostAuth::~THostAuth ; (; ). virtual . The dtor. ; Definition at line 362 of file THostAuth.cxx. Member Function Documentation. ◆ Activate(). void THostAuth::Activate ; (; ). inline . Definition at line 85 of file THostAuth.h. ◆ AddFirst(). void THostAuth::AddFirst ; (; Int_t ; level, . const char * ; details = nullptr . ). Add new method in first position If already in the list, set as first method 'level' with authentication 'details'. ; Faster then AddMethod(method,details)+SetFirst(method). ; Definition at line 651 of file THostAuth.cxx. ◆ AddMethod(). void THostAuth::AddMethod ; (; Int_t ; meth, . const char * ; details = nullptr . ). Add method to the list. ; If already there, change its details to 'details' ; Definition at line 277 of file THostAuth.cxx. ◆ AsString(). void THostAuth::AsString ; (; TString & ; out); const. Return a static string with all info in a serialized form. ; Definition at line 741 of file THostAuth.cxx. ◆ Class(). static TClass * THostAuth::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * THostAuth::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t THostAuth::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 111 of file THostAuth.h. ◆ CountFailure(). void THostAuth::CountFailure ; (; Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHostAuth.html:16241,authenticat,authentication,16241,doc/master/classTHostAuth.html,https://root.cern,https://root.cern/doc/master/classTHostAuth.html,1,['authenticat'],['authentication']
Security,"cope before the end of the program, ROOT might display a blank canvas).; 2224 template <typename X = RDFDetail::RInferredType, typename Y = RDFDetail::RInferredType>; 2225 RResultPtr<::TGraph> Graph(std::string_view x = """", std::string_view y = """"); 2226 {; 2227 auto graph = std::make_shared<::TGraph>();; 2228 const std::vector<std::string_view> columnViews = {x, y};; 2229 const auto userColumns = RDFInternal::AtLeastOneEmptyString(columnViews); 2230 ? ColumnNames_t(); 2231 : ColumnNames_t(columnViews.begin(), columnViews.end());; 2232 ; 2233 const auto validatedColumns = GetValidatedColumnNames(2, userColumns);; 2234 ; 2235 // We build a default name and title based on the input columns; 2236 const auto g_name = validatedColumns[1] + ""_vs_"" + validatedColumns[0];; 2237 const auto g_title = validatedColumns[1] + "" vs "" + validatedColumns[0];; 2238 graph->SetNameTitle(g_name.c_str(), g_title.c_str());; 2239 graph->GetXaxis()->SetTitle(validatedColumns[0].c_str());; 2240 graph->GetYaxis()->SetTitle(validatedColumns[1].c_str());; 2241 ; 2242 return CreateAction<RDFInternal::ActionTags::Graph, X, Y>(validatedColumns, graph, graph, fProxiedPtr);; 2243 }; 2244 ; 2245 ////////////////////////////////////////////////////////////////////////////; 2246 /// \brief Fill and return a TGraphAsymmErrors object (*lazy action*).; 2247 /// \param[in] x The name of the column that will fill the x axis.; 2248 /// \param[in] y The name of the column that will fill the y axis.; 2249 /// \param[in] exl The name of the column of X low errors; 2250 /// \param[in] exh The name of the column of X high errors; 2251 /// \param[in] eyl The name of the column of Y low errors; 2252 /// \param[in] eyh The name of the column of Y high errors; 2253 /// \return the TGraphAsymmErrors wrapped in a RResultPtr.; 2254 ///; 2255 /// Columns can be of a container type (e.g. std::vector<double>), in which case the graph; 2256 /// is filled with each one of the elements of the container.; 2257 /// If Multithre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:125481,validat,validatedColumns,125481,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['validat'],['validatedColumns']
Security,"copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooNumConvolution*_conv! Actual convolution calculation; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvPdf.html:44375,access,access,44375,root/html602/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html602/RooNumConvPdf.html,2,['access'],['access']
Security,"copy style; 3055 rhs.TAttLine::Copy(*this);; 3056 rhs.TAttFill::Copy(*this);; 3057 rhs.TAttMarker::Copy(*this);; 3058 }; 3059 ; 3060 return *this;; 3061}; 3062 ; 3063////////////////////////////////////////////////////////////////////////////////; 3064/// Paints this TEfficiency object; 3065///; 3066/// For details on the possible option see Draw(Option_t*); 3067///; 3068/// Note for 1D classes; 3069/// In 1D the TEfficiency uses a TGraphAsymmErrors for drawing; 3070/// The TGraph is created only the first time Paint is used. The user can manipulate the; 3071/// TGraph via the method TEfficiency::GetPaintedGraph(); 3072/// The TGraph creates behing an histogram for the axis. The histogram is created also only the first time.; 3073/// If the axis needs to be updated because in the meantime the class changed use this trick; 3074/// which will trigger a re-calculation of the axis of the graph; 3075/// TEfficiency::GetPaintedGraph()->Set(0); 3076///; 3077/// Note that in order to access the painted graph via GetPaintedGraph() you need either to call Paint or better; 3078/// gPad->Update();; 3079///; 3080 ; 3081void TEfficiency::Paint(const Option_t* opt); 3082{; 3083 ; 3084 ; 3085 if(!gPad); 3086 return;; 3087 ; 3088 TString option(opt);; 3089 option.ToUpper();; 3090 ; 3091 ; 3092 //use TGraphAsymmErrors for painting; 3093 if(GetDimension() == 1) {; 3094 if(!fPaintGraph) {; 3095 fPaintGraph = CreateGraph(opt);; 3096 }; 3097 else; 3098 // update existing graph already created; 3099 FillGraph(fPaintGraph, opt);; 3100 ; 3101 //paint graph; 3102 fPaintGraph->Paint(opt);; 3103 // paint all associated functions; 3104 if (fFunctions) {; 3105 // paint box with fit parameters; 3106 // the fit statistics will be painted if gStyle->SetOptFit(1) has been; 3107 // called by the user; 3108 TIter next(fFunctions);; 3109 TObject *obj = nullptr;; 3110 while ((obj = next())) {; 3111 if (obj->InheritsFrom(TF1::Class())) {; 3112 fPaintGraph->PaintStats((TF1 *)obj);; 3113 ((TF1 *)obj)->Paint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:122606,access,access,122606,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['access'],['access']
Security,corder/replayer interface for a user.; TRecorderInactive Represents state of TRecorder after its creation; TRecorderPaused Represents state of TRecorder when paused; TRecorderRecording Represents state of TRecorder when recording events; TRecorderReplaying Represents state of TRecorder when replaying; TRecorderState Abstract class that defines interface for a state of recorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to a TObject; TRefArray An array of references to TObjects; TRefArrayIter Object array iterator; TRefCnt ; TRefTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summury information ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:122184,authenticat,authentication,122184,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['authenticat'],['authentication']
Security,"cpp}; 222 TAxis *xaxis = h->GetXaxis(); etc.; 223 Double_t binCenter = xaxis->GetBinCenter(bin), etc.; 224~~~; 225 See class TAxis for a description of all the access functions.; 226 The axis range is always stored internally in double precision.; 227 ; 228\anchor convention; 229### Convention for numbering bins; 230 ; 231 For all histogram types: nbins, xlow, xup; 232~~~ {.cpp}; 233 bin = 0; underflow bin; 234 bin = 1; first bin with low-edge xlow INCLUDED; 235 bin = nbins; last bin with upper-edge xup EXCLUDED; 236 bin = nbins+1; overflow bin; 237~~~; 238 In case of 2-D or 3-D histograms, a ""global bin"" number is defined.; 239 For example, assuming a 3-D histogram with (binx, biny, binz), the function; 240~~~ {.cpp}; 241 Int_t gbin = h->GetBin(binx, biny, binz);; 242~~~; 243 returns a global/linearized gbin number. This global gbin is useful; 244 to access the bin content/error information independently of the dimension.; 245 Note that to access the information other than bin content and errors; 246 one should use the TAxis object directly with e.g.:; 247~~~ {.cpp}; 248 Double_t xcenter = h3->GetZaxis()->GetBinCenter(27);; 249~~~; 250 returns the center along z of bin number 27 (not the global bin); 251 in the 3-D histogram h3.; 252 ; 253\anchor alpha; 254### Alphanumeric Bin Labels; 255 ; 256 By default, a histogram axis is drawn with its numeric bin labels.; 257 One can specify alphanumeric labels instead with:; 258 ; 259 - call TAxis::SetBinLabel(bin, label);; 260 This can always be done before or after filling.; 261 When the histogram is drawn, bin labels will be automatically drawn.; 262 See examples labels1.C and labels2.C; 263 - call to a Fill function with one of the arguments being a string, e.g.; 264~~~ {.cpp}; 265 hist1->Fill(somename, weight);; 266 hist2->Fill(x, somename, weight);; 267 hist2->Fill(somename, y, weight);; 268 hist2->Fill(somenamex, somenamey, weight);; 269~~~; 270 See examples hlabels1.C and hlabels2.C; 271 - via TTree::Draw. see for exa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:10992,access,access,10992,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['access'],['access']
Security,"create it if its not already in the list. TDictionary * Get(TListOfDataMembers::DeclId_t id); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'. TDictionary * Get(DataMemberInfo_t* info, bool skipChecks = false); Return (after creating it if necessary) the TDataMember; describing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object of class TListOfDataMembers. void Update(TDictionary* member); Move the member or data member to the expect set of list. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TDictionary* member); Mark 'func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfDataMembers.html:14460,hash,hash,14460,root/html602/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html602/TListOfDataMembers.html,2,['hash'],['hash']
Security,"creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of byt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:22232,authenticat,authenticated,22232,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['authenticat'],['authenticated']
Security,"cribed by this streamerInfo is a base class; 3251/// of the actual type of the object.; 3252/// This routine should only be called if the class described by this; 3253/// StreamerInfo is 'emulated'.; 3254 ; 3255TClass *TStreamerInfo::GetActualClass(const void *obj) const; 3256{; 3257 R__ASSERT(!fClass->IsLoaded());; 3258 ; 3259 if (fNVirtualInfoLoc != 0) {; 3260 TStreamerInfo *allocator = *(TStreamerInfo**)( (const char*)obj + fVirtualInfoLoc[0] );; 3261 if (allocator) return allocator->GetClass();; 3262 }; 3263 return (TClass*)fClass;; 3264}; 3265 ; 3266////////////////////////////////////////////////////////////////////////////////; 3267/// Return true if the checksum passed as argument is one of the checksum; 3268/// value produced by the older checksum calculation algorithm.; 3269 ; 3270Bool_t TStreamerInfo::MatchLegacyCheckSum(UInt_t checksum) const; 3271{; 3272 for(UInt_t i = 1; i < TClass::kLatestCheckSum; ++i) {; 3273 if ( checksum == GetCheckSum( (TClass::ECheckSum) i) ) return kTRUE;; 3274 }; 3275 return kFALSE;; 3276}; 3277 ; 3278////////////////////////////////////////////////////////////////////////////////; 3279/// Recalculate the checksum of this TStreamerInfo based on its code.; 3280///; 3281/// The class ckecksum is used by the automatic schema evolution algorithm; 3282/// to uniquely identify a class version.; 3283/// The check sum is built from the names/types of base classes and; 3284/// data members.; 3285/// The valid range of code is determined by ECheckSum.; 3286/// - kNoEnum: data members of type enum are not counted in the checksum; 3287/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 3288/// - kWithTypeDef: use the sugared type name in the calculation.; 3289///; 3290/// This is needed for backward compatibility.; 3291/// ### WARNING; 3292/// This function must be kept in sync with TClass::GetCheckSum.; 3293/// They are both used to handle backward compatibility",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:131821,checksum,checksum,131821,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,3,['checksum'],['checksum']
Security,"cribes Lorentz transformations including Lorentz boosts and rotations (see TRotation) ;  CTLorentzRotationRow;  CTLorentzVectorTLorentzVector is a general four-vector class, which can be used either for the description of position and time (x,y,z,t) or momentum and energy (px,py,pz,E) ;  CTMacOSXSystem;  CTMacroClass supporting a collection of lines with C++ code ;  CTMakeProject;  CTMapTMap implements an associative array of (key,value) pairs using a THashTable for efficient retrieval (therefore TMap does not conserve the order of the entries) ;  CTMapFileThis class implements a shared memory region mapped to a file ;  CTMapIterIterator of map ;  CTMapRecKeep track of an object in the mapped file ;  CTMarkerManages Markers ;  CTMarker3DBoxA special 3-D marker designed for event display ;  CTMaterialManages a detector material ;  CTMathTextTo draw TeX Mathematical Formula ;  CTMatrixDEigenTMatrixDEigen ;  CTMatrixDSymEigenTMatrixDSymEigen ;  CTMatrixTTMatrixT ;  CTMatrixTBaseLinear Algebra Package ;  CTMatrixTColumn;  CTMatrixTColumn_const;  CTMatrixTDiag;  CTMatrixTDiag_const;  CTMatrixTFlat;  CTMatrixTFlat_const;  CTMatrixTLazyTemplates of Lazy Matrix classes ;  CTMatrixTRow;  CTMatrixTRow_const;  CTMatrixTSparseTMatrixTSparse ;  CTMatrixTSparseDiag;  CTMatrixTSparseDiag_const;  CTMatrixTSparseRow;  CTMatrixTSparseRow_const;  CTMatrixTSub;  CTMatrixTSub_const;  CTMatrixTSymTMatrixTSym ;  CTMatrixTSymLazy;  CTMCParticleThis class serves as a data storage for description of one particle ;  CTMCVerboseClass for printing a detailed information from MC application ;  CTMD5This code implements the MD5 message-digest algorithm ;  CTMehrotraSolver;  CTMemberInspectorAbstract base class for accessing the data-members of a class ;  CTMemberStreamer;  ►CTMemFileA TMemFile is like a normal TFile except that it reads and writes only from memory ;  CTMemBlock;  CTMemStat;  CTMemStatHook;  CTMemStatShowUtility class post-processing the file generated by TMemStat (default memstat.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:169890,access,accessing,169890,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['access'],['accessing']
Security,"cro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Bool_t Load() const; Load the macro into the interpreter.; Return true in case the loading was successful. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SaveSource(FILE* fp); Save macro source in file pointer fp.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMacro.html:8969,checksum,checksum,8969,root/html602/TMacro.html,https://root.cern,https://root.cern/root/html602/TMacro.html,2,['checksum'],['checksum']
Security,"cro(const TMacro& ); Copy constructor. ~TMacro(); Delete this macro. TMacro& operator=(const TMacro& ); Copy constructor. TObjString * AddLine(const char* text); Add line with text in the list of lines of this macro. void Browse(TBrowser* b); When clicking in the browser, the following action is performed; on this macro, depending the content of the variable TMacro.Browse.; TMacro.Browse can be set in the system.rootrc or .rootrc file like; TMacro.Browse : Action; or set via gEnv->SetValue, eg; gEnv->SetValue(""TMacro.Browse"",""Print"");; By default TMacro.Browse=""""; -if TMacro.Browse ="""" the macro is executed; -if TMacro.Browse =""Print"" the macro is printed in stdout; -if TMacro.Browse is of the form ""mymacro.C""; the macro void mymacro.C(TMacro *m) is called where m=this macro; An example of macro.C saving the macro into a file and viewing it; with emacs is shown below:; void mymacro(TMacro *m) {; m->SaveSource(""xx.log"");; gSystem->Exec(""emacs xx.log&"");; }. TMD5 * Checksum(); Returns checksum of the current content. The returned TMD5 object must; be deleted by the user. Returns 0 in case of error. Long_t Exec(const char* params = 0, Int_t* error = 0); Execute this macro with params, if params is 0, default parameters; (set via SetParams) are used.; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine().; Returns the result of the macro (return value or value of the last; expression), cast to a Long_t. TObjString * GetLineWith(const char* text) const; Search the first line containing text. void Paint(Option_t* option = """"); Execute this macro (called by TPad::Paint). void Print(Option_t* option = """") const; Print contents of this macro. Int_t ReadFile(const char* filename); Read lines in filename in this macro. void SaveSource(const char* filename); Save macro source in filename. void SavePrimitive(ostream& out, Option_t* option = """"); Save macro source on stream out. void SetParams(const char* params = 0); Set default parameters to execute this ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMacro.html:8330,checksum,checksum,8330,root/html528/TMacro.html,https://root.cern,https://root.cern/root/html528/TMacro.html,3,['checksum'],['checksum']
Security,croTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TListOfFunctionTemplates*fFuncTemplateList of global function templates; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TStringfGitBranchGit branch; TStringfGitCommitGit commit SHA1 of built; TStringfGitDateDate and time when make was run; TListOfFunctions*fGlobalFunctionsList of global functions; TListOfDataMembers*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrupted; TList*TDirectory::fListList of objects in memory; TSeqCollection*fMappedFilesList of memory mapped files; TSeqCollection*fMessageHandlersList of message handlers; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustCleanTrue if object destructor scans canvases; TStringTNamed::fNameobject identifier; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TPluginManager*fPluginManagerKeeps track of plugin library handlers; const TObject*fPrimitiveCurrently selected primitive; TSeqCollection*fProofsList of proof sessions; Bool_tfReadingObjectTrue while reading an object [Deprecated (will be removed in next release); TFolder*fRootFoldertop level folder //root; TSeqCollection*fSecContextsList of security contexts (TSecContext); TVirtualPad*fSelectPadCurrently selected pad; TSeqCollection*fSocketsList of network sockets; TSeqCollection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; TSeqCollection*fTasksList of tasks; Int_tfTimerTimer flag; TStringTNamed::fTitleobject title; TCollection*fTypesList of data types definition; TUUIDTDirectory::fUUIDUnique identifier; TProcessUUID*fUUIDsPointer to TProcessID managing TUUIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:20068,secur,security,20068,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,2,['secur'],['security']
Security,"cs code. ; Definition at line 32 of file TColorGradient.h. Classes; struct  Point;  . Public Types; enum  ECoordinateMode { kPadMode; , kObjectBoundingMode; };  ; typedef std::vector< Color_t >::size_type SizeType_t;  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TColorGradient ();  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Color_t *colorIndices, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ;  TColorGradient (Color_t newColor, UInt_t nPoints, const Double_t *points, const Double_t *colors, ECoordinateMode mode=kObjectBoundingMode);  There is no way to validate parameters here, so it's up to user to pass correct arguments. ;  ; Double_t GetColorAlpha (UInt_t indx) const;  Return alpha parameter of selected color. ;  ; const Double_t * GetColorPositions () const;  Get color positions. ;  ; const Double_t * GetColors () const;  Get colors. ;  ; ECoordinateMode GetCoordinateMode () const;  Get coordinate mode. ;  ; SizeType_t GetNumberOfSteps () const;  Get number of steps. ;  ; TClass * IsA () const override;  ; void ResetColor (UInt_t nPoints, const Double_t *points, const Color_t *colorIndices);  Reset color. ;  ; void ResetColor (UInt_t nPoints, const Double_t *points, const Double_t *colorIndices);  Reset color. ;  ; void SetC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColorGradient.html:1928,validat,validate,1928,doc/master/classTColorGradient.html,https://root.cern,https://root.cern/doc/master/classTColorGradient.html,1,['validat'],['validate']
Security,"ct * ; obj, . bool ;  . ). overridevirtual . Overload TDirectory interface method to prohibit insertion of objects in read-only directory workspace representation. ; Reimplemented from TDirectoryFile.; Definition at line 2895 of file RooWorkspace.cxx. ◆ Class(). static TClass * RooWorkspace::WSDir::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooWorkspace::WSDir::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooWorkspace::WSDir::Class_Version ; (; ). inlinestaticconstexpr . do not persist ; ReturnsVersion of this class ; Definition at line 240 of file RooWorkspace.h. ◆ DeclFileName(). static const char * RooWorkspace::WSDir::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 240 of file RooWorkspace.h. ◆ InternalAppend(). void RooWorkspace::WSDir::InternalAppend ; (; TObject * ; obj). protected . Internal access to TDirectory append method. ; Definition at line 2873 of file RooWorkspace.cxx. ◆ IsA(). TClass * RooWorkspace::WSDir::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TDirectoryFile.; Definition at line 240 of file RooWorkspace.h. ◆ Streamer(). void RooWorkspace::WSDir::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TDirectoryFile. ◆ StreamerNVirtual(). void RooWorkspace::WSDir::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 240 of file RooWorkspace.h. Friends And Related Symbol Documentation. ◆ RooWorkspace. friend class RooWorkspace. friend . Definition at line 236 of file RooWorkspace.h. Member Data Documentation. ◆ _wspace. RooWorkspace* RooWorkspace::WSDir::_wspace. protected . Definition at line 238 of file RooWorkspace.h. Libraries for RooWorkspace::WSDir:. [legend]; The documentation for this class was generated from the following files:; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace_1_1WSDir.html:25629,access,access,25629,doc/master/classRooWorkspace_1_1WSDir.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace_1_1WSDir.html,1,['access'],['access']
Security,"ct ; Reimplemented from THashList.; Definition at line 87 of file TListOfFunctionTemplates.h. ◆ Load(). void TListOfFunctionTemplates::Load ; (; ). Load all the functions known to the interpreter for the scope 'fClass' into this collection. ; Definition at line 356 of file TListOfFunctionTemplates.cxx. ◆ MapObject(). void TListOfFunctionTemplates::MapObject ; (; TObject * ; obj). private . Add pair<id, object> to the map of functions and their ids. ; Definition at line 53 of file TListOfFunctionTemplates.cxx. ◆ operator=(). TListOfFunctionTemplates & TListOfFunctionTemplates::operator= ; (; const TListOfFunctionTemplates & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfFunctionTemplates::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from THashList.; Definition at line 310 of file TListOfFunctionTemplates.cxx. ◆ Remove() [1/2]. TObject * TListOfFunctionTemplates::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Reimplemented from THashList.; Definition at line 323 of file TListOfFunctionTemplates.cxx. ◆ Remove() [2/2]. TObject * TListOfFunctionTemplates::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from THashList.; Definition at line 339 of file TListOfFunctionTemplates.cxx. ◆ Streamer(). void TListOfFunctionTemplates::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from THashList. ◆ StreamerNVirtual(). void TListOfFunctionTemplates::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:30722,hash,hash,30722,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,2,['hash'],['hash']
Security,"ct before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLast() const. Int_t IndexOf(const TObject* obj) const. Int_t GetSize() const. TListOfEnumsWithLock(const TListOfEnumsWithLock& ). TListOfEnumsWithLock& operator=(const TListOfEnumsWithLock& ). » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-02 16:15; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfEnumsWithLock.html:13535,hash,hash,13535,root/html604/TListOfEnumsWithLock.html,https://root.cern,https://root.cern/root/html604/TListOfEnumsWithLock.html,2,['hash'],['hash']
Security,"ct before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLast() const. Int_t IndexOf(const TObject* obj) const. Int_t GetSize() const. TListOfEnumsWithLock(const TListOfEnumsWithLock& ). TListOfEnumsWithLock& operator=(const TListOfEnumsWithLock& ). » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-30 15:14; This page ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnumsWithLock.html:13476,hash,hash,13476,root/html602/TListOfEnumsWithLock.html,https://root.cern,https://root.cern/root/html602/TListOfEnumsWithLock.html,2,['hash'],['hash']
Security,"ct of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TSecContext;  TSecContext (const char *url, Int_t meth, Int_t offset, const char *id, const char *token, TDatime expdate=kROOTTZERO, void *ctx=nullptr);  Ctor for SecContext object. ;  ;  TSecContext (const char *user, const char *host, Int_t meth, Int_t offset, const char *id, const char *token, TDatime expdate=kROOTTZERO, void *ctx=nullptr);  Ctor for SecContext object. ;  ; virtual ~TSecContext ();  Dtor: delete (deActivate, local/remote cleanup, list removal) all what is still active. ;  ; void AddForCleanup (Int_t port, Int_t proto, Int_t type);  Create a new TSecContextCleanup Internally is added to the list. ;  ; void * GetContext () const;  ; TDatime GetExpDate () const;  ; const char * GetHost () const;  ; const char * GetID () const;  ; Int_t GetMethod () const;  ; const char * GetMethodName () const;  ; Int_t GetOffSet () const;  ; TList * GetSecContextCleanup () const;  ; const char * GetToken () const;  ; const char * GetUser () const;  ; TClass * IsA () const override;  ; Bool_t IsA (const char *methodname);  Checks if this security context is for method named 'methname' Case sensitive. ;  ; Bool_t IsActive () const;  Check remote OffSet and expiring Date. ;  ; void Print (Option_t *option=""F"") const override;  If opt is ""F"" (default) print object content. ;  ; void SetExpDate (TDatime expdate);  ; void SetID (const char *id);  ; void SetOffSet (Int_t offset);  ; void SetUser (const char *user);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSecContext.html:2680,secur,security,2680,doc/master/classTRootSecContext.html,https://root.cern,https://root.cern/doc/master/classTRootSecContext.html,1,['secur'],['security']
Security,"ct { Int_t fMyInt1; Int_t fMyInt2; Int_t fMyInt3; Char_t fMyCode[4]; };"" );. from ROOT import MyStruct; mystruct = MyStruct(); f = TFile('mytree.root','RECREATE'); tree = TTree('T','Just A Tree'); tree.Branch('myints',mystruct,'MyInt1/I:MyInt2:MyInt3'); tree.Branch('mycode',AddressOf(mystruct,'fMyCode'),'MyCode/C'); for i in range(0,10):; mystruct.fMyInt1 = i; mystruct.fMyInt2 = i*i; mystruct.fMyInt3 = i*i*i; mystruct.fMyCode = ""%03d"" % i # note string assignment. tree.Fill(). f.Write(); f.Close(); The C++ class is defined through the gROOT.ProcessLine() call, and note how the AddressOf() function is used for data members of built-in type. Most of the above is for ROOT version 5.02 and later only. For older releases, and without further support, here is an example as to how you can get hold of a pointer-to-pointer to a ROOT object:; h = TH1F(); addressofobject = array('i',[h.IsA().DynamicCast(h.IsA(),h)]); 19.1.10 Using Your Own Classes; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1072619,access,accessed,1072619,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessed']
Security,"ct(void *what, size_t size) {; 354 PValue_t m = PValue_t(what);; 355 for (size_t i=0; i < size; ++i, ++m ); 356 m->~Value_t();; 357 }; 358 ; 359 static const bool fgLargeIterator = sizeof(typename Cont_t::iterator) > fgIteratorArenaSize;; 360 typedef Iterators<Cont_t,fgLargeIterator> Iterators_t;; 361 ; 362 };; 363 ; 364 /** @class ROOT::Detail::TCollectionProxyInfo::Pushback; 365 *; 366 * Small helper to encapsulate all necessary data accesses for; 367 * containers like vector, list, deque; 368 *; 369 * @author M.Frank; 370 * @version 1.0; 371 * @date 10/10/2004; 372 */; 373 template <class T> struct Pushback : public Type<T> {; 374 typedef T Cont_t;; 375 typedef typename T::iterator Iter_t;; 376 typedef typename T::value_type Value_t;; 377 typedef Environ<Iter_t> Env_t;; 378 typedef Env_t *PEnv_t;; 379 typedef Cont_t *PCont_t;; 380 typedef Value_t *PValue_t;; 381 static void resize(void* obj, size_t n) {; 382 PCont_t c = PCont_t(obj);; 383 c->resize(n);; 384 }; 385 static void* feed(void *from, void *to, size_t size) {; 386 PCont_t c = PCont_t(to);; 387 PValue_t m = PValue_t(from);; 388 for (size_t i=0; i<size; ++i, ++m); 389 c->push_back(*m);; 390 return nullptr;; 391 }; 392 static int value_offset() {; 393 return 0;; 394 }; 395 };; 396 ; 397 /** @class ROOT::Detail::TCollectionProxyInfo::Pushfront; 398 *; 399 * Small helper to encapsulate all necessary data accesses for; 400 * containers like forward_list; 401 *; 402 * @author D.Piparo; 403 * @version 1.0; 404 * @date 26/02/2015; 405 */; 406 template <class T> struct Pushfront : public Type<T> {; 407 typedef T Cont_t;; 408 typedef typename T::iterator Iter_t;; 409 typedef typename T::value_type Value_t;; 410 typedef Environ<Iter_t> Env_t;; 411 typedef Env_t *PEnv_t;; 412 typedef Cont_t *PCont_t;; 413 typedef Value_t *PValue_t;; 414 static void resize(void* obj, size_t n) {; 415 PCont_t c = PCont_t(obj);; 416 c->resize(n);; 417 }; 418 static void* feed(void *from, void *to, size_t size) {; 419 PCont_t c = PCont_t(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:13164,access,accesses,13164,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['access'],['accesses']
Security,"ct::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidTHttpEngine::Process(); voidTHttpEngine::SetServer(THttpServer* serv). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. void*fCallbacks! call-back table for civetweb webserver; void*fCtx! civetweb context; Bool_tfDebug! debug mode; TStringTNamed::fNameobject identifier; THttpServer*THttpEngine::fServer! object server; TStringTNamed::fTitleobject title; TStringfTopName! name of top item. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TCivetweb(); constructor. ~TCivetweb(); destructor. Int_t ProcessLog(const char* message); process civetweb log message, can be used to detect critical errors. Bool_t Create(const char* args); Creates embedded civetweb server; As main argument, http port should be specified like ""8090"".; Or one can provide combination of ipaddress and portnumber like 127.0.0.1:8090; Extra parameters like in URL string could be specified after '?' mark:; thrds=N - there N is number of threads used by the civetweb (default is 5); top=name - configure top name, visible in the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain; loopback - bind specified port to loopback 127.0.0.1 address; debug - enable debug mode, server always returns html page with request info. TCivetweb(). const char * GetTopName() const. Bool_t IsDebugMode() const; indicates that. » Last changed: Mon Jun 29 16:38:47 2015 » Last generated: 2015-06-29 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCivetweb.html:7426,authenticat,authentication,7426,root/html534/TCivetweb.html,https://root.cern,https://root.cern/root/html534/TCivetweb.html,2,['authenticat'],['authentication']
Security,"ct::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); constructor. Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__FitterBase.html:8309,access,accessor,8309,root/html604/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html604/TMVA__FitterBase.html,1,['access'],['accessor']
Security,"ct::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); constructor. Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. FitterBase(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*> ranges, const TString& theOption); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__FitterBase.html:8301,access,accessor,8301,root/html602/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html602/TMVA__FitterBase.html,1,['access'],['accessor']
Security,"ct::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. static TVirtualMCApplication*fgInstancesingleton instance. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TVirtualMCApplication. Function documentation; TVirtualMCApplication(const char* name, const char* title). Standard constructor. TVirtualMCApplication(). Default constructor. ~TVirtualMCApplication(). Destructor. TVirtualMCApplication* Instance(). Static access method. void Field(const Double_t* x, Double_t* b) const; No magnetic field. TVirtualMCApplication(const char* name, const char* title); Standard constructor. void ConstructGeometry(). methods. Construct user geometry. Bool_t MisalignGeometry(); Misalign user geometry (optional). {return kFALSE;}. void ConstructOpGeometry(); Define parameters for optical processes (optional). {}. void InitGeometry(); Initialize geometry; (Usually used to define sensitive volumes IDs). void AddParticles(); Add user defined particles (optional). {}. void AddIons(); Add user defined ions (optional). {}. void GeneratePrimaries(); Generate primary particles. void BeginEvent(); Define actions at the beginning of the event. void BeginPrimary(); Define actions at the beginning of the primary track. void PreTrack(); Define actions at the beginning of each track. void Stepping(); Define action at each step. void PostTrack(); Define actions at the end of each track. void FinishPrimary(); Define actions at the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMCApplication.html:7430,access,access,7430,root/html602/TVirtualMCApplication.html,https://root.cern,https://root.cern/root/html602/TVirtualMCApplication.html,2,['access'],['access']
Security,"ct::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidAdd(TObject* arg, Int_t refCount); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidswapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLinkedList.html:6074,hash,hashing,6074,root/html528/RooLinkedList.html,https://root.cern,https://root.cern/root/html528/RooLinkedList.html,1,['hash'],['hashing']
Security,"ct::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidAdd(TObject* arg, Int_t refCount); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidswapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added.; if (htsize>0) {; cout << ""RooLinkedList::ctor htsize="" << htsize << endl ;; }. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given refer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooLinkedList.html:6143,hash,hashing,6143,root/html530/RooLinkedList.html,https://root.cern,https://root.cern/root/html530/RooLinkedList.html,1,['hash'],['hashing']
Security,"ct::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidAdd(TObject* arg, Int_t refCount); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidswapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize); Constructor with hashing threshold. If collection size exceeds threshold; a hash table is added. RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinkedList.html:6088,hash,hashing,6088,root/html526/RooLinkedList.html,https://root.cern,https://root.cern/root/html526/RooLinkedList.html,1,['hash'],['hashing']
Security,"ct::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. TXMLDocument*fTXMLDocxmlDoc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDOMParser(); TDOMParser constructor. ~TDOMParser(); TDOMParser destructor, it calls ReleaseUnderlying(). void ReleaseUnderlying(); Release any existing document. Int_t ParseFile(const char* filename); Parse the XML file where filename is the XML file name.; It will create a TXMLDocument if the file is parsed without; any error. It returns parse code error in case of parse error,; see TXMLParser. Int_t ParseBuffer(const char* buffer, Int_t len); It parses a buffer, much like ParseFile(). Int_t ParseContext(); Creates a XML docu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDOMParser.html:10615,validat,validate,10615,root/html602/TDOMParser.html,https://root.cern,https://root.cern/root/html602/TDOMParser.html,2,['validat'],['validate']
Security,"ct::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. _xmlSAXHandler*fSAXHandlerlibxml2 SAX handler. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TXMLParser. ←; TSAXParser. Function documentation; TSAXParser(); Create SAX parser. ~TSAXParser(); TSAXParser desctructor. void OnStartDocument(); Emit a signal for OnStartDocument. void OnEndDocument(); Emit a signal for OnEndDocument. void OnStartElement(const char* name, const TList* attr); Emit a signal for OnStarElement, where name is the Element's name and; attribute is a TList of (TObjString*, TObjString *) TPair's.; The TPair's key is the attribute's name and value is the attribute's; value. void OnEndElement(const char* name); Emit a s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSAXParser.html:11286,validat,validate,11286,root/html602/TSAXParser.html,https://root.cern,https://root.cern/root/html602/TSAXParser.html,2,['validat'],['validate']
Security,"ct::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static ROOT::TSchemaRule::RuleType_tkNone; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static ROOT::TSchemaRule::RuleType_tkReadRawRule; static ROOT::TSchemaRule::RuleType_tkReadRule; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. TStringfAttributesAttributes to be applied to the member (like Owner/NotOwner); TStringfChecksumSource checksum string; vector<UInt_t>*fChecksumVect! Source checksum vector (for searching purposes); TStringfCodeUser specified code snippet; Bool_tfEmbedValue determining if the rule should be embedded; TStringfIncludeIncludes string; TObjArray*fIncludeVect! Includes vector; ROOT::TSchemaRule::ReadFuncPtr_tfReadFuncPtr! Conversion function pointer for read rule; ROOT::TSchemaRule::ReadRawFuncPtr_tfReadRawFuncPtr! Conversion function pointer for readraw rule; ROOT::TSchemaRule::RuleType_tfRuleTypeType of the rule; TStringfSourceSource data member string; TStringfSourceClassSource class; TObjArray*fSourceVect! Source data member vector (for searching purposes); TStringfTargetTarget data mamber string; TStringfTargetClassTarget class, this is the owner of this rule object.; TObjArray*fTargetVect! Target data member vector (for searching purposes); TStringfVersionSource version string; vector<pair<Int_t,Int_t> >*fVersionVect! Source version vector (for searching purposes). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRule(). virtual ~TSchemaRule(). TSchemaRule(const ROOT::TSchemaRule& rhs). void Clear(Option_t* = """"). Bool_t SetFromRule(const char* rule). const char * GetVersion() const. Bool_t SetVersion(const TString& version). Bool_t TestVersion(Int_t version) const. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TSchemaRule.html:7729,checksum,checksum,7729,root/html602/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html602/ROOT__TSchemaRule.html,4,['checksum'],['checksum']
Security,"cted:. RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list; Bool_t_useNptr!. private:. static RooLinkedList::Pool*_pool!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0). RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedListElem* createElement(TObject* obj, RooLinkedListElem* elem = 0); cout << ""RooLinkedList::createElem("" << this << "") obj = "" << obj << "" elem = "" << elem << endl ;. void deleteElement(RooLinkedListElem* ). RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing the given object. void Add(TObject* arg, Int_t refCount); Insert object into collection with given reference count value. Bool_t Remove(TObject* arg); Remove object from collection. TObject* At(Int_t index) const; Return object stored in sequential position given by index.; If index is out of range, a null pointer is returned. Bool_t Replace(const TObject* oldArg, const TObject* newArg); Replace object 'oldArg' in collection with new object 'newArg'.; If 'oldArg' is not found in collection kFALSE is returned. TObject* FindObject(const char* name) const; Return pointer to obejct with given name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLinkedList.html:7639,hash,hash,7639,root/html602/RooLinkedList.html,https://root.cern,https://root.cern/root/html602/RooLinkedList.html,2,['hash'],['hash']
Security,"cted:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; vector<double>_low; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html:34259,validat,validate,34259,root/html602/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__LinInterpVar.html,4,"['access', 'validat']","['access', 'validate']"
Security,"ction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. Int_t DeleteVariable(const char* name); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. void SaveContext(); Save the current CINT state. void SaveGlobalsContext(); Save the current CINT state of global objects. void UpdateListOfGlobals(); Update the list of pointers to global variables. This function; is called by TROOT::GetListOfGlobals(). void UpdateListOfGlobalFunctions(); Update the list of pointers to global functions. This function; is called by TROOT::GetListOfGlobalFunctions(). void UpdateListOfTypes(); Update the list of pointers to Datatype (typedef) definitions. This; function is called by TROOT::GetListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE); Set pointer to CINT's G__ClassInfo in TClass. Bool_t CheckClassInfo(const char* name, Bool_t autoload = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:23228,access,accessed,23228,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,1,['access'],['accessed']
Security,"ction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. void SaveContext(); Save the current CINT state. void SaveGlobalsContext(); Save the current CINT state of global objects. void UpdateListOfGlobals(); Update the list of pointers to global variables. This function; is called by TROOT::GetListOfGlobals(). void UpdateListOfGlobalFunctions(); Update the list of pointers to global functions. This function; is called by TROOT::GetListOfGlobalFunctions(). void UpdateListOfTypes(); Update the list of pointers to Datatype (typedef) definitions. This; function is called by TROOT::GetListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE); Set pointer to CINT's G__ClassInfo in TClass. Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE); Checks if a class with the specified name is defined in CINT.; Returns kFALSE is class is not defined. void CreateListOfBaseClasses(TClass* cl); Create list of pointers ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCint.html:22633,access,accessed,22633,root/html530/TCint.html,https://root.cern,https://root.cern/root/html530/TCint.html,2,['access'],['accessed']
Security,"ction documentation; TArchiveFile(const char* archive, const char* member, TFile* file); Specify the archive name and member name. The member can be a decimal; number which allows to access the n-th sub-file. This method is; normally only called via TFile. ~TArchiveFile(); Dtor. Long64_t GetMemberFilePosition() const; Return position in archive of current member. Int_t GetNumberOfMembers() const; Returns number of members in archive. Int_t SetMember(const char* member); Explicitely make the specified member the current member.; Returns -1 in case of error, 0 otherwise. Int_t SetMember(Int_t idx); Explicitely make the member with the specified index the current member.; Returns -1 in case of error, 0 otherwise. TArchiveFile * Open(const char* url, TFile* file); Return proper archive file handler depending on passed url.; The handler is loaded via the plugin manager and is triggered by; the extension of the archive file. In case no handler is found 0; is returned. The file argument is used to access the archive.; The archive should be specified as url with the member name as the; anchor, e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#tpc.root"",; where tpc.root is the file in the archive to be opened.; Alternatively the sub-file can be specified via its index number,; e.g. ""root://pcsalo.cern.ch/alice/event_1.zip#3"".; This function is normally only called via TFile::Open(). Bool_t ParseUrl(const char* url, TString& archive, TString& member, TString& type); Try to determine if url contains an anchor specifying an archive member.; Returns kFALSE in case of an error. TArchiveFile(const TArchiveFile& ). TArchiveFile& operator=(const TArchiveFile& ). TArchiveFile(); { }. Int_t OpenArchive(). Int_t SetCurrentMember(). TArchiveMember * GetMember() const; { return fCurMember; }. TObjArray * GetMembers() const; { return fMembers; }. const char * GetArchiveName() const; { return fArchiveName; }. const char * GetMemberName() const; { return fMemberName; }. Int_t GetMemberIndex() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TArchiveFile.html:7755,access,access,7755,root/html602/TArchiveFile.html,https://root.cern,https://root.cern/root/html602/TArchiveFile.html,2,['access'],['access']
Security,"ction.cxx:407; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::kInitHashTableCapacity@ kInitHashTableCapacityDefinition TCollection.h:159; TCollection::HashULong_t Hash() const overrideReturn hash value for this object.Definition TCollection.h:186; TCollection::SetCurrentCollectionvoid SetCurrentCollection()Set this collection to be the globally accessible collection.Definition TCollection.cxx:688; TCollection::GetCurrentCollectionstatic TCollection * GetCurrentCollection()Return the globally accessible collection.Definition TCollection.cxx:680; TCollection::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TCollection.cxx:574; TCollection::CapacityInt_t Capacity() constDefinition TCollection.h:167; TCollection::RemoveAllvoid RemoveAll()Definition TCollection.h:204; TCollection::UseRWLockvirtual bool UseRWLock(Bool_t enable=true)Set this collection to use a RW lock upon access, making it thread safe.Definition TCollection.cxx:761; TCollection::fgEmptyingGarbagestatic Bool_t fgEmptyingGarbageDefinition TCollection.h:136; TCollection::AssertClassBool_t AssertClass(TClass *cl) constMake sure all objects in this collection inherit from class cl.Definition TCollection.cxx:223; TCollection::fgGarbageStackstatic Int_t fgGarbageStackDefinition TCollection.h:137; TCollection::endTIter end() constDefinition TCollection.h:293; TCollection::lsvoid ls(Option_t *option="""") const overrideList (ls) all objects in this collection.Definition TCollection.cxx:382; TCollection::GrowByvirtual Int_t GrowBy(Int_t delta) constIncrease the collection's capacity by delta slots.Definition TCollection.cxx:360; TCollection::SetNamevoid SetName(const char *name)Definition TCollection.h:206; TCollection::beginTIter begin() constDefinition TCollection.h:292; TCollection::EStatusBitsEStatusBitsDefinition TCollection.h:143; TCollection::kUseRWLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8h_source.html:18800,access,access,18800,doc/master/TCollection_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8h_source.html,1,['access'],['access']
Security,"ction::kNoUsingDecls@ kNoUsingDecls; TDictionary::EMemberSelection::kOnlyUsingDecls@ kOnlyUsingDecls; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TDumpMembersDefinition TClass.cxx:554; TDumpMembers::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overridePrint value of member mname.Definition TClass.cxx:574; TDumpMembers::TDumpMembersTDumpMembers(bool noAddr)Definition TClass.cxx:557; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:555; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) overrideRemove object from the hashtable.Definition THashTable.cxx:417; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:349140,hash,hash,349140,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['hash'],['hash']
Security,"ction::kNoUsingDecls@ kNoUsingDecls; TDictionary::EMemberSelection::kOnlyUsingDecls@ kOnlyUsingDecls; TDictionary::DeclId_tconst void * DeclId_tDefinition TDictionary.h:224; TDumpMembersDefinition TClass.cxx:621; TDumpMembers::Inspectvoid Inspect(TClass *cl, const char *parent, const char *name, const void *addr, Bool_t isTransient) overridePrint value of member mname.Definition TClass.cxx:641; TDumpMembers::TDumpMembersTDumpMembers(bool noAddr)Definition TClass.cxx:624; TDumpMembers::fNoAddrbool fNoAddrDefinition TClass.cxx:622; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TExMapThis class stores a (key,value) pair using an external hash.Definition TExMap.h:33; TExMap::GetValueLong64_t GetValue(ULong64_t hash, Long64_t key)Return the value belonging to specified key and hash value.Definition TExMap.cxx:174; TExMap::AddAtvoid AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value)Add an (key,value) pair to the table.Definition TExMap.cxx:117; TFunctionTemplateDictionary for function template This class describes one single function template.Definition TFunctionTemplate.h:26; TFunctionGlobal functions class (global functions are obtained from CINT).Definition TFunction.h:30; TFunction::GetNargsInt_t GetNargs() constNumber of function arguments.Definition TFunction.cxx:174; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THashTable::Addvoid Add(TObject *obj) overrideAdd object to the hash table.Definition THashTable.cxx:92; THashTable::GetListForObjectconst TList * GetListForObject(const char *name) constReturn the TList corresponding to object's name based hash value.Definition THashTable.cxx:268; THashTable::RemoveTObject * Remove(TObject *obj) overrideRemove object from the hashtable.Definition THashTable.cxx:417; TInterpreter::SuspendAutoLoadingRAIIDefinition TInterpreter.h:120; TInterpret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:351778,hash,hash,351778,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['hash'],['hash']
Security,"ctionMinimizer * GetMinimizer () const;  ; int RunMinosError (unsigned int i, double &errLow, double &errUp, int runopt);  ; bool SetCovariance (std::span< const double > cov, unsigned int nrow) override;  set initial covariance matrix ;  ; virtual bool SetCovarianceDiag (std::span< const double > d2, unsigned int n) override;  set initial second derivatives ;  ; virtual void SetMinimizer (ROOT::Minuit2::ModularFunctionMinimizer *m);  ; void SetMinimizerType (ROOT::Minuit2::EMinimizerType type);  . Private Attributes; unsigned int fDim;  ; std::vector< double > fErrors;  ; ROOT::Minuit2::ModularFunctionMinimizer * fMinimizer;  ; ROOT::Minuit2::FunctionMinimum * fMinimum;  ; int fMinosStatus = -1;  ; ROOT::Minuit2::FCNBase * fMinuitFCN;  ; ROOT::Minuit2::MnUserParameterState fState;  ; bool fUseFumili;  ; std::vector< double > fValues;  . Additional Inherited Members;  Protected Attributes inherited from ROOT::Math::Minimizer; MinimizerOptions fOptions;  minimizer options ;  ; int fStatus = -1;  status of minimizer ;  ; bool fValidError = false;  flag to control if errors have been validated (Hesse has been run in case of Minuit) ;  . #include <Minuit2/Minuit2Minimizer.h>. Inheritance diagram for ROOT::Minuit2::Minuit2Minimizer:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Minuit2Minimizer() [1/2]. ROOT::Minuit2::Minuit2Minimizer::Minuit2Minimizer ; (; ROOT::Minuit2::EMinimizerType ; type = ROOT::Minuit2::kMigrad). Default constructor. ; Definition at line 86 of file Minuit2Minimizer.cxx. ◆ Minuit2Minimizer() [2/2]. ROOT::Minuit2::Minuit2Minimizer::Minuit2Minimizer ; (; const char * ; type). Constructor with a char (used by PM) ; Definition at line 93 of file Minuit2Minimizer.cxx. ◆ ~Minuit2Minimizer(). ROOT::Minuit2::Minuit2Minimizer::~Minuit2Minimizer ; (; ). override . Destructor (no operations) ; Definition at line 145 of file Minuit2Minimizer.cxx. Member Function Docume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:12229,validat,validated,12229,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,1,['validat'],['validated']
Security,"ctionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimiza",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:11827,access,accessors,11827,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,2,['access'],['accessors']
Security,"ctionary & operator= (const TDictionary &other);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQClass.html:24540,hash,hash,24540,doc/master/classTQClass.html,https://root.cern,https://root.cern/doc/master/classTQClass.html,1,['hash'],['hash']
Security,"ctionary & operator= (const TDictionary &other);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTEnum.html:4390,hash,hash,4390,doc/v632/classTEnum.html,https://root.cern,https://root.cern/doc/v632/classTEnum.html,8,['hash'],['hash']
Security,"ctionary generation of STL collection involving one of ROOT’s core classes when the user header contains only a forward declaration of the class [ROOT-7695]. Bugs. [ROOT-7680] - Can’t build v6-02-12 on MacOS X 10.11; [ROOT-7695] - Segmentation violation in rootcint; [ROOT-7709] - PyROOT not functional with system-default Python version on MacOS X 10.11; [ROOT-7715] - Building ROOT with CMake not in my PATH fails. Release 6.04/08; Build. Add –disable-search-usrlocal to configure/make to be able to avoid conflict with incompatible installation (e.g. homebrew).; Add /opt/X11 to configure/make search for include files and libraries.; Updates PCRE to 8.37 (current upstream version) which can detect PPC64LE machine.; Fail cmake configuration if the specified CMAKE_BUILD_TYPE is unknown; Fix RPATH for MacOSX (El Capitan) to avoid building with -Drpath=ON. The default uses rpath=@loader_path/../lib. Core. Add missing protection when creating new StreamerInfo.; Add accessor functions and functionality needed by CMS event display.; Do not delete resource when replaceing default TApplication. Interpreter. Prevent crash in expressions which contain use undefined identifier ROOT-7737; Disable unnecessary code during dictionary generation that triggered problem due to the lack of support for template parameter packs ROOT-7708; Add suport in the type and name normalization routine for template parameter packs ROOT-7708. IO. For backward compatibility with ROOT5, allow to define IO constructors with the signature MyClass::MyClass(void&) where void is a forward declared type.; In TBuffer shrink buffers when requested. Histograms. Fix interval calculation in Divide for the Poisson ratio case. Minuit. Make function pointer held by TMinuitMinimize thread local. Patches Release 6.04/08; Bugs. [ROOT-7627] - [ICC][CMake][PATCH] Pass CC and CXX to builtin_lzma if Intel C++ Compiler (ICC) Is used; [ROOT-7629] - [CMake][PPC64LE][PATCH] Set correct ROOT architecture on PPC64LE – linuxppc64gcc;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:33111,access,accessor,33111,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['access'],['accessor']
Security,"ctions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TMVA::CvSplit; Bool_t fMakeFoldDataSet;  ; UInt_t fNumFolds;  ; std::vector< std::vector< TMVA::Event * > > fTestEvents;  ; std::vector< std::vector< TMVA::Event * > > fTrainEvents;  ;  Protected Attributes inherited from TMVA::Configurable; MsgLogger * fLogger;  ! message logger ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TMVA/CvSplit.h>. Inheritance diagram for TMVA::CvSplitKFolds:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ CvSplitKFolds(). TMVA::CvSplitKFolds::CvSplitKFolds ; (; UInt_t ; numFolds, . TString ; splitExpr = """", . Bool_t ; stratified = kTRUE, . UInt_t ; seed = 100 . ). Splits a dataset into k folds, ready for use in cross validation. ; Parameters. [in]numFoldsNumber of folds to split data into ; [in]stratifiedIf true, use stratified splitting, balancing the number of events across classes and folds. If false, no such balancing is done. For ; [in]splitExprExpression used to split data into folds. If """" a random assignment will be done. Otherwise the expression is fed into a TFormula and evaluated per event. The resulting value is the fold assignment. ; [in]seedUsed only when using random splitting (i.e. when splitExpr is """"). Seed is used to initialise the random number generator when assigning events to folds. . Definition at line 243 of file CvSplit.cxx. ◆ ~CvSplitKFolds(). TMVA::CvSplitKFolds::~CvSplitKFolds ; (; ). inlineoverride . Definition at line 98 of file CvSplit.h. Member Function Documentation. ◆ Class(). static TClass * TMVA::CvSplitKFolds::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::CvSplitKFolds::Class_Name ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CvSplitKFolds.html:15896,validat,validation,15896,doc/master/classTMVA_1_1CvSplitKFolds.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CvSplitKFolds.html,1,['validat'],['validation']
Security,"ctions |; Static Protected Member Functions |; Protected Attributes |; Static Protected Attributes |; List of all members ; TGSelectedPicture Class Reference. . Definition at line 67 of file TGPicture.h. Public Member Functions;  TGSelectedPicture (const TGClient *client, const TGPicture *p);  Create a ""selected"" looking picture based on the original TGPicture. ;  ;  ~TGSelectedPicture () override;  Delete selected picture. ;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGPicture;  ~TGPicture () override;  Delete picture object. ;  ; virtual void Draw (Handle_t id, GContext_t gc, Int_t x, Int_t y) const;  Draw a picture. ;  ; UInt_t GetHeight () const;  ; Pixmap_t GetMask () const;  ; const char * GetName () const override;  Returns name of object. ;  ; Pixmap_t GetPicture () const;  ; UInt_t GetWidth () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsScaled () const;  ; void Print (Option_t *option="""") const override;  Print picture info. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGSelectedPicture.html:1269,hash,hash,1269,doc/master/classTGSelectedPicture.html,https://root.cern,https://root.cern/doc/master/classTGSelectedPicture.html,1,['hash'],['hash']
Security,"ctor.; 1301///; 1302/// \note Use `TClass::GetClass(""class"")` to get access to a TClass object for a certain class!; 1303 ; 1304TClass::TClass(const char *name, Version_t cversion,; 1305 const std::type_info &info, TVirtualIsAProxy *isa,; 1306 const char *dfil, const char *ifil, Int_t dl, Int_t il,; 1307 Bool_t silent) :; 1308 TDictionary(name),; 1309 fPersistentRef(nullptr),; 1310 fStreamerInfo(nullptr), fConversionStreamerInfo(nullptr), fRealData(nullptr),; 1311 fBase(nullptr), fData(nullptr), fUsingData(nullptr), fEnums(nullptr), fFuncTemplate(nullptr), fMethod(nullptr), fAllPubData(nullptr),; 1312 fAllPubMethod(nullptr),; 1313 fClassMenuList(nullptr),; 1314 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1315 fInstanceCount(0), fOnHeap(0),; 1316 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1317 fTypeInfo(nullptr), fShowMembers(nullptr),; 1318 fStreamer(nullptr), fIsA(nullptr), fGlobalIsA(nullptr), fIsAMethod(nullptr),; 1319 fMerge(nullptr), fResetAfterMerge(nullptr), fNew(nullptr), fNewArray(nullptr), fDelete(nullptr), fDeleteArray(nullptr),; 1320 fDestructor(nullptr), fDirAutoAdd(nullptr), fStreamerFunc(nullptr), fConvStreamerFunc(nullptr), fSizeof(-1),; 1321 fCanSplit(-1), fIsSyntheticPair(kFALSE), fHasCustomStreamerMember(kFALSE), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),; 1322 fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),; 1323 fState(kHasTClassInit),; 1324 fCurrentInfo(nullptr), fLastReadInfo(nullptr), fRefProxy(nullptr),; 1325 fSchemaRules(nullptr), fStreamerImpl(&TClass::StreamerDefault); 1326{; 1327 R__LOCKGUARD(gInterpreterMutex);; 1328 // use info; 1329 Init(name, cversion, &info, isa, dfil, ifil, dl, il, nullptr, silent);; 1330}; 1331 ; 1332////////////////////////////////////////////////////////////////////////////////; 1333/// we found at least one equivalent.; 133",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:49995,access,access,49995,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['access']
Security,"ctor.; 1368///; 1369/// \note Use `TClass::GetClass(""class"")` to get access to a TClass object for a certain class!; 1370 ; 1371TClass::TClass(const char *name, Version_t cversion,; 1372 const std::type_info &info, TVirtualIsAProxy *isa,; 1373 const char *dfil, const char *ifil, Int_t dl, Int_t il,; 1374 Bool_t silent) :; 1375 TDictionary(name),; 1376 fPersistentRef(nullptr),; 1377 fStreamerInfo(nullptr), fConversionStreamerInfo(nullptr), fRealData(nullptr),; 1378 fBase(nullptr), fData(nullptr), fUsingData(nullptr), fEnums(nullptr), fFuncTemplate(nullptr), fMethod(nullptr), fAllPubData(nullptr),; 1379 fAllPubMethod(nullptr),; 1380 fClassMenuList(nullptr),; 1381 fDeclFileName(""""), fImplFileName(""""), fDeclFileLine(0), fImplFileLine(0),; 1382 fInstanceCount(0), fOnHeap(0),; 1383 fCheckSum(0), fCollectionProxy(nullptr), fClassVersion(0), fClassInfo(nullptr),; 1384 fTypeInfo(nullptr), fShowMembers(nullptr),; 1385 fStreamer(nullptr), fIsA(nullptr), fGlobalIsA(nullptr), fIsAMethod(nullptr),; 1386 fMerge(nullptr), fResetAfterMerge(nullptr), fNew(nullptr), fNewArray(nullptr), fDelete(nullptr), fDeleteArray(nullptr),; 1387 fDestructor(nullptr), fDirAutoAdd(nullptr), fStreamerFunc(nullptr), fConvStreamerFunc(nullptr), fSizeof(-1),; 1388 fCanSplit(-1), fIsSyntheticPair(kFALSE), fHasCustomStreamerMember(kFALSE), fProperty(0), fClassProperty(0), fHasRootPcmInfo(kFALSE), fCanLoadClassInfo(kFALSE),; 1389 fIsOffsetStreamerSet(kFALSE), fVersionUsed(kFALSE), fRuntimeProperties(0), fOffsetStreamer(0), fStreamerType(TClass::kDefault),; 1390 fState(kHasTClassInit),; 1391 fCurrentInfo(nullptr), fLastReadInfo(nullptr), fRefProxy(nullptr),; 1392 fSchemaRules(nullptr), fStreamerImpl(&TClass::StreamerDefault); 1393{; 1394 R__LOCKGUARD(gInterpreterMutex);; 1395 // use info; 1396 Init(name, cversion, &info, isa, dfil, ifil, dl, il, nullptr, silent);; 1397}; 1398 ; 1399////////////////////////////////////////////////////////////////////////////////; 1400/// we found at least one equivalent.; 140",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:52746,access,access,52746,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['access']
Security,"ctor.h:31; TVector3Definition TVector3.h:22; v2@ v2Definition rootcling_impl.cxx:3702; v4@ v4Definition rootcling_impl.cxx:3704; v3@ v3Definition rootcling_impl.cxx:3703; v1@ v1Definition rootcling_impl.cxx:3701; For backward compatibility there are two constructors from an Double_t and Float_t C array. Access to the components; There are two sets of access functions to the components of a LorentzVector: X(), Y(), Z(), T() and Px(), Py(), Pz() and E(). Both sets return the same values but the first set is more relevant for use where TLorentzVector describes a combination of position and time and the second set is more relevant where TLorentzVector describes momentum and energy:; Double_t xx =v.X();; ...; Double_t tt = v.T();; ; Double_t px = v.Px();; ...; Double_t ee = v.E();; double; v@ vDefinition rootcling_impl.cxx:3699; ttauto * ttDefinition textangle.C:16; The components of TLorentzVector can also accessed by index:; xx = v(0); or xx = v[0];; yy = v(1); yy = v[1];; zz = v(2); zz = v[2];; tt = v(3); tt = v[3];; You can use the Vect() member function to get the vector component of TLorentzVector:; TVector3 p = v.Vect();; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; For setting components also two sets of member functions can be used:; v.SetX(1.); or v.SetPx(1.);; ... ...; v.SetT(1.); v.SetE(1.);; To set more the one component by one call you can use the SetVect() function for the TVector3 part or SetXYZT(), SetPxPyPzE(). For convenience there is; also a SetXYZM():; v.SetVect(TVector3(1,2,3));; v.SetXYZT(x,y,z,t);; v.SetPxPyPzE(px,py,pz,e);; v.SetXYZM(x,y,z,m); // -> v=(x,y,z,e=Sqrt(x*x+y*y+z*z+m*m)); e#define e(i)Definition RSha256.hxx:103; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; mTMarker mDefinition textangle.C:8. Vector components in non-cartesian coordinate systems; There are a couple of member functions to get and set the TVector3 part of the parameters in spherical coordinate syste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLorentzVector.html:2717,access,accessed,2717,doc/master/classTLorentzVector.html,https://root.cern,https://root.cern/doc/master/classTLorentzVector.html,1,['access'],['accessed']
Security,"ctor<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:12777,access,access,12777,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,8,['access'],"['access', 'accessors']"
Security,"ctor<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar ee). bool operator==(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >& rhs) const. Scalar Px() const; ------ Individual element access, in various coordinate systems ------; individual coordinate accessors in various coordinate systems. spatial X component. { return fCoordinates.Px(); }. Scalar X() const. spatial Y component. { return fCoordinates.Px(); }. Scalar Py() const; { return fCoordinates.Py(); }. Scalar Y() const. spatial Z component. { return fCoordinates.Py(); }. Scalar Pz() const; { return fCoordinates.Pz(); }. Scalar Z() const. return 4-th component (time, or energy for a 4-momentum vector). { return fCoordinates.Pz(); }. Scalar E() const; { return fCoordinates.E(); }. Scalar T() const. return magnitude (mass) squared M2 = T**2 - X**2 - Y**2 - Z**2; (we use -,-,-,+ metric). { return fCoordinates.E(); }. Scalar M2() const. return magnitude (mass) using the (-,-,-,+) metric.; If M2 is negative (space-like vector) a GenVector_exception; is suggested and if continuing, - sqrt( -M2) is returned. { return fCoordinates.M2(); }. Scalar M() const. return the spatial (3D) magnitude ( sqrt(X**2 + Y**2 + Z**2) ). { return fCoordinates.M();}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:12777,access,access,12777,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,8,['access'],"['access', 'accessors']"
Security,"ctory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. int GetFsInfo(const char* path, Long_t* id, Long_t* bsize, Long_t* blocks, Long_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:24878,access,access,24878,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,6,['access'],['access']
Security,"ctrum2Fit Spectrum2 Fitter using algorithm without matrix inversion and conjugate gradient method for symmetrical matrices (Stiefel-Hestens method); TSpectrum2Painter TSpectrum 3d graphics package; TSpectrum2Transform Spectrum2 Transformer, it calculates classic orthogonal 2D transforms; TSpectrum3 Peak Finder, Background estimator, Markov smoothing and Deconvolution for 3-D histograms; TSpectrumFit Spectrum Fitter using algorithm without matrix inversion and conjugate gradient method for symmetrical matrices (Stiefel-Hestens method); TSpectrumTransform Spectrum Transformer, it calculates classic orthogonal 1D transforms; TSpider Helper class to draw spider; TSpiderEditor GUI for editing the spider plot attributes.; TSpline Spline base class; TSpline3 Class to create third natural splines; TSpline5 Class to create quintic natural splines; TSplinePoly Spline polynomial terms; TSplinePoly3 Third spline polynomial terms; TSplinePoly5 Quintic spline polynomial terms; TStatistic Named statistical variable; TStatsFeedback Present PROOF query feedback; TStatus Status class; TStdExceptionHandler C++ exception handler; TStopwatch A stopwatch which times real and cpu time; TStorage Storage manager class; TStreamerArtificial StreamerElement injected by a TSchemaRule. Transient only to preverse forward compatibility.; TStreamerBase Streamer element of type base class; TStreamerBasicPointer Streamer element for a pointer to a basic type; TStreamerBasicType Streamer element for a basic type; TStreamerElement Base class for one element (data member) to be Streamed; TStreamerInfo Streamer information for one class version; TStreamerInfoActions ; TStreamerInfoActions::TActionSequence ; TStreamerInfoActions::TConfiguration ; TStreamerInfoActions::TConfiguredAction A configured action; TStreamerLoop Streamer element for a pointer to an array of objects; TStreamerObject Streamer element of type object; TStreamerObjectAny Streamer element of type object other than TObject; TStreamerObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:133342,inject,injected,133342,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,3,['inject'],['injected']
Security,"cts from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t h). void WriteUShort(UShort_t h). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t ll). void WriteULong64(ULong64_t ll). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& h). void ReadUShort(UShort_t& h). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& ll). void ReadLong64(Long64_t& ll). void ReadULong64(ULong64_t& ll). void ReadFloat(Float_t& f). void ReadDouble(Double_t& d). void ReadCharP(Char_t* c). Int_t ReadArray(UChar_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBufferFile.html:46982,hash,hashsize,46982,root/html528/TBufferFile.html,https://root.cern,https://root.cern/root/html528/TBufferFile.html,4,['hash'],['hashsize']
Security,"cts from the buffer using the StreamerInfoLoopAction. void SetGlobalReadParam(Int_t mapsize); Set the initial size of the map used to store object and class; references during reading. The default size is kMapSize=503.; Increasing the default has the benefit that when reading many; small objects the array does not need to be resized too often; (the system is always dynamic, even with the default everything; will work, only the initial resizing will cost some time).; Per TBuffer object this option can be changed using SetReadParam(). void SetGlobalWriteParam(Int_t mapsize); Set the initial size of the hashtable used to store object and class; references during writing. The default size is kMapSize=503.; Increasing the default has the benefit that when writing many; small objects the hashtable does not get too many collisions; (the system is always dynamic, even with the default everything; will work, only a large number of collisions will cost performance).; For optimal performance hashsize should always be a prime.; Per TBuffer object this option can be changed using SetWriteParam(). Int_t GetGlobalReadParam(); Get default read map size. Int_t GetGlobalWriteParam(); Get default write map size. void WriteBool(Bool_t b). void WriteChar(Char_t c). void WriteUChar(UChar_t c). void WriteShort(Short_t s). void WriteUShort(UShort_t s). void WriteInt(Int_t i). void WriteUInt(UInt_t i). void WriteLong(Long_t l). void WriteULong(ULong_t l). void WriteLong64(Long64_t l). void WriteULong64(ULong64_t l). void WriteFloat(Float_t f). void WriteDouble(Double_t d). void WriteCharP(const Char_t* c). void ReadBool(Bool_t& b). void ReadChar(Char_t& c). void ReadUChar(UChar_t& c). void ReadShort(Short_t& s). void ReadUShort(UShort_t& s). void ReadInt(Int_t& i). void ReadUInt(UInt_t& i). void ReadULong(ULong_t& l). void ReadLong64(Long64_t& l). void ReadULong64(ULong64_t& l). void ReadFloat(Float_t& f). void ReadDouble(Double_t& d). void ReadCharP(Char_t* c). Int_t ReadArray(UChar_t*& c)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBufferFile.html:49793,hash,hashsize,49793,root/html602/TBufferFile.html,https://root.cern,https://root.cern/root/html602/TBufferFile.html,2,['hash'],['hashsize']
Security,"cts in the TObjectTable. ;  . Protected Member Functions; TString AccessHeader (TString &buf, const char *name, const char *value=nullptr, Bool_t doing_set=kFALSE);  method used to get or set http header in the string buffer ;  ; TString CountHeader (const TString &buf, Int_t number=-1111) const;  method used to counter number of headers or returns name of specified header ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::condition_variable fCond;  ! condition used to wait for processing ;  ; TString fContentType;  ! type of content ;  ; TString fFileName;  ! file name ;  ; TString fHeader;  ! response header like ContentEncoding, Cache-Control and so on ;  ; TString fMethod;  ! request method like GET or POST ;  ; Bool_t fNotifyFlag {kFALSE};  ! indicate that notification called ;  ; TString fPathName;  ! item path ;  ; TString fQuery;  ! additional arguments ;  ; TString fRequestHeader;  ! complete header, provided with request ;  ; TString fTopName;  ! top item name ;  ; TString fUserName;  ! authenticated user name (if any) ;  ; UInt_t fWSId {0};  ! websocket identifier, used in web-socket related operations ;  ; Int_t fZipping {kNoZip};  ! indicate if and when content should be compressed ;  . Private Member Functions; void AssignWSId ();  Assign websocket identifier from the engine. ;  ; std::shared_ptr< THttpWSEngine > TakeWSEngine ();  Takeout websocket handle with HTTP call. ;  . Private Attributes; std::string fContent;  ! content - text or binary ;  ; std::string fPostData;  ! data received with post request - text - or binary ;  ; std::shared_ptr< THttpWSEngine > fWSEngine;  ! web-socket engine, which supplied to run created web socket ;  . Friends; class THttpServer;  ; class THttpWSEngine;  ; class THttpWSHandler;  . Additional Inherited Members;  Protected Types ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpCallArg.html:16174,authenticat,authenticated,16174,doc/master/classTHttpCallArg.html,https://root.cern,https://root.cern/doc/master/classTHttpCallArg.html,1,['authenticat'],['authenticated']
Security,"cts unless the THashList is the owner (set via SetOwner()). ; Reimplemented from THashList.; Definition at line 160 of file TListOfDataMembers.cxx. ◆ DeclFileName(). static const char * TListOfDataMembers::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 102 of file TListOfDataMembers.h. ◆ Delete(). void TListOfDataMembers::Delete ; (; Option_t * ; option = """"). overridevirtual . Delete all TDataMember object files. ; Reimplemented from THashList.; Definition at line 171 of file TListOfDataMembers.cxx. ◆ Find(). TDictionary * TListOfDataMembers::Find ; (; DeclId_t ; id); const. Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ; Definition at line 205 of file TListOfDataMembers.cxx. ◆ FindObject() [1/3]. TObject * THashList::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from THashList.; Definition at line 51 of file THashList.cxx. ◆ FindObject() [2/3]. TObject * TListOfDataMembers::FindObject ; (; const char * ; name); const. overridevirtual . Specialize FindObject to do search for the a data member just by name or create it if its not already in the list. ; Reimplemented from THashList.; Definition at line 182 of file TListOfDataMembers.cxx. ◆ FindObject() [3/3]. TObject * THashList::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from THashList.; Definition at line 52 of file THashList.cxx. ◆ Get() [1/2]. TDictionary * TListOfDataMembers::Get ; (; DataMemberInfo_t * ; info, . bool ; skipChecks = kFALSE . ). Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ; The skipChecks flag controls the consistency checks performed inspecti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:28863,hash,hash,28863,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['hash'],['hash']
Security,"culation algorithm.; 6493 ; 6494Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6495{; 6496 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6497 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6498 }; 6499 return kFALSE;; 6500}; 6501 ; 6502////////////////////////////////////////////////////////////////////////////////; 6503/// Call GetCheckSum with validity check.; 6504 ; 6505UInt_t TClass::GetCheckSum(ECheckSum code) const; 6506{; 6507 bool isvalid;; 6508 return GetCheckSum(code,isvalid);; 6509}; 6510 ; 6511////////////////////////////////////////////////////////////////////////////////; 6512/// Return GetCheckSum(kCurrentCheckSum,isvalid);; 6513 ; 6514UInt_t TClass::GetCheckSum(Bool_t &isvalid) const; 6515{; 6516 return GetCheckSum(kCurrentCheckSum,isvalid);; 6517}; 6518 ; 6519////////////////////////////////////////////////////////////////////////////////; 6520/// Compute and/or return the class check sum.; 6521///; 6522/// isvalid is set to false, if the function is unable to calculate the; 6523/// checksum.; 6524///; 6525/// The class ckecksum is used by the automatic schema evolution algorithm; 6526/// to uniquely identify a class version.; 6527/// The check sum is built from the names/types of base classes and; 6528/// data members.; 6529/// Original algorithm from Victor Perevovchikov (perev@bnl.gov).; 6530///; 6531/// The valid range of code is determined by ECheckSum.; 6532///; 6533/// - kNoEnum: data members of type enum are not counted in the checksum; 6534/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6535/// - kWithTypeDef: use the sugared type name in the calculation.; 6536///; 6537/// This is needed for backward compatibility.; 6538///; 6539/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6540/// They are both used to handle backward compatibility and should both return the same values.; 6541/// TStreamerInfo us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:250182,checksum,checksum,250182,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"culation algorithm.; 6560 ; 6561Bool_t TClass::MatchLegacyCheckSum(UInt_t checksum) const; 6562{; 6563 for(UInt_t i = 1; i < kLatestCheckSum; ++i) {; 6564 if ( checksum == GetCheckSum( (ECheckSum) i ) ) return kTRUE;; 6565 }; 6566 return kFALSE;; 6567}; 6568 ; 6569////////////////////////////////////////////////////////////////////////////////; 6570/// Call GetCheckSum with validity check.; 6571 ; 6572UInt_t TClass::GetCheckSum(ECheckSum code) const; 6573{; 6574 bool isvalid;; 6575 return GetCheckSum(code,isvalid);; 6576}; 6577 ; 6578////////////////////////////////////////////////////////////////////////////////; 6579/// Return GetCheckSum(kCurrentCheckSum,isvalid);; 6580 ; 6581UInt_t TClass::GetCheckSum(Bool_t &isvalid) const; 6582{; 6583 return GetCheckSum(kCurrentCheckSum,isvalid);; 6584}; 6585 ; 6586////////////////////////////////////////////////////////////////////////////////; 6587/// Compute and/or return the class check sum.; 6588///; 6589/// isvalid is set to false, if the function is unable to calculate the; 6590/// checksum.; 6591///; 6592/// The class ckecksum is used by the automatic schema evolution algorithm; 6593/// to uniquely identify a class version.; 6594/// The check sum is built from the names/types of base classes and; 6595/// data members.; 6596/// Original algorithm from Victor Perevovchikov (perev@bnl.gov).; 6597///; 6598/// The valid range of code is determined by ECheckSum.; 6599///; 6600/// - kNoEnum: data members of type enum are not counted in the checksum; 6601/// - kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; 6602/// - kWithTypeDef: use the sugared type name in the calculation.; 6603///; 6604/// This is needed for backward compatibility.; 6605///; 6606/// WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; 6607/// They are both used to handle backward compatibility and should both return the same values.; 6608/// TStreamerInfo us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:252933,checksum,checksum,252933,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"cumentation. ◆ TUnixSystem(). TUnixSystem::TUnixSystem ; (; ). Definition at line 575 of file TUnixSystem.cxx. ◆ ~TUnixSystem(). TUnixSystem::~TUnixSystem ; (; ). virtual . Reset to original state. ; Definition at line 581 of file TUnixSystem.cxx. Member Function Documentation. ◆ Abort(). void TUnixSystem::Abort ; (; int ; code = 0). overridevirtual . Abort the application. ; Reimplemented from TSystem.; Definition at line 2202 of file TUnixSystem.cxx. ◆ AcceptConnection(). int TUnixSystem::AcceptConnection ; (; int ; sock). overridevirtual . Accept a connection. ; In case of an error return -1. In case non-blocking I/O is enabled and no connections are available return -2. ; Reimplemented from TSystem.; Definition at line 3276 of file TUnixSystem.cxx. ◆ AccessPathName(). Bool_t TUnixSystem::AccessPathName ; (; const char * ; path, . EAccessMode ; mode = kFileExists . ). overridevirtual . Returns FALSE if one can access a file using the specified access mode. ; Mode is the same as for the Unix access(2) function. Attention, bizarre convention of return value!! ; Reimplemented from TSystem.; Definition at line 1579 of file TUnixSystem.cxx. ◆ AddDynamicPath(). void TUnixSystem::AddDynamicPath ; (; const char * ; lib). overridevirtual . Add a new directory to the dynamic path. ; Reimplemented from TSystem.; Definition at line 4725 of file TUnixSystem.cxx. ◆ AddFileHandler(). void TUnixSystem::AddFileHandler ; (; TFileHandler * ; h). overridevirtual . Add a file handler to the list of system file handlers. ; Only adds the handler if it is not already in the list of file handlers. ; Reimplemented from TSystem.; Definition at line 782 of file TUnixSystem.cxx. ◆ AddSignalHandler(). void TUnixSystem::AddSignalHandler ; (; TSignalHandler * ; h). overridevirtual . Add a signal handler to list of system signal handlers. ; Only adds the handler if it is not already in the list of signal handlers. ; Reimplemented from TSystem.; Definition at line 837 of file TUnixSystem.cxx. ◆ Ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:38832,access,access,38832,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['access'],['access']
Security,"current (last indexed) entry ;  ; virtual double Weight (Int_t i) const;  get the weight of entry at position i ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MarkovChain.html:4550,hash,hash,4550,doc/master/classRooStats_1_1MarkovChain.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MarkovChain.html,1,['hash'],['hash']
Security,"current directory to its previous state. ; Definition at line 143 of file TDirectory.cxx. Member Function Documentation. ◆ CdNull(). void TDirectory::TContext::CdNull ; (; ). private . Set the current directory to null. ; This is called from the TContext destructor. Since the destructor is inline, we do not want to have it directly use a global variable. ; Definition at line 133 of file TDirectory.cxx. ◆ operator=(). TContext & TDirectory::TContext::operator= ; (; TContext & ; ). privatedelete . ◆ RegisterCurrentDirectory(). void TDirectory::TContext::RegisterCurrentDirectory ; (; ). private . Definition at line 1344 of file TDirectory.cxx. Friends And Related Symbol Documentation. ◆ TDirectory. friend class TDirectory. friend . Definition at line 101 of file TDirectory.h. Member Data Documentation. ◆ fActiveDestructor. std::atomic<bool> TDirectory::TContext::fActiveDestructor {false}. private . Pointer to the previous current directory. ; Definition at line 92 of file TDirectory.h. ◆ fDirectory. std::atomic<TDirectory*> TDirectory::TContext::fDirectory {nullptr}. private . Definition at line 91 of file TDirectory.h. ◆ fDirectoryWait. std::atomic<bool> TDirectory::TContext::fDirectoryWait {false}. private . Set to true during the destructor execution. ; Definition at line 93 of file TDirectory.h. ◆ fNext. TContext* TDirectory::TContext::fNext {nullptr}. private . Pointer to the next TContext in the implied list of context pointing to fPrevious. ; Definition at line 95 of file TDirectory.h. ◆ fPrevious. TContext* TDirectory::TContext::fPrevious {nullptr}. private . Set to true if a TDirectory might still access this object. ; Definition at line 94 of file TDirectory.h. Libraries for TDirectory::TContext:. [legend]; The documentation for this class was generated from the following files:; core/base/inc/TDirectory.h; core/base/src/TDirectory.cxx. TDirectoryTContext. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectory_1_1TContext.html:6005,access,access,6005,doc/master/classTDirectory_1_1TContext.html,https://root.cern,https://root.cern/doc/master/classTDirectory_1_1TContext.html,1,['access'],['access']
Security,"cxx. ◆ AddOverlap() [1/2]. void TGeoParallelWorld::AddOverlap ; (; const char * ; volname, . Bool_t ; activate = kTRUE . ). To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world. ; Better be done before misalignment ; Definition at line 120 of file TGeoParallelWorld.cxx. ◆ AddOverlap() [2/2]. void TGeoParallelWorld::AddOverlap ; (; TGeoVolume * ; vol, . Bool_t ; activate = kTRUE . ). To use this optimization, the user should declare the full list of volumes which may overlap with any of the physical nodes of the parallel world. ; Better be done before misalignment ; Definition at line 108 of file TGeoParallelWorld.cxx. ◆ BuildBVH(). void TGeoParallelWorld::BuildBVH ; (; ). Build the BVH acceleration structure. ; Definition at line 1315 of file TGeoParallelWorld.cxx. ◆ CheckBVH(). bool TGeoParallelWorld::CheckBVH ; (; void * ; bvh, . size_t ; expected_leaf_count . ); const. Check/validate the BVH acceleration structure. ; Definition at line 1261 of file TGeoParallelWorld.cxx. ◆ CheckOverlaps(). void TGeoParallelWorld::CheckOverlaps ; (; Double_t ; ovlp = 0.001). Check overlaps within a tolerance value. ; Definition at line 1245 of file TGeoParallelWorld.cxx. ◆ Class(). static TClass * TGeoParallelWorld::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGeoParallelWorld::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGeoParallelWorld::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 184 of file TGeoParallelWorld.h. ◆ CloseGeometry(). Bool_t TGeoParallelWorld::CloseGeometry ; (; ). The main geometry must be closed. ; Definition at line 165 of file TGeoParallelWorld.cxx. ◆ DeclFileName(). static const char * TGeoParallelWorld::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoParallelWorld.html:19284,validat,validate,19284,doc/master/classTGeoParallelWorld.html,https://root.cern,https://root.cern/doc/master/classTGeoParallelWorld.html,1,['validat'],['validate']
Security,"cxx. ◆ FromGLBuffer(). void TASImage::FromGLBuffer ; (; UChar_t * ; buf, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Creates an image (screenshot) from a RGBA buffer. ; Reimplemented from TImage.; Definition at line 6690 of file TASImage.cxx. ◆ FromPad(). void TASImage::FromPad ; (; TVirtualPad * ; pad, . Int_t ; x = 0, . Int_t ; y = 0, . UInt_t ; w = 0, . UInt_t ; h = 0 . ). overridevirtual . Create an image from the given pad, afterwards this image can be saved in any of the supported image formats. ; Reimplemented from TImage.; Definition at line 1080 of file TASImage.cxx. ◆ FromWindow(). void TASImage::FromWindow ; (; Drawable_t ; wid, . Int_t ; x = 0, . Int_t ; y = 0, . UInt_t ; w = 0, . UInt_t ; h = 0 . ). overridevirtual . Create an image (screenshot) from specified window. ; Reimplemented from TImage.; Definition at line 6638 of file TASImage.cxx. ◆ GetArgbArray(). UInt_t * TASImage::GetArgbArray ; (; ). overridevirtual . Return a pointer to internal array[width x height] of ARGB32 values This array is directly accessible. ; That allows to manipulate/change the image. ; Reimplemented from TImage.; Definition at line 3591 of file TASImage.cxx. ◆ GetArray(). TArrayD * TASImage::GetArray ; (; UInt_t ; w = 0, . UInt_t ; h = 0, . TImagePalette * ; palette = gWebImagePalette . ). overridevirtual . In case of vectorized image return an associated array of doubles otherwise this method creates and returns a 2D array of doubles corresponding to palette. ; If palette is ZERO a color converted to double value [0, 1] according to formula Double_t((r << 16) + (g << 8) + b)/0xFFFFFF; b#define b(i)Definition RSha256.hxx:100; g#define g(i)Definition RSha256.hxx:105; Double_tdouble Double_tDefinition RtypesCore.h:59; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; The r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:54881,access,accessible,54881,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['access'],['accessible']
Security,"cxx. ◆ ShowCache(). Int_t TDataSetManagerFile::ShowCache ; (; const char * ; uri = 0). overridevirtual . Show cached information matching uri. ; Reimplemented from TDataSetManager.; Definition at line 1319 of file TDataSetManagerFile.cxx. ◆ Streamer(). void TDataSetManagerFile::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TDataSetManager. ◆ StreamerNVirtual(). void TDataSetManagerFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 100 of file TDataSetManagerFile.h. ◆ UpdateUsedSpace(). void TDataSetManagerFile::UpdateUsedSpace ; (; ). overrideprotectedvirtual . updates the used space maps ; Reimplemented from TDataSetManager.; Definition at line 1959 of file TDataSetManagerFile.cxx. ◆ WriteDataSet(). Int_t TDataSetManagerFile::WriteDataSet ; (; const char * ; group, . const char * ; user, . const char * ; dsName, . TFileCollection * ; dataset, . UInt_t ; option = 0, . TMD5 * ; checksum = 0 . ). Writes indicated dataset. ; If option has the bit kFileMustExist set, the file must still exist, otherwise the new dataset is not written (returns 3 in this case). If checksum is non-zero the files current checksum is checked against it, if it does not match the file is not written (the function returns 2 in this case, if the file has disappeared it is also not written (i.e. checksum implies the bit kFileMustExist set in option). Returns != 0 for success, 0 for error ; Definition at line 1394 of file TDataSetManagerFile.cxx. Member Data Documentation. ◆ fCacheUpdatePeriod. Int_t TDataSetManagerFile::fCacheUpdatePeriod. private . Definition at line 42 of file TDataSetManagerFile.h. ◆ fDataSetDir. TString TDataSetManagerFile::fDataSetDir. private . Definition at line 33 of file TDataSetManagerFile.h. ◆ fDataSetLockFile. TString TDataSetManagerFile::fDataSetLockFile. private . Definition at line 36 of file TDataSetManagerFile.h. ◆ fIsRemote. Bool_t TDataSetManagerFile::fIs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:34455,checksum,checksum,34455,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['checksum'],['checksum']
Security,"d (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the director",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:46240,checksum,checksum,46240,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,2,['checksum'],['checksum']
Security,"d (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClass.html:46697,checksum,checksum,46697,root/html532/TClass.html,https://root.cern,https://root.cern/root/html532/TClass.html,4,['checksum'],['checksum']
Security,"d (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:45494,checksum,checksum,45494,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,2,['checksum'],['checksum']
Security,"d (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:63027,checksum,checksum,63027,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['checksum'],['checksum']
Security,"d . Set locking mode for current database. ; Definition at line 1334 of file TSQLFile.cxx. ◆ SetTablesType(). void TSQLFile::SetTablesType ; (; const char * ; tables_type). Defines tables type, which is used in CREATE TABLE statements Now is only used for MySQL database, where following types are supported: ""BDB"", ""HEAP"", ""ISAM"", ""InnoDB"", ""MERGE"", ""MRG_MYISAM"", ""MYISAM"" Default for TSQLFile is ""InnoDB"". ; For more detailes see MySQL docs. ; Definition at line 528 of file TSQLFile.cxx. ◆ SetUseIndexes(). void TSQLFile::SetUseIndexes ; (; Int_t ; use_type = kIndexesBasic). Specify usage of indexes for data tables. . Index Description . kIndexesNone = 0 no indexes are used . kIndexesBasic = 1 indexes used only for keys list and objects list tables (default) . kIndexesClass = 2 index also created for every normal class table . kIndexesAll = 3 index created for every table, including streamer tables . Indexes in general should increase speed of access to objects data, but they required more operations and more disk space on server side ; Definition at line 615 of file TSQLFile.cxx. ◆ SetUseSuffixes(). void TSQLFile::SetUseSuffixes ; (; Bool_t ; on = kTRUE). enable/disable uasge of suffixes in columns names can be changed before first object is saved into file ; Definition at line 498 of file TSQLFile.cxx. ◆ SetUseTransactions(). void TSQLFile::SetUseTransactions ; (; Int_t ; mode = kTransactionsAuto). Defines usage of transactions statements for writing objects data to database. ; | Index | Description | |----—|----------—| | kTransactionsOff=0 - no transaction operation are allowed | | kTransactionsAuto=1 - automatic mode. Each write operation, produced by TSQLFile, will be supplied by START TRANSACTION and COMMIT calls. If any error happen, ROLLBACK will returns database to previous state | | kTransactionsUser=2 - transactions are delegated to user. Methods StartTransaction(), Commit() and Rollback() should be called by user. |; Default UseTransactions option is kTran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:89262,access,access,89262,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['access'],['access']
Security,"d ; (; Int_t ; newsize). Expand the TExMap. ; Definition at line 279 of file TExMap.cxx. ◆ FindElement(). Int_t TExMap::FindElement ; (; ULong64_t ; hash, . Long64_t ; key . ). private . Find an entry with specified hash and key in the TExMap. ; Returns the slot of the key or the next empty slot. ; Definition at line 237 of file TExMap.cxx. ◆ FixCollisions(). void TExMap::FixCollisions ; (; Int_t ; index). private . Rehash the map in case an entry has been removed. ; Definition at line 257 of file TExMap.cxx. ◆ GetSize(). Int_t TExMap::GetSize ; (; ); const. inline . Definition at line 71 of file TExMap.h. ◆ GetValue() [1/3]. Long64_t TExMap::GetValue ; (; Long64_t ; key). inline . Definition at line 73 of file TExMap.h. ◆ GetValue() [2/3]. Long64_t TExMap::GetValue ; (; ULong64_t ; hash, . Long64_t ; key . ). Return the value belonging to specified key and hash value. ; If key not found return 0. ; Definition at line 174 of file TExMap.cxx. ◆ GetValue() [3/3]. Long64_t TExMap::GetValue ; (; ULong64_t ; hash, . Long64_t ; key, . UInt_t & ; slot . ). Return the value belonging to specified key and hash value. ; If key not found return 0. In 'slot', return the index of the slot used or the first empty slot. (to be used with AddAt). ; Definition at line 197 of file TExMap.cxx. ◆ HighWaterMark(). Bool_t TExMap::HighWaterMark ; (; ). inlineprivate . Definition at line 54 of file TExMap.h. ◆ IsA(). TClass * TExMap::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 81 of file TExMap.h. ◆ operator()() [1/2]. Long64_t & TExMap::operator() ; (; Long64_t ; key). inline . Definition at line 79 of file TExMap.h. ◆ operator()() [2/2]. Long64_t & TExMap::operator() ; (; ULong64_t ; hash, . Long64_t ; key . ). Return a reference to the value belonging to the key with the specified hash value. ; If the key does not exist it will be added. NOTE: the reference will be invalidated an Expand() triggered by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTExMap.html:15191,hash,hash,15191,doc/master/classTExMap.html,https://root.cern,https://root.cern/doc/master/classTExMap.html,1,['hash'],['hash']
Security,"d ;  ; Float_t GetNEvents_unboosted (void) const;  return the number of unboosted events that entered the node (during training), or -1 if traininfo undefined ;  ; Float_t GetNEvents_unweighted (void) const;  return the number of unweighted events that entered the node (during training), or -1 if traininfo undefined ;  ; UInt_t GetNFisherCoeff () const;  ; Double_t GetNodeR () const;  return the node resubstitution estimate, R(t), for Cost Complexity pruning, or -1 if traininfo undefined ;  ; Int_t GetNodeType (void) const;  return node type: 1 signal node, -1 bkg leave, 0 intermediate Node ;  ; Float_t GetNSigEvents (void) const;  return the sum of the signal weights in the node, or -1 if traininfo undefined ;  ; Float_t GetNSigEvents_unboosted (void) const;  return the sum of unboosted signal weights in the node, or -1 if traininfo undefined ;  ; Float_t GetNSigEvents_unweighted (void) const;  ; Double_t GetNSValidation () const;  return number of signal events from the pruning validation sample, or -1 if traininfo undefined ;  ; Int_t GetNTerminal () const;  return number of terminal nodes in the subtree rooted here, or -1 if traininfo undefined ;  ; virtual DecisionTreeNode * GetParent () const;  ; Float_t GetPurity (void) const;  return S/(S+B) (purity) at this node (from training) ;  ; Float_t GetResponse (void) const;  return the response of the node (for regression) ;  ; virtual DecisionTreeNode * GetRight () const;  ; Float_t GetRMS (void) const;  return the RMS of the response of the node (for regression) ;  ; Float_t GetSampleMax (UInt_t ivar) const;  return the maximum of variable ivar from the training sample that pass/end up in this node, if traininfo defined, otherwise Log Fatal and return 9999 ;  ; Float_t GetSampleMin (UInt_t ivar) const;  return the minimum of variable ivar from the training sample that pass/end up in this node, if traininfo defined, otherwise Log Fatal and return -9999 ;  ; Short_t GetSelector () const;  return index of variable us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html:3691,validat,validation,3691,doc/master/classTMVA_1_1DecisionTreeNode.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html,1,['validat'],['validation']
Security,"d = kFALSE;  flag used for suppression of signals ;  . Private Member Functions; Bool_t AcceptResults (Int_t connections, TVirtualProofPlayer *mergerPlayer);  Accept and merge results from a set of workers. ;  ; Int_t CatMotd ();  Print message of the day (in the file pointed by the env PROOFMOTD or from fConfDir/etc/proof/motd). ;  ; Int_t CleanupWaitingQueries (Bool_t del=kTRUE, TList *qls=0);  Cleanup the waiting queries list. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetPriority ();  Get the processing priority for the group the user belongs too. ;  ; Bool_t IsWaiting ();  Return kTRUE if the session is waiting for the OK to start processing. ;  ; TProofQueryResult * MakeQueryResult (Long64_t nentries, const char *opt, TList *inl, Long64_t first, TDSet *dset, const char *selec, TObject *elist);  Create a TProofQueryResult instance for this query. ;  ; TProofQueryResult * NextQuery ();  Get the next query from the waiting list. ;  ; Int_t OldAuthSetup (TString &wconf);  Setup authentication related stuff for old versions. ;  ; Int_t QueueQuery (TProofQueryResult *pq);  Add a query to the waiting list Returns the number of queries in the list. ;  ; void RedirectOutput (const char *dir=0, const char *mode=""w"");  Redirect stdout to a log file. ;  ; Int_t SendResults (TSocket *sock, TList *outlist=0, TQueryResult *pq=0);  Sends all objects from the given list to the specified socket. ;  ; void SetIdle (Bool_t st=kTRUE);  Change the idle status. ;  ; void SetQueryRunning (TProofQueryResult *pq);  Set query in running state. ;  ; Int_t UnloadPackage (const char *package);  ; Int_t UnloadPackages ();  ; Int_t WaitingQueries ();  Return the number of waiting queries. ;  . Private Attributes; Int_t fActSessions;  ; TString fAdminPath;  ; TString fArchivePath;  ; TString fCacheDir;  ; TProofLockPath * fCacheLock;  ; Int_t fCompressMsg;  ; TStopwatch fCompute;  ; TString fConfDir;  ; TString fConfFile;  ; Float_t fCpuTime;  ; TString fDataDir;  ; TString fDataDirOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:27402,authenticat,authentication,27402,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['authenticat'],['authentication']
Security,"d Members; Includes; Libraries. Function documentation; RestrictPhi(). void SetCoordinates(const ROOT::Math::PtEtaPhiM4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fPt; dest[1] = fEta; dest[2] = fPhi; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar mass). Set internal data based on 4 Scalar numbers. GetCoordinates(ROOT::Math::PtEtaPhiM4D<double>::Scalar& pt, ROOT::Math::PtEtaPhiM4D<double>::Scalar& eta, ROOT::Math::PtEtaPhiM4D<double>::Scalar& phi, ROOT::Math::PtEtaPhiM4D<double>::Scalar& mass) const. get internal data into 4 Scalar numbers. { pt=fPt; eta=fEta; phi = fPhi; mass = fM; }. Scalar Pt() const; --------- Coordinates and Coordinate-like Scalar properties -------------; 4-D Cylindrical eta coordinate accessors. { return fPt; }. Scalar Eta() const; { return fEta; }. Scalar Phi() const. M() is the invariant mass;; in this coordinate system it can be negagative if set that way. { return fPhi; }. Scalar M() const; { return fM; }. Scalar Mag() const; { return M(); }. Scalar Perp() const; { return Pt(); }. Scalar Rho() const; { return Pt(); }. Scalar Px() const; other coordinate representation. { return fPt*cos(fPhi);}. Scalar X() const; { return Px(); }. Scalar Py() const; { return fPt*sin(fPhi);}. Scalar Y() const; { return Py(); }. Scalar Pz() const. Scalar Z() const; { return Pz(); }. Scalar P() const. magnitude of momentum. Scalar R() const; { return P(); }. Scalar P2() const. squared magnitude of spatial components (momentum squared). { Scalar p = P(); return p*p; }. Scalar E2() const. energy squared. Scalar E() const. Energy (timelike component of momentum-energy 4-vector). { return std::sqrt(E2() ); }. Scalar T() const; { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html:5609,access,accessors,5609,root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PtEtaPhiM4D_double_.html,5,['access'],['accessors']
Security,"d PrintNeuron(TMVA::TNeuron* neuron) const; print a neuron, for debugging. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); get the mva value generated by the NN. const std::vector<Float_t> & GetRegressionValues(); get the regression value generated by the NN. const std::vector<Float_t> & GetMulticlassValues(); get the multiclass classification values generated by the NN. void AddWeightsXMLTo(void* parent) const; create XML description of ANN classifier. void ReadWeightsFromXML(void* wghtnode); read MLP from xml weight file. void ReadWeightsFromStream(istream& istr); destroy/clear the network then read it back in from the weights file. const TMVA::Ranking* CreateRanking(); compute ranking of input variables by summing function of weights. void CreateWeightMonitoringHists(const TString& bulkname, vector<TH1*>* hv = 0) const. void WriteMonitoringHistosToFile() const; write histograms to file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. Bool_t Debug() const; who the hell makes such strange Debug flags that even use ""global pointers"".. void SetActivation(TMVA::TActivation* activation); setters for subclasses. void SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator). void Train(); this will have to be overridden by every subclass. Double_t GetNetworkOutput(); { return GetOutputNeuron()->GetActivationValue(); }. Int_t NumCycles(); accessors. { return fNcycles; }. TNeuron* GetInputNeuron(Int_t index); { return (TNeuron*)fInputLayer->At(index); }. TNeuron* GetOutputNeuron(Int_t index = 0); { return fOutputNeurons.at(index); }. » Author: Andreas Hoecker, Peter Speckmayer, Matt Jachowski, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: MethodANNBase.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodANNBase.html:22344,access,accessors,22344,root/html532/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodANNBase.html,1,['access'],['accessors']
Security,"d errors messages generated by the RooFit core code. ; ; Each message generated by the core; has a message level (DEBUG,INFO,PROGRESS,WARNING,ERROR or FATAL), an originating object,; and a 'topic'. Currently implemented topics are ""Generation"",""Plotting"",; ""Integration"", ""Minimization"" and ""Workspace"" and ""ChangeTracking"".; ; The RooMsgService class allows to filter and redirect messages into 'streams' ; according to message level, topic, (base) class of originating object, name of originating; object and based on attribute labels attached to individual objects. ; ; The current default configuration creates streams for all messages at WARNING level; or higher (e.g. ERROR and FATAL) and for all INFO message on topics Generation,Plotting,; Integration and Minimization and redirects them to stdout. Users can create additional streams ; for logging of e.g. DEBUG messages on particular topics or objects and or redirect streams to; C++ streams or files.; ; The singleton instance is accessible through RooMsgService::instance() ;; . Function Members (Methods); public:. virtual~RooMsgService(); voidTObject::AbstractMethod(const char* method) const; Int_taddStream(RooFit::MsgLevel level, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg()); static Bool_tanyDebug(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); voidclearErrorCount(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_t&debugCode(); RooWorkspace*debugWorkspace(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteStream(Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMsgService.html:1397,access,accessible,1397,root/html528/RooMsgService.html,https://root.cern,https://root.cern/root/html528/RooMsgService.html,6,['access'],['accessible']
Security,"d errors messages generated by the RooFit core code. ; ; Each message generated by the core; has a message level (DEBUG,INFO,PROGRESS,WARNING,ERROR or FATAL), an originating object,; and a 'topic'. Currently implemented topics are ""Generation"",""Plotting"",; ""Integration"", ""Minimization"" and ""Workspace"" and ""ChangeTracking"".; ; The RooMsgService class allows to filter and redirect messages into 'streams' ; according to message level, topic, (base) class of originating object, name of originating; object and based on attribute labels attached to individual objects. ; ; The current default configuration creates streams for all messages at WARNING level; or higher (e.g. ERROR and FATAL) and for all INFO message on topics Generation,Plotting,; Integration and Minimization and redirects them to stdout. Users can create additional streams ; for logging of e.g. DEBUG messages on particular topics or objects and or redirect streams to; C++ streams or files.; ; The singleton instance is accessible through RooMsgService::instance() ;; . Function Members (Methods); public:. virtual~RooMsgService(); voidTObject::AbstractMethod(const char* method) const; Int_taddStream(RooFit::MsgLevel level, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg()); static Bool_tanyDebug(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); voidclearErrorCount(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voiddeleteStream(Int_t id); virtual Int_tTObject::DistancetoPrimitive(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMsgService.html:1397,access,accessible,1397,root/html526/RooMsgService.html,https://root.cern,https://root.cern/root/html526/RooMsgService.html,1,['access'],['accessible']
Security,"d errors messages generated by the RooFit core code. ; ; Each message generated by the core; has a message level (DEBUG,INFO,PROGRESS,WARNING,ERROR or FATAL), an originating object,; and a 'topic'. Currently implemented topics are ""Generation"",""Plotting"",; ""Integration"", ""Minimization"" and ""Workspace"" and ""ChangeTracking"".; ; The RooMsgService class allows to filter and redirect messages into 'streams' ; according to message level, topic, (base) class of originating object, name of originating; object and based on attribute labels attached to individual objects. ; ; The current default configuration creates streams for all messages at WARNING level; or higher (e.g. ERROR and FATAL) and for all INFO message on topics Generation,Plotting,; Integration and Minimization and redirects them to stdout. Users can create additional streams ; for logging of e.g. DEBUG messages on particular topics or objects and or redirect streams to; C++ streams or files.; ; The singleton instance is accessible through RooMsgService::instance() ;; . Function Members (Methods); public:. ~StreamConfig(); voidaddTopic(RooFit::MsgTopic newTopic); Bool_tmatch(RooFit::MsgLevel level, RooFit::MsgTopic facility, const RooAbsArg* obj); Bool_tmatch(RooFit::MsgLevel level, RooFit::MsgTopic facility, const TObject* obj); RooMsgService::StreamConfig&operator=(const RooMsgService::StreamConfig&); RooMsgService::StreamConfig&operator=(RooMsgService::StreamConfig&&); voidremoveTopic(RooFit::MsgTopic oldTopic); RooMsgService::StreamConfigStreamConfig(); RooMsgService::StreamConfigStreamConfig(const RooMsgService::StreamConfig&); RooMsgService::StreamConfigStreamConfig(RooMsgService::StreamConfig&&). Data Members; public:. Bool_tactive; stringbaseClassName; stringclassName; Color_tcolor; RooFit::MsgLevelminLevel; stringobjectName; ostream*os; Bool_tprefix; stringtagName; Int_ttopic; Bool_tuniversal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t match(RooFit:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMsgService__StreamConfig.html:1423,access,accessible,1423,root/html602/RooMsgService__StreamConfig.html,https://root.cern,https://root.cern/root/html602/RooMsgService__StreamConfig.html,2,['access'],['accessible']
Security,"d events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. Bool_tfDirtrue if a directory is open remotely; void*fDirpdirectory handler; TFTP*fFTPConnection to rootd; Bool_tfFTPOwnerTrue if owner of the FTP instance; TStringfHostRemote host; Int_tfPortRemote port; TStringfUserRemote user. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetSystem(Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. TNetSystem(const char* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free dir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetSystem.html:21192,access,access,21192,root/html528/TNetSystem.html,https://root.cern,https://root.cern/root/html528/TNetSystem.html,6,['access'],['access']
Security,"d every time when new snapshot created ;  ; Bool_t fFixedSize {kFALSE};  ! is canvas size fixed ;  ; std::vector< std::unique_ptr< ROOT::RWebDisplayHandle > > fHelpHandles;  ! array of handles for help widgets ;  ; Int_t fJsonComp {0};  ! compression factor for messages send to the client ;  ; Bool_t fLongerPolling {kFALSE};  ! when true, make longer polling in blocking operations ;  ; ObjectSelectSignal_t fObjSelectSignal;  ! signal emitted when new object selected in the pad ;  ; PadClickedSignal_t fPadClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; PadClickedSignal_t fPadDblClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; std::map< TPad *, PadStatus > fPadsStatus;  ! map of pads in canvas and their status flags ;  ; Int_t fPaletteDelivery {1};  ! colors palette delivery 0:never, 1:once, 2:always, 3:per subpad ;  ; Int_t fPrimitivesMerge {100};  ! number of PS primitives, which will be merged together ;  ; Bool_t fProcessingData {kFALSE};  ! flag used to prevent blocking methods when process data is invoked ;  ; Bool_t fReadOnly {kFALSE};  !< configured display ;  ; Int_t fStyleDelivery {0};  ! gStyle delivery to clients: 0:never, 1:once, 2:always ;  ; UInt_t fStyleHash {0};  ! last hash of gStyle ;  ; Long64_t fStyleVersion {0};  ! current gStyle object version, checked every time when new snapshot created ;  ; Int_t fTF1UseSave {1};  ! use save buffer for TF1/TF2, 0:off, 1:prefer, 2:force ;  ; TWebCanvasTimer * fTimer {nullptr};  ! timer to submit control messages ;  ; UpdatedSignal_t fUpdatedSignal;  ! signal emitted when canvas updated or state is changed ;  ; std::map< TObject *, bool > fUsedObjs;  ! map of used objects during streaming ;  ; std::vector< WebConn > fWebConn;  ! connections ;  ; std::shared_ptr< ROOT::RWebWindow > fWindow;  ; std::vector< int > fWindowGeometry;  ! last received window geometry ;  ;  Protected Attributes inherited from TCanvasImp; TCanvas * fCanvas {nullptr};  .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:15579,hash,hash,15579,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['hash'],['hash']
Security,"d for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. The boolena 'gui' should be kTRUE when invoked from the GUI. void DetachSession(Int_t , Option_t* = """"); Detach session with 'id' from its proofserv. The 'id' is the number; shown by QuerySessions. The correspondent TProof object is deleted.; If id == 0 all the known sessions are detached.; Option opt=""S"" or ""s"" forces session shutdown. void DetachSession(TProof* , Option_t* = """"); Detach session 'p' from its proofserv. The instance 'p' is invalidated; and should be deleted by the caller. Bool_t MatchUrl(const char* url); Checks if 'url' refers to the same 'user@host:port' entity as the URL; in memory. TProofMgr::MatchUrl cannot be used here because of the; 'double' default port, implying an additional check on the port effectively; open. void ShowWorkers(); Show available workers. const char * GetMssUrl(Bool_t = kFALSE); Gets the URL to be prepended to paths when accessing the MSS associated; with the connected cluster, if any. The information is retrieved from; the cluster the first time or if retrieve is true. TList * QuerySessions(Option_t* opt = ""S""); Get list of sessions accessible to this manager. Bool_t HandleInput(const void* ); Handle asynchronous input on the socket. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Int_t Reset(Bool_t hard = kFALSE, const char* usr = 0); Send a cleanup request for the sessions associated with the current user.; If 'hard' is true sessions are signalled for termination and moved to; terminate at all stages (top master, sub-master, workers). Otherwise; (default) only top-master sessions are asked to terminate, triggering; a gentle session termination. In all cases all sessions should be gone; after a few (2 or 3) session checking cycles.; A user with superuser privileges can also asks cleaning for an different; user, specified by 'usr', or for all users (usr = *); Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofMgr.html:11311,access,accessing,11311,root/html534/TXProofMgr.html,https://root.cern,https://root.cern/root/html534/TXProofMgr.html,3,['access'],['accessing']
Security,"d give them to the fitter; as variables; --Example:; You want to fit ""sin(x)|cos(2*x)"" very fast. Calculate; sin(x) and cos(2*x) beforehand and store them in array *data.; Then:; TLinearFitter *lf=new TLinearFitter(2, ""hyp2"");; lf->AssignData(npoint, 2, data, y);. 2.3 Resetting the formula; 2.3.1 If the input data is stored (or added via AssignData() function),; the fitting formula can be reset without re-adding all the points.; --Example:; TLinearFitter *lf=new TLinearFitter(""1++x++x*x"");; lf->AssignData(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:5174,access,access,5174,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,6,['access'],['access']
Security,"d in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:23951,authenticat,authentication,23951,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,5,['authenticat'],['authentication']
Security,"d in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const Double32_t& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const Double32_t& rhs) const; element wise comparison. bool operator<(const Double32_t& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0. T& operator()(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0. const T& At(unsigned int i, unsigned int j) const. read only access to matrix element, with indices starting from 0.; Function will check index values and it will assert if they are wrong. T& At(unsigned int i, unsigned int j). read/write access to matrix element with indices starting from 0.; Function will check index values and it will assert if they are wrong. T & operator[](unsigned int i); { return (*fMat)(fRow,j); }. const T & operator[](unsigned int i) const; { return (*fMat)(fRow, j); }. SMatrix<T,D1,D2,R>& operator+=(const Double32_t& rhs). addition with a scalar. SMatrix<T,D1,D2,R>& operator-=(const Double32_t& rhs). subtraction with a scalar. SMatrix<T,D1,D2,R>& operator*=(const Double32_t& rhs). multiplication with a scalar. SMatrix<T,D1,D2,R>& operator/=(const Double32_t& rhs). division with a scalar. bool Invert(); @name --- Li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:7054,access,access,7054,root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,32,['access'],['access']
Security,"d inside the context (e.g. it does not automatically close the file). . Definition at line 89 of file TDirectory.h. Public Member Functions;  TContext ();  ;  TContext (TDirectory *newCurrent);  ;  TContext (TDirectory *previous, TDirectory *newCurrent);  ;  ~TContext ();  Destructor. ;  . Private Member Functions;  TContext (TContext &)=delete;  Pointer to the next TContext in the implied list of context pointing to fPrevious. ;  ; void CdNull ();  Set the current directory to null. ;  ; TContext & operator= (TContext &)=delete;  ; void RegisterCurrentDirectory ();  . Private Attributes; std::atomic< bool > fActiveDestructor {false};  Pointer to the previous current directory. ;  ; std::atomic< TDirectory * > fDirectory {nullptr};  ; std::atomic< bool > fDirectoryWait {false};  Set to true during the destructor execution. ;  ; TContext * fNext {nullptr};  Pointer to the next TContext in the implied list of context pointing to fPrevious. ;  ; TContext * fPrevious {nullptr};  Set to true if a TDirectory might still access this object. ;  . Friends; class TDirectory;  . #include <TDirectory.h>; Constructor & Destructor Documentation. ◆ TContext() [1/4]. TDirectory::TContext::TContext ; (; TContext & ; ). privatedelete . Pointer to the next TContext in the implied list of context pointing to fPrevious. . ◆ TContext() [2/4]. TDirectory::TContext::TContext ; (; TDirectory * ; previous, . TDirectory * ; newCurrent . ). inline . Definition at line 108 of file TDirectory.h. ◆ TContext() [3/4]. TDirectory::TContext::TContext ; (; ). inline . Definition at line 120 of file TDirectory.h. ◆ TContext() [4/4]. TDirectory::TContext::TContext ; (; TDirectory * ; newCurrent). inline . Definition at line 126 of file TDirectory.h. ◆ ~TContext(). TDirectory::TContext::~TContext ; (; ). Destructor. ; Reset the current directory to its previous state. ; Definition at line 143 of file TDirectory.cxx. Member Function Documentation. ◆ CdNull(). void TDirectory::TContext::CdNull ; (; ). priv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDirectory_1_1TContext.html:3583,access,access,3583,doc/master/classTDirectory_1_1TContext.html,https://root.cern,https://root.cern/doc/master/classTDirectory_1_1TContext.html,1,['access'],['access']
Security,"d look something like ""data/toymc_%04d.dat""; and should contain one integer field that encodes the sample serial number. When fitting only, data sets may optionally be read from ascii files, using the same file; pattern. Bool_t generateAndFit(Int_t nSamples, Int_t nEvtPerSample = 0, Bool_t keepGenData = kFALSE, const char* asciiFilePat = 0); Generate and fit 'nSamples' samples of 'nEvtPerSample' events.; If keepGenData is set, all generated data sets will be kept in memory and can be accessed; later via genData(). Data sets will be written out is ascii form if the pattern string is supplied.; The pattern, which is a template for snprintf, should look something like ""data/toymc_%04d.dat""; and should contain one integer field that encodes the sample serial number. Bool_t generate(Int_t nSamples, Int_t nEvtPerSample = 0, Bool_t keepGenData = kFALSE, const char* asciiFilePat = 0); Generate 'nSamples' samples of 'nEvtPerSample' events.; If keepGenData is set, all generated data sets will be kept in memory; and can be accessed later via genData(). Data sets will be written out in ascii form if the pattern string is supplied.; The pattern, which is a template for snprintf, should look something like ""data/toymc_%04d.dat""; and should contain one integer field that encodes the sample serial number. Bool_t fit(Int_t nSamples, const char* asciiFilePat); Fit 'nSamples' datasets, which are read from ASCII files. The ascii file pattern, which is a template for snprintf, should look something like ""data/toymc_%04d.dat""; and should contain one integer field that encodes the sample serial number. Bool_t fit(Int_t nSamples, TList& dataSetList); Fit 'nSamples' datasets, as supplied in 'dataSetList'. void resetFitParams(); Reset all fit parameters to the initial model; parameters at the time of the RooMCStudy constructor. RooFitResult* doFit(RooAbsData* genSample); Internal function. Performs actual fit according to specifications. RooFitResult* refit(RooAbsData* genSample = 0); Redo fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMCStudy.html:16841,access,accessed,16841,root/html528/RooMCStudy.html,https://root.cern,https://root.cern/root/html528/RooMCStudy.html,6,['access'],['accessed']
Security,"d peaks, peaks with amplitude less than; threshold*highest_peak/100 are ignored; fBackgroundRemove-; background_remove-logical variable, true if the removal of background before; deconvolution is desired� ; fDeconIterations-number; of iterations in deconvolution operation; fMarkov-logical; variable, if it is true, first the source spectrum is replaced by new spectrum; calculated using Markov chains method ; fAverWindow-width of averaging smoothing window ;  ; References:; [1] M.A. Mariscotti: A method for; identification of peaks in the presence of background and its application to; spectrum analysis. NIM 50 (1967), 309-320.; [2] �M.; Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3] Z.K. Silagadze, A new; algorithm for automatic photopeak searches. NIM A 376 (1996), 451.;  ; Example of peak searching method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the destination spectrum. Based on the output data one can tune the; parameters. ; Example 1 � script Search3.c:;  . Fig. 1 Three-dimensional; spectrum with 5 peaks (, threshold=5%, 3 iterations steps in; the deconvolution);  . Fig. 2 Spectrum from Fig. 1; after background elimination and deconvolution;  ; Script:; // Example to illustrate high; resolution peak searching function (class TSpectrum3).; // To execute this example,; do; // root > .x Search3.C; void Search3() {; �� Int_t i, j, k, nfound;; �� Int_t nbinsx = 32;; �� Int_t nbinsy = 32;; �� Int_t nbinsz =; 32;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� =; nbinsy;�� ; �� Int_t zmin� = 0;; �� Int_t zmax� = nbinsz;����� ; �� Double_t*** source = new; Double_t**[nbinsx];; �� Double_t*** dest = new Double_t; **[nbinsx];����� ; �� for(i=0;i<nbinsx;i++){; ����� source[i]=new Double_t*; [nbinsy];; �����; for(j=0;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum3.html:34870,access,access,34870,root/html602/TSpectrum3.html,https://root.cern,https://root.cern/root/html602/TSpectrum3.html,2,['access'],['access']
Security,"d peaks, peaks with amplitude less than; threshold*highest_peak/100 are ignored; fBackgroundRemove-; background_remove-logical variable, true if the removal of background before; deconvolution is desired� ; fDeconIterations-number; of iterations in deconvolution operation; fMarkov-logical; variable, if it is true, first the source spectrum is replaced by new spectrum; calculated using Markov chains method ; fAverWindow-width of averaging smoothing window ;  ; References:; [1] M.A. Mariscotti: A method for; identification of peaks in the presence of background and its application to; spectrum analysis. NIM 50 (1967), 309-320.; [2] �M.; Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3] Z.K. Silagadze, A new; algorithm for automatic photopeak searches. NIM A 376 (1996), 451.;  ; Example of peak searching method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the destination spectrum. Based on the output data one can tune the; parameters. ; Example 1 � script Search3.c:;  . Fig. 1 Three-dimensional; spectrum with 5 peaks (, threshold=5%, 3 iterations steps in; the deconvolution);  . Fig. 2 Spectrum from Fig. 1; after background elimination and deconvolution;  ; Script:; // Example to illustrate high; resolution peak searching function (class TSpectrum3).; // To execute this example,; do; // root > .x Search3.C; void Search3() {; �� Int_t i, j, k, nfound;; �� Int_t nbinsx = 32;; �� Int_t nbinsy = 32;; �� Int_t nbinsz =; 32;�� ; �� Int_t xmin� = 0;; �� Int_t xmax� =; nbinsx;; �� Int_t ymin� = 0;; �� Int_t ymax� =; nbinsy;�� ; �� Int_t zmin� = 0;; �� Int_t zmax� = nbinsz;����� ; �� float *** source = new; float **[nbinsx];; �� float *** dest = new float; **[nbinsx];����� ; �� for(i=0;i<nbinsx;i++){; ����� source[i]=new float*; [nbinsy];; �����; for(j=0;j<nbinsy;j++",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum3.html:34020,access,access,34020,root/html528/TSpectrum3.html,https://root.cern,https://root.cern/root/html528/TSpectrum3.html,4,['access'],['access']
Security,"d prototype F is used for states ""II"" and ""III"" of; master split category mc. Furthermore parameters m,s of prototype G are split; in category c while parameter a of prototype F is split in; the product of categories c and d. The actual build is then; performed by passing the build configuration to RooSimWSTool, e.g. wst.build(""MASTER"",mbc) ;. By default, a specialization is built for each permutation of; states of the spitting categories that are used. It is possible; to restrict the building of specialized p.d.f to a subset of states; by adding a restriction on the number of states to build as follows. mbc.restrictBuild(""c"",""A,B"") ;. The restrictBuild method can be called multiple times, but at most; once for each used splitting category. For simple builds with a single; prototype, restriction can be specified with a Restrict() argument; on the build command line. Function Members (Methods); public:. virtual~ObjBuildConfig(); static TClass*Class(); virtual TClass*IsA() const; RooSimWSTool::ObjBuildConfigObjBuildConfig(); RooSimWSTool::ObjBuildConfigObjBuildConfig(const RooSimWSTool::ObjBuildConfig&); RooSimWSTool::ObjBuildConfig&operator=(const RooSimWSTool::ObjBuildConfig&); voidprint(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. RooCmdArg_conflProtocol; RooCategory*_masterCat; map<RooAbsPdf*,RooSimWSTool::ObjSplitRule>_pdfmap; map<RooAbsCategory*,list<const RooCatType*> >_restr; RooArgSet_usedSplitCats. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void print(); Print details of a validated build configuration. ObjBuildConfig(); {}. virtual ~ObjBuildConfig(); {}. » Last changed: Tue Jun 2 15:33:56 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooSimWSTool__ObjBuildConfig.html:4418,validat,validated,4418,root/html604/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html604/RooSimWSTool__ObjBuildConfig.html,1,['validat'],['validated']
Security,"d selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file `hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx:; double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Implements TVirtualTreePlayer.; Definition at line 1925 of file TTreePlayer.cxx. ◆ MakeReader(). Int_t TTreePlayer::MakeReader ; (; const char * ; classname, . Option_t * ; option . ). overridevirtual . Generate skeleton selector class for this tree. ; The following files are produced: classname.h and classname.C. If classname is 0, the selector will be called ""nameoftree"". The opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:35870,access,access,35870,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['access'],['access']
Security,"d selector will also call methods named macrofilename_methodname in each of 6 main selector methods if the method macrofilename_methodname exist (Where macrofilename is stripped of its extension).; Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> bool h1analysisProxy_Notify();; Process -> bool h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h1analysisProxy_Terminate();. If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist it is included before the declaration of the proxy class. This can be used in particular to insure that the include files needed by the macro file are properly loaded.; The default histogram is accessible via the variable named 'htemp'.; If the library of the classes describing the data in the branch is loaded, the skeleton will add the needed include statements and give the ability to access the object stored in the branches.; To draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; A more complete example is available in the tutorials directory: h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C ; Definition at line 6768 of file TTree.cxx. ◆ MakeSelector(). Int_t TTree::MakeSelector ; (; const char * ; selector = nullptr, . Option_t * ; option = """" . ). virtual . Generate skeleton selector class for this tree. ; The following files are produced: selector.h and selector.C. If selector is 0, the selector will be called ""nameoftree"". The option can be used to specify the branches that will have a data member.; If option is ""=le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:178585,access,access,178585,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['access']
Security,"d server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectClasses(); Calls GetSubschemaSubentry() and performs and LDAPSearch with; the attribute ""objectClasses"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * GetAttributeTypes(); Calls GetSubschemaSubentry() and performs and LDAPSearch with the; attribute ""attributeTypes"" to be returned with the result.; The returned result object must be deleted by the user. TLDAPResult * Search(const char* base = """", Int_t scope = LDAP_SCOPE_BASE, const char* filter = 0, TList* attrs = 0, Bool_t attrso",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLDAPServer.html:7180,password,password,7180,root/html528/TLDAPServer.html,https://root.cern,https://root.cern/root/html528/TLDAPServer.html,3,['password'],['password']
Security,"d the -noIncludePaths and –noIncludePaths to rootcling and genereflex respectively to avoid storing in the dictionaries the include paths passed with the “-I” switch. ROOT will rely on ROOT_INCLUDE_PATH only at runtime to find headers. I/O. Resolve an issue when space is freed in a large ROOT file and a TDirectory is updated and stored the lower (less than 2GB) freed portion of the file [ROOT-8055]. TTree. Do not automatically setup read cache during TTree::Fill(). This fixes [ROOT-8031]. Fast Cloning. Added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address [ROOT-5078].; The new cache can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces.; The new cache is enabled by default.; To update the size of the cache or disable it:; From TTreeCloner use: TTreeCloner::SetCacheSize; From TTree::CopyEntries add to the option string ""cachesize=SIZE""; From hadd, use the command line option -cachesize SIZE; SIZE should be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Release 6.04/18; Published on 2016-06-22.; Core. Fix the validity of TRef after the first ProcessID is full. TTree. Properly handle the last element of arrays in the TTreeFormula functions MinIf and MaxIf ROOT-7258. Bugs and issues fixed. [ROOT-6923] - Memory leak with circular TTree; [ROOT-7258] - MinIf and MaxIf TTreeFormula functions ignore last element; [ROOT-7867] - memprobe script is broken when using CMake; [ROOT-8066] - problems creating dictionaries in pyROOT; [ROOT-8068] - Fix file flags for bin/setxrd.* bin/thisroot.*; [ROOT-8096] - genreflex crash with gcc6 build; [ROOT-8148] - Memory leak in TStorage::ObjectAlloc; [ROOT-8221] - Enum value kKey_Shift not accessible from python with ROOT 6. HEAD of the v6-04-00-patches branch; Changes will be part of the future 6.04/20. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:40048,access,accessible,40048,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['access'],['accessible']
Security,"d the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClass.html:46463,checksum,checksum,46463,root/html530/TClass.html,https://root.cern,https://root.cern/root/html530/TClass.html,2,['checksum'],['checksum']
Security,"d the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClass.html:46920,checksum,checksum,46920,root/html532/TClass.html,https://root.cern,https://root.cern/root/html532/TClass.html,4,['checksum'],['checksum']
Security,"d the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddInstance(Bool_t heap = kFALSE); { fInstanceCount++; if (heap) fOnHeap++; }. Bool_t CanIgnoreTObjectStreamer(); { return TestBit(kIgnoreTObjectStreamer);}. void Dump() const; { TDictionary::Dump(); }. Version_t GetC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:45717,checksum,checksum,45717,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,2,['checksum'],['checksum']
Security,"d the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. void RegisterStreamerInfo(TVirtualStreamerInfo* info); Register the StreamerInfo in the given slot, change the State of the; TClass as appropriate. void RemoveStreamerInfo(Int_t slot); Remove and delete the StreamerInfo in the given slot.; Update the slot accordingly. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::MergeFunc_t GetMerge() const; Return the wrapper around Merge. ROOT::ResetAfterMergeFunc_t GetResetAfterMerge() const; Return the wrapper around Merge. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:63250,checksum,checksum,63250,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['checksum'],['checksum']
Security,"d(T x) {; 166 auto y = x - fCarry[0];; 167 auto t = fSum[0] + y;; 168 fCarry[0] = (t - fSum[0]) - y;; 169 fSum[0] = t;; 170 }; 171 ; 172 ; 173 /// Accumulate from a range denoted by iterators.; 174 ///; 175 /// This function will auto-vectorise with random-access iterators.; 176 /// \param[in] begin Beginning of a range. Needs to be a random access iterator for automatic; 177 /// vectorisation, because a contiguous block of memory needs to be read.; 178 /// \param[in] end End of the range.; 179 template <class Iterator>; 180 void Add(Iterator begin, Iterator end) {; 181 static_assert(std::is_floating_point<; 182 typename std::remove_reference<decltype(*begin)>::type>::value,; 183 ""Iterator needs to point to floating-point values."");; 184 const std::size_t n = std::distance(begin, end);; 185 ; 186 for (std::size_t i=0; i<n; ++i) {; 187 AddIndexed(*(begin++), i);; 188 }; 189 }; 190 ; 191 ; 192 /// Fill from a container that supports index access.; 193 /// \param[in] inputs Container with index access such as std::vector or array.; 194 template<class Container_t>; 195 void Add(const Container_t& inputs) {; 196 static_assert(std::is_floating_point<typename Container_t::value_type>::value,; 197 ""Container does not hold floating-point values."");; 198 for (std::size_t i=0; i < inputs.size(); ++i) {; 199 AddIndexed(inputs[i], i);; 200 }; 201 }; 202 ; 203 ; 204 /// Iterate over a range and return an instance of a KahanSum.; 205 ///; 206 /// See Add(Iterator,Iterator) for details.; 207 /// \param[in] begin Beginning of a range.; 208 /// \param[in] end End of the range.; 209 /// \param[in] initialValue Optional initial value.; 210 template <class Iterator>; 211 static KahanSum<T, N> Accumulate(Iterator begin, Iterator end,; 212 T initialValue = T{}) {; 213 KahanSum<T, N> theSum(initialValue);; 214 theSum.Add(begin, end);; 215 ; 216 return theSum;; 217 }; 218 ; 219 ; 220 /// Add `input` to the sum.; 221 ///; 222 /// Particularly helpful when filling from a for loop.; 223 /// Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Util_8h_source.html:7612,access,access,7612,doc/master/Util_8h_source.html,https://root.cern,https://root.cern/doc/master/Util_8h_source.html,1,['access'],['access']
Security,"d(const char* archfile); Set (or update) query in archived state. void Print(Option_t* opt = """") const; Print query content. Use opt = ""F"" for a full listing. void Browse(TBrowser* b = 0); To support browsing of the results. void SetInputList(TList* in, Bool_t adopt = kTRUE); Set / change the input list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fInputList will always be owner of its objects. void SetOutputList(TList* out, Bool_t adopt = kTRUE); Set / change the output list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fOutputList will always be owner of its objects. Bool_t Matches(const char* ref); Return TRUE if reference ref matches. TObject * GetInputObject(const char* classname) const; Return first instance of class 'classname' in the input list.; Usefull to access TDSet, TEventList, ... TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec). void SetFinalized(); { fFinalized = kTRUE; }. TQueryResult(); { }. Int_t GetSeqNum() const; { return fSeqNum; }. EQueryStatus GetStatus() const; { return fStatus; }. TDatime GetStartTime() const; { return fStart; }. TDatime GetEndTime() const; { return fEnd; }. const char * GetOptions() const; { return fOptions; }. TList * GetInputList(); { return fInputList; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetFirst() const; { return fFirst; }. Long64_t GetBytes() const; { return fBytes; }. Float_t GetUsedCPU() const; { return fUsedCPU; }. TMacro * GetLogFile() const; { return fLogFile; }. TMacro * GetSelecHdr() const; { return fSelecHdr; }. TMacro * GetSelecImp() const; { return fSelecImp; }. const char * GetLibList() const; { return fLibList; }. const char * GetParList() const; { return fParList; }. TList * GetOutputList(); { return fOu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQueryResult.html:10036,access,access,10036,root/html528/TQueryResult.html,https://root.cern,https://root.cern/root/html528/TQueryResult.html,4,['access'],['access']
Security,"d(const char* archfile); Set (or update) query in archived state. void Print(Option_t* opt = """") const; Print query content. Use opt = ""F"" for a full listing. void Browse(TBrowser* b = 0); To support browsing of the results. void SetInputList(TList* in, Bool_t adopt = kTRUE); Set / change the input list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fInputList will always be owner of its objects. void SetOutputList(TList* out, Bool_t adopt = kTRUE); Set / change the output list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fOutputList will always be owner of its objects. Bool_t Matches(const char* ref); Return TRUE if reference ref matches. TObject * GetInputObject(const char* classname) const; Return first instance of class 'classname' in the input list.; Usefull to access TDSet, TEventList, ... TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec). void SetFinalized(); { fFinalized = kTRUE; }. void SetPrepTime(Float_t preptime); { fPrepTime = preptime; }. void SetMergeTime(Float_t mergetime); { fMergeTime = mergetime; }. void SetRecvTime(Float_t recvtime); { fRecvTime = recvtime; }. void SetTermTime(Float_t termtime); { fTermTime = termtime; }. void SetNumMergers(Int_t nmergers); { fNumMergers = nmergers; }. TQueryResult(); { }. Int_t GetSeqNum() const; { return fSeqNum; }. EQueryStatus GetStatus() const; { return fStatus; }. TDatime GetStartTime() const; { return fStart; }. TDatime GetEndTime() const; { return fEnd; }. const char * GetOptions() const; { return fOptions; }. TList * GetInputList(); { return fInputList; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetFirst() const; { return fFirst; }. Long64_t GetBytes() const; { return fBytes; }. Float_t GetUsedCPU() const; { ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQueryResult.html:10738,access,access,10738,root/html534/TQueryResult.html,https://root.cern,https://root.cern/root/html534/TQueryResult.html,2,['access'],['access']
Security,"d(key,value) instead. void Add(TObject* key, TObject* value); Add a (key,value) pair to the map. Float_t AverageCollisions() const; Return the ratio of entries vs occupied slots. Int_t Capacity() const; Return number of slots in the hashtable. Use GetSize() to get the; number of objects stored in the TMap. void Clear(Option_t* option = """"); Remove all (key,value) pairs from the map. The keys/values are; deleted depending on the state of key-ownership (SetOwner()) and; value-ownership (SetOwnerValue()). To delete these objects regardless of the ownership state use:; - Delete() to delete only keys;; - DeleteValues() to delete only values;; - DeleteAll() to delete both keys and values. Int_t Collisions(const char* keyname) const; Returns the number of collisions for a key with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* key) const; Returns the number of collisions for a key (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all (key,value) pairs from the map AND delete the keys; when they are allocated on the heap. void DeleteValues(); Remove all (key,value) pairs from the map AND delete the values; when they are allocated on the heap. void DeleteAll(); Remove all (key,value) pairs from the map AND delete the keys AND; values when they are allocated on the heap. Bool_t DeleteEntry(TObject* key); Remove (key,value) pair with key from the map. Returns true; if the key was found and removed, false otherwise.; The key and value objects are deleted if map is the owner; of keys and values respectively. TObject * FindObject(const char* keyname) const; Check if a (key,value) pair exists with keyname as name of the key.; Returns a TPair* (need to downcast from TObject). Use Key() and; Value() to get the pointers to the key and value, respectively.; Returns 0 if not found. TObject * FindObject(const TObject* key) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMap.html:9648,hash,hash,9648,root/html528/TMap.html,https://root.cern,https://root.cern/root/html528/TMap.html,6,['hash'],['hash']
Security,"d,; 6909 // we need to reset fStreamerType; 6910 fStreamer = str;; 6911 fStreamerType = TClass::kDefault;; 6912 if (fProperty != -1) {; 6913 fProperty = -1;; 6914 Property();; 6915 }; 6916 }; 6917}; 6918 ; 6919////////////////////////////////////////////////////////////////////////////////; 6920/// Set a wrapper/accessor function around this class custom streamer.; 6921 ; 6922void TClass::SetStreamerFunc(ClassStreamerFunc_t strm); 6923{; 6924 R__LOCKGUARD(gInterpreterMutex);; 6925 if (fProperty != -1 && !fConvStreamerFunc &&; 6926 ( (fStreamerFunc == nullptr && strm != nullptr) || (fStreamerFunc != nullptr && strm == nullptr) ) ); 6927 {; 6928 fStreamerFunc = strm;; 6929 ; 6930 // Since initialization has already been done, make sure to tweak it; 6931 // for the new state.; 6932 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6933 fStreamerType = kInstrumented;; 6934 fStreamerImpl = &TClass::StreamerInstrumented;; 6935 }; 6936 } else {; 6937 fStreamerFunc = strm;; 6938 }; 6939 fCanSplit = -1;; 6940}; 6941 ; 6942////////////////////////////////////////////////////////////////////////////////; 6943/// Set a wrapper/accessor function around this class custom conversion streamer.; 6944 ; 6945void TClass::SetConvStreamerFunc(ClassConvStreamerFunc_t strm); 6946{; 6947 R__LOCKGUARD(gInterpreterMutex);; 6948 if (fProperty != -1 &&; 6949 ( (fConvStreamerFunc == nullptr && strm != nullptr) || (fConvStreamerFunc != nullptr && strm == nullptr) ) ); 6950 {; 6951 fConvStreamerFunc = strm;; 6952 ; 6953 // Since initialization has already been done, make sure to tweak it; 6954 // for the new state.; 6955 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 6956 fStreamerType = kInstrumented;; 6957 fStreamerImpl = &TClass::ConvStreamerInstrumented;; 6958 }; 6959 } else {; 6960 fConvStreamerFunc = strm;; 6961 }; 6962 fCanSplit = -1;; 6963}; 6964 ; 6965 ; 6966////////////////////////////////////////////////////////////////////////////////; 696",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:266448,access,accessor,266448,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['access'],['accessor']
Security,"d,; 6976 // we need to reset fStreamerType; 6977 fStreamer = str;; 6978 fStreamerType = TClass::kDefault;; 6979 if (fProperty != -1) {; 6980 fProperty = -1;; 6981 Property();; 6982 }; 6983 }; 6984}; 6985 ; 6986////////////////////////////////////////////////////////////////////////////////; 6987/// Set a wrapper/accessor function around this class custom streamer.; 6988 ; 6989void TClass::SetStreamerFunc(ClassStreamerFunc_t strm); 6990{; 6991 R__LOCKGUARD(gInterpreterMutex);; 6992 if (fProperty != -1 && !fConvStreamerFunc &&; 6993 ( (fStreamerFunc == nullptr && strm != nullptr) || (fStreamerFunc != nullptr && strm == nullptr) ) ); 6994 {; 6995 fStreamerFunc = strm;; 6996 ; 6997 // Since initialization has already been done, make sure to tweak it; 6998 // for the new state.; 6999 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 7000 fStreamerType = kInstrumented;; 7001 fStreamerImpl = &TClass::StreamerInstrumented;; 7002 }; 7003 } else {; 7004 fStreamerFunc = strm;; 7005 }; 7006 fCanSplit = -1;; 7007}; 7008 ; 7009////////////////////////////////////////////////////////////////////////////////; 7010/// Set a wrapper/accessor function around this class custom conversion streamer.; 7011 ; 7012void TClass::SetConvStreamerFunc(ClassConvStreamerFunc_t strm); 7013{; 7014 R__LOCKGUARD(gInterpreterMutex);; 7015 if (fProperty != -1 &&; 7016 ( (fConvStreamerFunc == nullptr && strm != nullptr) || (fConvStreamerFunc != nullptr && strm == nullptr) ) ); 7017 {; 7018 fConvStreamerFunc = strm;; 7019 ; 7020 // Since initialization has already been done, make sure to tweak it; 7021 // for the new state.; 7022 if (HasInterpreterInfo() && fStreamerType != kTObject && !fStreamer) {; 7023 fStreamerType = kInstrumented;; 7024 fStreamerImpl = &TClass::ConvStreamerInstrumented;; 7025 }; 7026 } else {; 7027 fConvStreamerFunc = strm;; 7028 }; 7029 fCanSplit = -1;; 7030}; 7031 ; 7032 ; 7033////////////////////////////////////////////////////////////////////////////////; 703",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:269199,access,accessor,269199,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['access'],['accessor']
Security,"d-only TFile except that it is being read via a HTTP server. Make sure url is a valid TUrl object. The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell variable. The proxy can be specified as (in sh, or equivalent csh): export http_proxy=http://pcsalo.cern.ch:3128 The proxy can also be specified via the static method TWebFile::SetProxy(). Basic authentication (AuthType Basic) is supported. The user name and passwd can be specified in the url like this: http://username:mypasswd@pcsalo.cern.ch/files/aap.root If the file specified in the URL does not exist or is not accessible the kZombie bit will be set in the TWebFile object. Use IsZombie() to see if the file is accessible. ; Definition at line 181 of file TWebFile.cxx. ◆ ~TWebFile(). TWebFile::~TWebFile ; (; ). virtual . Cleanup. ; Definition at line 199 of file TWebFile.cxx. Member Function Documentation. ◆ BasicAuthentication(). TString TWebFile::BasicAuthentication ; (; ). protectedvirtual . Return basic authentication scheme, to be added to the request. ; Definition at line 1385 of file TWebFile.cxx. ◆ CheckProxy(). void TWebFile::CheckProxy ; (; ). protectedvirtual . Check if shell var ""http_proxy"" has been set and should be used. ; Definition at line 353 of file TWebFile.cxx. ◆ Class(). static TClass * TWebFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TWebFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TWebFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 95 of file TWebFile.h. ◆ Close(). void TWebFile::Close ; (; Option_t * ; option = """"). overridevirtual . Close a Web file. ; Close the socket connection and delete the cache See also the TFile::Close() function ; Reimplemented from TFile.; Definition at line 412 of file TWebFile.cxx. ◆ DeclFileName(). static const char * TWebFile::DeclFileName ; (; ). inlinestatic . ReturnsName of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:45790,authenticat,authentication,45790,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['authenticat'],['authentication']
Security,"d. ;  ; static const char * DeclFileName ();  ; static void DecodeNameCycle (const char *namecycle, char *name, Short_t &cycle, const size_t namesize=0);  Decode a namecycle ""aap;2"" into name ""aap"" and cycle ""2"". ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void InternalAppend (TObject *obj);  Internal access to TDirectory append method. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.) ;  ; void InitDirectoryFile (TClass *cl=nullptr);  Initialize the key associated with this directory (and the related data members. ;  ;  Protected Member Functions inherited from TDirectory;  TDirectory (const TDirectory &directory)=delete;  ; void BuildDirectory (TFile *motherFile, TDirectory *motherDir);  Initialise directory to defaults. ;  ; Bool_t cd1 (const char *path);  flag to add histograms, graphs,etc to the directory ;  ; void CleanTargets ();  Clean the pointers to this object (gDirectory, TContext, etc.). ;  ; void FillFullPath (TString &buf) const;  Recursive method to fill full path for directory. ;  ; void operator= (const TDirectory &)=delete;  ; void Register",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace_1_1WSDir.html:19226,access,access,19226,doc/master/classRooWorkspace_1_1WSDir.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace_1_1WSDir.html,1,['access'],['access']
Security,"d. Also see RResultPtr. Examples; See this tutorial for an example implementation of an action helper.; It is also possible to inspect the code used by built-in RDataFrame actions at ActionHelpers.hxx. ; Definition at line 2984 of file RInterface.hxx. ◆ Cache() [1/4]. template<typename Proxied , typename DataSource = void> . template<typename... ColumnTypes> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; const ColumnNames_t & ; columnList). inline . Save selected columns in memory. ; Template Parameters. ColumnTypesvariadic list of branch/column types. . Parameters. [in]columnListcolumns to be cached in memory. . Returnsa RDataFrame that wraps the cached dataset.; This action returns a new RDataFrame object, completely detached from the originating RDataFrame. The new dataframe only contains the cached columns and stores their content in memory for fast, zero-copy subsequent access.; Use Cache if you know you will only need a subset of the (Filtered) data that fits in memory and that will be accessed many times.; NoteCache will refuse to process columns with names of the form #columnname. These are special columns made available by some data sources (e.g. RNTupleDS) that represent the size of column columnname, and are not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an Alias(): df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""}). Example usage:; Types and columns specified: auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; double; Types inferred and columns specified (this invocation relies on jitting): auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; Types inferred and columns selected with a regexp (this invocation relies on jitting): auto cache_all_cols_df = df.Cache(myRegexp);. Definition at line 1459 of file RInterface.hxx. ◆ Cache() [2/4]. template<typename Proxied , typename DataSource = void> . RInterface< RL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:42504,access,accessed,42504,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['access'],['accessed']
Security,"d. Bool_t ExecuteHttp(THttpCallArg* arg); Executes http request, specified in THttpCallArg structure; Method can be called from any thread; Actual execution will be done in main ROOT thread, where analysis code is running. void ProcessRequests(); Process requests, submitted for execution; Regularly invoked by THttpTimer, when somewhere in the code; gSystem->ProcessEvents() is called.; User can call serv->ProcessRequests() directly, but only from main analysis thread. void ProcessRequest(THttpCallArg* arg); Process single http request; Depending from requested path and filename different actions will be performed.; In most cases information is provided by TRootSniffer class. Bool_t Register(const char* subfolder, TObject* obj); Register object in folders hierarchy. See TRootSniffer::RegisterObject() for more details. Bool_t Unregister(TObject* obj); Unregister object in folders hierarchy. See TRootSniffer::UnregisterObject() for more details. void Restrict(const char* path, const char* options); Restrict access to specified object. See TRootSniffer::Restrict() for more details. Bool_t RegisterCommand(const char* cmdname, const char* method, const char* icon = 0); Register command which can be executed from web interface. As method one typically specifies string, which is executed with; gROOT->ProcessLine() method. For instance; serv->RegisterCommand(""Invoke"",""InvokeFunction()"");. Or one could specify any method of the object which is already registered; to the server. For instance:; serv->Register(""/"", hpx);; serv->RegisterCommand(""/ResetHPX"", ""/hpx/->Reset()"");; Here symbols '/->' separates item name from method to be executed. One could specify additional arguments in the command with; syntax like %arg1%, %arg2% and so on. For example:; serv->RegisterCommand(""/ResetHPX"", ""/hpx/->SetTitle(\""%arg1%\"")"");; serv->RegisterCommand(""/RebinHPXPY"", ""/hpxpy/->Rebin2D(%arg1%,%arg2%)"");; Such parameter(s) will be requested when command clicked in the browser. Once command is re",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpServer.html:13179,access,access,13179,root/html534/THttpServer.html,https://root.cern,https://root.cern/root/html534/THttpServer.html,2,['access'],['access']
Security,"d. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSniffer(const char* name, const char* objpath = ""Objects""); constructor. ~TRootSniffer(); destructor. void SetCurrentCallArg(THttpCallArg* arg); set current http arguments, which then used in different process methods; For instance, if user authorized with some user name,; depending from restrictions some objects will be invisible; or user get full access to the element. void Restrict(const char* path, const char* options); Restrict access to the specified location. Hides or provides read-only access to different parts of the hierarchy; Restriction done base on user-name specified with http requests; Options can be specified in URL style (separated with &); Following parameters can be specified:; visible = [all|user(s)] - make item visible for all users or only specified user; hidden = [all|user(s)] - make item hidden from all users or only specified user; readonly = [all|user(s)] - make item read-only for all users or only specified user; allow = [all|user(s)] - make full access for all users or only specified user; allow_method = method(s) - allow method(s) execution even when readonly flag specified for the object; Like make command seen by all but can be executed only by admin; sniff->Restrict(""/CmdReset"",""allow=admin"");; Or fully hide command from guest account; sniff->Restrict(""/CmdRebin"",""hidden=guest"");. Bool_t HasRestriction(const char* item_name); Made fast check if item with specified name is in restriction list; If returns true, requires precise check with CheckRestriction() method. Int_t WithCurrentUserName(const char* option); return 2 when option match to current user name; return 1 when option==all; return 0 when option does not match user name. Int_t CheckRestriction(const char* item_name); Checked if restriction is applied to the item; full_item_name should have full path to the item. Returns -1 - object invisible, cannot be accessed or listed; 0 - no ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootSniffer.html:10275,access,access,10275,root/html604/TRootSniffer.html,https://root.cern,https://root.cern/root/html604/TRootSniffer.html,2,['access'],['access']
Security,"d. Note that if a parameter is dropped or keeps its old name, its old value will be copied to the new function. The syntax used in the examples above also applies to the predefined parametrized functions like gaus and expo.; Comparisons operators are also supported (&amp;&amp;, ||, ==, &lt;=, &gt;=, !); Examples:; sin(x*(x&lt;0.5 || x&gt;1)); If the result of a comparison is TRUE, the result is 1, otherwise 0.; Already predefined names can be given. For example, if the formula; TFormula old(""old"",sin(x*(x&lt;0.5 || x&gt;1))); one can assign a name to the formula. By default the name of the object = title = formula itself.; TFormula new(""new"",""x*old""); is equivalent to:; TFormula new(""new"",""x*sin(x*(x&lt;0.5 || x&gt;1))""); The class supports unlimited number of variables and parameters. By default the names which can be used for the variables are x,y,z,t or x[0],x[1],x[2],x[3],....x[N] for N-dimensional formulas.; This class is not anymore the base class for the function classes TF1, but it has now a data member of TF1 which can be accessed via TF1::GetFormula.; TFormula supports gradient and hessian calculations through clad. To calculate the gradient one needs to first declare a CladStorage of the same size as the number of parameters and then pass the variables and the created CladStorage:; TFormula f(""f"", ""x*[0] - y*[1]"");; Double_t p[] = {40, 30};; Double_t x[] = {1, 2};; f.SetParameters(p);; TFormula::CladStorage grad(2);; f.GradientPar(x, grad);; f#define f(i)Definition RSha256.hxx:104; Double_tdouble Double_tDefinition RtypesCore.h:59; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFormulaThe Formula class.Definition TFormula.h:89; TFormula::CladStoragestd::vector< Double_t > CladStorageDefinition TFormula.h:184; double; xDouble_t x[n]Definition legend1.C:17; The process is similar for hessians, except that the size of the created CladStorage should be the square of the number of parameters because HessianPar returns a f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormula.html:3453,access,accessed,3453,doc/master/classTFormula.html,https://root.cern,https://root.cern/doc/master/classTFormula.html,1,['access'],['accessed']
Security,"d. char * At(int index); Returns class at index from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc.; Returns 0 if index points beyond last class name. int Classes(). { return fgTally; }. void Init(); { fgCursor = 0; SortTable(); }. void Add(const char* cname, Version_t id, const type_info& info, VoidFuncPtr_t dict, Int_t pragmabits); Add a class to the class table (this is a static function). void Remove(const char* cname); Remove a class from the class table. This happens when a shared library; is unloaded (i.e. the dtor's of the global init objects are called). TClassRec * FindElementImpl(const char* cname, Bool_t insert); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. TClassRec * FindElement(const char* cname, Bool_t insert = kFALSE); Find a class by name in the class table (using hash of name). Returns; 0 if the class is not in the table. Unless arguments insert is true in; which case a new entry is created and returned. Version_t GetID(const char* cname); Returns the ID of a class. Int_t GetPragmaBits(const char* name); Returns the pragma bits as specified in the LinkDef.h file. VoidFuncPtr_t GetDict(const char* cname); Given the class name returns the Dictionary() function of a class; (uses hash of name). VoidFuncPtr_t GetDict(const type_info& info); Given the type_info returns the Dictionary() function of a class; (uses hash of type_info::name()). char * Next(); Returns next class from sorted class table. Don't use this iterator; while modifying the class table. The class table can be modified; when making calls like TClass::GetClass(), etc. void PrintTable(); Print the class table. Before printing the table is sorted; alphabetically. void SortTable(); Sort the class table by ascending class ID's. void Termi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClassTable.html:7662,hash,hash,7662,root/html528/TClassTable.html,https://root.cern,https://root.cern/root/html528/TClassTable.html,4,['hash'],['hash']
Security,"d.; 39This signal could be connected to some garbage-collector object.; 40 ; 41~~~ {.cpp}; 42 ChangedBy(const char *method_name); 43~~~; 44This signal is emitted when some important data members of; 45the object were changed. method_name parameter can be used; 46as an identifier of the modifier method.; 47 ; 48~~~ {.cpp}; 49 Message(const char *msg); 50~~~; 51 ; 52General purpose message signal; 53*/; 54 ; 55#include ""TQObject.h""; 56#include ""TQConnection.h""; 57#include ""THashList.h""; 58#include ""TPRegexp.h""; 59#include ""TROOT.h""; 60#include ""TBuffer.h""; 61#include ""TClass.h""; 62#include ""TMethod.h""; 63#include ""TBaseClass.h""; 64#include ""TDataType.h""; 65#include ""TInterpreter.h""; 66#include ""TQClass.h""; 67#include ""TError.h""; 68#include <iostream>; 69#include ""RQ_OBJECT.h""; 70#include ""TVirtualMutex.h""; 71#include ""RConfigure.h""; 72#include ""strlcpy.h""; 73 ; 74void *gTQSender; // A pointer to the object that sent the last signal.; 75 // Getting access to the sender might be practical; 76 // when many signals are connected to a single slot.; 77 ; 78Bool_t TQObject::fgAllSignalsBlocked = kFALSE;; 79 ; 80 ; 81ClassImpQ(TQObject); 82ClassImpQ(TQObjSender); 83ClassImpQ(TQClass); 84 ; 85////////////////////////////////////////////////////////////////////////////////; 86/// Removes ""const"" words and blanks from full (with prototype); 87/// method name and resolve any typedefs in the method signature.; 88/// If a null or empty string is passed in, an empty string; 89/// is returned.; 90///; 91/// Example:; 92/// ~~~ {.cpp}; 93/// CompressName("" Draw(const char *, const char *,; 94/// Option_t * , Int_t , Int_t)"");; 95/// ~~~; 96/// returns the string ""Draw(char*,char*,char*,int,int)"".; 97 ; 98TString TQObject::CompressName(const char *method_name); 99{; 100 TString res(method_name);; 101 if (res.IsNull()); 102 return res;; 103 ; 104 {; 105 static TVirtualMutex * lock = nullptr;; 106 R__LOCKGUARD2(lock);; 107 ; 108 static TPMERegexp *constRe = nullptr, *wspaceRe = nullptr;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:2780,access,access,2780,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['access'],['access']
Security,"d::ostream &output);  Write down the sources. ;  ; void WriteReadRawRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for ReadRaw rule, the function name is being written to rule[""funcname""]. ;  ; void WriteReadRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for Read rule, the function name is being written to rule[""funcname""]. ;  ; void WriteSchemaList (std::list< SchemaRuleMap_t > &rules, const std::string &listName, std::ostream &output);  Write schema rules. ;  . Variables; R__EXTERN TVirtualRWMutex * gCoreMutex = nullptr;  ; R__EXTERN SchemaRuleClassMap_t gReadRawRules;  ; R__EXTERN SchemaRuleClassMap_t gReadRules;  . Detailed Description; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; TBranchProxyDirector This class is used to 'drive' and hold a serie of TBranchProxy objects which represent and give access to the content of TTree object.; Namespace for new ROOT classes and functions.; Base class for iterating of hierarchical structure.; VSD Structures.; This is intended to be used as part of a generate Selector class which will hold the directory and its associate ; Typedef Documentation. ◆ ColumnNamesPtr_t. using ROOT::ColumnNamesPtr_t = typedef std::shared_ptr<const ColumnNames_t>. Definition at line 997 of file RDataFrame.cxx. ◆ DelArrFunc_t. typedef void(* ROOT::DelArrFunc_t) (void *). Definition at line 111 of file Rtypes.h. ◆ DelFunc_t. typedef void(* ROOT::DelFunc_t) (void *). Definition at line 110 of file Rtypes.h. ◆ DesFunc_t. typedef void(* ROOT::DesFunc_t) (void *). Definition at line 112 of file Rtypes.h. ◆ DirAutoAdd_t. typedef void(* ROOT::DirAutoAdd_t) (void *, TDirectory *). Definition at line 113 of file Rtypes.h. ◆ Double_v. using ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/namespaceROOT.html:12207,access,access,12207,doc/v624/namespaceROOT.html,https://root.cern,https://root.cern/doc/v624/namespaceROOT.html,1,['access'],['access']
Security,"d::vector< Event * > * ; events, . Types::ETreeType ; type, . Bool_t ; deleteEvents = true . ). Sets the event collection (by DataSetFactory) ; Definition at line 250 of file DataSet.cxx. ◆ SetVerbose(). void TMVA::DataSet::SetVerbose ; (; Bool_t ; ). inline . Definition at line 112 of file DataSet.h. ◆ Streamer(). virtual void TMVA::DataSet::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMVA::DataSet::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 175 of file DataSet.h. ◆ TreeIndex(). UInt_t TMVA::DataSet::TreeIndex ; (; Types::ETreeType ; type); const. inline . Definition at line 181 of file DataSet.h. Member Data Documentation. ◆ fBlockBelongToTraining. std::vector<Char_t> TMVA::DataSet::fBlockBelongToTraining. private . when dividing the dataset to blocks, sets whether the certain block is in the Training set or else in the validation set boolean are stored, taken std::vector<Char_t> for performance reasons (instead of std::vector<Bool_t>) ; Definition at line 165 of file DataSet.h. ◆ fClassEvents. std::vector< std::vector<Long64_t> > TMVA::DataSet::fClassEvents. private . number of events of class 0,1,2,... in training[0] and testing[1] (+validation, trainingoriginal) ; Definition at line 158 of file DataSet.h. ◆ fCurrentEventIdx. Long64_t TMVA::DataSet::fCurrentEventIdx. mutableprivate . Definition at line 146 of file DataSet.h. ◆ fCurrentTreeIdx. UInt_t TMVA::DataSet::fCurrentTreeIdx. mutableprivate . Definition at line 145 of file DataSet.h. ◆ fdsi. const DataSetInfo* TMVA::DataSet::fdsi. private . -> datasetinfo that created this dataset ; Definition at line 139 of file DataSet.h. ◆ fEventCollection. std::vector< std::vector<Event*> > TMVA::DataSet::fEventCollection. private . list of events for training/testing/... ; Definition at line 141 of file DataSet.h. ◆ fHasNegativeEventWeights. Bool_t TMVA::DataSet::fHasNegativeEvent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DataSet.html:25215,validat,validation,25215,doc/master/classTMVA_1_1DataSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DataSet.html,1,['validat'],['validation']
Security,"d; 586 I : integral of bins with option ""width"" printed; 587 o : number of overflows printed; 588 u : number of underflows printed; 589 r : standard deviation printed; 590 R : standard deviation and standard deviation error printed; 591 m : mean value printed; 592 M : mean value mean error values printed; 593 e : number of entries printed; 594 n : name of histogram is printed; 595 ; 596For example, to print only name of histogram and number of entries do:; 597 ; 598 gStyle->SetOptStat(""ne"");; 599 ; 600To print only the name of the histogram do:; 601 ; 602 gStyle->SetOptStat(""n"");; 603 ; 604The default value is:; 605 ; 606 gStyle->SetOptStat(""nemr"");; 607 ; 608When a histogram is painted, a `TPaveStats` object is created and added; 609to the list of functions of the histogram. If a `TPaveStats` object; 610already exists in the histogram list of functions, the existing object is just; 611updated with the current histogram parameters.; 612 ; 613Once a histogram is painted, the statistics box can be accessed using; 614`h->FindObject(""stats"")`. In the command line it is enough to do:; 615 ; 616 Root > h->Draw(); 617 Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); 618 ; 619because after `h->Draw()` the histogram is automatically painted. But; 620in a script file the painting should be forced using `gPad->Update()`; 621in order to make sure the statistics box is created:; 622 ; 623 h->Draw();; 624 gPad->Update();; 625 TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");; 626 ; 627Without `gPad->Update()` the line `h->FindObject(""stats"")` returns a null pointer.; 628 ; 629When a histogram is drawn with the option `SAME`, the statistics box; 630is not drawn. To force the statistics box drawing with the option; 631`SAME`, the option `SAMES` must be used.; 632If the new statistics box hides the previous statistics box, one can change; 633its position with these lines (`h` being the pointer to the histogram):; 634 ; 635 Root > TPaveStats *st = (TPaveStats*)h->Find",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:27649,access,accessed,27649,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['access'],['accessed']
Security,"d; executable containing the modified Library. (It is understood; that the user who changes the contents of definitions files in the; Library will not necessarily be able to recompile the application; to use the modified definitions.). b) Use a suitable shared library mechanism for linking with the; Library. A suitable mechanism is one that (1) uses at run time a; copy of the library already present on the user's computer system,; rather than copying library functions into the executable, and (2); will operate properly with a modified version of the library, if; the user installs one, as long as the modified version is; interface-compatible with the version that the work was made with. c) Accompany the work with a written offer, valid for at; least three years, to give the same user the materials; specified in Subsection 6a, above, for a charge no more; than the cost of performing this distribution. d) If distribution of the work is made by offering access to copy; from a designated place, offer equivalent access to copy the above; specified materials from the same place. e) Verify that the user has already received a copy of these; materials or that you have already sent this user a copy. For an executable, the required form of the ""work that uses the; Library"" must include any data and utility programs needed for; reproducing the executable from it. However, as a special exception,; the materials to be distributed need not include anything that is; normally distributed (in either source or binary form) with the major; components (compiler, kernel, and so on) of the operating system on; which the executable runs, unless that component itself accompanies; the executable. It may happen that this requirement contradicts the license; restrictions of other proprietary libraries that do not normally; accompany the operating system. Such a contradiction means you cannot; use both them and the Library together in an executable that you; distribute.; ; 7. You may place lib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:18665,access,access,18665,d/license.html,https://root.cern,https://root.cern/d/license.html,2,['access'],['access']
Security,d; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooCatType*_defCat; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooRealProxy_inputVar; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooThresholdCategory.html:22665,access,access,22665,root/html602/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html602/RooThresholdCategory.html,2,['access'],['access']
Security,"dBefore (TObjLink *before, TObject *obj) override;  Insert object before object before in the list. ;  ; void AddFirst (TObject *obj) override;  Add object at the beginning of the list. ;  ; void AddFirst (TObject *obj, Option_t *opt) override;  Add object at the beginning of the list and also store option. ;  ; void AddLast (TObject *obj) override;  Add object at the end of the list. ;  ; void AddLast (TObject *obj, Option_t *opt) override;  Add object at the end of the list and also store option. ;  ; void Clear (Option_t *option="""") override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Delete all TFunction object files. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const char *name) const override;  Specialize FindObject to do search for the a function just by name or create it if its not already in the list. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; TFunctionTemplate * Get (DeclId_t id);  Return (after creating it if necessary) the TMethod or TFunction describing the function corresponding to the Decl 'id'. ;  ; virtual TList * GetListForObject (const char *name) const;  Return the set of overloads for this name, collecting all available ones. ;  ; virtual TList * GetListForObject (const TObject *obj) const;  Return the set of overloads for function obj, collecting all available ones. ;  ; TClass * IsA () const override;  ; void Load ();  Load all the functions known to the interpreter for the scope 'fClass' into this collection. ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctionTemplates.html:2162,hash,hash,2162,doc/master/classTListOfFunctionTemplates.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctionTemplates.html,1,['hash'],['hash']
Security,"dConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const char * ; onfile_classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7193 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7204 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7066 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7036 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4772 of file TClass.cxx. ◆ ForceReload(). void TClass::ForceReload ; (; TClass * ; oldcl). we found at least one equivalent. ; let's force a reload ; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:67912,checksum,checksum,67912,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['checksum'],['checksum']
Security,"dConversionStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const char * ; onfile_classname, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. ; Definition at line 7260 of file TClass.cxx. ◆ FindConversionStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindConversionStreamerInfo ; (; const TClass * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7271 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7133 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7103 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4839 of file TClass.cxx. ◆ ForceReload(). void TClass::ForceReload ; (; TClass * ; oldcl). we found at least one equivalent. ; let's force a reload ; Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:67913,checksum,checksum,67913,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['checksum'],['checksum']
Security,"dExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fDirpdirectory handler. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSystem. ←; TWebSystem. Function documentation; TWebSystem(); Create helper class that allows directory access via httpd.; The name must start with '-' to bypass the TSystem singleton check. Int_t MakeDirectory(const char* name); Make a directory via httpd. Not supported. void * OpenDirectory(const char* name); Open a directory via httpd. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp); Free directory via httpd. const char * GetDirEntry(void* dirp); Get directory entry via httpd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Int_t Unlink(const char* path); Unlink, i.e. remove, a file or directory. Returns 0 when successful,; -1 in case of failure. Not supported for httpd. void * GetDirPtr() const; { return fDirp; }. TWebSystem(). virtual ~TWebSystem(); { }. » Author: Fons Rademakers 17/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebSystem.html:20591,access,access,20591,root/html602/TWebSystem.html,https://root.cern,https://root.cern/root/html602/TWebSystem.html,3,['access'],['access']
Security,"dServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); voidfixCoefNormalization(const RooArgSet& refCoefNorm); voidfixCoefRange(const char* rangeName); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:13879,hash,hash,13879,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,6,['hash'],['hash']
Security,"dServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); voidfixRefRange(const char* rangeName); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:14332,hash,hash,14332,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,3,['hash'],['hash']
Security,"dSetOptions(const ROOT::Math::MinimizerOptions& opt); voidSetPrecision(double prec); voidSetPrintLevel(int level); voidSetStrategy(int strategyLevel); voidSetTolerance(double tol); virtual boolSetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); voidSetValidError(bool on); virtual boolSetVariable(unsigned int ivar, const string& name, double val, double step); virtual boolSetVariableValue(unsigned int, double); virtual boolSetVariableValues(const double* x); intStatus() const; intStrategy() const; doubleTolerance() const; virtual intVariableIndex(const string&) const; virtual stringVariableName(unsigned int) const; virtual const double*X() const. private:. ROOT::Math::Minimizer&operator=(const ROOT::Math::Minimizer& rhs). Data Members; protected:. intfDebugprint level; unsigned intfMaxCallsmax number of function calls ; unsigned intfMaxItermax number or iterations used to find the minimum; doublefPrecprecision; intfStatusstatus of minimizer ; intfStrategyminimizer strategy; doublefToltolerance (absolute); doublefUperror scale ; boolfValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~Minimizer(). Destructor (no operations). {}. void Clear(); reset for consecutive minimizations - implement if needed. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set a function to minimize using gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). return SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetUpperLimited",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__Minimizer.html:4333,validat,validated,4333,root/html528/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__Minimizer.html,3,['validat'],['validated']
Security,"dSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::GetEditorModeInt_t GetEditorMode() constDefinition TROOT.h:219; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function is called by the SavePrimitive functions ...Definition TROOT.cxx:1083; TROOT::GetGitCommitconst char * GetGitCommit() constDefinition TROOT.h:223; TROOT::fGitBranchTString fGitBranchGit branch.Definition TROOT.h:121; TROOT::GetListOfTypesTCollection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::GetListOfTasksTSeqCollection * GetListOfTasks() constDefinition TROOT.h:247; TROOT::IsBatchBool_t IsBatch() constDefinition TROOT.h:279; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IsWebDisplayBool_t IsWebDisplay() constDefinition TROOT.h:287; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2891; TROOT::GetVersionTimeInt_t GetVersionTime() constDefinition TROOT.h:227; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:44842,access,access,44842,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['access'],['access']
Security,"dSpecialObjectTObject * FindSpecialObject(const char *name, void *&where)Returns address and folder of a ROOT object if it exists.Definition TROOT.cxx:1367; TROOT::RemoveTObject * Remove(TObject *) overrideRemove an object from the in-memory list.Definition TROOT.cxx:2618; TROOT::InitSystemvoid InitSystem()Operating System interface.Definition TROOT.cxx:1978; TROOT::ProcessLineFastLongptr_t ProcessLineFast(const char *line, Int_t *error=nullptr)Process interpreter command directly via CINT interpreter.Definition TROOT.cxx:2407; TROOT::GetEditorModeInt_t GetEditorMode() constDefinition TROOT.h:219; TROOT::ClassSavedBool_t ClassSaved(TClass *cl)return class status 'ClassSaved' for class cl This function is called by the SavePrimitive functions ...Definition TROOT.cxx:1083; TROOT::GetGitCommitconst char * GetGitCommit() constDefinition TROOT.h:223; TROOT::fGitBranchTString fGitBranchGit branch.Definition TROOT.h:121; TROOT::GetListOfTypesTCollection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::GetListOfTasksTSeqCollection * GetListOfTasks() constDefinition TROOT.h:247; TROOT::IsBatchBool_t IsBatch() constDefinition TROOT.h:279; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IsWebDisplayBool_t IsWebDisplay() constDefinition TROOT.h:287; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::GetVersionTimeInt_t GetVersionTime() constDefinition TROOT.h:227; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3082; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:44841,access,access,44841,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['access'],['access']
Security,"dTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteDirectiveOutput() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetCurrentClass() const; voidGetCurrentModule(TString& out_module) const; const TList*GetDataMembers(TDocParser::EAccess access) const; TDocOutput*GetDocOutput() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const TList*GetEnums(TDocParser::EAccess access) const; virtual const char*TObject::GetIconName() const; Long_tGetLineNumber() const; const TList*GetMethods(TDocParser::EAccess access) const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetSourceInfo(TDocParser::ESourceInfo type) const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; UInt_tInContext(Int_t context) const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDocParser.html:2980,access,access,2980,root/html528/TDocParser.html,https://root.cern,https://root.cern/root/html528/TDocParser.html,5,['access'],['access']
Security,"dTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Int_tFindElement(ULong64_t hash, Long64_t key); voidFixCollisions(Int_t index); Bool_tHighWaterMark(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TExMap.html:6301,hash,hash,6301,root/html528/TExMap.html,https://root.cern,https://root.cern/root/html528/TExMap.html,4,['hash'],['hash']
Security,"dTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = 0) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*TClass::GetCurrentStreamerInfo(); TDataMember*TC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQClass.html:6611,checksum,checksum,6611,root/html528/TQClass.html,https://root.cern,https://root.cern/root/html528/TQClass.html,3,['checksum'],['checksum']
Security,"dTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Int_tTClass::GetClassSize() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQClass.html:6614,checksum,checksum,6614,root/html534/TQClass.html,https://root.cern,https://root.cern/root/html534/TQClass.html,1,['checksum'],['checksum']
Security,"data analysis of the CDF experiments and online software for the ATLAS experiment. In 2002 he joined the physics application software group of CERN, and since 2005 he joined the ROOT team with the responsibility of the Math work package, which provides development and support for the ROOT mathematical and statistical libraries. ; ; . Oksana Shadura ; ; Currently, I am employed as a software developer from the University of Nebraska-Lincoln (CMS), based at CERN and working as a core developer in the ROOT framework. My area of research is a various improvement for ROOT I/O, particularly ROOT compression algorithms. Another area of investigation is work on improved ROOT modularity for the build system. I was involved in support of C++ modules in ROOT and performance benchmarking of ROOT.; I did my doctoral studies in Simulation group at CERN, working in GeantV project (EP-SFT, CERN). Previous work experience was a long term work in Ukrainian Grid Initiative on various positions, including responsibilities on grid sites management and experiment support, administration, and security management.; ; . Olivier Couet ; ; Olivier Couet received a Physic's Master from the  Strasbourg University and a Master’s Degree in Engineering from the ""Ecole Nationale Supérieure de Physique de Strasbourg"" (ENSPS) on work in computer graphics and image processing in 1985. He then performed his Ph.D work (in Computer Graphics) at the ""Laboratoire D'Annecy le Vieux de Physique des Particules"" (LAPP) on the PAW project. He has been employed by CERN since 1988. He was one of the main authors of the PAW system, more precisely its graphical components (HIGZ and HPLOT). HIGZ has been the standard graphics package in High Energy Physics for years and is still being used. He was responsible for the PAW system from 1995 until he joined the ROOT team in 2002 and took responsibility of the graphics work package.; ; . Philippe Canal ; ; Philippe Canal has been working in the FNAL Computing Division si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/team.html:8033,secur,security,8033,d/team.html,https://root.cern,https://root.cern/d/team.html,1,['secur'],['security']
Security,"data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.9.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one could produce images with requests: root.png, root.gif, root.jpeg. For example:; [shell] wget ""http://localhost:8080/Files/hsimple.root/hpx/root.png?w=500&h=500&opt=lego1"" -O lego1.png; For all such requests following parameters could be specified:. h - image height; w - image width; opt - draw options. 1.9.3 Methods execution; By default THttpServer starts in monitoring (read-only) mode and therefore forbid any methods execution. One could specify read-write mode when server is started:; auto serv = new THttpServer(""http:8080;rw"");; Or one could disable read-only mode with the call:; serv->SetReadOnly(kFALSE);; Or one could allow access to the folder, object or specific object methods with:; serv->Restrict(""/Histograms"", ""allow=admin""); // allow full access for user with 'admin' account; serv->Restrict(""/Histograms/hist1"", ""allow=all""); // allow full access for all users; serv->Restrict(""/Histograms/hist1"", ""allow_method=Rebin""); // allow only Rebin method; ‘exe.json’ accepts following parameters:. method - name of method to execute; prototype - method prototype (see TClass::GetMethodWithPrototype for details); compact - compact parameter, used to compress return value; _ret_object_ - name of the object which should be returned as result of method execution (used together with remote TTree::Draw call). Example of retrieving object title:; [shell] wget 'http://localhost:8080/Objects/subfolder/obj/exe.json?method=GetTitle' -O title.json; Example of TTree::Draw method execution:; [shell] wget 'http://localhost:8080/Files/job1.root/ntuple/exe.json?method=Draw&prototype=""Option_t*""&opt=""px:py>>h1""&_ret_object_=h1' -O exe.json; One also used exe.bin method - in this case results of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:17524,access,access,17524,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,3,['access'],['access']
Security,date contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:40384,access,access,40384,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,1,['access'],['access']
Security,dateElements ();  Update element flags when geometry is loaded from a file. ;  ; void Voxelize (Option_t *option=nullptr);  Voxelize all non-divided volumes. ;  . Private Attributes; Bool_t fActivity;  flag for GL reflections ;  ; TObjArray * fArrayPNE;  ; UChar_t * fBits;  ; TObjArray * fBorderSurfaces;  ; TGeoShape * fClippingShape;  ; Bool_t fClosed;  ; TGeoNavigator * fCurrentNavigator;  Lock existing navigators. ;  ; TVirtualGeoTrack * fCurrentTrack;  ; TGeoVolume * fCurrentVolume;  current navigator ;  ; Bool_t fDrawExtra;  ; TGeoElementTable * fElementTable;  clipping shape for raytracing ;  ; Int_t fExplodedView;  ; TObjArray * fGDMLMatrices;  ; TGeoHMatrix * fGLMatrix;  ; TObjArray * fGShapes;  ; TObjArray * fGVolumes;  list of runtime shapes ;  ; THashList * fHashGVolumes;  hash list of volumes providing fast search ;  ; THashList * fHashPNE;  hash list of group volumes providing fast search ;  ; THashList * fHashVolumes;  ; Bool_t fIsGeomCleaning;  flag set when reading geometry ;  ; Bool_t fIsGeomReading;  ; Bool_t fIsNodeSelectable;  switch ON/OFF volume activity (default OFF - all volumes active)) ;  ; Int_t * fKeyPNEId;  ; Bool_t fLoopVolumes;  flag that geometry is closed ;  ; TGeoVolume * fMasterVolume;  top physical node ;  ; TList * fMaterials;  ; TObjArray * fMatrices;  current painter ;  ; Bool_t fMatrixReflection;  flag for using GL matrix ;  ; Bool_t fMatrixTransform;  flag that the list of physical nodes has to be drawn ;  ; Int_t fMaxThreads;  ; Int_t fMaxVisNodes;  ; TList * fMedia;  ; Bool_t fMultiThread;  Max number of threads. ;  ; NavigatorsMap_t fNavigators;  ; Int_t fNLevel;  table of elements ;  ; Int_t fNNodes;  upper time limit for tracks drawing ;  ; TObjArray * fNodes;  ; Int_t fNpdg;  current track ;  ; Int_t fNPNEId;  ; Int_t fNsegments;  ; Int_t fNtracks;  ; TObjArray * fOpticalSurfaces;  ; TObjArray * fOverlaps;  ; TVirtualGeoPainter * fPainter;  flag that nodes are the selected objects in pad rather than volumes ;  ; TGeoVolu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:64123,hash,hash,64123,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,2,['hash'],['hash']
Security,"dated.; 1.3 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call. When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"", ""/rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.4 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one should create a password file, using the htdigest utility.; [shell] htdigest -c .htdigest domain_name user_name; It is recommended not to use special symbols in domain or user names. Several users can be add to the “.htdigetst” file. When starting the server, the following arguments should be specified:; root [0] new THttpServer(""http:8080?auth_file=.htdigest&auth_domain=domain_name"");; After that, the web browser will automatically request to input a name/password for the domain “domain_name”; Based on authorized accounts, one could restrict or enable access to some elements in the server objects hierarchy, using THttpServer::Restrict() method.; For instance, one could hide complete folder from ‘guest’ account:; root [6] serv->Restrict(""/Folder"", ""hidden=guest"");; Or one could hide from all but ‘admin’ account:; root [7] serv->Restrict(""/Folder"", ""visible=admin"");; Hidden folders or objects can not be accessed via http protocol.;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:4182,access,access,4182,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,2,"['access', 'authenticat']","['access', 'authenticated']"
Security,"ddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo( const char* classname, Int_t version ); Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo( const TClass* cl, Int_t version ); Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo( const char* classname, UInt_t checksum ); Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ); Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default constructor. ROOT::NewFunc_t GetNew() const; Return the wrapper around new ThisClass(). ROOT::NewArrFunc_t GetNewArray() const; Return the wrapper around new ThisClass[]. ROOT::DelFunc_t GetDelete() const; Return the wrapper around delete ThiObject. ROOT::DelArrFunc_t GetDeleteArray() const; Return the wrapper around delete [] ThiObject. ROOT::DesFunc_t GetDestructor() const; Return the wrapper around the destructor. ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const; Return the wrapper around the directory auto add function. void SetClassSize(Int_t sizof); { fSizeof = sizof; }. void AddIns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:40961,checksum,checksum,40961,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,2,['checksum'],['checksum']
Security,"ddRecord(bool fromFile=false)Add a record.Definition TTVSession.cxx:161; TTVSession::PreviousTTVRecord * Previous()Definition TTVSession.h:97; TTVSession::GetEntriesInt_t GetEntries()Definition TTVSession.h:91; TTVSession::FirstTTVRecord * First()Definition TTVSession.h:94; TTVSession::RemoveLastRecordvoid RemoveLastRecord()Remove current record from list.Definition TTVSession.cxx:224; TTVSession::NextTTVRecord * Next()Definition TTVSession.h:96; TTVSession::UpdateRecordvoid UpdateRecord(const char *name)Updates current record according to new X, Y, Z settings.Definition TTVSession.cxx:272; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::TurnOffvirtual void TurnOff()Remove timer from system timer list.Definition TTimer.cxx:231; TTimer::TurnOnvirtual void TurnOn()Add the timer to the system timer list.Definition TTimer.cxx:243; TTimer::Resetvoid Reset()Reset the timer.Definition TTimer.cxx:159; TTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram...Definition TTreePlayer.h:37; TTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features.Definition TTreeViewer.h:54; TTreeViewer::SetScanRedirectvoid SetScanRedirect(bool mode); TTreeViewer::fBarLbl2TGLabel * fBarLbl2Label of option text entry.Definition TTreeViewer.h:130; TTreeViewer::fDialogBoxTGSelectBox * fDialogBoxExpression editor.Definition TTreeViewer.h:87; TTreeViewer::SetCurrentRecordvoid SetCurrentRecord(Long64_t entry); TTreeViewer::fBarRecTGCheckButton * fBarRecCommand recording toggle.Definition TTreeViewer.h:134; TTreeViewer::fProgressBarTGHProgressBar * fProgressBarProgress bar.Definition TTreeViewer.h:152; TTreeViewer::HandleTimerbool HandleTimer(TTimer *timer) overrideExecute action in response of a timer timing out.; TTreeViewer::SetHistogramTitlevoid SetHistogramTitle(const char *title); TTreeViewer::Ezconst char * Ez(); TTreeViewer::UpdateRecordvoid U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:140128,access,access,140128,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['access'],['access']
Security,"de <TFile.h>; #include <TNtuple.h>; #include <TH2.h>; #include <TProfile.h>; #include <TCanvas.h>; #include <TFrame.h>; #include <TROOT.h>; #include <TSystem.h>; #include <TRandom3.h>; #include <TBenchmark.h>; #include <TInterpreter.h>; ; TFile *hsimple(Int_t getFile=0); {; TString filename = ""hsimple.root"";; TString dir = gROOT->GetTutorialDir();; dir.ReplaceAll(""/./"",""/"");; TFile *hfile = nullptr;; if (getFile) {; // if the argument getFile =1 return the file ""hsimple.root""; // if the file does not exist, it is created; TString fullPath = dir+""hsimple.root"";; if (!gSystem->AccessPathName(fullPath,kFileExists)) {; hfile = TFile::Open(fullPath); //in $ROOTSYS/tutorials; if (hfile) return hfile;; }; //otherwise try $PWD/hsimple.root; if (!gSystem->AccessPathName(""hsimple.root"",kFileExists)) {; hfile = TFile::Open(""hsimple.root""); //in current dir; if (hfile) return hfile;; }; }; //no hsimple.root file found. Must generate it !; //generate hsimple.root in current directory if we have write access; if (gSystem->AccessPathName(""."",kWritePermission)) {; printf(""you must run the script in a directory with write access\n"");; return nullptr;; }; hfile = (TFile*)gROOT->FindObject(filename); if (hfile) hfile->Close();; hfile = new TFile(filename,""RECREATE"",""Demo ROOT file with histograms"");; ; // Create some histograms, a profile histogram and an ntuple; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; hpx->SetFillColor(48);; TH2F *hpxpy = new TH2F(""hpxpy"",""py vs px"",40,-4,4,40,-4,4);; TProfile *hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; TNtuple *ntuple = new TNtuple(""ntuple"",""Demo ntuple"",""px:py:pz:random:i"");; ; gBenchmark->Start(""hsimple"");; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; c1->SetFillColor(42);; c1->GetFrame()->SetFillColor(21);; c1->GetFrame()->SetBorderSize(6);; c1->GetFrame()->SetBorderMode(-1);; ; ; // Fill histograms randomly; TRandom3 randomNum;; Floa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8C.html:1742,access,access,1742,doc/master/hsimple_8C.html,https://root.cern,https://root.cern/doc/master/hsimple_8C.html,1,['access'],['access']
Security,"de;  List (ls) all objects in this collection. ;  ; virtual TIterator * MakeReverseIterator () const;  ; Bool_t Notify () override;  'Notify' all objects in this collection. ;  ; TObject * operator() (const char *name) const;  Find an object in this collection by name. ;  ; void Paint (Option_t *option="""") override;  Paint all objects in this collection. ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:6392,access,access,6392,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,2,['access'],['access']
Security,"de;  Return a list iterator. ;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Unload ();  Mark 'all func' as being unloaded. ;  ; void Unload (TFunction *func);  Mark 'func' as being unloaded. ;  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:5722,hash,hashlist,5722,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['hash'],['hashlist']
Security,"deDefault print for collections, calls Print(option, 1).Definition TCollection.cxx:476; somewhere close to the method declaration. ; Reimplemented from TCollection.; Definition at line 197 of file TCollection.cxx. ◆ Rehash(). void THashTable::Rehash ; (; Int_t ; newCapacity, . Bool_t ; checkObjValidity = kTRUE . ). Rehash the hashtable. ; If the collision rate becomes too high (i.e. the average size of the linked lists become too long) then lookup efficiency decreases since relatively long lists have to be searched every time. To improve performance rehash the hashtable. This resizes the table to newCapacity slots and refills the table. Use AverageCollisions() to check if you need to rehash. Set checkObjValidity to kFALSE if you know that all objects in the table are still valid (i.e. have not been deleted from the system in the meanwhile). ; Definition at line 365 of file THashTable.cxx. ◆ Remove(). TObject * THashTable::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the hashtable. ; Implements TCollection.; Definition at line 417 of file THashTable.cxx. ◆ RemoveSlow(). TObject * THashTable::RemoveSlow ; (; TObject * ; obj). Remove object from the hashtable without using the hash value. ; Definition at line 442 of file THashTable.cxx. ◆ SetRehashLevel(). void THashTable::SetRehashLevel ; (; Int_t ; rehash). inline . Definition at line 80 of file THashTable.h. ◆ Streamer(). void THashTable::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TCollection. ◆ StreamerNVirtual(). void THashTable::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 82 of file THashTable.h. Friends And Related Symbol Documentation. ◆ THashTableIter. friend class THashTableIter. friend . Definition at line 37 of file THashTable.h. Member Data Documentation. ◆ fCont. TList** THashTable::fCont. private . Definition at line 40 of file THashTable.h. ◆ fEn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:27759,hash,hashtable,27759,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hashtable']
Security,"dePath + interpreter include path). Cache used by GetIncludePath; 311 TString fIncludePath; //Used to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; 312 TString fLinkedLibs; //Used to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; 313 TString fSoExt; //Extension of shared library (.so, .sl, .a, .dll, etc.); 314 TString fObjExt; //Extension of object files (.o, .obj, etc.); 315 EAclicMode fAclicMode{kDefault}; //Whether the compilation should be done debug or opt; 316 TString fMakeSharedLib; //Directive used to build a shared library; 317 TString fMakeExe; //Directive used to build an executable; 318 TString fLinkdefSuffix; //Default suffix for linkdef files to be used by ACLiC (see EACLiCProperties); 319 Int_t fAclicProperties{0}; //Various boolean flag for change ACLiC's behavior.; 320 TSeqCollection *fCompiled{nullptr}; //List of shared libs from compiled macros to be deleted; 321 TSeqCollection *fHelpers{nullptr}; //List of helper classes for alternative file/directory access; 322 ; 323 TString &GetLastErrorString(); //Last system error message (thread local).; 324 const TString &GetLastErrorString() const; //Last system error message (thread local).; 325 ; 326 TSystem *FindHelper(const char *path, void *dirptr = nullptr);; 327 virtual Bool_t ConsistentWith(const char *path, void *dirptr = nullptr);; 328 virtual const char *ExpandFileName(const char *fname);; 329 virtual Bool_t ExpandFileName(TString &fname);; 330 virtual void SigAlarmInterruptsSyscalls(Bool_t) { }; 331 virtual const char *GetLinkedLibraries();; 332 virtual void DoBeep(Int_t /*freq*/=-1, Int_t /*duration*/=-1) const { printf(""\a""); fflush(stdout); }; 333 ; 334 static const char *StripOffProto(const char *path, const char *proto);; 335 ; 336private:; 337 TSystem(const TSystem&) = delete;; 338 TSystem& operator=(const TSystem&) = delete;; 339 Bool_t ExpandFileName(const char *fname, char *xname, const int kBufSize);; 340 ; 341public:; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:13337,access,access,13337,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['access'],['access']
Security,"ded likelihood terms. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  ; void generateEvent (Int_t code) override;  Forwards to the PDF's implementation. ;  ; Int_t getAnalyticalIntegral (RooArgSet &allVars, RooArgSet &numVars, const char *rangeName=nullptr) const override;  Forwards to the PDF's implementation. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Forwards to the PDF's implementation. ;  ; Int_t getGenerator (const RooArgSet &directVars, RooArgSet &generateVars, bool staticInitOK=true) const override;  Forwards to the PDF's implementation. ;  ; Int_t getMaxVal (const RooArgSet &vars) const override;  Advertise capability to determine maximum value of function for given set of observables. ;  ; void initGenerator (Int_t code) override;  Forwards to the PDF's implementation. ;  ; std::unique_ptr< ROOT::Math::IntegratorOneDim > & integrator () const;  Direct access to the unique_ptr holding the integrator that's used to sample the bins. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &) const override;  Returns true, since this PDF is meant to be binned. ;  ; bool isDirectGenSafe (const RooAbsArg &arg) const override;  Forwards to the PDF's implementation. ;  ; double maxVal (Int_t code) const override;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; Int_t minTrialSamples (const RooArgSet &arGenObs) const override;  ; const RooAbsReal & observable () const;  ; const RooAbsPdf & pdf () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Return a list of all bin edges, so the PDF is plotted as a step function. ;  ; bool selfNormalized () const override;  Forwards to the PDF's implementation. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:7158,access,access,7158,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['access'],['access']
Security,"deflate_server_no_context_takeover;; 2511 int websocket_deflate_client_no_context_takeover;; 2512 int websocket_deflate_initialized;; 2513 int websocket_deflate_flush;; 2514 z_stream websocket_deflate_state;; 2515 z_stream websocket_inflate_state;; 2516#endif; 2517 int handled_requests; /* Number of requests handled by this connection; 2518 */; 2519 int buf_size; /* Buffer size */; 2520 int request_len; /* Size of the request + headers in a buffer */; 2521 int data_len; /* Total size of data in a buffer */; 2522 int status_code; /* HTTP reply status code, e.g. 200 */; 2523 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2524 * throttle */; 2525 ; 2526 time_t last_throttle_time; /* Last time throttled data was sent */; 2527 int last_throttle_bytes; /* Bytes sent this second */; 2528 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2529 * atomic transmissions for websockets */; 2530#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2531 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2532#endif; 2533 ; 2534 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2535 * for quick access */; 2536};; 2537 ; 2538 ; 2539/* Directory entry */; 2540struct de {; 2541 struct mg_connection *conn;; 2542 char *file_name;; 2543 struct mg_file_stat file;; 2544};; 2545 ; 2546 ; 2547#define mg_cry_internal(conn, fmt, ...) \; 2548 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2549 ; 2550#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2551 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARGS__); 2552 ; 2553static void mg_cry_internal_wrap(const struct mg_connection *conn,; 2554 struct mg_context *ctx,; 2555 const char *func,; 2556 unsigned line,; 2557 const char *fmt,; 2558 ...) PRINTF_ARGS(5, 6);; 2559 ; 2560 ; 2561#if !defined(NO_THREAD_NAME); 2562#if defined(_WIN32) && defined(_MSC_VER); 2563/* Set the thread name for debugging purposes in Visual Studio; 2564 * http://msdn.microsoft.com/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:79626,access,access,79626,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"deflate_server_no_context_takeover;; 2512 int websocket_deflate_client_no_context_takeover;; 2513 int websocket_deflate_initialized;; 2514 int websocket_deflate_flush;; 2515 z_stream websocket_deflate_state;; 2516 z_stream websocket_inflate_state;; 2517#endif; 2518 int handled_requests; /* Number of requests handled by this connection; 2519 */; 2520 int buf_size; /* Buffer size */; 2521 int request_len; /* Size of the request + headers in a buffer */; 2522 int data_len; /* Total size of data in a buffer */; 2523 int status_code; /* HTTP reply status code, e.g. 200 */; 2524 int throttle; /* Throttling, bytes/sec. <= 0 means no; 2525 * throttle */; 2526 ; 2527 time_t last_throttle_time; /* Last time throttled data was sent */; 2528 int last_throttle_bytes; /* Bytes sent this second */; 2529 pthread_mutex_t mutex; /* Used by mg_(un)lock_connection to ensure; 2530 * atomic transmissions for websockets */; 2531#if defined(USE_LUA) && defined(USE_WEBSOCKET); 2532 void *lua_websocket_state; /* Lua_State for a websocket connection */; 2533#endif; 2534 ; 2535 void *tls_user_ptr; /* User defined pointer in thread local storage,; 2536 * for quick access */; 2537};; 2538 ; 2539 ; 2540/* Directory entry */; 2541struct de {; 2542 struct mg_connection *conn;; 2543 char *file_name;; 2544 struct mg_file_stat file;; 2545};; 2546 ; 2547 ; 2548#define mg_cry_internal(conn, fmt, ...) \; 2549 mg_cry_internal_wrap(conn, NULL, __func__, __LINE__, fmt, __VA_ARGS__); 2550 ; 2551#define mg_cry_ctx_internal(ctx, fmt, ...) \; 2552 mg_cry_internal_wrap(NULL, ctx, __func__, __LINE__, fmt, __VA_ARGS__); 2553 ; 2554static void mg_cry_internal_wrap(const struct mg_connection *conn,; 2555 struct mg_context *ctx,; 2556 const char *func,; 2557 unsigned line,; 2558 const char *fmt,; 2559 ...) PRINTF_ARGS(5, 6);; 2560 ; 2561 ; 2562#if !defined(NO_THREAD_NAME); 2563#if defined(_WIN32) && defined(_MSC_VER); 2564/* Set the thread name for debugging purposes in Visual Studio; 2565 * http://msdn.microsoft.com/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:79658,access,access,79658,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"del::Create();; 290 /// auto hadronFlavour = model->MakeField<float>({; 291 /// ""hadronFlavour"", ""flavour from hadron ghost clustering""; 292 /// });; 293 /// ~~~; 294 template <typename T, typename... ArgsT>; 295 std::shared_ptr<T> MakeField(const NameWithDescription_t &fieldNameDesc, ArgsT &&...args); 296 {; 297 EnsureNotFrozen();; 298 EnsureValidFieldName(fieldNameDesc.fName);; 299 auto field = std::make_unique<RField<T>>(fieldNameDesc.fName);; 300 field->SetDescription(fieldNameDesc.fDescription);; 301 std::shared_ptr<T> ptr;; 302 if (fDefaultEntry); 303 ptr = fDefaultEntry->AddValue<T>(*field, std::forward<ArgsT>(args)...);; 304 fFieldNames.insert(field->GetFieldName());; 305 fFieldZero->Attach(std::move(field));; 306 return ptr;; 307 }; 308 ; 309 /// Adds a field whose type is not known at compile time. Thus there is no shared pointer returned.; 310 ///; 311 /// Throws an exception if the field is null.; 312 void AddField(std::unique_ptr<RFieldBase> field);; 313 ; 314 /// Register a subfield so it can be accessed directly from entries belonging to the model. Because registering a; 315 /// subfield does not fundamentally change the model, previously created entries will not be invalidated, nor; 316 /// modified in any way; a registered subfield is merely an accessor added to the default entry (if present) and any; 317 /// entries created afterwards.; 318 ///; 319 /// Using models with registered subfields for writing is not allowed. Attempting to do so will result in an; 320 /// exception.; 321 ///; 322 /// Throws an exception if the provided subfield could not be found in the model.; 323 void RegisterSubfield(std::string_view qualifiedFieldName);; 324 ; 325 /// Adds a top-level field based on existing fields.; 326 ///; 327 /// The mapping function takes one argument, which is a string containing the name of the projected field. The return; 328 /// value of the mapping function should be the name of the (existing) field onto which the projection is made.; 329 //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleModel_8hxx_source.html:14445,access,accessed,14445,doc/master/RNTupleModel_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx_source.html,1,['access'],['accessed']
Security,"deleted by the user. ; Definition at line 2572 of file TString.cxx. ◆ EscChar(). int EscChar ; (; const char * ; src, . char * ; dst, . int ; dstlen, . char * ; specchars, . char ; escchar . ). Escape specchars in src with escchar and copy to dst. ; Definition at line 2593 of file TString.cxx. ◆ Form(). char * Form ; (; const char * ; fmt, .  ; ... . ). Formats a string in a circular formatting buffer. ; Removes the need to create and delete short lived strings. Don't pass Form() pointers from user code down to ROOT functions as the circular buffer may be overwritten downstream. Use Form() results immediately or use TString::Format() instead. ; Definition at line 2489 of file TString.cxx. ◆ Format(). static char * Format ; (; const char * ; format, . va_list ; ap . ). static . Format a string in a circular formatting buffer (using a printf style format descriptor). ; Definition at line 2442 of file TString.cxx. ◆ Hash(). UInt_t Hash ; (; const char * ; str). Return a case-sensitive hash value (endian independent). ; Definition at line 576 of file TString.cxx. ◆ Mash(). static void Mash ; (; UInt_t & ; hash, . UInt_t ; chars . ). inlinestatic . Utility used by Hash(). ; Definition at line 566 of file TString.cxx. ◆ MemIsEqual(). static int MemIsEqual ; (; const char * ; p, . const char * ; q, . Ssiz_t ; n . ). static . Returns false if strings are not equal. ; Definition at line 885 of file TString.cxx. ◆ operator+() [1/5]. TString operator+ ; (; char ; c, . const TString & ; s . ). Add string to char. ; Definition at line 1557 of file TString.cxx. ◆ operator+() [2/5]. TString operator+ ; (; const char * ; cs, . const TString & ; s . ). Use the special concatenation constructor. ; Definition at line 1533 of file TString.cxx. ◆ operator+() [3/5]. TString operator+ ; (; const TString & ; s, . char ; c . ). Add char to string. ; Definition at line 1549 of file TString.cxx. ◆ operator+() [4/5]. TString operator+ ; (; const TString & ; s, . const char * ; cs . ). Use the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx.html:5087,hash,hash,5087,doc/master/TString_8cxx.html,https://root.cern,https://root.cern/doc/master/TString_8cxx.html,1,['hash'],['hash']
Security,"dentified.; non-sensitivity of the algorithm to continuous; background.; ability to identify peaks close to the edges of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of doublets and multiplets.; The algorithm should be able to recognize close positioned peaks.; ability to identify peaks with different sigma.; . Fig. 27 An example of one-dimensional synthetic spectrum with found peaks; denoted by markers.; ; References:. M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967),; 309-320.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�,; I. Turzo.:Identification of peaks in; multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; A 376 (1996), 451.; . Examples of peak searching method:. The SearchHighRes function provides users with the possibility to vary the; input parameters and with the access to the output deconvolved data in the; destination spectrum. Based on the output data one can tune the parameters.; ; Example 15 - script SearchHR1.c:; . Fig. 28 One-dimensional spectrum with found peaks denoted by markers, 3; iterations steps in the deconvolution.; . Fig. 29 One-dimensional spectrum with found peaks denoted by markers, 8; iterations steps in the deconvolution.; ; Script:; ; // Example to illustrate high resolution peak searching function (class TSpectrum).; // To execute this example, do; // root > .x SearchHR1.C; #include ; void SearchHR1() {; Float_t fPositionX[100];; Float_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; Double_t nbins = 1024,a;; Double_t xmin = 0;; Double_t xmax = (Double_t)nbins;; Float_t * source = new float[nbins];; Float_t * dest = new float[nbins];; TH1F *h = new TH1F(""h"",""High resolution peak searching, number of iterations = 3"",nbins,xmin,xmax);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; TFile *f = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum.html:52759,access,access,52759,root/html528/TSpectrum.html,https://root.cern,https://root.cern/root/html528/TSpectrum.html,4,['access'],['access']
Security,"der of the final cleaning. TNetSystem(const char* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free directory via rootd. const char * GetDirEntry(void* dirp = 0); Get directory entry via rootd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Int_t Unlink(const char* path); Remove a path. TNetFile& operator=(const TNetSystem& ). TNetSystem(const TNetSystem& ). void * GetDirPtr() const; { return fDirp; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-03-14 16:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetSystem.html:22901,access,access,22901,root/html534/TNetSystem.html,https://root.cern,https://root.cern/root/html534/TNetSystem.html,3,['access'],['access']
Security,"der of the final cleaning. TNetSystem(const char* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free directory via rootd. const char * GetDirEntry(void* dirp = 0); Get directory entry via rootd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Int_t Unlink(const char* path); Remove a path. TNetFile& operator=(const TNetSystem& ). TNetSystem(const TNetSystem& ). void * GetDirPtr() const; { return fDirp; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TNetSystem.html:23517,access,access,23517,root/html604/TNetSystem.html,https://root.cern,https://root.cern/root/html604/TNetSystem.html,3,['access'],['access']
Security,"der of the final cleaning. TNetSystem(const char* url, Bool_t ftpowner = kTRUE); Create helper class that allows directory access via rootd.; Use ftpowner = TRUE (default) if this instance is responsible; for cleaning of the underlying TFTP connection; this allows; to have control on the order of the final cleaning. void InitRemoteEntity(const char* url); Parse and save coordinates of the remote entity (user, host, port, ...). void Create(const char* url, TSocket* sock = 0); Create a TNetSystem object. ~TNetSystem(); Destructor. Int_t MakeDirectory(const char* name); Make a directory via rootd. void * OpenDirectory(const char* name); Open a directory via rfiod. Returns an opaque pointer to a dir; structure. Returns 0 in case of error. void FreeDirectory(void* dirp = 0); Free directory via rootd. const char * GetDirEntry(void* dirp = 0); Get directory entry via rootd. Returns 0 in case no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Int_t Unlink(const char* path); Remove a path. TNetFile& operator=(const TNetSystem& ). TNetSystem(const TNetSystem& ). void * GetDirPtr() const; { return fDirp; }. » Author: Fons Rademakers 14/08/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetSystem.html:23517,access,access,23517,root/html602/TNetSystem.html,https://root.cern,https://root.cern/root/html602/TNetSystem.html,3,['access'],['access']
Security,"der* fTreeReader; ///< Tree reader we belong to; 131 TDictionary* fDict; ///< Type that the branch should contain; 132 Detail::TBranchProxy* fProxy = nullptr; ///< Proxy for this branch, owned by TTreeReader; 133 TLeaf* fLeaf = nullptr;; 134 std::vector<Long64_t> fStaticClassOffsets;; 135 typedef EReadStatus (TTreeReaderValueBase::*Read_t)();; 136 Read_t fProxyReadFunc = &TTreeReaderValueBase::ProxyReadDefaultImpl; ///<! Pointer to the Read implementation to use.; 137 /**; 138 * If true, the reader will not do any type-checking against the actual; 139 * type held by the branch. Useful to just check if the current entry can; 140 * be read or not without caring about its value.; 141 * \note Only used by TTreeReaderOpaqueValue.; 142 */; 143 bool fOpaqueRead{false};; 144 ; 145 // FIXME: re-introduce once we have ClassDefInline!; 146 //ClassDefOverride(TTreeReaderValueBase, 0);//Base class for accessors to data via TTreeReader; 147 ; 148 friend class ::TTreeReader;; 149 };; 150 ; 151 /**; 152 * \brief Read a value in a branch without knowledge of its type; 153 *; 154 * This class is helpful in situations where the actual contents of the branch; 155 * at the current entry are not relevant and one only wants to know whether; 156 * the entry can be read.; 157 */; 158 class R__CLING_PTRCHECK(off) TTreeReaderOpaqueValue final : public ROOT::Internal::TTreeReaderValueBase {; 159 public:; 160 TTreeReaderOpaqueValue(TTreeReader &tr, const char *branchname); 161 : TTreeReaderValueBase(&tr, branchname, /*dict*/ nullptr, /*opaqueRead*/ true); 162 {; 163 }; 164 ; 165 protected:; 166 const char *GetDerivedTypeName() const { return """"; }; 167 };; 168 ; 169} // namespace Internal; 170} // namespace ROOT; 171 ; 172 ; 173template <typename T>; 174class R__CLING_PTRCHECK(off) TTreeReaderValue final: public ROOT::Internal::TTreeReaderValueBase {; 175// R__CLING_PTRCHECK is disabled because pointer / types are checked by CreateProxy().; 176 ; 177public:; 178 using NonConstT_t = typename std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:6765,access,accessors,6765,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,1,['access'],['accessors']
Security,"der, agreement or; otherwise) that contradict the conditions of this License, they do not; excuse you from the conditions of this License. If you cannot; distribute so as to satisfy simultaneously your obligations under this; License and any other pertinent obligations, then as a consequence you; may not distribute the Library at all. For example, if a patent; license would not permit royalty-free redistribution of the Library by; all those who receive copies directly or indirectly through you, then; the only way you could satisfy both it and this License would be to; refrain entirely from distribution of the Library. If any portion of this section is held invalid or unenforceable under any; particular circumstance, the balance of the section is intended to apply,; and the section as a whole is intended to apply in other circumstances. It is not the purpose of this section to induce you to infringe any; patents or other property right claims or to contest validity of any; such claims; this section has the sole purpose of protecting the; integrity of the free software distribution system which is; implemented by public license practices. Many people have made; generous contributions to the wide range of software distributed; through that system in reliance on consistent application of that; system; it is up to the author/donor to decide if he or she is willing; to distribute software through any other system and a licensee cannot; impose that choice. This section is intended to make thoroughly clear what is believed to; be a consequence of the rest of this License. 12. If the distribution and/or use of the Library is restricted in; certain countries either by patents or by copyrighted interfaces, the; original copyright holder who places the Library under this License may add; an explicit geographical distribution limitation excluding those countries,; so that distribution is permitted only in or among countries not thus; excluded. In such case, this License incorpora",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:23131,integrity,integrity,23131,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['integrity'],['integrity']
Security,"der.cxx:321; TMVA::Reader::AddVariablevoid AddVariable(const TString &expression, Float_t *)Add a float variable or expression to the reader.Definition Reader.cxx:303; TMVA::Reader::GetMVAErrorDouble_t GetMVAError() constDefinition Reader.h:94; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TStopwatchStopwatch class.Definition TStopwatch.h:28; TStopwatch::Startvoid Start(Bool_t reset=kTRUE)Start the stopwatch.Definition TStopwatch.cxx:58; TStopwatch::Stopvoid Stop()Stop the stopwatch.Definition TStopwatch.cxx:77; TStopwatch::Printvoid Print(Option_t *option="""") const overridePrint the real and cpu time passed between the start and stop events.Definition TStopwatch.cxx:219; TStringBasic string class.Definition TString.h:139; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; double; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(). tutorialstmvaTMVAClassificationApplication.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html:25820,access,access,25820,doc/master/TMVAClassificationApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationApplication_8C_source.html,2,['access'],['access']
Security,"derA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; A more complete example including error handling and a few combinations of TTreeReaderValue and TTreeReaderArray would look like this:; #include <TFile.h>; #include <TH1.h>; #include <TTreeReader.h>; #include <TTreeReaderValue.h>; #include <TTreeReaderArray.h>; ; #include ""TriggerInfo.h""; #include ""Muon.h""; #include ""Tau.h""; ; #include <vector>; #include <iostream>; ; bool CheckValue(ROOT::Internal::TTreeReaderValueBase& value) {; if (value.GetSetupStatus() < 0) {; std::cerr << ""Error "" << value.GetSetupStatus(); << ""setting up reader for "" << value.GetBranchName() << '\n';; return false;; }; return true;; }; ; ; // Analyze the tree ""MyTree"" in the file passed into the function.; // Returns false in case of errors.; bool analyze(TFile* file) {; // Create a TTreeReader named ""MyTree"" from the given TDirectory.; // The TTreeReader gives access to the TTree to the TTreeReaderValue and; // TTreeReaderArray objects. It knows the current entry number and knows; // how to iterate through the TTree.; TTreeReader reader(""MyTree"", file);; ; // Read a single float value in each tree entries:; TTreeReaderValue<float> weight(reader, ""event.weight"");; ; // Read a TriggerInfo object from the tree entries:; TTreeReaderValue<TriggerInfo> triggerInfo(reader, ""triggerInfo"");; ; //Read a vector of Muon objects from the tree entries:; TTreeReaderValue<std::vector<Muon>> muons(reader, ""muons"");; ; //Read the pT for all jets in the tree entry:; TTreeReaderArray<double> jetPt(reader, ""jets.pT"");; ; // Read the taus in the tree entry:; TTreeReaderArray<Tau> taus(reader, ""taus"");; ; ; // Now iterate through the TTree entries and fill a histogram.; ; TH1F(""hist"", ""TTreeReader example histogram"", 10, 0., 100.);; ; bool firstEntry = true;; while (reader.Next()) {; if (firstEntry) {; // Check that branches exist and their types match our expectation.; if (!CheckValue(we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:3736,access,access,3736,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['access'],['access']
Security,"derived from a TCanvas do the following:; TRootEmbeddedCanvas *embedded = new TRootEmbeddedCanvas(0, p, w, h);; [note name must be 0, not null string """"]; Int_t wid = embedded->GetCanvasWindowId();; TMyCanvas *myc = new TMyCanvas(""myname"", 10, 10, wid);; embedded->AdoptCanvas(myc);; [ the MyCanvas is adopted by the embedded canvas and will be; destroyed by it ]. ~TRootEmbeddedCanvas(); Delete embedded ROOT canvas. void AdoptCanvas(TCanvas* c); Canvas c is adopted from this embedded canvas. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t , Int_t , Atom_t action, Int_t , Int_t ); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. void SavePrimitive(ostream& out, Option_t* option = """"); Save an embedded canvas as a C++ statement(s) on output stream out. TRootEmbeddedCanvas(const TRootEmbeddedCanvas& ). TRootEmbeddedCanvas& operator=(const TRootEmbeddedCanvas& ). TCanvas * GetCanvas() const; { return fCanvas; }. Int_t GetCanvasWindowId() const; { return fCWinId; }. Bool_t GetAutoFit() const; { return fAutoFit; }. void SetAutoFit(Bool_t fit = kTRUE); { fAutoFit = fit; }. » Author: Fons Rademakers 15/07/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ »",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootEmbeddedCanvas.html:20171,expose,expose,20171,root/html534/TRootEmbeddedCanvas.html,https://root.cern,https://root.cern/root/html534/TRootEmbeddedCanvas.html,3,['expose'],['expose']
Security,"derived from a TCanvas do the following:; TRootEmbeddedCanvas *embedded = new TRootEmbeddedCanvas(0, p, w, h);; [note name must be 0, not null string """"]; Int_t wid = embedded->GetCanvasWindowId();; TMyCanvas *myc = new TMyCanvas(""myname"", 10, 10, wid);; embedded->AdoptCanvas(myc);; [ the MyCanvas is adopted by the embedded canvas and will be; destroyed by it ]. ~TRootEmbeddedCanvas(); Delete embedded ROOT canvas. void AdoptCanvas(TCanvas* c); Canvas c is adopted from this embedded canvas. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t , Int_t , Atom_t action, Int_t , Int_t ); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. void SavePrimitive(ostream& out, Option_t* option = """"); Save an embedded canvas as a C++ statement(s) on output stream out. TRootEmbeddedCanvas(const TRootEmbeddedCanvas& ). TRootEmbeddedCanvas& operator=(const TRootEmbeddedCanvas& ). TCanvas * GetCanvas() const; { return fCanvas; }. Int_t GetCanvasWindowId() const; { return fCWinId; }. Bool_t GetAutoFit() const; { return fAutoFit; }. void SetAutoFit(Bool_t fit = kTRUE); { fAutoFit = fit; }. » Author: Fons Rademakers 15/07/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootEmbeddedCanvas.html:20052,expose,expose,20052,root/html528/TRootEmbeddedCanvas.html,https://root.cern,https://root.cern/root/html528/TRootEmbeddedCanvas.html,3,['expose'],['expose']
Security,"ders.; Folders have a name and a title and are identified in the folder hierarchy; by a ""Unix-like"" naming mechanism. The root of all folders is //root.; New folders can be dynamically added or removed to/from a folder.; The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects; are posted. Other classes/tasks can access these objects by specifying; only a string pathname. This whiteboard facility greatly improves the; modularity of an application, minimizing the class relationship problem; that penalizes large applications. Pointers are efficient to communicate between classes.; However, one has interest to minimize direct coupling between classes; in the form of direct pointers. One better uses the naming and search; service provided by the Root folders hierarchy. This makes the classes; loosely coupled and also greatly facilitates I/O operations.; In a client/server environment, this mechanism facilitates the access; to any kind of object in //root stores running on different processes. A TFolder is created by invoking the TFolder constructor. It is placed; inside an existing folder via the TFolder::AddFolder method.; One can search for a folder or an object in a folder using the FindObject; method. FindObject analyzes the string passed as its argument and searches; in the hierarchy until it finds an object or folder matching the name. When a folder is deleted, its reference from the parent folder and; possible other folders is deleted. If a folder has been declared the owner of its objects/folders via; TFolder::SetOwner, then the contained objects are deleted when the; folder is deleted. By default, a folder does not own its contained objects.; NOTE that folder ownership can be set; - via TFolder::SetOwner; - or via TCollection::SetOwner on the collection specified to TFolder::AddFolder. Standard Root objects are automatically added to the folder hierarchy.; For example, the following folders exi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFolder.html:1326,access,access,1326,root/html528/TFolder.html,https://root.cern,https://root.cern/root/html528/TFolder.html,6,['access'],['access']
Security,"des; Libraries. Function documentation; RooProfileLL(const char* name, const char* title, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. RooMinuit* minuit(); { return _minuit ; }. RooAbsReal& nll(); { return const_cast<RooAbsReal&>(_nll.arg()) ; }. void clearAbsMin(); { _absMinValid = kFALSE ; }. » Last changed: Tue Dec 8 17:03:18 2009 » Last generated: 2009-12-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:34497,validat,validateAbsMin,34497,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,1,['validat'],['validateAbsMin']
Security,"describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Fit::DataRange::SetRangevoid SetRange(unsigned int icoord, double xmin, double xmax)set a range [xmin,xmax] for the new coordinate icoord If more range exists for other coordinates,...Definition DataRange.cxx:124; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parameter settings from number of parameters and a vector of values and optionally step value...Definition FitConfig.cxx:135; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::Resultconst FitResult & Result() constget fit resultDefinition Fitter.h:394; ROOT::Fit::Fitter::FitFCNbool FitFCN(unsigned int npar, Function &fcn, const double *params=nullptr, unsigned int dataSize=0, int fitType=0)Fit using the a generic FCN function as a C++ callable object implementing double () (const double *)...Definition Fitter.h:649; ROOT::Fit::Fitter::Configconst FitConfig & Config() constaccess to the fit configuration (const method)Definition Fitter.h:422; ROOT::Fit::ParameterSettings::SetStepSizevoid SetStepSize(double err)set the step sizeDefinition ParameterSettings.h:122; ROOT::Fit::ParameterSettings::SetLimitsvoid Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/combinedFit_8C.html:6301,access,access,6301,doc/master/combinedFit_8C.html,https://root.cern,https://root.cern/doc/master/combinedFit_8C.html,2,['access'],['access']
Security,"dicates any remote server session using TServerSocket) [p] = for parallel sockets (forced internally for rootd; ignored for proofd) [auth] = ""up"" or ""k"" to force UsrPwd or Krb5 authentication [port] = is the remote port number [service] = service name used to determine the port (for backward compatibility, specification of port as priority) options = ""m"" or ""s"", when proto=proofd indicates whether we are master or slave (used internally by TSlave); An already opened connection can be used by passing its socket in opensock.; If 'err' is defined, '*err' on return from a failed call contains an error code (see NetErrors.h).; Example:; TSocket::CreateAuthSocket(""pk://qwerty@machine.fq.dn:5052"",3); creates an authenticated parallel socket of size 3 to a sockd server running on remote machine machine.fq.dn on port 5052; authentication will attempt protocol Kerberos first.; NB: may hang if the remote server is not of the correct type; at present TSocket has no way to find out the type of the remote server automatically; Returns pointer to an authenticated socket or 0 if creation or authentication is unsuccessful. ; Definition at line 1290 of file TSocket.cxx. ◆ CreateAuthSocket() [2/2]. TSocket * TSocket::CreateAuthSocket ; (; const char * ; user, . const char * ; url, . Int_t ; port, . Int_t ; size = 0, . Int_t ; tcpwindowsize = -1, . TSocket * ; opensock = nullptr, . Int_t * ; err = nullptr . ). static . Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ; url: [[proto][p][auth]://]host[/?options]; where proto = ""sockd"", ""rootd"", ""proofd"" indicates the type of remote server if missing ""sockd"" is assumed (""sockd"" indicates any remote server session using TServerSocket) [p] = for parallel sockets (forced internally for rootd) [auth] = ""up"" or ""k"" to force UsrPwd or Krb5 authentication [options] = ""m"" or ""s"", when proto=proofd indicates whether we are master or slave (used internally by TSlave); An alre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:24622,authenticat,authenticated,24622,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,2,['authenticat'],"['authenticated', 'authentication']"
Security,"dimensions varying along z ;  ►CTTreeA TTree object has a header with a name and a title ;  CTClusterIteratorHelper class to iterate over cluster of baskets ;  CTFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends ;  CTTreeCacheA specialized TFileCacheRead object for a TTree ;  CTTreeCacheUnzipSpecialization of TTreeCache for parallel Unzipping ;  ►CTTreeClonerClass implementing or helping the various TTree cloning method ;  CCompareEntry;  CCompareSeek;  CTTreeDrawArgsParserA class that parses all parameters for TTree::Draw() ;  CTTreeFormulaUsed to pass a selection expression to the Tree drawing routine ;  CTTreeFormulaManagerUsed to coordinate one or more TTreeFormula objects ;  CTTreeFriendLeafIterIterator on all the leaves in a TTree and its friend ;  CTTreeIndexA Tree Index with majorname and minorname ;  CTTreeInput;  CTTreePerfStatsTTree I/O performance measurement ;  CTTreePlayerImplement some of the functionality of the class TTree requiring access to extra libraries (Histogram, display, etc) ;  ►CTTreeReaderTTreeReader is a simple, robust and fast interface to read values from a TTree, TChain or TNtuple ;  CIterator_t;  ►CTTreeReaderArrayExtracts array data from a TTree ;  CIterator_t;  CTTreeReaderValueExtracts data from a TTree ;  CTTreeResultClass defining interface to a TTree query result with the same interface as for SQL databases ;  CTTreeRowClass defining interface to a row of a TTree query result ;  CTTreeSQLImplement TTree for a SQL backend ;  CTTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree ;  CTTreeViewerA graphic user interface designed to handle ROOT trees and to take advantage of TTree class features ;  CTTUBEA tube ;  CTTUBSA segment of a tube ;  CTTVLVContainerThis class represent the list view container for the ;  CTTVLVEntryThis class represent entries that goes into the TreeViewer listview container ;  CTTVRecordI/O classes for TreeViewer session handling ;  CT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:159748,access,access,159748,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['access'],['access']
Security,"dinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(Scalar[] dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:13525,access,access,13525,root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,2,['access'],['access']
Security,"dir, TString& name); 1553{; 1554 if (name.IsNull() || name == ""."") {; 1555 if (dir) {; 1556 name = dir;; 1557 if (dir[strlen(dir) - 1] != '/'); 1558 name += '/';; 1559 } else name = """";; 1560 return name.Data();; 1561 }; 1562 ; 1563 if (!dir || !dir[0]); 1564 dir = ""/"";; 1565 else if (dir[strlen(dir) - 1] != '/'); 1566 name.Prepend('/');; 1567 name.Prepend(dir);; 1568 ; 1569 return name.Data();; 1570}; 1571 ; 1572//---- Paths & Files -----------------------------------------------------------; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Returns FALSE if one can access a file using the specified access mode.; 1576/// Mode is the same as for the Unix access(2) function.; 1577/// Attention, bizarre convention of return value!!; 1578 ; 1579Bool_t TUnixSystem::AccessPathName(const char *path, EAccessMode mode); 1580{; 1581 TSystem *helper = FindHelper(path);; 1582 if (helper); 1583 return helper->AccessPathName(path, mode);; 1584 ; 1585 if (::access(StripOffProto(path, ""file:""), mode) == 0); 1586 return kFALSE;; 1587 GetLastErrorString() = GetError();; 1588 ; 1589 return kTRUE;; 1590}; 1591 ; 1592////////////////////////////////////////////////////////////////////////////////; 1593/// Copy a file. If overwrite is true and file already exists the; 1594/// file will be overwritten. Returns 0 when successful, -1 in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 1597 ; 1598int TUnixSystem::CopyFile(const char *f, const char *t, Bool_t overwrite); 1599{; 1600 if (!AccessPathName(t) && !overwrite); 1601 return -2;; 1602 ; 1603 FILE *from = fopen(f, ""r"");; 1604 if (!from); 1605 return -1;; 1606 ; 1607 FILE *to = fopen(t, ""w"");; 1608 if (!to) {; 1609 fclose(from);; 1610 return -1;; 1611 }; 1612 ; 1613 const int bufsize = 1024;; 1614 char buf[bufsize];; 1615 int ret = 0;; 1616 while (!ret && !feof(from)) {; 1617 size_t numread = fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:48483,access,access,48483,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['access'],['access']
Security,"directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is used to avoid going through the NIC card for local operations. int GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file coul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:24797,access,access,24797,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,12,['access'],['access']
Security,dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxyRooAbsAnaConvPdf::_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDecay.html:43510,access,access,43510,root/html602/RooDecay.html,https://root.cern,https://root.cern/root/html602/RooDecay.html,2,['access'],['access']
Security,"dium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface […]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC’s is to define and use only one dummy tracking medium as in the example (or a NULL pointer).; 18.2.4 User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; 18.3 Shapes; Shapes are geometrical objects that provide the basic modeling functionality. They provide the definition of the local coordinate system of the volume. Any volume must have a shape. Any shape recognized by the modeller has to derive from the base TGeoShape class, providing methods for:. Finding out if a point defined in their local frame is contained or not by the shape;; Computing the distance to enter/exit the shape from a local point, given a known direction;; Computing the maximum distance in any direction from a local point that does NOT result in a boundary crossing of the shape (safe distance);; Computing the cosines of the normal vector to the crossed shape surface, given a starting local point and an ongoing direction. All the features above are globally managed by the modeller in order to provide navigation functionality. In addition to those, shapes have also to implement addition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:896435,access,accessing,896435,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessing']
Security,"dl, Int_t il) const =0; ROOT::Internal::TInitBehavior::~TInitBehaviorvirtual ~TInitBehavior()Definition Rtypes.h:153; ROOT::Internal::TInitBehavior::Registervirtual void Register(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits) const =0; ROOT::TClassAltDefinition TClassTable.cxx:128; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassStreamerDefinition TClassStreamer.h:26; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:2968; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileMergeInfoDefinition TFileMergeInfo.h:42; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; ROOT::Internal::DefineBehaviorconst TInitBehavior * DefineBehavior(void *, void *)Definition TGenericClassInfo.cxx:44; ROOT::Internal::HasConsistentHashMemberBool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/Rtypes_8h_source.html:28247,access,accessing,28247,doc/v632/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/v632/Rtypes_8h_source.html,1,['access'],['accessing']
Security,"dl, Int_t il) const =0; ROOT::Internal::TInitBehavior::~TInitBehaviorvirtual ~TInitBehavior()Definition Rtypes.h:158; ROOT::Internal::TInitBehavior::Registervirtual void Register(const char *cname, Version_t id, const std::type_info &info, DictFuncPtr_t dict, Int_t pragmabits) const =0; ROOT::TClassAltDefinition TClassTable.cxx:128; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassStreamerDefinition TClassStreamer.h:26; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollectionCollection abstract base class.Definition TCollection.h:65; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TFileMergeInfoDefinition TFileMergeInfo.h:42; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberStreamerDefinition TMemberStreamer.h:26; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualIsAProxyDefinition TVirtualIsAProxy.h:27; bool; int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Internal::DefaultStreamervoid DefaultStreamer(TBuffer &R__b, const TClass *cl, void *objpointer)Default streamer implementation used by ClassDefInline to avoid requirement to include TBuffer....Definition TBuffer.cxx:30; ROOT::Internal::DefineBehaviorconst TInitBehavior * DefineBehavior(void *, void *)Definition TGenericClassInfo.cxx:45; ROOT::Internal::HasConsistentHashMemberBool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Rtypes_8h_source.html:29784,access,accessing,29784,doc/master/Rtypes_8h_source.html,https://root.cern,https://root.cern/doc/master/Rtypes_8h_source.html,1,['access'],['accessing']
Security,"dl;; 803 }; 804 ; 805 if( it->find( ""source"" ) != it->end() ) {; 806 output << "" rule->fSource = \"""" << (*it)[""source""];; 807 output << ""\"";"" << std::endl;; 808 }; 809 ; 810 //--------------------------------------------------------------------; 811 // Deal with non mandatory keys; 812 ///////////////////////////////////////////////////////////////////////; 813 ; 814 if( it->find( ""funcname"" ) != it->end() ) {; 815 std::string code = (*it)[""code""];; 816 StrReplace( code, ""\n"", ""\\n"" );; 817 StrReplace( code, ""\"""", ""\\\"""");; 818 ; 819 output << "" rule->fFunctionPtr = (void *)TFunc2void( "";; 820 output << (*it)[""funcname""] << "");"" << std::endl;; 821 output << "" rule->fCode = \"""" << code;; 822 output << ""\"";"" << std::endl;; 823 }; 824 ; 825 if( it->find( ""version"" ) != it->end() ) {; 826 output << "" rule->fVersion = \"""" << (*it)[""version""];; 827 output << ""\"";"" << std::endl;; 828 }; 829 ; 830 if( it->find( ""checksum"" ) != it->end() ) {; 831 output << "" rule->fChecksum = \"""" << (*it)[""checksum""];; 832 output << ""\"";"" << std::endl;; 833 }; 834 ; 835 if( it->find( ""embed"" ) != it->end() ) {; 836 output << "" rule->fEmbed = "" << (*it)[""embed""];; 837 output << "";"" << std::endl;; 838 }; 839 ; 840 if( it->find( ""include"" ) != it->end() ) {; 841 output << "" rule->fInclude = \"""" << (*it)[""include""];; 842 output << ""\"";"" << std::endl;; 843 }; 844 ; 845 if( it->find( ""attributes"" ) != it->end() ) {; 846 output << "" rule->fAttributes = \"""" << (*it)[""attributes""];; 847 output << ""\"";"" << std::endl;; 848 }; 849 }; 850 }; 851 ; 852 /////////////////////////////////////////////////////////////////////////////; 853 /// Get the list of includes specified in the shema rules; 854 ; 855 void GetRuleIncludes( std::list<std::string> &result ); 856 {; 857 std::list<std::string> tmp;; 858 std::list<SchemaRuleMap_t>::iterator rule;; 859 SchemaRuleMap_t::iterator attr;; 860 SchemaRuleClassMap_t::iterator it;; 861 ; 862 //-----------------------------------------------------------------------; 863 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html:31340,checksum,checksum,31340,doc/master/RConversionRuleParser_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html,2,['checksum'],['checksum']
Security,"double , const ROOT::Minuit2::MnUserTransformation& ); construct from internal parameters (after minimization). ~MnUserParameterState(); {}. MnUserParameterState(const MnUserParameterState& state); {}. MnUserParameterState& operator=(const ROOT::Minuit2::MnUserParameterState& state). const MnGlobalCorrelationCoeff& GlobalCC() const; {return fGlobalCC;}. const std::vector<double>& IntParameters() const; Minuit internal representation. {return fIntParameters;}. const MnUserCovariance& IntCovariance() const; {return fIntCovariance;}. const MnUserTransformation& Trafo() const; transformation internal <-> external. {return fParameters.Trafo();}. bool IsValid() const; {return fValid;}. bool HasCovariance() const; {return fCovarianceValid;}. bool HasGlobalCC() const; {return fGCCValid;}. double Fval() const; {return fFVal;}. double Edm() const; {return fEDM;}. unsigned int NFcn() const; {return fNFcn;}. const std::vector<ROOT::Minuit2::MinuitParameter>& MinuitParameters() const; facade: forward interface of MnUserParameters and MnUserTransformation ; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. void Add(const string& name, double val, double err); add free Parameter. void Add(const string& name, double val, double err, double , double ); add limited Parameter. void Add(const string& , double ); add const Parameter. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void RemoveLimits(unsigned int ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Minuit2__MnUserParameterState.html:5595,access,access,5595,root/html528/ROOT__Minuit2__MnUserParameterState.html,https://root.cern,https://root.cern/root/html528/ROOT__Minuit2__MnUserParameterState.html,1,['access'],['access']
Security,"double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:17680,access,access,17680,root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::PositionVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:16367,access,access,16367,root/html526/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PositionVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"dow.hxx:174; ROOT::RWebWindow::SetClientVersionvoid SetClientVersion(const std::string &vers)Set client version, used as prefix in scripts URL When changed, web browser will reload all related J...Definition RWebWindow.cxx:1331; ROOT::RWebWindow::RemoveMasterConnectionvoid RemoveMasterConnection(unsigned connid=0)Remove master connection - if any.Definition RWebWindow.cxx:344; ROOT::RWebWindow::RemoveEmbedWindowvoid RemoveEmbedWindow(unsigned connid, int channel)Remove RWebWindow associated with the channelfEmbed.Definition RWebWindow.cxx:1909; ROOT::RWebWindow::SetCallBacks_R__DEPRECATED_LATER(""Use GetUrl() to get valid connection URL"") std _R__DEPRECATED_LATER(""Use GetAddr() to get valid connection URL"") std void SetCallBacks(WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr)Set call-backs function for connect, data and disconnect events.Definition RWebWindow.cxx:1814; ROOT::RWebWindow::SetRequireAuthKeyvoid SetRequireAuthKey(bool on)Configure if authentication key in connection string is required.Definition RWebWindow.hxx:319; ROOT::RWebWindow::GenerateKeystd::string GenerateKey() constGenerate new unique key for the window.Definition RWebWindow.cxx:612; ROOT::RWebWindow::SetUseCurrentDirvoid SetUseCurrentDir(bool on=true)Configure if window can access local files via currentdir/ path of http server.Definition RWebWindow.hxx:327; ROOT::RWebWindow::fDisconnCallbackWebWindowConnectCallback_t fDisconnCallback! callback for disconnect eventDefinition RWebWindow.hxx:162; ROOT::RWebWindow::GetMaxQueueLengthunsigned GetMaxQueueLength() constReturn maximal queue length of data which can be held by window.Definition RWebWindow.hxx:307; ROOT::RWebWindow::EQueueEntryKindEQueueEntryKindDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Disconnect@ kind_DisconnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_Connect@ kind_ConnectDefinition RWebWindow.hxx:127; ROOT::RWebWindow::kind_None@ kind_NoneDefinition RWe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:44042,authenticat,authentication,44042,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['authenticat'],['authentication']
Security,"down the sources. More...;  ; void WriteReadRawRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for ReadRaw rule, the function name is being written to rule[""funcname""]. More...;  ; void WriteReadRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for Read rule, the function name is being written to rule[""funcname""]. More...;  ; void WriteSchemaList (std::list< SchemaRuleMap_t > &rules, const std::string &listName, std::ostream &output);  Write schema rules. More...;  . Variables; R__EXTERN TVirtualRWMutex * gCoreMutex = nullptr;  ; R__EXTERN SchemaRuleClassMap_t gReadRawRules;  ; R__EXTERN SchemaRuleClassMap_t gReadRules;  . Detailed Description; tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ; TBranchProxyDirector This class is used to 'drive' and hold a serie of TBranchProxy objects which represent and give access to the content of TTree object.; A helper class for managing IMT work during TTree:Fill operations.; Namespace for new ROOT classes and functions.; Base class for iterating of hierarchical structure.; VSD Structures.; This is intended to be used as part of a generate Selector class which will hold the directory and its associate ; Typedef Documentation. ◆ ColumnNamesPtr_t. using ROOT::ColumnNamesPtr_t = typedef std::shared_ptr<const ColumnNames_t>. Definition at line 866 of file RDataFrame.cxx. ◆ DelArrFunc_t. typedef void(* ROOT::DelArrFunc_t) (void *). Definition at line 109 of file Rtypes.h. ◆ DelFunc_t. typedef void(* ROOT::DelFunc_t) (void *). Definition at line 108 of file Rtypes.h. ◆ DesFunc_t. typedef void(* ROOT::DesFunc_t) (void *). Definition at line 110 of file Rtypes.h. ◆ DirAutoAdd_t. typedef void(* ROOT::DirAutoAdd_t) (void *, TDirector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:12270,access,access,12270,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['access'],['access']
Security,"do” button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the “Undo” does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable.; 18.11.4 Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object.; 18.11.5 Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button “Position” allows editing the positioning matrix of a given node. . Visualization. This category allows changing the visibility of the edited volume or for its daughters, as well as other visualization settings. The radio button “All” allows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1037555,access,accessible,1037555,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessible']
Security,draw item text ;  ; Pixel_t fGrayPixel;  gray draw color ;  ; GContext_t fHighlightGC;  highlighted icon drawing context ;  ; Int_t fHspacing;  horizontal spacing between items ;  ; Int_t fIndent;  number of pixels indentation ;  ; TGListTreeItem * fLast;  pointer to last item in list ;  ; UInt_t fLastEventState;  modifier state of the last keyboard event ;  ; GContext_t fLineGC;  dashed line drawing context ;  ; Int_t fMargin;  number of pixels margin from left side ;  ; TGListTreeItem * fSelected;  pointer to selected item in list ;  ; TGToolTip * fTip;  tooltip shown when moving over list items ;  ; TGListTreeItem * fTipItem;  item for which tooltip is set ;  ; Bool_t fUserControlled;  let user decides what is the behaviour on events ;  ; Int_t fVspacing;  vertical spacing between items ;  ;  Protected Attributes inherited from TGContainer; Bool_t fBdown;  ; TGCanvas * fCanvas;  pointer to canvas ;  ; Bool_t fDragging;  true if in dragging mode ;  ; TGRectangle fExposedRegion;  exposed area ;  ; TString fKeyInput;  keyboard input (buffer) ;  ; TTimer * fKeyTimer;  keyboard timer ;  ; Bool_t fKeyTimerActive;  kTRUE - keyboard timer is active ;  ; TGFrameElement * fLastActiveEl;  last active item ;  ; Bool_t fLastCase;  case sensitivity of last search ;  ; Bool_t fLastDir;  direction of last search ;  ; TString fLastName;  the name of object of last search ;  ; Bool_t fLastSubstring;  substring search option of last search ;  ; const TGWindow * fMsgWindow;  window handling container messages ;  ; Bool_t fOnMouseOver;  kTRUE when mouse pointer is over entry ;  ; Bool_t fScrolling;  kTRUE - when scrolling is ON ;  ; TTimer * fScrollTimer;  autoscroll timer ;  ; Int_t fSelected;  number of selected items ;  ; Int_t fTotal;  total items ;  ; TGViewPort * fViewPort;  container viewport ;  ; Int_t fX0;  ; Int_t fXDND;  ; Int_t fXf;  ; Int_t fXp;  ; Int_t fY0;  corner of rubber band box ;  ; Int_t fYDND;  ; Int_t fYf;  other corner of rubber band box ;  ; Int_t fYp;  prev,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGListTree.html:45084,expose,exposed,45084,doc/master/classTGListTree.html,https://root.cern,https://root.cern/doc/master/classTGListTree.html,1,['expose'],['exposed']
Security,"ds of this class Note that in case the list of methods is not yet created, it will be done by GetListOfMethods(). ;  ; TClass *const * GetPersistentRef () const;  ; TRealData * GetRealData (const char *name) const;  Return pointer to TRealData element with name ""name"". ;  ; TVirtualRefProxy * GetReferenceProxy () const;  ; ROOT::ResetAfterMergeFunc_t GetResetAfterMerge () const;  Return the wrapper around Merge. ;  ; const ROOT::Detail::TSchemaRuleSet * GetSchemaRules () const;  Return the set of the schema rules if any. ;  ; ROOT::Detail::TSchemaRuleSet * GetSchemaRules (Bool_t create=kFALSE);  Return the set of the schema rules if any. ;  ; const char * GetSharedLibs ();  Get the list of shared libraries containing the code for class cls. ;  ; ShowMembersFunc_t GetShowMembersWrapper () const;  ; EState GetState () const;  ; TClassStreamer * GetStreamer () const;  Return the Streamer Class allowing streaming (if any). ;  ; ClassStreamerFunc_t GetStreamerFunc () const;  Get a wrapper/accessor function around this class custom streamer (member function). ;  ; TVirtualStreamerInfo * GetStreamerInfo (Int_t version=0, Bool_t isTransient=kFALSE) const;  returns a pointer to the TVirtualStreamerInfo object for version If the object does not exist, it is created ;  ; TVirtualStreamerInfo * GetStreamerInfoAbstractEmulated (Int_t version=0) const;  For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ;  ; const TObjArray * GetStreamerInfos () const;  ; const std::type_info * GetTypeInfo () const;  ; Bool_t HasConsistentHashMember ();  Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ;  ; Bool_t HasCustomStreamerMember () const;  The class has a Streamer method and it is implem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:16365,access,accessor,16365,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,3,['access'],['accessor']
Security,"ds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; Bool_tfAWaitkTRUE if waiting at the async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for exchanging information; Int_tfByteCurcurrent position in the first buffer; Int_tfByteLeftbytes left in the first buffer; XrdProofConn*fConninstance of the underlying connection module; Bool_tfDontTimeoutIf true wait forever for incoming messages; TXHandler*fHandlerHandler of asynchronous events (input, error); TStringfHostRemote host; Bool_tfIForwardWhether the interrupt should be propagated; intfILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; intfSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t PickUpReady(); Manage asynchronous message. TXSockBuf * PopUpSpare(Int_t sz). void PushBackSpare(). void PostMsg(Int_t type, const char* msg = 0); Post a message into the queu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXSocket.html:11162,access,access,11162,root/html534/TXSocket.html,https://root.cern,https://root.cern/root/html534/TXSocket.html,1,['access'],['access']
Security,"ds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TDCacheFile::stat64fStatBuffer! (transient) Cached file status buffer (for performance); Bool_tfStatCached! (transient) is file status cached?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDCacheFile(const char* path, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a dCache file object. A dCache file is the same as a TFile; except that it is being accessed via a dCache server. The url; argument must be of the form: dcache:/pnfs/<path>/<file>.root or; dcap://<nodename.org>/<path>/<file>.root. If the file specified in the; URL does not exist, is not accessable or can not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDCacheFile.html:22811,access,accessable,22811,root/html528/TDCacheFile.html,https://root.cern,https://root.cern/root/html528/TDCacheFile.html,3,['access'],['accessable']
Security,"ds to blocking i/o; static Int_tTFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. private:. TDCacheFile::stat64fStatBuffer! (transient) Cached file status buffer (for performance); Bool_tfStatCached! (transient) is file status cached?. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDCacheFile(const char* path, Option_t* option = """", const char* ftitle = """", Int_t compress = 1); Create a dCache file object. A dCache file is the same as a TFile; except that it is being accessed via a dCache server. The url; argument must be of the form: dcache:/pnfs/<path>/<file>.root or; dcap://<nodename.org>/<path>/<file>.root. If the file specified in the; URL does not exist, is not accessable or can not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheFile.html:22711,access,accessable,22711,root/html526/TDCacheFile.html,https://root.cern,https://root.cern/root/html526/TDCacheFile.html,1,['access'],['accessable']
Security,"dth() const; TMVA::IntervalTMVA::Interval::Interval(const TMVA::Interval& other); TMVA::IntervalTMVA::Interval::Interval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::MsgLogger&Log() const; TMVA::LogIntervalLogInterval(const TMVA::LogInterval& other); TMVA::LogIntervalLogInterval(Double_t min, Double_t max, Int_t nbins = 0); TMVA::LogInterval&operator=(const TMVA::LogInterval&); virtual voidTMVA::Interval::Print(ostream& os) const; voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. static TMVA::MsgLogger*fgLoggermessage logger. protected:. Double_tTMVA::Interval::fMaxthe constraints of the Interval; Double_tTMVA::Interval::fMin; Int_tTMVA::Interval::fNbinswhen >0 : number of bins (discrete interval); when ==0 continuous interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LogInterval(Double_t min, Double_t max, Int_t nbins = 0). LogInterval(const TMVA::LogInterval& other). ~LogInterval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize(Int_t iBin = 0) const; retuns the step size between the numbers of a ""discrete LogInterval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetWidth() const. Double_t GetMean() const. Double_t GetMin() const; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Int_t GetNbins() const; { return fNbins; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Last changed: Sat Mar 14 16:43:35 2015 » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__LogInterval.html:2258,access,accessors,2258,root/html534/TMVA__LogInterval.html,https://root.cern,https://root.cern/root/html534/TMVA__LogInterval.html,1,['access'],['accessors']
Security,"dthtotal width in GeV; Int_tfX; Int_tfYX,Y: quantum numbers for the 4-th generation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParticlePDG(); default constructor. TParticlePDG(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t Width, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti, Int_t TrackingCode). TParticlePDG(const TParticlePDG& ); copy constructor. TParticlePDG& operator=(const TParticlePDG& ); assignement operator. ~TParticlePDG(); destructor. Int_t AddDecayChannel(Int_t Type, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); add new decay channel, Particle owns those... TDecayChannel* DecayChannel(Int_t i); return pointer to decay channel object at index i. void PrintDecayChannel(TDecayChannel* dc, Option_t* opt = """") const; print the list of decays. void Print(Option_t* opt = """") const. Print the entire information of this kind of particle. Int_t PdgCode() const; ****** access methods. { return fPdgCode; }. Double_t Mass() const; { return fMass; }. Double_t Charge() const; { return fCharge; }. Double_t Lifetime() const; { return fLifetime; }. Double_t Width() const; { return fWidth; }. Int_t Parity() const; { return fParity; }. Double_t Spin() const; { return fSpin; }. Double_t Isospin() const; { return fIsospin; }. Double_t I3() const; { return fI3; }. Int_t Strangeness() const; { return fStrangeness; }. Int_t Charm() const; { return fCharm; }. Int_t Beauty() const; { return fBeauty; }. Int_t Top() const; { return fTop; }. Int_t X() const; { return fX; }. Int_t Y() const; { return fY; }. Int_t Stable() const; { return fStable; }. const char* ParticleClass() const; { return fParticleClass.Data(); }. TObjArray* DecayList(); { return fDecayList; }. Int_t NDecayChannels() const. Int_t TrackingCode() const; { return fTrackingCode; }. TParticlePDG* AntiParticle(); { return fAntiParticle; }. const TParticlePDG* AntiParticle() const; { return fAntiPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParticlePDG.html:9418,access,access,9418,root/html602/TParticlePDG.html,https://root.cern,https://root.cern/root/html602/TParticlePDG.html,2,['access'],['access']
Security,"duce column type (this invocation needs jitting internally); 1795 /// auto myHist1 = myDf.Histo1D({""histName"", ""histTitle"", 64u, 0., 128.}, ""myColumn"");; 1796 /// // Explicit column type; 1797 /// auto myHist2 = myDf.Histo1D<float>({""histName"", ""histTitle"", 64u, 0., 128.}, ""myColumn"");; 1798 /// ~~~; 1799 ///; 1800 /// \note Differently from other ROOT interfaces, the returned histogram is not associated to gDirectory; 1801 /// and the caller is responsible for its lifetime (in particular, a typical source of confusion is that; 1802 /// if result histograms go out of scope before the end of the program, ROOT might display a blank canvas).; 1803 template <typename V = RDFDetail::RInferredType>; 1804 RResultPtr<::TH1D> Histo1D(const TH1DModel &model = {"""", """", 128u, 0., 0.}, std::string_view vName = """"); 1805 {; 1806 const auto userColumns = vName.empty() ? ColumnNames_t() : ColumnNames_t({std::string(vName)});; 1807 ; 1808 const auto validatedColumns = GetValidatedColumnNames(1, userColumns);; 1809 ; 1810 std::shared_ptr<::TH1D> h(nullptr);; 1811 {; 1812 ROOT::Internal::RDF::RIgnoreErrorLevelRAII iel(kError);; 1813 h = model.GetHistogram();; 1814 h->SetDirectory(nullptr);; 1815 }; 1816 ; 1817 if (h->GetXaxis()->GetXmax() == h->GetXaxis()->GetXmin()); 1818 RDFInternal::HistoUtils<::TH1D>::SetCanExtendAllAxes(*h);; 1819 return CreateAction<RDFInternal::ActionTags::Histo1D, V>(validatedColumns, h, h, fProxiedPtr);; 1820 }; 1821 ; 1822 ////////////////////////////////////////////////////////////////////////////; 1823 /// \brief Fill and return a one-dimensional histogram with the values of a column (*lazy action*).; 1824 /// \tparam V The type of the column used to fill the histogram.; 1825 /// \param[in] vName The name of the column that will fill the histogram.; 1826 /// \return the monodimensional histogram wrapped in a RResultPtr.; 1827 ///; 1828 /// This overload uses a default model histogram TH1D(name, title, 128u, 0., 0.).; 1829 /// The ""name"" and ""title"" strings",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:101335,validat,validatedColumns,101335,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['validat'],['validatedColumns']
Security,"dvirtual . If one of the TObject we have a referenced to is deleted, remove the reference. ; Reimplemented from TObject.; Definition at line 1275 of file RooMCStudy.cxx. ◆ refit(). RooFit::OwningPtr< RooFitResult > RooMCStudy::refit ; (; RooAbsData * ; genSample = nullptr). protected . Redo fit on 'current' toy sample, or if genSample is not nullptr do fit on given sample instead. ; Definition at line 621 of file RooMCStudy.cxx. ◆ resetFitParams(). void RooMCStudy::resetFitParams ; (; ). protected . Reset all fit parameters to the initial model parameters at the time of the RooMCStudy constructor. ; Definition at line 578 of file RooMCStudy.cxx. ◆ run(). bool RooMCStudy::run ; (; bool ; doGenerate, . bool ; DoFit, . Int_t ; nSamples, . Int_t ; nEvtPerSample, . bool ; keepGenData, . const char * ; asciiFilePat . ). protected . Run engine method. ; Generate and/or fit, according to flags, 'nSamples' samples of 'nEvtPerSample' events. If keepGenData is set, all generated data sets will be kept in memory and can be accessed later via genData().; When generating, data sets will be written out in ascii form if the pattern string is supplied The pattern, which is a template for snprintf, should look something like ""data/toymc_%04d.dat"" and should contain one integer field that encodes the sample serial number.; When fitting only, data sets may optionally be read from ascii files, using the same file pattern. ; Definition at line 321 of file RooMCStudy.cxx. ◆ Streamer(). void RooMCStudy::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooMCStudy::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 152 of file RooMCStudy.h. Friends And Related Symbol Documentation. ◆ RooAbsMCStudyModule. friend class RooAbsMCStudyModule. friend . Definition at line 97 of file RooMCStudy.h. Member Data Documentation. ◆ _allDependents. RooArgSet RooMCStudy::_all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:40630,access,accessed,40630,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['access'],['accessed']
Security,"dvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498; TStatistic::HashULong_t Hash() const overrideReturn hash value for this object.Definition TStatistic.h:53. Reimplemented from TObject.; Definition at line 53 of file TStatistic.h. ◆ IsA(). TClass * TStatistic::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 77 of file TStatistic.h. ◆ ls(). void TStatistic::ls ; (; Option_t * ; option = """"); const. inlineoverridevirtual . The ls function lists the contents of a class on stdout. ; Ls output is typically much less verbose then Dump(). ; Reimplemented from TObject.; Definition at line 75 of file TStatistic.h. ◆ Merge(). Int_t TStatistic::Merge ; (; TCollection * ; in). Merge implementation of TStatistic. ; Parameters. [in]inOther TStatistic objects to be added to the current one. The function merges the statistics of all objects together to form a new one. Merging quantities is done via simple addition for the following class data members:; number of entries fN; the sum of weights fW; the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStatistic.html:16220,hash,hash,16220,doc/master/classTStatistic.html,https://root.cern,https://root.cern/doc/master/classTStatistic.html,1,['hash'],['hash']
Security,"dy existing info is the same as; 939 // the current one? Yes; 940 // In case a class (eg Event.h) has a TClonesArray of Tracks, it could be; 941 // that the old info does not have the class name (Track) in the data; 942 // member title. Set old title to new title; 943 if (info) {; 944 // We found an existing TStreamerInfo for our ClassVersion; 945 Bool_t match = kTRUE;; 946 Bool_t done = kFALSE;; 947 Bool_t oldIsNonVersioned = kFALSE;; 948 if (fClassVersion!=0 && !fClass->TestBit(TClass::kWarned) && (fClassVersion == info->GetClassVersion()) && (fCheckSum != info->GetCheckSum())) {; 949 // The TStreamerInfo's checksum is different from the checksum for the compile class.; 950 ; 951 match = kFALSE;; 952 oldIsNonVersioned = (info->fOnFileClassVersion==1 && info->fClassVersion != 1) || isStdPair;; 953 ; 954 if (fClass->IsLoaded() && (fClassVersion == fClass->GetClassVersion()) && fClass->HasDataMemberInfo()) {; 955 // In the case where the read-in TStreamerInfo does not; 956 // match in the 'current' in memory TStreamerInfo for; 957 // a non foreign class (we can not get here if this is; 958 // a foreign class so we do not need to test it),; 959 // we need to add this one more test since the CINT behaviour; 960 // with enums changed over time, so verify the checksum ignoring; 961 // members of type enum. We also used to not count the //[xyz] comment; 962 // in the checksum, so test for that too.; 963 if ( (fCheckSum == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(fCheckSum) ); 964 &&(info->GetCheckSum() == fClass->GetCheckSum() || fClass->MatchLegacyCheckSum(info->GetCheckSum())); 965 ); 966 {; 967 match = kTRUE;; 968 }; 969 if (fOldVersion <= 2) {; 970 // Names of STL base classes was modified in vers==3. Allocators removed; 971 // (We could be more specific (see test for the same case below); 972 match = kTRUE;; 973 }; 974 if (!match && CompareContent(0,info,kFALSE,kFALSE,file)) {; 975 match = kTRUE;; 976 }; 977#ifdef TEST_FOR_BACKWARD_COMPATIBILITY_ABSTRACT_C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:35345,checksum,checksum,35345,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['checksum'],['checksum']
Security,"d EnableMetrics ();  Enable performance measurements (decompression time, bytes read from storage, etc.) ;  ; RIterator end ();  ; RNTupleCollectionView GetCollectionView (DescriptorId_t fieldId);  ; RNTupleCollectionView GetCollectionView (std::string_view fieldName);  Raises an exception if: ;  ; const RNTupleDescriptor & GetDescriptor ();  Returns a cached copy of the page source descriptor. ;  ; template<typename T > ; RNTupleDirectAccessView< T > GetDirectAccessView (DescriptorId_t fieldId);  ; template<typename T > ; RNTupleDirectAccessView< T > GetDirectAccessView (std::string_view fieldName);  ; RNTupleGlobalRange GetEntryRange ();  Returns an iterator over the entry indices of the RNTuple. ;  ; const Detail::RNTupleMetrics & GetMetrics () const;  ; const RNTupleModel & GetModel ();  ; NTupleSize_t GetNEntries () const;  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId);  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId, std::shared_ptr< T > objPtr);  ; template<typename T > ; RNTupleView< T > GetView (DescriptorId_t fieldId, T *rawPtr);  ; template<typename T > ; RNTupleView< T > GetView (std::string_view fieldName);  Provides access to an individual field that can contain either a scalar value or a collection, e.g. ;  ; template<typename T > ; RNTupleView< T > GetView (std::string_view fieldName, std::shared_ptr< T > objPtr);  ; template<typename T > ; RNTupleView< T > GetView (std::string_view fieldName, T *rawPtr);  ; void LoadEntry (NTupleSize_t index);  Analogous to Fill(), fills the default entry of the model. ;  ; void LoadEntry (NTupleSize_t index, REntry &entry);  Fills a user provided entry after checking that the entry has been instantiated from the ntuple model. ;  ; void PrintInfo (const ENTupleInfo what=ENTupleInfo::kSummary, std::ostream &output=std::cout) const;  Prints a detailed summary of the ntuple, including a list of fields. ;  ; void Show (NTupleSize_t index, std::ostream &output=std:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html:2869,access,access,2869,doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleReader.html,1,['access'],['access']
Security,"d Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const override;  Default print for collections, calls Print(option, 1). ;  ; void RemoveAll ();  ; virtual void RemoveAll (TCollection *col);  Remove all objects in collection col from this collection. ;  ; void SetCurrentCollection ();  Set this collection to be the globally accessible collection. ;  ; void SetName (const char *name);  ; virtual void SetOwner (Bool_t enable=kTRUE);  Set whether this collection is the owner (enable==true) of its content. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool UseRWLock (Bool_t enable=true);  Set this collection to use a RW lock upon access, making it thread safe. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write all objects in this collection. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write all objects in this collection. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRefArray.html:8637,access,access,8637,doc/master/classRooRefArray.html,https://root.cern,https://root.cern/doc/master/classRooRefArray.html,16,['access'],['access']
Security,"d UpdateTempMatrix (Double_t x=0, Double_t y=0, Double_t z=0, TRotMatrix *matrix=nullptr);  Update temp matrix. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeometry.html:7491,hash,hash,7491,doc/master/classTGeometry.html,https://root.cern,https://root.cern/doc/master/classTGeometry.html,1,['hash'],['hash']
Security,"e ""TVirtualMutex.h""; #include ""ThreadLocalStorage.h""; #include <stdint.h>. Include dependency graph for TString.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Macros; #define BIG_CONSTANT(x)   (x##LLU);  ; #define ROTL64(x, y)   rotl64(x,y);  . Functions; char * Compress (const char *str);  Remove all blanks from the string str. ;  ; int EscChar (const char *src, char *dst, int dstlen, char *specchars, char escchar);  Escape specchars in src with escchar and copy to dst. ;  ; char * Form (const char *fmt,...);  Formats a string in a circular formatting buffer. ;  ; static char * Format (const char *format, va_list ap);  Format a string in a circular formatting buffer (using a printf style format descriptor). ;  ; UInt_t Hash (const char *str);  Return a case-sensitive hash value (endian independent). ;  ; static void Mash (UInt_t &hash, UInt_t chars);  Utility used by Hash(). ;  ; static int MemIsEqual (const char *p, const char *q, Ssiz_t n);  Returns false if strings are not equal. ;  ; TString operator+ (char c, const TString &s);  Add string to char. ;  ; TString operator+ (const char *cs, const TString &s);  Use the special concatenation constructor. ;  ; TString operator+ (const TString &s, char c);  Add char to string. ;  ; TString operator+ (const TString &s, const char *cs);  Use the special concatenation constructor. ;  ; TString operator+ (const TString &s1, const TString &s2);  Use the special concatenation constructor. ;  ; TBuffer & operator<< (TBuffer &buf, const TString *s);  Write TString or derived to TBuffer. ;  ; Bool_t operator== (const TString &s1, const char *s2);  Compare TString with a char *. ;  ; Bool_t operator== (const TSubString &s1, const TSubString &s2);  Compare two sub-strings. ;  ; Bool_t operator== ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx.html:1557,hash,hash,1557,doc/master/TString_8cxx.html,https://root.cern,https://root.cern/doc/master/TString_8cxx.html,1,['hash'],['hash']
Security,"e &hash) const;  Return the collection of UID corresponding to the hash if the hash has already been seen or nullptr otherwise. ;  ; bool Insert (const HashValue &hash, RUidColl &&coll) const;  If the hash is there, return false. ;  . Static Public Member Functions; static HashValue Hash (char *buf, int len);  Return the hash object corresponding to the buffer. ;  . Private Attributes; std::unique_ptr< RHashMap > fHashMap;  ; std::unique_ptr< ROOT::TRWSpinLock > fRWLock;  . #include <ROOT/RConcurrentHashColl.hxx>; Constructor & Destructor Documentation. ◆ RConcurrentHashColl(). ROOT::Internal::RConcurrentHashColl::RConcurrentHashColl ; (; ). Definition at line 41 of file RConcurrentHashColl.cxx. ◆ ~RConcurrentHashColl(). ROOT::Internal::RConcurrentHashColl::~RConcurrentHashColl ; (; ). default . Member Function Documentation. ◆ Find(). const RUidColl * ROOT::Internal::RConcurrentHashColl::Find ; (; const HashValue & ; hash); const. Return the collection of UID corresponding to the hash if the hash has already been seen or nullptr otherwise. ; Definition at line 46 of file RConcurrentHashColl.cxx. ◆ Hash(). RConcurrentHashColl::HashValue ROOT::Internal::RConcurrentHashColl::Hash ; (; char * ; buf, . int ; len . ). static . Return the hash object corresponding to the buffer. ; Definition at line 56 of file RConcurrentHashColl.cxx. ◆ Insert(). bool ROOT::Internal::RConcurrentHashColl::Insert ; (; const HashValue & ; hash, . RUidColl && ; coll . ); const. If the hash is there, return false. ; Otherwise, insert the hash and UID collection and return true. ; Definition at line 61 of file RConcurrentHashColl.cxx. Member Data Documentation. ◆ fHashMap. std::unique_ptr<RHashMap> ROOT::Internal::RConcurrentHashColl::fHashMap. mutableprivate . Definition at line 32 of file RConcurrentHashColl.hxx. ◆ fRWLock. std::unique_ptr<ROOT::TRWSpinLock> ROOT::Internal::RConcurrentHashColl::fRWLock. mutableprivate . Definition at line 33 of file RConcurrentHashColl.hxx. Libraries for ROOT:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html:1722,hash,hash,1722,doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RConcurrentHashColl.html,2,['hash'],['hash']
Security,"e (And optionally fix it) ;  ; void SetPOI (const std::string &POI);  insert PoI at beginning of vector of PoIs ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1Measurement.html:4394,hash,hash,4394,doc/master/classRooStats_1_1HistFactory_1_1Measurement.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1Measurement.html,1,['hash'],['hash']
Security,"e (Long64_t, Long64_t) final;  Mark unused bytes on the file. ;  ; void MakeProject (const char *, const char *=""*"", Option_t *=""new"") final;  Generate source code necessary to access the objects stored in the file. ;  ; TString MakeSelectQuery (TClass *cl);  Produce SELECT statement which can be used to get all data of class cl in one SELECT statement. ;  ; void Map () final;  ; void Map (Option_t *) final;  List the contents of a file sequentially. ;  ; void Paint (Option_t *="""") final;  Paint all objects in the file. ;  ; void Print (Option_t *="""") const final;  Print all objects in the file. ;  ; Bool_t ReadBuffer (char *, Int_t) final;  Read a buffer from the file. ;  ; Bool_t ReadBuffer (char *, Long64_t, Int_t) final;  Read a buffer from the file at the offset 'pos' in the file. ;  ; void ReadFree () final;  Read the FREE linked list. ;  ; Int_t Recover () final;  Attempt to recover file if not correctly closed. ;  ; Int_t ReOpen (Option_t *mode) final;  Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ;  ; void ResetErrno () const final;  Method resetting the errno. ;  ; Bool_t Rollback ();  Rollback all operations, done after StartTransaction() call. ;  ; void Seek (Long64_t, ERelativeTo=kBeg) final;  Seek to a specific position in the file. Pos it either kBeg, kCur or kEnd. ;  ; void SetArrayLimit (Int_t limit=20);  Defines maximum number of columns for array representation If array size bigger than limit, array data will be converted to raw format This is usefull to prevent tables with very big number of columns If limit==0, all arrays will be stored in raw format If limit<0, all array values will be stored in column form Default value is 21. ;  ; void SetEND (Long64_t) final;  ; void SetTablesType (const char *table_type);  Defines tables type, which is used in CREATE TABLE statements Now is only used for MySQL database, where following types are supported: ""BDB"", ""HEAP"", ""ISAM"", ""InnoDB"", ""MERGE"", ""MRG_MYISAM""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:13006,access,access,13006,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['access'],['access']
Security,"e (ROOT::TClassAlt *alt);  ; static void Terminate ();  Deletes the class table (this static class function calls the dtor). ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Types; typedef ROOT::TMapTypeToClassRec IdMap_t;  . Private Member Functions;  TClassTable ();  TClassTable is a singleton (i.e. only one can exist per application). ;  . Static Private Member Functions; static Bool_t CheckClassTableInit ();  Return true fs the table exist. ;  ; static ROOT::TClassRec * FindElement (const char *cname, Bool_t insert);  Find a class by name in the class table (using hash of name). ;  ; static void SortTable ();  Sort the class table by ascending class ID's. ;  . Static Private Attributes; static ROOT::TClassAlt ** fgAlternate;  ; static UInt_t fgCursor;  ; static IdMap_t * fgIdMap;  ; static UInt_t fgSize;  ; static Bool_t fgSorted;  ; static ROOT::TClassRec ** fgSortedTable;  ; static ROOT::TClassRec ** fgTable;  ; static std::atomic< UInt_t > fgTally;  . Friends; void ROOT::ResetClassVersion (TClass *, const char *, Short_t);  ; class TROOT;  . Additional Inherited Members;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TClassTable.h>. Inheritance diagram for TClassTable:. This browser is not able to show SVG: try Firefox, Chrome, Sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTable.html:12462,hash,hash,12462,doc/master/classTClassTable.html,https://root.cern,https://root.cern/doc/master/classTClassTable.html,1,['hash'],['hash']
Security,"e ) const;; 33 const TSchemaRule* GetRuleWithTarget( const TString& name ) const;; 34 Bool_t HasRuleWithSource( const TString& name, Bool_t needingAlloc ) const;; 35 Bool_t HasRuleWithTarget( const TString& name, Bool_t willset ) const;; 36 };; 37 ; 38 enum EConsistencyCheck {; 39 kNoCheck = 0,; 40 kCheckAll = 1,; 41 kCheckConflict = 2; 42 };; 43 ; 44 TSchemaRuleSet();; 45 virtual ~TSchemaRuleSet();; 46 ; 47 Bool_t AddRule(TSchemaRule *rule, EConsistencyCheck checkConsistency = kCheckAll, TString *errmsg = nullptr);; 48 Bool_t AddRules(TSchemaRuleSet *rules, EConsistencyCheck checkConsistency = kCheckAll, TString *errmsg = nullptr);; 49 Bool_t HasRuleWithSourceClass( const TString &source) const;; 50 const TMatches FindRules( const TString &source ) const;; 51 const TMatches FindRules( const TString &source, Int_t version ) const;; 52 const TMatches FindRules( const TString &source, UInt_t checksum ) const;; 53 const TMatches FindRules( const TString &source, Int_t version, UInt_t checksum ) const;; 54 TClass* GetClass();; 55 UInt_t GetClassCheckSum() const;; 56 TString GetClassName() const;; 57 Int_t GetClassVersion() const;; 58 const TObjArray* GetRules() const;; 59 const TObjArray* GetPersistentRules() const;; 60 void RemoveRule( TSchemaRule* rule );; 61 void RemoveRules( TObjArray* rules );; 62 void SetClass( TClass* cls );; 63 ; 64 void ls(Option_t *option="""") const override;; 65 void AsString(TString &out) const;; 66 ; 67 private:; 68 TObjArray* fPersistentRules; // Array of the rules that will be embeded in the file; 69 TObjArray* fRemainingRules; //! Array of non-persistent rules - just for cleanup purposes - owns the elements; 70 TObjArray* fAllRules; //! Array of all rules; 71 TClassRef fClass; //! Target class pointer (for consistency checking); 72 TString fClassName; // Target class name; 73 Int_t fVersion; // Target class version; 74 UInt_t fCheckSum; // Target class checksum; 75 ; 76 ClassDefOverride( TSchemaRuleSet, 1 ); 77 ; 78 };; 79 ; 80} // End of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRuleSet_8h_source.html:1836,checksum,checksum,1836,doc/master/TSchemaRuleSet_8h_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRuleSet_8h_source.html,1,['checksum'],['checksum']
Security,"e * ; sl, . Int_t ; output_size . ). private . Redirect output of worker sl to some merger. ; Definition at line 4258 of file TProof.cxx. ◆ RegisterDataSet(). Bool_t TProof::RegisterDataSet ; (; const char * ; dataSetName, . TFileCollection * ; dataSet, . const char * ; optStr = """" . ). virtual . Register the 'dataSet' on the cluster under the current user, group and the given 'dataSetName'. ; If a dataset with the same name already exists the action fails unless 'opts' contains 'O', in which case the old dataset is overwritten, or contains 'U', in which case 'newDataSet' is added to the existing dataset (duplications are ignored, if any). If 'opts' contains 'V' the dataset files are also verified (if the dataset manager is configured to allow so). By default the dataset is not verified. If 'opts' contains 'T' the in the dataset object (status bits, meta,...) is trusted, i.e. not reset (if the dataset manager is configured to allow so). If 'opts' contains 'S' validation would be run serially (meaningful only if validation is required). Returns kTRUE on success. ; Reimplemented in TProofLite.; Definition at line 10707 of file TProof.cxx. ◆ ReleaseMonitor(). void TProof::ReleaseMonitor ; (; TMonitor * ; mon). private . Release the used monitor to be used, making sure to delete newly created monitors. ; Definition at line 2654 of file TProof.cxx. ◆ Remove() [1/2]. Int_t TProof::Remove ; (; const char * ; ref, . Bool_t ; all = kFALSE . ). Send remove request for the query specified by ref. ; If all = TRUE remove also local copies of the query, if any. Generic method working for all queries known by the server. This method can be also used to reset the list of queries waiting to be processed: for that purpose use ref == ""cleanupqueue"". ; Definition at line 6034 of file TProof.cxx. ◆ Remove() [2/2]. Int_t TProof::Remove ; (; Int_t ; query, . Bool_t ; all = kFALSE . ). Send remove request for the qry-th query in fQueries. ; Definition at line 6013 of file TProof.cxx. ◆ Remo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:130876,validat,validation,130876,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,2,['validat'],['validation']
Security,"e 543 of file RooLinkedList.cxx. ◆ First(). TObject * RooLinkedList::First ; (; ); const. inline . Definition at line 93 of file RooLinkedList.h. ◆ fwdIterator(). RooFIter RooLinkedList::fwdIterator ; (; ); const. Create a one-time-use forward iterator for this list. ; ReturnsRooFIter that only supports next() ; Definition at line 756 of file RooLinkedList.cxx. ◆ getHashTableSize(). Int_t RooLinkedList::getHashTableSize ; (; ); const. inline . Definition at line 59 of file RooLinkedList.h. ◆ GetName(). const char * RooLinkedList::GetName ; (; ); const. inlineoverridevirtual . Returns name of object. ; This default method returns the class name. Classes that give objects a name should override this method. ; Reimplemented from TObject.; Definition at line 104 of file RooLinkedList.h. ◆ GetSize(). Int_t RooLinkedList::GetSize ; (; ); const. inline . Definition at line 69 of file RooLinkedList.h. ◆ Hash(). ULong_t RooLinkedList::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; RooLinkedList::HashULong_t Hash() const overrideReturn hash value for this object.Definition RooLinkedList.h:110; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinkedList.html:20575,hash,hash,20575,doc/master/classRooLinkedList.html,https://root.cern,https://root.cern/doc/master/classRooLinkedList.html,1,['hash'],['hash']
Security,"e ; (; TS3HTTPRequest::EHTTPVerb ; httpVerb); const. protected . Returns the first line of a HTTP request for this object. ; Note that since we don't use the virtual host syntax which is supported by Amazon, we must include the bucket name in thr resource. For example, we don't use http://mybucket.s3.amazonaws.com/path/to/my/file but instead http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1"" Also note that the path must include the leading '/'. ; Definition at line 178 of file TS3HTTPRequest.cxx. ◆ MakeTokenHeader(). TString TS3HTTPRequest::MakeTokenHeader ; (; ); const. protected . Returns the session security token header for this HTTP request. ; Definition at line 205 of file TS3HTTPRequest.cxx. ◆ SetAccessKey(). TS3HTTPRequest & TS3HTTPRequest::SetAccessKey ; (; const TString & ; accessKey). inline . Definition at line 145 of file TS3HTTPRequest.h. ◆ SetAuthKeys(). TS3HTTPRequest & TS3HTTPRequest::SetAuthKeys ; (; const TString & ; accessKey, . const TString & ; secretKey . ). inline . Definition at line 132 of file TS3HTTPRequest.h. ◆ SetAuthType(). TS3HTTPRequest & TS3HTTPRequest::SetAuthType ; (; TS3HTTPRequest::EAuthType ; authType). inline . Definition at line 139 of file TS3HTTPRequest.h. ◆ SetBucket(). TS3HTTPRequest & TS3HTTPRequest::SetBucket ; (; const TString & ; bucket). inline . Definition at line 120 of file TS3HTTPRequest.h. ◆ SetHost(). TS3HTTPRequest & TS3HTTPRequest::SetHost ; (; const TString & ; host). inline . Definition at line 114 of file TS3HTTPRequest.h. ◆ SetObjectKey(). TS3HTTPRequest & TS3HTTPRequest::SetObjectKey ; (; const TString & ; objectKey). inline . Definition at line 126 of file TS3HTTPRequest.h. ◆ SetSecretKey(). TS3HTTPRequest & TS3HTTPRequest::SetSecretKey ; (; const TString & ; secretKey). inline . Definition at line 151 of file TS3HTTPRequest.h. ◆ SetSessionToken(). TS3HTTPRequest & TS3HTTPRequest::SetSessionToken ; (; const TString & ; token).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3HTTPRequest.html:18083,access,accessKey,18083,doc/master/classTS3HTTPRequest.html,https://root.cern,https://root.cern/doc/master/classTS3HTTPRequest.html,1,['access'],['accessKey']
Security,"e ; (; const TASImage & ; img). Image copy constructor. ; Definition at line 296 of file TASImage.cxx. ◆ ~TASImage(). TASImage::~TASImage ; (; ). override . Image destructor, clean up image and visual. ; Definition at line 358 of file TASImage.cxx. Member Function Documentation. ◆ AlphaBlend(). UInt_t TASImage::AlphaBlend ; (; UInt_t ; bot, . UInt_t ; top . ). static . Return alpha-blended value computed from bottom and top pixel values. ; Definition at line 5151 of file TASImage.cxx. ◆ Append(). void TASImage::Append ; (; const TImage * ; im, . const char * ; option = ""+"", . const char * ; color = ""#00000000"" . ). overridevirtual . Append image. ; option:; ""+"" - appends to the right side; ""/"" - appends to the bottom . Reimplemented from TImage.; Definition at line 3491 of file TASImage.cxx. ◆ BeginPaint(). void TASImage::BeginPaint ; (; Bool_t ; mode = kTRUE). overridevirtual . BeginPaint initializes internal array[width x height] of ARGB32 pixel values. ; That provides quick access to image during paint operations. To RLE compress image one needs to call EndPaint method when painting is over. ; Reimplemented from TImage.; Definition at line 3532 of file TASImage.cxx. ◆ Bevel(). void TASImage::Bevel ; (; Int_t ; x = 0, . Int_t ; y = 0, . UInt_t ; width = 0, . UInt_t ; height = 0, . const char * ; hi_color = ""#ffdddddd"", . const char * ; lo_color = ""#ff555555"", . UShort_t ; thick = 1, . Bool_t ; reverse = kFALSE . ). overridevirtual . Bevel is used to create 3D effect while drawing buttons, or any other image that needs to be framed. ; Bevel is drawn using 2 primary colors: one for top and left sides - hi color, and another for bottom and right sides - low color. Bevel can be drawn over existing image or as newly created, as it is shown in code below: TImage *img = TImage::Create();; img->Bevel(0, 0, 400, 300, ""#dddddd"", ""#000000"", 3);; TImageAn abstract interface to image processing library.Definition TImage.h:29; TImage::Createstatic TImage * Create()Create an imag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTASImage.html:36511,access,access,36511,doc/master/classTASImage.html,https://root.cern,https://root.cern/doc/master/classTASImage.html,1,['access'],['access']
Security,"e = ""/path/to/file"";; // TFile * input = TFile::Open( filename );; // TTree * signalTree = (TTree*)input->Get(""TreeName"");; // ```; TTree *sigTree = genTree(1000, 1.0, 1.0, 100);; TTree *bkgTree = genTree(1000, -1.0, 1.0, 101);; ; // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; TString outfileName(""TMVACV.root"");; TFile *outputFile = TFile::Open(outfileName, ""RECREATE"");; ; // DataLoader definitions; We declare variables in the tree so that TMVA can; // find them. For more information see TMVAClassification tutorial.; TMVA::DataLoader *dataloader = new TMVA::DataLoader(""datasetcv"");; ; // Data variables; dataloader->AddVariable(""x"", 'F');; dataloader->AddVariable(""y"", 'F');; ; // Spectator used for split; dataloader->AddSpectator(""eventID"", 'I');; ; // NOTE: Currently TMVA treats all input variables, spectators etc as; // floats. Thus, if the absolute value of the input is too large; // there can be precision loss. This can especially be a problem for; // cross validation with large event numbers.; // A workaround is to define your splitting variable as:; // `dataloader->AddSpectator(""eventID := eventID % 4096"", 'I');`; // where 4096 should be a number much larger than the number of folds; // you intend to run with.; ; // Attaches the trees so they can be read from; dataloader->AddSignalTree(sigTree, 1.0);; dataloader->AddBackgroundTree(bkgTree, 1.0);; ; // The CV mechanism of TMVA splits up the training set into several folds.; // The test set is currently left unused. The `nTest_ClassName=1` assigns; // one event to the test set for each class and puts the rest in the; // training set. A value of 0 is a special value and would split the; // datasets 50 / 50.; dataloader->PrepareTrainingAndTestTree("""", """",; ""nTest_Signal=1""; "":nTest_Background=1""; "":SplitMode=Random""; "":NormMode=NumEvents""; "":!V"");; ; // --------------------------------------------------------------------------; ; //; // This sets up a CrossValidation class (which wrap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidation_8C.html:21066,validat,validation,21066,doc/master/TMVACrossValidation_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidation_8C.html,1,['validat'],['validation']
Security,"e = 0); Generate a skeleton function for this tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name,; - Opening the Tree file,; - Declaration of Tree variables,; - Setting of branches addresses,; - A skeleton for the entry loop. To use this function:; - Open your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""MyAnalysis.C"");; where T is the name of the TTree in file myfile.root; and MyAnalysis.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy. TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierachy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:98837,access,access,98837,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['access'],['access']
Security,"e = 0); Generate a skeleton function for this tree. The function code is written on filename.; If filename is 0, filename will be called nameoftree.C. The generated code includes the following:; - Identification of the original Tree and Input file name,; - Opening the Tree file,; - Declaration of Tree variables,; - Setting of branches addresses,; - A skeleton for the entry loop. To use this function:; - Open your Tree file (eg: TFile f(""myfile.root"");); - T->MakeCode(""MyAnalysis.C"");; where T is the name of the TTree in file myfile.root; and MyAnalysis.C the name of the file created by this function. NOTE: Since the implementation of this function, a new and better; function TTree::MakeClass() has been developed. Int_t MakeProxy(const char* classname, const char* macrofilename = 0, const char* cutfilename = 0, const char* option = 0, Int_t maxUnrolling = 3); Generate a skeleton analysis class for this Tree using TBranchProxy. TBranchProxy is the base of a class hierarchy implementing an; indirect access to the content of the branches of a TTree. ""proxyClassname"" is expected to be of the form:; [path/]fileprefix; The skeleton will then be generated in the file:; fileprefix.h; located in the current directory or in 'path/' if it is specified.; The class generated will be named 'fileprefix'. ""macrofilename"" and optionally ""cutfilename"" are expected to point; to source files which will be included by the generated skeleton.; Method of the same name as the file(minus the extension and path); will be called by the generated skeleton's Process method as follow:; [if (cutfilename())] htemp->Fill(macrofilename());. ""option"" can be used select some of the optional features during; the code generation. The possible options are:; nohist : indicates that the generated ProcessFill should not; fill the histogram. 'maxUnrolling' controls how deep in the class hierarchy does the; system 'unroll' classes that are not split. Unrolling a class; allows direct access to its data members ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:108129,access,access,108129,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['access'],['access']
Security,"e = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidAdd(TObject* arg, Int_t refCount); RooLinkedListElem*createElement(TObject* obj, RooLinkedListElem* elem = 0); voiddeleteElement(RooLinkedListElem*); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; RooLinkedListElem*findLink(const TObject* arg) const; voidTObject::MakeZombie(); voidswapWithNext(RooLinkedListElem* elem). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. RooLinkedListElem*_curStore!; Int_t_curStoreSize!; Int_t_curStoreUsed!; RooLinkedListElem*_first! Link to first element of list; Int_t_hashThreshSize threshold for hashing; RooHashTable*_htableLink! Hash table by link pointer; RooHashTable*_htableName! Hash table by name ; RooLinkedListElem*_last! Link to last element of list; TString_name; Int_t_sizeCurrent size of list; list<std::pair<Int_t,RooLinkedListElem*> >_storeList!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinkedList(Int_t htsize = 0). RooLinkedList(const RooLinkedList& other); Copy constructor. RooLinkedListElem* createElement(TObject* obj, RooLinkedListElem* elem = 0); cout << ""RooLinkedList::createElem("" << this << "") obj = "" << obj << "" elem = "" << elem << endl ;. void deleteElement(RooLinkedListElem* ). RooLinkedList& operator=(const RooLinkedList& other); Assignment operator, copy contents from 'other'. void setHashTableSize(Int_t size); Change the threshold for hash-table use to given size.; If a hash table exists when this method is called, it is regenerated. ~RooLinkedList(); Destructor. RooLinkedListElem* findLink(const TObject* arg) const; Find the element link containing ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLinkedList.html:6384,hash,hashing,6384,root/html532/RooLinkedList.html,https://root.cern,https://root.cern/root/html532/RooLinkedList.html,1,['hash'],['hashing']
Security,"e = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_t*fCoords[fDim] Coordinates; Int_tfDimDimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamVect(); Default constructor for streamer. PDEFoamVect(Int_t ); User constructor creating n-dimensional vector; and allocating dynamically array of components. PDEFoamVect(const TMVA::PDEFoamVect& ); Copy constructor. ~PDEFoamVect(); Destructor. Double_t & operator[](Int_t ); [] is for access to elements as in ordinary matrix like a[j]=b[j]; (Perhaps against some strict rules but rather practical.); Range protection is built in, consequently for substitution; one should use rather use a=b than explicit loop!. TMVA::PDEFoamVect& operator*=(const Double_t& ); unary multiplication operator *=. TMVA::PDEFoamVect& operator+=(const TMVA::PDEFoamVect& ); unary addition operator +=; adding vector c*=x,. TMVA::PDEFoamVect& operator-=(const TMVA::PDEFoamVect& ); unary subtraction operator -=. TMVA::PDEFoamVect operator+(const TMVA::PDEFoamVect& ); addition operator +; sum of 2 vectors: c=a+b, a=a+b,; NEVER USE IT, VERY SLOW!!!. TMVA::PDEFoamVect operator-(const TMVA::PDEFoamVect& ); subtraction operator -; difference of 2 vectors; c=a-b, a=a-b,; NEVER USE IT, VERY SLOW!!!. void Print(Option_t* option) const. Int_t GetDim() const; { return fDim; }. Double_t GetCoord(Int_t i) const; { return fCoords[i]; }. » Last changed: Thu Dec 2 14:53:36 2010 » Last generated: 2010-12-02 14:53; This page has been automatically ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__PDEFoamVect.html:5956,access,access,5956,root/html528/TMVA__PDEFoamVect.html,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoamVect.html,1,['access'],['access']
Security,"e = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_t*fCoords[fDim] Coordinates; Int_tfDimDimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamVect(); Default constructor for streamer. PDEFoamVect(Int_t ); User constructor creating n-dimensional vector; and allocating dynamically array of components. PDEFoamVect(const TMVA::PDEFoamVect& ); Copy constructor. ~PDEFoamVect(); Destructor. Double_t & operator[](Int_t ); [] is for access to elements as in ordinary matrix like a[j]=b[j]; (Perhaps against some strict rules but rather practical.); Range protection is built in, consequently for substitution; one should use rather use a=b than explicit loop!. TMVA::PDEFoamVect& operator*=(const Double_t& ); unary multiplication operator *=. TMVA::PDEFoamVect& operator+=(const TMVA::PDEFoamVect& ); unary addition operator +=; adding vector c*=x,. TMVA::PDEFoamVect& operator-=(const TMVA::PDEFoamVect& ); unary subtraction operator -=. TMVA::PDEFoamVect operator+(const TMVA::PDEFoamVect& ); addition operator +; sum of 2 vectors: c=a+b, a=a+b,; NEVER USE IT, VERY SLOW!!!. TMVA::PDEFoamVect operator-(const TMVA::PDEFoamVect& ); subtraction operator -; difference of 2 vectors; c=a-b, a=a-b,; NEVER USE IT, VERY SLOW!!!. void Print(Option_t* option) const; Printout of all vector components. Int_t GetDim() const; { return fDim; }. Double_t GetCoord(Int_t i) const; { return fCoords[i]; }. » Author: S. Jadach, Tancredi Carli, Dominik Dannheim, Alexander Voigt » C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamVect.html:6025,access,access,6025,root/html530/TMVA__PDEFoamVect.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamVect.html,3,['access'],['access']
Security,"e = 1;; 922 fNet.Initialize(fWeightInitialization);; 923 for (TTrainingSettings & settings : fTrainingSettings) {; 924 ; 925 if (fInteractive){; 926 fInteractive->ClearGraphs();; 927 }; 928 ; 929 TNet<TCuda<>> net(settings.batchSize, fNet);; 930 net.SetWeightDecay(settings.weightDecay);; 931 net.SetRegularization(settings.regularization);; 932 ; 933 // Need to convert dropoutprobabilities to conventions used; 934 // by backend implementation.; 935 std::vector<Double_t> dropoutVector(settings.dropoutProbabilities);; 936 for (auto & p : dropoutVector) {; 937 p = 1.0 - p;; 938 }; 939 net.SetDropoutProbabilities(dropoutVector);; 940 ; 941 net.InitializeGradients();; 942 auto testNet = net.CreateClone(settings.batchSize);; 943 ; 944 Log() << kINFO << ""Training phase "" << trainingPhase << "" of ""; 945 << fTrainingSettings.size() << "":"" << Endl;; 946 trainingPhase++;; 947 ; 948 using DataLoader_t = TDataLoader<TMVAInput_t, TCuda<>>;; 949 ; 950 // Split training data into training and validation set; 951 const std::vector<Event *> &allData = GetEventCollection(Types::kTraining);; 952 const std::vector<Event *> trainingInputData =; 953 std::vector<Event *>(allData.begin(), allData.begin() + nTrainingSamples);; 954 const std::vector<Event *> testInputData =; 955 std::vector<Event *>(allData.begin() + nTrainingSamples, allData.end());; 956 ; 957 if (trainingInputData.size() != nTrainingSamples) {; 958 Log() << kFATAL << ""Inconsistent training sample size"" << Endl;; 959 }; 960 if (testInputData.size() != nTestSamples) {; 961 Log() << kFATAL << ""Inconsistent test sample size"" << Endl;; 962 }; 963 ; 964 size_t nThreads = 1;; 965 TMVAInput_t trainingTuple = std::tie(trainingInputData, DataInfo());; 966 TMVAInput_t testTuple = std::tie(testInputData, DataInfo());; 967 DataLoader_t trainingData(trainingTuple, nTrainingSamples,; 968 net.GetBatchSize(), net.GetInputWidth(),; 969 net.GetOutputWidth(), nThreads);; 970 DataLoader_t testData(testTuple, nTestSamples, testNet.GetBatchSize(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:33953,validat,validation,33953,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['validat'],['validation']
Security,"e Binary search tree including a volume search method. ; Definition at line 65 of file BinarySearchTree.h. Public Member Functions;  BinarySearchTree (const BinarySearchTree &b);  copy constructor that creates a true copy, i.e. a completely independent tree ;  ;  BinarySearchTree (void);  default constructor ;  ; virtual ~BinarySearchTree (void);  destructor ;  ; void CalcStatistics (TMVA::Node *n=nullptr);  calculate basic statistics (mean, rms for each variable) ;  ; virtual const char * ClassName () const;  ; void Clear (TMVA::Node *n=nullptr);  clear nodes ;  ; virtual Node * CreateNode (UInt_t) const;  ; virtual BinaryTree * CreateTree () const;  ; Double_t Fill (const std::vector< TMVA::Event * > &events, const std::vector< Int_t > &theVars, Int_t theType=-1);  create the search tree from the event collection using ONLY the variables specified in ""theVars"" ;  ; Double_t Fill (const std::vector< TMVA::Event * > &events, Int_t theType=-1);  create the search tree from the events in a TTree using ALL the variables specified included in the Event ;  ; UInt_t GetPeriode (void) const;  ; Double_t GetSumOfWeights (Int_t theType) const;  return the sum of event (node) weights ;  ; Double_t GetSumOfWeights (void) const;  return the sum of event (node) weights ;  ; void Insert (const Event *);  insert a new ""event"" in the binary tree ;  ; virtual TClass * IsA () const;  ; Float_t Max (Types::ESBType sb, UInt_t var);  access to Maximum for signal and background for each variable ;  ; Float_t Mean (Types::ESBType sb, UInt_t var);  access to mean for signal and background for each variable ;  ; Float_t Min (Types::ESBType sb, UInt_t var);  access to Minimum for signal and background for each variable ;  ; void NormalizeTree ();  Normalisation of tree. ;  ; Float_t RMS (Types::ESBType sb, UInt_t var);  access to RMS for signal and background for each variable ;  ; Float_t RMS (UInt_t var);  access to RMS for each variable ;  ; BinarySearchTreeNode * Search (Event *event) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html:1775,access,access,1775,doc/master/classTMVA_1_1BinarySearchTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html,3,['access'],['access']
Security,"e Graph Example . i 0 0.000000 1.986693 ; i 1 0.100000 2.955202 ; i 2 0.200000 3.894183 ; i 3 0.300000 4.794255 ; i 4 0.400000 5.646425 ; i 5 0.500000 6.442177 ; i 6 0.600000 7.173561 ; i 7 0.700000 7.833269 ; i 8 0.800000 8.414710 ; i 9 0.900000 8.912074 ; i 10 1.000000 9.320391 ; i 11 1.100000 9.635582 ; i 12 1.200000 9.854497 ; i 13 1.300000 9.974950 ; i 14 1.400000 9.995736 ; i 15 1.500000 9.916648 ; i 16 1.600000 9.738476 ; i 17 1.700000 9.463001 ; i 18 1.800000 9.092974 ; i 19 1.900000 8.632094 ; ; from __future__ import print_function; from ROOT import TCanvas, TGraph; from ROOT import gROOT; from math import sin; from array import array; ; ; c1 = TCanvas( 'c1', 'A Simple Graph Example', 200, 10, 700, 500 ); ; c1.SetFillColor( 42 ); c1.SetGrid(); ; n = 20; x, y = array( 'd' ), array( 'd' ); ; for i in range( n ):; x.append( 0.1*i ); y.append( 10*sin( x[i]+0.2 ) ); print(' i %i %f %f ' % (i,x[i],y[i])); ; gr = TGraph( n, x, y ); gr.SetLineColor( 2 ); gr.SetLineWidth( 4 ); gr.SetMarkerColor( 4 ); gr.SetMarkerStyle( 21 ); gr.SetTitle( 'a simple graph' ); gr.GetXaxis().SetTitle( 'X title' ); gr.GetYaxis().SetTitle( 'Y title' ); gr.Draw( 'ACP' ); ; # TCanvas.Update() draws the frame, after which one can change it; c1.Update(); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 12 ); c1.Modified(); c1.Update(); # If the graph does not appear, try using the ""i"" flag, e.g. ""python3 -i graph.py""; # This will access the interactive mode after executing the script, and thereby persist; # long enough for the graph to appear.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; SetBorderSizec SetBorderSize(2); AuthorWim Lavrijsen ; Definition in file graph.py. tutorialspyrootgraph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph_8py.html:1668,access,access,1668,doc/master/graph_8py.html,https://root.cern,https://root.cern/doc/master/graph_8py.html,1,['access'],['access']
Security,"e Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Static Public Attributes |; Private Member Functions |; Private Attributes |; Static Private Attributes |; List of all members ; TMVA::DNN::TCudaMatrix< AFloat > Class Template Reference. ; template<typename AFloat>; class TMVA::DNN::TCudaMatrix< AFloat >TCudaMatrix Class. ; The TCudaMatrix class represents matrices on a CUDA device. The elements of the matrix are stored in a TCudaDeviceBuffer object which takes care of the allocation and freeing of the device memory. TCudaMatrices are lightweight object, that means on assignment and copy creation only a shallow copy is performed and no new element buffer allocated. To perform a deep copy use the static Copy method of the TCuda architecture class.; The TCudaDeviceBuffer has an associated cuda stream, on which the data is transferred to the device. This stream can be accessed through the GetComputeStream member function and used to synchronize computations.; The TCudaMatrix class also holds static references to CUDA resources. Those are the cublas handle, a buffer of curand states for the generation of random numbers as well as a vector containing ones, which is used for summing column matrices using matrix-vector multiplication. The class also has a static buffer for returning results from the device. ; Definition at line 102 of file CudaMatrix.h. Public Member Functions;  TCudaMatrix ();  ;  TCudaMatrix (const TCudaMatrix &)=default;  ;  TCudaMatrix (const TMatrixT< AFloat > &);  ;  TCudaMatrix (size_t i, size_t j);  ;  TCudaMatrix (TCudaDeviceBuffer< AFloat > buffer, size_t m, size_t n);  ;  TCudaMatrix (TCudaMatrix &&)=default;  ;  ~TCudaMatrix ()=default;  ; cudaStream_t GetComputeStream () const;  ; const cublasHandle_t & GetCublasHandle () const;  ; AFloat * GetDataPointer ();  ; const AFloat * GetDataPointer () const;  ; TCudaDeviceBuffer< AFloat > GetDeviceBuffer () const;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCudaMatrix.html:1060,access,accessed,1060,doc/master/classTMVA_1_1DNN_1_1TCudaMatrix.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TCudaMatrix.html,1,['access'],['accessed']
Security,"e Return number of received bytes or -1 in case of error. ;  ; static Int_t SecureSend (TSocket *Socket, Int_t enc, Int_t KeyType, const char *In);  Encode null terminated str using the session private key indicated by enc and sends it over the network Returns number of bytes sent, or -1 in case of error. ;  ; static Int_t SendRSAPublicKey (TSocket *Socket, Int_t key=0);  Receives server RSA Public key Sends local RSA public key encoded. ;  ; static void SetAuthReUse (Bool_t authreuse);  Set global AuthReUse flag. ;  ; static void SetDefaultRSAKeyType (Int_t key);  Static method setting the default type of RSA key. ;  ; static void SetDefaultUser (const char *defaultuser);  Set default user name. ;  ; static void SetGlobalExpDate (TDatime expdate);  Set default expiring date for new validity contexts. ;  ; static void SetGlobalPasswd (const char *passwd);  Set global passwd to be used for authentication to rootd or proofd. ;  ; static void SetGlobalPwHash (Bool_t pwhash);  Set global passwd hash flag to be used for authentication to rootd or proofd. ;  ; static void SetGlobalSRPPwd (Bool_t srppwd);  Set global SRP passwd flag to be used for authentication to rootd or proofd. ;  ; static void SetGlobalUser (const char *user);  Set global user name to be used for authentication to rootd or proofd. ;  ; static void SetGlobusAuthHook (GlobusAuth_t func);  Set Globus authorization function. ;  ; static void SetKrb5AuthHook (Krb5Auth_t func);  Set kerberos5 authorization function. ;  ; static void SetPromptUser (Bool_t promptuser);  Set global PromptUser flag. ;  ; static void SetReadHomeAuthrc (Bool_t readhomeauthrc);  Set flag controlling the reading of $HOME/.rootauthrc. ;  ; static void SetRSAInit (Int_t init=1);  Static method setting RSA initialization flag. ;  ; static Int_t SetRSAPublic (const char *rsapubexport, Int_t klen);  Store RSA public keys from export string rsaPubExport. ;  ; static void SetSecureAuthHook (SecureAuth_t func);  Set secure authorization fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:15191,hash,hash,15191,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,2,"['authenticat', 'hash']","['authentication', 'hash']"
Security,"e RooLinkedList.cxx. ◆ RecursiveRemove(). void RooLinkedList::RecursiveRemove ; (; TObject * ; obj). overridevirtual . If one of the TObject we have a referenced to is deleted, remove the reference. ; Reimplemented from TObject.; Definition at line 481 of file RooLinkedList.cxx. ◆ Remove(). bool RooLinkedList::Remove ; (; TObject * ; arg). virtual . Remove object from collection. ; Definition at line 449 of file RooLinkedList.cxx. ◆ rend(). RooLinkedListIterImpl RooLinkedList::rend ; (; ); const. Definition at line 773 of file RooLinkedList.cxx. ◆ Replace(). bool RooLinkedList::Replace ; (; const TObject * ; oldArg, . const TObject * ; newArg . ). Replace object 'oldArg' in collection with new object 'newArg'. ; If 'oldArg' is not found in collection false is returned ; Definition at line 510 of file RooLinkedList.cxx. ◆ setHashTableSize(). void RooLinkedList::setHashTableSize ; (; Int_t ; size). Change the threshold for hash-table use to given size. ; If a hash table exists when this method is called, it is regenerated. ; Definition at line 331 of file RooLinkedList.cxx. ◆ SetName(). void RooLinkedList::SetName ; (; const char * ; name). inline . Definition at line 105 of file RooLinkedList.h. ◆ size(). std::size_t RooLinkedList::size ; (; ); const. inline . Definition at line 70 of file RooLinkedList.h. ◆ Sort(). void RooLinkedList::Sort ; (; bool ; ascend = true). Definition at line 779 of file RooLinkedList.cxx. ◆ Streamer(). void RooLinkedList::Streamer ; (; TBuffer & ; R__b). overridevirtual . Custom streaming handling schema evolution w.r.t past implementations. ; Reimplemented from TObject.; Definition at line 903 of file RooLinkedList.cxx. ◆ StreamerNVirtual(). void RooLinkedList::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 149 of file RooLinkedList.h. ◆ useNptr(). void RooLinkedList::useNptr ; (; bool ; flag). inline . Definition at line 107 of file RooLinkedList.h. Friends And Related Symbol Documentation. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLinkedList.html:24971,hash,hash,24971,doc/master/classRooLinkedList.html,https://root.cern,https://root.cern/doc/master/classRooLinkedList.html,1,['hash'],['hash']
Security,"e SparkContext instance. Finally, a couple of histograms are drawn from the created columns in the dataset.; import pyspark; import ROOT; ; # Point RDataFrame calls to Spark RDataFrame object; RDataFrame = ROOT.RDF.Experimental.Distributed.Spark.RDataFrame; ; # Setup the connection to Spark; # First create a dictionary with keys representing Spark specific configuration; # parameters. In this tutorial we use the following configuration parameters:; #; # 1. spark.app.name: The name of the Spark application; # 2. spark.master: The Spark endpoint responsible for running the; # application. With the syntax ""local[2]"" we signal Spark we want to run; # locally on the same machine with 2 cores, each running a separate; # process. The default behaviour of a Spark application would run; # locally on the same machine with as many concurrent processes as; # available cores, that could be also written as ""local[*]"".; #; # If you have access to a remote cluster you should substitute the endpoint URL; # of your Spark master in the form ""spark://HOST:PORT"" in the value of; # `spark.master`. Depending on the availability of your cluster you may request; # more computing nodes or cores per node with a similar configuration:; #; # sparkconf = pyspark.SparkConf().setAll(; # {""spark.master"": ""spark://HOST:PORT"",; # ""spark.executor.instances"": <number_of_nodes>,; # ""spark.executor.cores"" <cores_per_node>,}.items()); #; # You can find all configuration options and more details in the official Spark; # documentation at https://spark.apache.org/docs/latest/configuration.html .; ; # Create a SparkConf object with all the desired Spark configuration parameters; sparkconf = pyspark.SparkConf().setAll(; {""spark.app.name"": ""distrdf001_spark_connection"",; ""spark.master"": ""local[2]"",; ""spark.driver.memory"": ""4g""}.items()); # Create a SparkContext with the configuration stored in `sparkconf`; sparkcontext = pyspark.SparkContext(conf=sparkconf); ; # Create an RDataFrame that will use Spark as a back",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/distrdf001__spark__connection_8py.html:1581,access,access,1581,doc/master/distrdf001__spark__connection_8py.html,https://root.cern,https://root.cern/doc/master/distrdf001__spark__connection_8py.html,1,['access'],['access']
Security,"e TList is the owner (set via SetOwner()) and option ""nodelete"" is not set. If option=""nodelete"" then don't delete any heap objects that were marked with the kCanDelete bit, otherwise these objects will be deleted (this option is used by THashTable::Clear()). ; Implements TCollection.; Reimplemented in TListOfEnums, TListOfEnumsWithLock, TListOfDataMembers, TListOfFunctions, TListOfFunctionTemplates, TViewPubDataMembers, and TViewPubFunctions.; Definition at line 400 of file TList.cxx. ◆ DeclFileName(). static const char * TList::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 112 of file TList.h. ◆ Delete(). void TList::Delete ; (; Option_t * ; option = """"). overridevirtual . Remove all objects from the list AND delete all heap based objects. ; If option=""slow"" then keep list consistent during delete. This allows recursive list operations during the delete (e.g. during the dtor of an object in this list one can still access the list to search for other not yet deleted objects). ; Implements TCollection.; Reimplemented in TQCommand, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TViewPubDataMembers, and TViewPubFunctions.; Definition at line 468 of file TList.cxx. ◆ DoSort(). std::shared_ptr< TObjLink > * TList::DoSort ; (; TObjLinkPtr_t * ; head, . Int_t ; n . ). protected . Sort linked list. ; Definition at line 982 of file TList.cxx. ◆ FindLink(). TObjLink * TList::FindLink ; (; const TObject * ; obj, . Int_t & ; idx . ); const. protected . Returns the TObjLink object that contains object obj. ; In idx it returns the position of the object in the list. ; Definition at line 626 of file TList.cxx. ◆ FindObject() [1/2]. TObject * TList::FindObject ; (; const char * ; name); const. overridevirtual . Find an object in this list using its name. ; Requires a sequential scan till the object has been found. Returns 0 if object with specified name is not f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTList.html:30510,access,access,30510,doc/master/classTList.html,https://root.cern,https://root.cern/doc/master/classTList.html,1,['access'],['access']
Security,"e TROOT.h. Constructor & Destructor Documentation. ◆ TROOT() [1/3]. TROOT::TROOT ; (; const TROOT & ; ). privatedelete . ◆ TROOT() [2/3]. TROOT::TROOT ; (; ). protected . Only used by Dictionary. ; Default ctor. ; Definition at line 605 of file TROOT.cxx. ◆ TROOT() [3/3]. TROOT::TROOT ; (; const char * ; name, . const char * ; title, . VoidFuncPtr_t * ; initfunc = nullptr . ). Initialize the ROOT system. ; The creation of the TROOT object initializes the ROOT system. It must be the first ROOT related action that is performed by a program. The TROOT object must be created on the stack (can not be called via new since ""operator new"" is protected). The TROOT object is either created as a global object (outside the main() program), or it is one of the first objects created in main(). Make sure that the TROOT object stays in scope for as long as ROOT related actions are performed. TROOT is a so called singleton so only one instance of it can be created. The single TROOT object can always be accessed via the global pointer gROOT. The name and title arguments can be used to identify the running application. The initfunc argument can contain an array of function pointers (last element must be 0). These functions are executed at the end of the constructor. This way one can easily extend the ROOT system without adding permanent dependencies (e.g. the graphics system is initialized via such a function). ; Definition at line 639 of file TROOT.cxx. ◆ ~TROOT(). TROOT::~TROOT ; (; ). virtual . Clean up and free resources used by ROOT (files, network sockets, shared memory segments, etc.). ; Definition at line 867 of file TROOT.cxx. Member Function Documentation. ◆ AddClass(). void TROOT::AddClass ; (; TClass * ; cl). Add a class to the list and map of classes. ; This routine is deprecated, use TClass::AddClass directly. ; Definition at line 1025 of file TROOT.cxx. ◆ AddClassGenerator(). void TROOT::AddClassGenerator ; (; TClassGenerator * ; generator). Add a class generator. ; This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:40636,access,accessed,40636,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['access'],['accessed']
Security,"e TStreamerInfo::kAnyP+TStreamerInfo::kOffsetL: {; 1084 DOLOOP {; 1085 b.ReadFastArray((void**)(arr[k]+ioffset),cle,compinfo[i]->fLength,isPreAlloc,pstreamer);; 1086 }; 1087 }; 1088 continue;; 1089 ; 1090// case TStreamerInfo::kSTLvarp: // Variable size array of STL containers.; 1091// {; 1092// TMemberStreamer *pstreamer = compinfo[i]->fStreamer;; 1093// TClass *cl = compinfo[i]->fClass;; 1094// ROOT::NewArrFunc_t arraynew = cl->GetNewArray();; 1095// ROOT::DelArrFunc_t arraydel = cl->GetDeleteArray();; 1096// UInt_t start,count;; 1097// // Version_t v =; 1098// b.ReadVersion(&start, &count, cle);; 1099// if (pstreamer == 0) {; 1100// Int_t size = cl->Size();; 1101// Int_t imethod = compinfo[i]->fMethod+eoffset;; 1102// DOLOOP {; 1103// char **contp = (char**)(arr[k]+ioffset);; 1104// const Int_t *counter = (Int_t*)(arr[k]+imethod);; 1105// const Int_t sublen = (*counter);; 1106 ; 1107// for(int j=0;j<compinfo[i]->fLength;++j) {; 1108// if (arraydel) arraydel(contp[j]);; 1109// contp[j] = 0;; 1110// if (sublen<=0) continue;; 1111// if (arraynew) {; 1112// contp[j] = (char*)arraynew(sublen, 0);; 1113// char *cont = contp[j];; 1114// for(int k=0;k<sublen;++k) {; 1115// cl->Streamer( cont, b );; 1116// cont += size;; 1117// }; 1118// } else {; 1119// // Can't create an array of object; 1120// Error(""ReadBuffer"",""The element %s::%s type %d (%s) can be read because of the class does not have access to new %s[..]\n"",; 1121// GetName(),aElement->GetFullName(),kase,aElement->GetTypeName(),GetName());; 1122// void *cont = cl->New();; 1123// for(int k=0;k<sublen;++k) {; 1124// cl->Streamer( cont, b );; 1125// }; 1126// }; 1127// }; 1128// }; 1129// } else {; 1130// DOLOOP{(*pstreamer)(b,arr[k]+ioffset,compinfo[i]->fLength);}; 1131// }; 1132// b.CheckByteCount(start,count,aElement->GetFullName());; 1133// }; 1134// continue;; 1135 ; 1136 case TStreamerInfo::kSTLp: // Pointer to Container with no virtual table (stl) and no comment; 1137 case TStreamerInfo::kSTLp + TStreamerInfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoReadBuffer_8cxx_source.html:48597,access,access,48597,doc/master/TStreamerInfoReadBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoReadBuffer_8cxx_source.html,1,['access'],['access']
Security,"e TVirtualX.cxx. ◆ MoveWindow() [2/2]. void TVirtualX::MoveWindow ; (; Window_t ; id, . Int_t ; x, . Int_t ; y . ). virtual . Moves the specified window to the specified x and y coordinates. ; It does not change the window's size, raise the window, or change the mapping state of the window.; Parameters. [in]idwindow identifier ; [in]x,ycoordinates, which define the new position of the window relative to its parent. . Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1073 of file TVirtualX.cxx. ◆ NeedRedraw(). Bool_t TVirtualX::NeedRedraw ; (; ULongptr_t ; tgwindow, . Bool_t ; force . ). virtual . Notify the low level GUI layer ROOT requires ""tgwindow"" to be updated. ; Returns kTRUE if the notification was desirable and it was sent; At the moment only Qt4 layer needs that; One needs explicitly cast the first parameter to TGWindow to make it working in the implementation.; One needs to process the notification to confine all paint operations within ""expose"" / ""paint"" like low level event or equivalent ; Reimplemented in TGCocoa.; Definition at line 1126 of file TVirtualX.cxx. ◆ NextEvent(). void TVirtualX::NextEvent ; (; Event_t & ; event). virtual . The ""event"" is set to default event. ; This method however, should never be called. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 137 of file TVirtualX.cxx. ◆ OpenDisplay(). Int_t TVirtualX::OpenDisplay ; (; const char * ; dpyName). virtual . Opens connection to display server (if such a thing exist on the current platform). ; The encoding and interpretation of the display name.; On X11 this method returns on success the X display socket descriptor >0, 0 in case of batch mode, and <0 in case of failure (cannot connect to display dpyName). ; Reimplemented in TGCocoa, TGX11, TGWin32, and TGWin32VirtualXProxy.; Definition at line 1199 of file TVirtualX.cxx. ◆ OpenPixmap(). Int_t TVirtualX::OpenPixmap ; (; UInt_t ; w, . UInt_t ; h . ). virtual .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:105060,expose,expose,105060,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['expose'],['expose']
Security,"e a hunk; of text, such as the head of an HTTP request, without crossing the; boundary, so that the next call to RecvRaw() etc. reads the data; after the hunk. To achieve that, this function does the following:. 1. Peek at incoming data. 2. Determine whether the peeked data, along with the previously; read data, includes the terminator. 3a. If yes, read the data until the end of the terminator, and; exit. 3b. If no, read the peeked data and goto 1. The function is careful to assume as little as possible about the; implementation of peeking. For example, every peek is followed by; a read. If the read returns a different amount of data, the; process is retried until all data arrives safely. Reads at most one less than the number of characters specified by maxsize. const char * HttpTerminator(const char* start, const char* peeked, Int_t peeklen); Determine whether [START, PEEKED + PEEKLEN) contains an HTTP new; line [\r]\n. If so, return the pointer to the position after the line,; otherwise return 0. This is used as callback to GetHunk(). The data; between START and PEEKED has been read and cannot be ""unread""; the; data after PEEKED has only been peeked. TString BasicAuthentication(); Return basic authentication scheme, to be added to the request. void SetProxy(const char* url); Static method setting global proxy URL. const char * GetProxy(); Static method returning the global proxy URL. void ProcessHttpHeader(const TString& headerLine); Process the HTTP header in the argument. This method is intended to be; overwritten by subclasses that exploit the information contained in the; HTTP headers. TWebFile(); { }. TWebFile(const char* url, Option_t* opt = """"). » Author: Fons Rademakers 17/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TWebFile.html:32832,authenticat,authentication,32832,root/html604/TWebFile.html,https://root.cern,https://root.cern/root/html604/TWebFile.html,1,['authenticat'],['authentication']
Security,"e a hunk; of text, such as the head of an HTTP request, without crossing the; boundary, so that the next call to RecvRaw() etc. reads the data; after the hunk. To achieve that, this function does the following:. 1. Peek at incoming data. 2. Determine whether the peeked data, along with the previously; read data, includes the terminator. 3a. If yes, read the data until the end of the terminator, and; exit. 3b. If no, read the peeked data and goto 1. The function is careful to assume as little as possible about the; implementation of peeking. For example, every peek is followed by; a read. If the read returns a different amount of data, the; process is retried until all data arrives safely. Reads at most one less than the number of characters specified by maxsize. const char * HttpTerminator(const char* start, const char* peeked, Int_t peeklen); Determine whether [START, PEEKED + PEEKLEN) contains an HTTP new; line [\r]\n. If so, return the pointer to the position after the line,; otherwise return 0. This is used as callback to GetHunk(). The data; between START and PEEKED has been read and cannot be ""unread""; the; data after PEEKED has only been peeked. TString BasicAuthentication(); Return basic authentication scheme, to be added to the request. void SetProxy(const char* url); Static method setting global proxy URL. const char * GetProxy(); Static method returning the global proxy URL. void ProcessHttpHeader(const TString& headerLine); Process the HTTP header in the argument. This method is intended to be; overwritten by subclasses that exploit the information contained in the; HTTP headers. TWebFile(); { }. TWebFile(const char* url, Option_t* opt = """"). » Author: Fons Rademakers 17/01/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TWebFile.html:32832,authenticat,authentication,32832,root/html602/TWebFile.html,https://root.cern,https://root.cern/root/html602/TWebFile.html,1,['authenticat'],['authentication']
Security,"e aSlice goes out of scope. aSlices will; contain the histogram for the i-th parameter of the fit function at aSlices[i];; aSlices[n] (n being the number of parameters) contains the chi2 distribution of; the fits. If arr is NULL, the generated histograms are added to the list of objects; in the current directory. It is the user's responsability to delete; these histograms. Example: Assume a 2-d histogram h2; Root > h2->FitSlicesX(); produces 4 TH1D histograms; with h2_0 containing parameter 0(Constant) for a Gaus fit; of each bin in Y projected along X; with h2_1 containing parameter 1(Mean) for a gaus fit; with h2_2 containing parameter 2(RMS) for a gaus fit; with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit. Root > h2->FitSlicesX(0,15,22,10);; same as above, but only for bins 15 to 22 along Y; and only for bins in Y for which the corresponding projection; along X has more than cut bins filled. NOTE: To access the generated histograms in the current directory, do eg:; TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");. void FitSlicesY(TF1* f1 = 0, Int_t firstxbin = 0, Int_t lastxbin = -1, Int_t cut = 0, Option_t* option = ""QNR"", TObjArray* arr = 0); Project slices along Y in case of a 2-D histogram, then fit each slice; with function f1 and make a histogram for each fit parameter; Only bins along X between firstxbin and lastxbin are considered.; By default (firstxbin == 0, lastxbin == -1), all bins in x including; over- and underflows are taken into account.; If f1=0, a gaussian is assumed; Before invoking this function, one can set a subrange to be fitted along Y; via f1->SetRange(ymin,ymax); The argument option (default=""QNR"") can be used to change the fit options.; ""Q"" means Quiet mode; ""N"" means do not show the result of the fit; ""R"" means fit the function in the specified function range; ""G2"" merge 2 consecutive bins along Y; ""G3"" merge 3 consecutive bins along Y; ""G4"" merge 4 consecutive bins along Y; ""G5"" merge 5 consecutive bins alo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2.html:33270,access,access,33270,root/html528/TH2.html,https://root.cern,https://root.cern/root/html528/TH2.html,5,['access'],['access']
Security,"e aSlice goes out of scope. aSlices will; contain the histogram for the i-th parameter of the fit function at aSlices[i];; aSlices[n] (n being the number of parameters) contains the chi2 distribution of; the fits. If arr is NULL, the generated histograms are added to the list of objects; in the current directory. It is the user's responsability to delete; these histograms. Example: Assume a 2-d histogram h2; Root > h2->FitSlicesY(); produces 4 TH1D histograms; with h2_0 containing parameter 0(Constant) for a Gaus fit; of each bin in X projected along Y; with h2_1 containing parameter 1(Mean) for a gaus fit; with h2_2 containing parameter 2(RMS) for a gaus fit; with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit. Root > h2->FitSlicesY(0,15,22,10);; same as above, but only for bins 15 to 22 along X; and only for bins in X for which the corresponding projection; along Y has more than cut bins filled. NOTE: To access the generated histograms in the current directory, do eg:; TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");. A complete example of this function is given in tutorial:fitslicesy.C. with the following output:. /*; ; */. Double_t GetBinWithContent2(Double_t c, Int_t& binx, Int_t& biny, Int_t firstxbin = 1, Int_t lastxbin = -1, Int_t firstybin = 1, Int_t lastybin = -1, Double_t maxdiff = 0) const; compute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which; diff = abs(cell_content-c) <= maxdiff; In case several cells in the specified range with diff=0 are found; the first cell found is returned in binx,biny.; In case several cells in the specified range satisfy diff <=maxdiff; the cell with the smallest difference is returned in binx,biny.; In all cases the function returns the smallest difference. NOTE1: if firstxbin < 0, firstxbin is set to 1; if (lastxbin < firstxbin then lastxbin is set to the number of bins in X; ie if firstxbin=1 and lastxbin=0 (default) the search is on all bins in X except; for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2.html:35601,access,access,35601,root/html528/TH2.html,https://root.cern,https://root.cern/root/html528/TH2.html,4,['access'],['access']
Security,"e aSlice goes out of scope. aSlices will; contain the histogram for the i-th parameter of the fit function at aSlices[i];; aSlices[n] (n being the number of parameters) contains the chi2 distribution of; the fits. If arr is NULL, the generated histograms are added to the list of objects; in the current directory. It is the user's responsability to delete; these histograms. Example: Assume a 2-d histogram h2; Root > h2->FitSlicesY(); produces 4 TH1D histograms; with h2_0 containing parameter 0(Constant) for a Gaus fit; of each bin in X projected along Y; with h2_1 containing parameter 1(Mean) for a gaus fit; with h2_2 containing parameter 2(RMS) for a gaus fit; with h2_chi2 containing the chisquare/number of degrees of freedom for a gaus fit. Root > h2->FitSlicesY(0,15,22,10);; same as above, but only for bins 15 to 22 along X; and only for bins in X for which the corresponding projection; along Y has more than cut bins filled. NOTE: To access the generated histograms in the current directory, do eg:; TH1D *h2_1 = (TH1D*)gDirectory->Get(""h2_1"");. A complete example of this function is given in tutorial:fitslicesy.C. with the following output:. /*; ; */. Int_t GetBin(Int_t binx, Int_t biny, Int_t binz = 0) const; See comments in TH1::GetBin. Double_t GetBinWithContent2(Double_t c, Int_t& binx, Int_t& biny, Int_t firstxbin = 1, Int_t lastxbin = -1, Int_t firstybin = 1, Int_t lastybin = -1, Double_t maxdiff = 0) const; compute first cell (binx,biny) in the range [firstxbin,lastxbin][firstybin,lastybin] for which; diff = abs(cell_content-c) <= maxdiff; In case several cells in the specified range with diff=0 are found; the first cell found is returned in binx,biny.; In case several cells in the specified range satisfy diff <=maxdiff; the cell with the smallest difference is returned in binx,biny.; In all cases the function returns the smallest difference. NOTE1: if firstxbin < 0, firstxbin is set to 1; if (lastxbin < firstxbin then lastxbin is set to the number of bins in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2.html:39413,access,access,39413,root/html602/TH2.html,https://root.cern,https://root.cern/root/html602/TH2.html,1,['access'],['access']
Security,"e and error is generated if one of the; elements of newDeps is not found as a server. Double_t eval(const RooArgSet* nset = 0); Evaluate TFormula using given normalization set to be used as; observables definition passed to RooAbsReal::getVal(). DefinedValue(Int_t code); Interface to TFormula, return value defined by object with id 'code'; Object ids are mapped from object names by method DefinedVariable(). Int_t DefinedVariable(TString& name, int& action); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. Int_t DefinedVariable(TString& name); Interface to TFormula. If name passed by TFormula is recognized; as one of our RooAbsArg servers, return a unique id integer; that represent this variable. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. void printValue(ostream& os) const; Print value of formula. void printName(ostream& os) const; Print name of formula. void printTitle(ostream& os) const; Print title of formula. void printClassName(ostream& os) const; Print class name of formula. void printArgs(ostream& os) const; Print arguments of formula, i.e. dependents that are actually used. TObject* Clone(const char* newName = 0) const; { return new RooFormula(*this,newName) ; }. RooAbsArg* getParameter(const char* name); Return pointer to parameter with given name. RooAbsArg* getParameter(Int_t index); Return pointer to parameter at given index. Bool_t ok(); Function value accessor. { return _isOK ; }. void Print(Option_t* options = 0) const; Printing interface (human readable). RooFormula& operator=(const RooFormula& other). void initCopy(const RooFormula& other). » Last changed: Mon Dec 7 13:47:40 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFormula.html:16219,access,accessor,16219,root/html526/RooFormula.html,https://root.cern,https://root.cern/root/html526/RooFormula.html,1,['access'],['accessor']
Security,e and virtual functions.; TEveVectorT<float> A three-vector template without TObject inheritance and virtual functions.; TEveViewer Reve representation of TGLViewer.; TEveViewerList List of Viewers providing common operations on TEveViewer collections.; TEveViewerListEditor GUI editor for TEveViewerList.; TEveWindow Abstract base-class for eve-windows.; TEveWindowEditor GUI editor for TEveWindow.; TEveWindowFrame Eve-window containing any TGFrame.; TEveWindowManager Manager for EVE windows.; TEveWindowPack Eve-window containing a TGPack.; TEveWindowSlot An unoccupied eve-window slot.; TEveWindowTab Eve-window containing a TGTab.; TEventIter Event iterator used by TProofPlayer's; TEventIterObj Event iterator for objects; TEventIterTree Event iterator for Trees; TEventIterUnit Event iterator for objects; TEventList A list of selected entries in a TTree.; TExMap Map with external hash; TExMapIter TExMap iterator; TExec To execute a CINT command; TF1 The Parametric 1-D function; TF12 Projection of a TF2 along x or y; TF1Editor user interface for TF1 objects; TF2 The Parametric 2-D function; TF2GL GL renderer for TF2 and TF3.; TF3 The Parametric 3-D function; TFFTComplex ; TFFTComplexReal ; TFFTReal ; TFFTRealComplex ; TFITSHDU Class interfacing FITS HDUs; TFPBlock File prefetch block; TFTP File Transfer Protocol class using rootd; TFastCgi fastcgi engine for THttpServer; TFcnAdapter wrapper class implementing the Minuit2 interface for TMinuit2-like objective functions; TFeldmanCousins calculate the CL upper limit using the Feldman-Cousins method; TFile ROOT file; TFileCacheRead TFile cache when reading; TFileCacheWrite TFile cache when writing; TFileCollection Collection of TFileInfo objects; TFileDrawMap Draw a 2-d map of the objects in a file; TFileHandler Handles events on file descriptors; TFileInfo Describes generic file info including meta data information; TFileInfoMeta Describes TFileInfo meta data; TFileIter TFile class iterator; TFileMergeInfo ; TFileMerger Fil,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:73872,hash,hash,73872,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['hash'],['hash']
Security,e and virtual functions.; TEveVectorT<float> A three-vector template without TObject inheritance and virtual functions.; TEveViewer Reve representation of TGLViewer.; TEveViewerList List of Viewers providing common operations on TEveViewer collections.; TEveViewerListEditor GUI editor for TEveViewerList.; TEveWindow Abstract base-class for eve-windows.; TEveWindowEditor GUI editor for TEveWindow.; TEveWindowFrame Eve-window containing any TGFrame.; TEveWindowManager Manager for EVE windows.; TEveWindowPack Eve-window containing a TGPack.; TEveWindowSlot An unoccupied eve-window slot.; TEveWindowTab Eve-window containing a TGTab.; TEventIter Event iterator used by TProofPlayer's; TEventIterObj Event iterator for objects; TEventIterTree Event iterator for Trees; TEventIterUnit Event iterator for objects; TEventList A list of selected entries in a TTree.; TExMap Map with external hash; TExMapIter TExMap iterator; TExec To execute a CINT command; TF1 The Parametric 1-D function; TF12 Projection of a TF2 along x or y; TF1Editor user interface for TF1 objects; TF2 The Parametric 2-D function; TF2GL GL renderer for TF2 and TF3.; TF3 The Parametric 3-D function; TFFTComplex ; TFFTComplexReal ; TFFTReal ; TFFTRealComplex ; TFITSHDU Class interfacing FITS HDUs; TFPBlock File prefetch block; TFTP File Transfer Protocol class using rootd; TFcnAdapter wrapper class implementing the Minuit2 interface for TMinuit2-like objective functions; TFeldmanCousins calculate the CL upper limit using the Feldman-Cousins method; TFile ROOT file; TFileCacheRead TFile cache when reading; TFileCacheWrite TFile cache when writing; TFileCollection Collection of TFileInfo objects; TFileDrawMap Draw a 2-d map of the objects in a file; TFileHandler Handles events on file descriptors; TFileInfo Describes generic file info including meta data information; TFileInfoMeta Describes TFileInfo meta data; TFileIter TFile class iterator; TFileMergeInfo ; TFileMerger File copying and merging services; TFilePref,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:70791,hash,hash,70791,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,['hash'],['hash']
Security,e and virtual functions.; TEveVectorT<float> A three-vector template without TObject inheritance and virtual functions.; TEveViewer Reve representation of TGLViewer.; TEveViewerList List of Viewers providing common operations on TEveViewer collections.; TEveViewerListEditor GUI editor for TEveViewerList.; TEveWindow Abstract base-class for eve-windows.; TEveWindowEditor GUI editor for TEveWindow.; TEveWindowFrame Eve-window containing any TGFrame.; TEveWindowManager Manager for EVE windows.; TEveWindowPack Eve-window containing a TGPack.; TEveWindowSlot An unoccupied eve-window slot.; TEveWindowTab Eve-window containing a TGTab.; TEventIter Event iterator used by TProofPlayer's; TEventIterObj Event iterator for objects; TEventIterTree Event iterator for Trees; TEventIterUnit Event iterator for objects; TEventList A list of selected entries in a TTree.; TExMap Map with external hash; TExMapIter TExMap iterator; TExec To execute a CINT command; TF1 The Parametric 1-D function; TF12 Projection of a TF2 along x or y; TF1Editor user interface for TF1 objects; TF2 The Parametric 2-D function; TF2GL GL renderer for TF2 and TF3.; TF3 The Parametric 3-D function; TFFTComplex ; TFFTComplexReal ; TFFTReal ; TFFTRealComplex ; TFITSHDU Class interfacing FITS HDUs; TFTP File Transfer Protocol class using rootd; TFcnAdapter wrapper class implementing the Minuit2 interface for TMinuit2-like objective functions; TFeldmanCousins calculate the CL upper limit using the Feldman-Cousins method; TFile ROOT file; TFileCacheRead TFile cache when reading; TFileCacheWrite TFile cache when writing; TFileCollection Collection of TFileInfo objects; TFileDrawMap Draw a 2-d map of the objects in a file; TFileHandler Handles events on file descriptors; TFileInfo Describes generic file info including meta data information; TFileInfoMeta Describes TFileInfo meta data; TFileIter TFile class iterator; TFileMerger File copying and merging services; TFileSet TDataSet class to read the native file system d,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:69962,hash,hash,69962,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['hash'],['hash']
Security,"e branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooSetProxy_depListList of dependents defining dimensions of histogram; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistFunc.html:32079,access,access,32079,root/html532/RooHistFunc.html,https://root.cern,https://root.cern/root/html532/RooHistFunc.html,1,['access'],['access']
Security,"e bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the tab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTable.html:10702,hash,hash,10702,root/html534/THashTable.html,https://root.cern,https://root.cern/root/html534/THashTable.html,3,['hash'],['hash']
Security,e can be a top-level field or a nested field. Returns nullptr if the field is not in the...Definition RNTupleModel.cxx:291; ROOT::Experimental::RNTupleModel::GetMutableFieldRFieldBase & GetMutableField(std::string_view fieldName)Definition RNTupleModel.cxx:406; ROOT::Experimental::RNTupleModel::Freezevoid Freeze()Definition RNTupleModel.cxx:507; ROOT::Experimental::RNTupleModel::CreateBarestatic std::unique_ptr< RNTupleModel > CreateBare()A bare model has no default entry.Definition RNTupleModel.cxx:236; ROOT::Experimental::RNTupleModel::IsFrozenbool IsFrozen() constDefinition RNTupleModel.hxx:363; ROOT::Experimental::RNTupleModel::GetDescriptionconst std::string & GetDescription() constDefinition RNTupleModel.hxx:386; ROOT::Experimental::RNTupleModel::AddFieldvoid AddField(std::unique_ptr< RFieldBase > field)Adds a field whose type is not known at compile time.Definition RNTupleModel.cxx:312; ROOT::Experimental::RNTupleModel::RegisterSubfieldvoid RegisterSubfield(std::string_view qualifiedFieldName)Register a subfield so it can be accessed directly from entries belonging to the model.Definition RNTupleModel.cxx:335; ROOT::Experimental::RNTupleModel::operator=RNTupleModel & operator=(const RNTupleModel &)=delete; ROOT::Experimental::RNTupleModel::~RNTupleModel~RNTupleModel()=default; ROOT::Experimental::RNTupleModel::fIsFrozenbool fIsFrozenChanged by Freeze() / Unfreeze() and by the RUpdater.Definition RNTupleModel.hxx:215; ROOT::Experimental::RNTupleModel::Unfreezevoid Unfreeze()Definition RNTupleModel.cxx:493; ROOT::Experimental::RNTupleModel::fFieldZerostd::unique_ptr< RFieldZero > fFieldZeroHierarchy of fields consisting of simple types and collections (sub trees)Definition RNTupleModel.hxx:198; ROOT::Experimental::RNTupleWriteOptionsCommon user-tunable settings for storing ntuples.Definition RNTupleWriteOptions.hxx:48; ROOT::Experimental::RNTupleWriterAn RNTuple that gets filled with entries (data) and writes them to storage.Definition RNTupleWriter.hxx:60; ROO,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleModel_8hxx_source.html:31918,access,accessed,31918,doc/master/RNTupleModel_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleModel_8hxx_source.html,1,['access'],['accessed']
Security,"e can call the TTree::MakeSelector method. It creates two files similar to TTree::MakeClass.; In the resulting files is a class that is a descendent of TSelector and implements the following methods:. TSelector::Begin() - this method is called every time a loop over the tree starts. This is a convenient place to create your histograms.; TSelector::Notify() - it is called at the first entry of a new tree in a chain.; TSelector::Process() - it is called to process an event. It is the user’s responsibility to read the corresponding entry in memory (may be just a partial read). Once the entry is in memory one can apply a selection and if the event is selected histograms can be filled. Processing stops when this function returns kFALSE. It combines the methods TSelector::ProcessCut() and TSelector::ProcessFill() in one, avoiding the necessity to maintain the state in the class to communicate between these two functions. It reduces the information that needs to be shared between them and promotes a more granular data access by reading branches as they are needed.; TSelector::Terminate() - it is called at the end of a loop on a TTree. This is a convenient place to draw and fit your histograms.; TSelector::Version() - this function provides backward compatibility for old versions and support for the future upgrades.; The TSelector, unlike the resulting class from MakeClass, separates the processing into a ProcessCut() and ProcessFill(), so we can limit reading of branches to the ones we need.; When a selector is used with a TChain in methods Process(), ProcessFill(), ProcessCut(), you must use the pointer to the current TTree to call the method GetEntry(entry). The parameter entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use. fChain->GetTree()->GetEntry(entry);; To create a selector call:; root[] T->MakeSelector(""MySelector"");; Where T is the TTree and MySelector is the name of created class and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:644712,access,access,644712,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"e can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). void SetFile(const char* filename); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetStatus(Bool_t status = 1); Set branch status to Process or DoNotProcess. void Streamer(TBuffer& ); Stream a class object. Int_t WriteBasket(TBasket* basket, Int_t where); Write the current basket to disk and return the number of bytes; written to the file.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBranch.html:25987,access,access,25987,root/html534/TBranch.html,https://root.cern,https://root.cern/root/html534/TBranch.html,3,['access'],['access']
Security,"e can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). void SetFile(const char* filename); Set file where this branch writes/reads its buffers.; By default the branch buffers reside in the file where the; Tree was created.; If the file name where the tree was created is an absolute; path name or an URL (e.g. /castor/... or root://host/...); and if the fname is not an absolute path name or an URL then; the path of the tree file is prepended to fname to make the; branch file relative to the tree file. In this case one can; move the tree + all branch files to a different location in; the file system and still access the branch files.; The ROOT file will be connected only when necessary.; If called by TBranch::Fill (via TBasket::WriteFile), the file; will be created with the option ""recreate"".; If called by TBranch::GetEntry (via TBranch::GetBasket), the file; will be opened in read mode.; To open a file in ""update"" mode or with a certain compression; level, use TBranch::SetFile(TFile *file). Bool_t SetMakeClass(Bool_t decomposeObj = kTRUE); Set the branch in a mode where the object are decomposed; (Also known as MakeClass mode).; Return whether the setting was possible (it is not possible for; TBranch and TBranchObject). void SetObject(void* objadd); Set object this branch is pointing to. void SetStatus(Bool_t status = 1); Set branch status to Process or DoNotProcess. void Streamer(TBuffer& b); Stream a class object. Int_t WriteBasket(TBasket* basket, Int_t where); Write the current basket to disk and return the number of bytes; written to the file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranch.html:25668,access,access,25668,root/html528/TBranch.html,https://root.cern,https://root.cern/root/html528/TBranch.html,3,['access'],['access']
Security,"e canonical range (-pi,pi]. explicit AxisAngle(const ROOT::Math::AxisAngle& ); ======== Construction From other Rotation Forms ==================. Construct from another supported rotation type (see gv_detail::convert ). {gv_detail::convert(r,*this);}. AxisAngle & operator=( OtherRotation const & r ). Assign from another supported rotation type (see gv_detail::convert ). void SetComponents(double* begin, double* end); ======== Components ==============. Set the axis and then the angle given a pair of pointers or iterators; defining the beginning and end of an array of four Scalars.; Precondition: The first three components are assumed to represent; the rotation axis vector and the 4-th the rotation angle.; The angle is assumed to be in the range (-pi,pi].; The axis vector is automatically normalized to be a unit vector. void GetComponents(IT begin, IT end). Get the axis and then the angle into data specified by an iterator begin; and another to the end of the desired data (4 past start). Scalar Angle() const. access to rotation angle. { return fAngle; }. XYZVector operator()(const ROOT::Math::AxisAngle::XYZVector& v) const. AVector operator*(const AVector & v). Overload operator * for rotation on a vector. void Invert(). Invert an AxisAngle rotation in place. { fAngle = -fAngle; }. AxisAngle Inverse() const. Return inverse of an AxisAngle rotation. { AxisAngle result(*this); result.Invert(); return result; }. return ! operator==(rhs). void RectifyAngle(). double Pi(); { return 3.14159265358979323; }. AxisAngle operator*(RotationX const & r1, AxisAngle const & r2). Multiplication of an axial rotation by an AxisAngle. AxisAngle operator*(RotationY const & r1, AxisAngle const & r2). AxisAngle operator*(RotationZ const & r1, AxisAngle const & r2). » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__AxisAngle.html:5223,access,access,5223,root/html534/ROOT__Math__AxisAngle.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__AxisAngle.html,1,['access'],['access']
Security,"e class for BinarySearch and Decision Trees. More...;  ; class  CCPruner;  A helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) More...;  ; class  CCTreeWrapper;  ; class  ClassifierFactory;  This is the MVA factory. More...;  ; class  ClassInfo;  Class that contains all the information of a class. More...;  ; class  Config;  Singleton class for global configuration settings used by TMVA. More...;  ; class  Configurable;  ; class  ConvergenceTest;  Check for convergence. More...;  ; class  CostComplexityPruneTool;  A class to prune a decision tree using the Cost Complexity method. More...;  ; class  CrossEntropy;  Implementation of the CrossEntropy as separation criterion. More...;  ; class  CrossValidation;  Class to perform cross validation, splitting the dataloader into folds. More...;  ; class  CrossValidationFoldResult;  ; class  CrossValidationResult;  Class to save the results of cross validation, the metric for the classification ins ROC and you can ROC curves ROC integrals, ROC average and ROC standard deviation. More...;  ; class  CvSplit;  ; class  CvSplitKFolds;  ; class  CvSplitKFoldsExpr;  ; class  DataInputHandler;  Class that contains all the data information. More...;  ; class  DataLoader;  ; class  DataSet;  Class that contains all the data information. More...;  ; class  DataSetFactory;  Class that contains all the data information. More...;  ; class  DataSetInfo;  Class that contains all the data information. More...;  ; class  DataSetManager;  Class that contains all the data information. More...;  ; class  DecisionTree;  Implementation of a Decision Tree. More...;  ; class  DecisionTreeNode;  ; struct  DeleteFunctor_t;  ; class  DTNodeTrainingInfo;  ; class  Envelope;  Abstract base class for all high level ml algorithms, you can book ml methods like BDT, MLP. More...;  ; class  Event;  ; class  Executor;  Base Executor class. More...;  ; class  ExpectedErrorPrune",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA.html:1778,validat,validation,1778,doc/master/namespaceTMVA.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA.html,2,['validat'],['validation']
Security,"e class that prevent its derived class from being split’ to any user class. This fixes ROOT-7972.; TTree. Do not automatically setup read cache during TTree::Fill(). This fixes ROOT-8031.; Fast Cloning We added a cache specifically for the fast option of the TTreeCloner to significantly reduce the run-time when fast-cloning remote files to address ROOT-5078. It can be controlled from the TTreeCloner, TTree::CopyEntries or hadd interfaces. The new cache is enabled by default, to update the size of the cache or disable it from TTreeCloner use: TTreeCloner::SetCacheSize. To do the same from TTree::CopyEntries add to the option string “cachesize=SIZE”. To update the size of the cache or disable it from hadd, use the command line option -cachesize SIZE. SIZE shouyld be given in number bytes and can be expressed in ‘human readable form’ (number followed by size unit like MB, MiB, GB or GiB, etc. or SIZE can be set zero to disable the cache. Histogram Libraries. Protect access to TROOT::GetListOfGlobalFunctions in TFormula. Math. Update MixMax random number generator for 32 bit architectures. TColor. Import TColor from master to make sure the high quality palettes are defined only ones. This was requested here. PyROOT. Fix case where c++ exception in a constructor were not propagated to python ROOT-7864; Fix case where PyROOT was unable to call copy constructor ROOT-7783; Fix handling of vector<enums> ROOT-7916; Fix the wrong return value when calling a c++ function returning short, or when retuning a char with a negative value ROOT-7872; Added a new configuration option (ROOT.PyConfig.DisableRootLogon) to disable processing of the rootlogon[.py|C] macro in addition to the -n option in the command arguments. Bug Fixes and Tasks. [ROOT-7426] - Cannot print elements of vector on Mac; [ROOT-7739] - TVectorD times double returns a TH1 on ROOT command line; [ROOT-7825] - wrong value passed to function expecting “const T*&""; [ROOT-7830] - Cling automatic RooFit objects always rel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:26301,access,access,26301,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['access'],['access']
Security,"e compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THnSparse.html:4495,hash,hash,4495,root/html532/THnSparse.html,https://root.cern,https://root.cern/root/html532/THnSparse.html,1,['hash'],['hash']
Security,"e compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const THnSparse* h, Double_t c = 1.); voidAddBinContent(const Int_t* x, Double_t v = 1.); voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:4495,hash,hash,4495,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,2,['hash'],['hash']
Security,"e compacted to use as few bits as; possible; e.g. a histogram with 10 bins in x and 20 bins in y will only; use 4 bits for the x representation and 5 bits for the y representation.; This is handled by the internal class THnSparseCompactBinCoord.; Bin data (content and coordinates) are allocated in chunks of size; fChunkSize; this parameter can be set when constructing a THnSparse. Each; chunk is represented by an object of class THnSparseArrayChunk. Translation from an n-dimensional bin coordinate to the linear index within; the chunks is done by GetBin(). It creates a hash from the compacted bin; coordinates (the hash of a bin coordinate is the compacted coordinate itself; if it takes less than 8 bytes, the size of a Long64_t.; This hash is used to lookup the linear index in the TExMap member fBins;; the coordinates of the entry fBins points to is compared to the coordinates; passed to GetBin(). If they do not match, these two coordinates have the same; hash - which is extremely unlikely but (for the case where the compact bin; coordinates are larger than 4 bytes) possible. In this case, fBinsContinued; contains a chain of linear indexes with the same hash. Iterating through this; chain and comparing each bin coordinates with the one passed to GetBin() will; retrieve the matching bin. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~THnSparse(); voidTObject::AbstractMethod(const char* method) const; voidTHnBase::Add(const THnBase* h, Double_t c = 1.); voidTHnBase::Add(const TH1* hist, Double_t c = 1.); voidAddBinContent(const Int_t* idx, Double_t v = 1.); virtual voidAddBinContent(Long64_t bin, Double_t v = 1.); virtual voidAddBinError2(Long64_t bin, Double_t e2); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTHnBase::Browse(TBrowser* b); voidTHnBase::CalculateErrors(Bool_t calc = kTRUE); static TClass*Class(); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparse.html:4408,hash,hash,4408,root/html534/THnSparse.html,https://root.cern,https://root.cern/root/html534/THnSparse.html,3,['hash'],['hash']
Security,"e corresponding file if such file exists ; Definition at line 911 of file TDocParser.cxx. ◆ GetCurrentClass(). TClass * TDocParser::GetCurrentClass ; (; ); const. inline . Definition at line 171 of file TDocParser.h. ◆ GetCurrentModule(). void TDocParser::GetCurrentModule ; (; TString & ; out_module); const. Return the name of module for which sources are currently parsed. ; Definition at line 967 of file TDocParser.cxx. ◆ GetDataMembers(). const TList * TDocParser::GetDataMembers ; (; EAccess ; access); const. inline . Definition at line 175 of file TDocParser.h. ◆ GetDocOutput(). TDocOutput * TDocParser::GetDocOutput ; (; ); const. inline . Definition at line 173 of file TDocParser.h. ◆ GetEnums(). const TList * TDocParser::GetEnums ; (; EAccess ; access); const. inline . Definition at line 176 of file TDocParser.h. ◆ GetLineNumber(). Long_t TDocParser::GetLineNumber ; (; ); const. inline . Definition at line 174 of file TDocParser.h. ◆ GetMethods(). const TList * TDocParser::GetMethods ; (; EAccess ; access); const. inline . Definition at line 170 of file TDocParser.h. ◆ GetSourceInfo(). const char * TDocParser::GetSourceInfo ; (; ESourceInfo ; type); const. inline . Definition at line 177 of file TDocParser.h. ◆ HandleDirective(). Bool_t TDocParser::HandleDirective ; (; TString & ; keyword, . Ssiz_t & ; pos, . TString & ; word, . Ssiz_t & ; copiedToCommentUpTo . ). protectedvirtual . Process directives to the documentation engine, like ""Begin_Html"" / ""End_Html"", ""Begin_Macro"" / ""End_Macro"", and ""Begin_Latex"" / ""End_Latex"". ; Definition at line 977 of file TDocParser.cxx. ◆ InContext(). UInt_t TDocParser::InContext ; (; Int_t ; context); const. checks whether we are in a parse context, return the entry closest to the current context. ; If context is a EParseContextFlag just look for the first match in the flags ; Definition at line 1158 of file TDocParser.cxx. ◆ InitKeywords(). void TDocParser::InitKeywords ; (; ); const. protected . fill C++ keywords into fgKeyw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDocParser.html:23049,access,access,23049,doc/master/classTDocParser.html,https://root.cern,https://root.cern/doc/master/classTDocParser.html,1,['access'],['access']
Security,"e current canvas name is used as a file name for various formats such as PostScript, GIF, JPEG, C macro file, root file.; Save As…: popup a dialog for saving the current canvas drawing in a new filename.; Print: popup a dialog to print the current canvas drawing; Quit ROOT: exit the ROOT session. 2.3.1.2 Edit Menu; There is only one active menu entry in the Edit menu. The others menu entries will be implemented and will become active in the near future. Clear: delete all objects in the canvas or in the selected pad according to the selected entry in the submenu. 2.3.1.3 View Menu. Editor: toggles the view of the editor. If it is selected activates and shows up the editor on the left side of the canvas window. According to the selected object, the editor loads the corresponding user interface for easy change of the object’s attributes.; Toolbar: toggles the view of the toolbar. If it is selected activates and shows up the toolbar. It contains buttons for easy and fast access to most frequently used commands and for graphics primitive drawing. Tool tips are provided for helping users.; Status Bar: toggles the view of the status bar. If it is selected, the status bar below the canvas window shows up. There the identification of the objects is displayed when moving the mouse (such as the object’s name, the object’s type, its coordinates, etc.).; Colors: creates a new canvas showing the color palette.; Markers: creates a new canvas showing the various marker styles.; Iconify: create the canvas window icon, does not close the canvas; View With…: If the last selected pad contains a 3-d structure, a new canvas is created with a 3-D picture according to the selection made from the cascaded menu: X3D or OpenGL. The 3-D image can be interactively rotated, zoomed in wire-frame, solid, hidden line or stereo mode. 2.3.1.4 Options Menu. Auto Resize Canvas: turns auto-resize of the canvas on/off:. on - the canvas fits to the window when changing the window size;; off - the canvas s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:38480,access,access,38480,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"e current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static UChar_t GetAcceptOptions ();  Return default options for Accept. ;  ; static void SetAcceptOptions (UChar_t Opt);  Set default options for Accept according to modifier 'mod'. ;  ; static void ShowAcceptOptions ();  Print default options for Accept. ;  ;  Static Public Member Functions inherited from TSocket; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static TSocket * CreateAuthSocket (const char *url, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server. ;  ; static TSocket * CreateAuthSocket (const char *user, const char *host, Int_t port, Int_t size=0, Int_t tcpwindowsize=-1, TSocket *s=nullptr, Int_t *err=nullptr);  Creates a socket or a parallel socket and authenticates to the remote server specified in 'url' on remote 'port' as 'user'. ;  ; static const char * DeclFileName ();  ; static Int_t GetClientProtocol ();  Static method returning supported client protocol. ;  ; static ULong64_t GetSocketBytesRecv ();  Get total number of bytes received via all sockets. ;  ; static ULong64_t GetSocketBytesSent ();  Get total number of bytes sent via all sockets. ;  ; static void NetError (const char *where, Int_t error);  Print error string depending on error code. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTServerSocket.html:15387,authenticat,authenticates,15387,doc/master/classTServerSocket.html,https://root.cern,https://root.cern/doc/master/classTServerSocket.html,1,['authenticat'],['authenticates']
Security,"e drawing buttons, or any other; image that needs to be framed. Bevel is drawn using 2 primary colors:; one for top and left sides - hi color, and another for bottom and; right sides - low color. Bevel can be drawn over exisiting image or; as newly created, as it is shown in code below:. TImage *img = TImage::Create();; img->Bevel(0, 0, 400, 300, ""#dddddd"", ""#000000"", 3);. void Pad(const char* color = ""#00FFFFFF"", UInt_t left = 0, UInt_t right = 0, UInt_t top = 0, UInt_t bottom = 0); Enlarge image, padding it with specified color on each side in; accordance with requested geometry. void Crop(Int_t x = 0, Int_t y = 0, UInt_t width = 0, UInt_t height = 0); Crop an image. void Append(const TImage* im, const char* option = ""+"", const char* color = ""#00000000""); Append image. option:; ""+"" - appends to the right side; ""/"" - appends to the bottom. void BeginPaint(Bool_t fast = kTRUE); BeginPaint initializes internal array[width x height] of ARGB32 pixel; values.; That provides quick access to image during paint operations.; To RLE compress image one needs to call EndPaint method when paintinig; is over. void EndPaint(); EndPaint does internal RLE compression of image data. UInt_t * GetArgbArray(); Return a pointer to internal array[width x height] of ARGB32 values; This array is directly accessible. That allows to manipulate/change the; image. UInt_t * GetRgbaArray(); Return a pointer to an array[width x height] of RGBA32 values.; This array is created from internal ARGB32 array,; must be deleted after usage. UInt_t * GetScanline(UInt_t y); Return a pointer to scanline. void FillRectangleInternal(UInt_t col, Int_t x, Int_t y, UInt_t width, UInt_t height); Fill rectangle of size (width, height) at position (x,y); within the existing image with specified color. void FillRectangle(const char* col = 0, Int_t x = 0, Int_t y = 0, UInt_t width = 0, UInt_t height = 0); Fill rectangle of size (width, height) at position (x,y); within the existing image with specified color. To crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TASImage.html:36089,access,access,36089,root/html526/TASImage.html,https://root.cern,https://root.cern/root/html526/TASImage.html,7,['access'],['access']
Security,"e enum valueTObject; ls(Option_t *option="""") const overrideROOT::TSchemaRulevirtual; MakeZombie()TObjectinlineprotected; MayNotUse(const char *method) constTObject; Notify()TObjectvirtual; Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constTObject; operator delete(void *ptr)TObject; operator delete(void *ptr, void *vp)TObject; operator delete[](void *ptr)TObject; operator delete[](void *ptr, void *vp)TObject; operator new(size_t sz)TObjectinline; operator new(size_t sz, void *vp)TObjectinline; operator new[](size_t sz)TObjectinline; operator new[](size_t sz, void *vp)TObjectinline; operator=(const TSchemaRule &rhs)ROOT::TSchemaRule; TObject::operator=(const TObject &rhs)TObjectinline; operator==(const TSchemaRule &rhs) constROOT::TSchemaRule; Paint(Option_t *option="""")TObjectvirtual; ParseChecksum(const char *checksum) constROOT::TSchemaRuleprivate; Pop()TObjectvirtual; Print(Option_t *option="""") constTObjectvirtual; ProcessChecksum(const TString &checksum) constROOT::TSchemaRuleprivate; ProcessDeclaration(TObjArray *array, const TString &list)ROOT::TSchemaRuleprivatestatic; ProcessList(TObjArray *array, const TString &list)ROOT::TSchemaRuleprivatestatic; ProcessVersion(const TString &version) constROOT::TSchemaRuleprivate; Read(const char *name)TObjectvirtual; ReadFuncPtr_t typedefROOT::TSchemaRule; ReadRawFuncPtr_t typedefROOT::TSchemaRule; RecursiveRemove(TObject *obj)TObjectvirtual; ResetBit(UInt_t f)TObjectinline; RuleType_t enum nameROOT::TSchemaRule; SaveAs(const char *filename="""", Option_t *option="""") constTObjectvirtual; SavePrimitive(std::ostream &out, Option_t *option="""")TObjectvirtual; SetAttributes(const TString &attributes)ROOT::TSchemaRule; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetChecksum(const TString &checksum)ROOT::TSchemaRule; SetCode(const TString &code)ROOT::TSchemaRule; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetEmbed(Bool_t embed)ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TSchemaRule-members.html:5961,checksum,checksum,5961,doc/master/classROOT_1_1TSchemaRule-members.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TSchemaRule-members.html,1,['checksum'],['checksum']
Security,"e executed in the event loop.; RDataFrame is built with a modular and flexible workflow in mind, summarised as follows:. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, CSV files, SQLite files, RNTuples, and it can be extended to custom data formats. From Python, NumPy arrays can be imported into RDataFrame as well.; Transform the dataframe by:; Applying filters. This selects only specific rows of the dataset.; Creating custom columns. Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. Produce results. Actions are used to aggregate data into results. Most actions are lazy, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the crash course to discover more idiomatic and flexible ways to express analyses with RDataFrame. . TTreeReader ROOT::RDataFrame . TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:146; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:44; ROOT::RDataFrame d(""myTree"", file, {""A"", ""B"", ""C""});; d.Filter(IsGoodEvent).Foreach(DoStuff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:11303,access,access,11303,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['access'],['access']
Security,"e executed in the event loop.; RDataFrame is built with a modular and flexible workflow in mind, summarised as follows:. Construct a dataframe object by specifying a dataset. RDataFrame supports TTree as well as TChain, CSV files, SQLite files, RNTuples, and it can be extended to custom data formats. From Python, NumPy arrays can be imported into RDataFrame as well.; Transform the dataframe by:; Applying filters. This selects only specific rows of the dataset.; Creating custom columns. Custom columns can, for example, contain the results of a computation that must be performed for every row of the dataset. Produce results. Actions are used to aggregate data into results. Most actions are lazy, i.e. they are not executed on the spot, but registered with RDataFrame and executed only when a result is accessed for the first time. Make sure to book all transformations and actions before you access the contents of any of the results. This lets RDataFrame accumulate work and then produce all results at the same time, upon first access to any of them.; The following table shows how analyses based on TTreeReader and TTree::Draw() translate to RDataFrame. Follow the crash course to discover more idiomatic and flexible ways to express analyses with RDataFrame. . TTreeReader ROOT::RDataFrame . TTreeReader reader(""myTree"", file);; TTreeReaderValue<A_t> a(reader, ""A"");; TTreeReaderValue<B_t> b(reader, ""B"");; TTreeReaderValue<C_t> c(reader, ""C"");; while(reader.Next()) {; if(IsGoodEvent(*a, *b, *c)); DoStuff(*a, *b, *c);; }; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; ROOT::RDataFrame d(""myTree"", file, {""A"", ""B"", ""C""});; d.Filter(IsGoodEvent).Foreach(DoStuff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:11692,access,access,11692,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['access'],['access']
Security,"e for `GlobalObservablesSource` is ""data"", which; // corresponds to the new default behavior explained above.; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; In case you create a RooFit dataset directly by calling its constructor, you can also pass the global observables in a command argument instead of calling RooAbsData::setGlobalObservables() later: RooDataSet data{""dataset"", ""dataset"", x, RooFit::GlobalObservables(g1, g2)};; RooDataSetContainer class to hold unbinned data.Definition RooDataSet.h:33; RooFit::GlobalObservablesRooCmdArg GlobalObservables(Args_t &&... argsOrArgSet)Definition RooGlobalFunc.h:306; To access the set of global observables stored in a RooAbsData, call RooAbsData::getGlobalObservables(). It returns a nullptr if no global observable snapshots are stored in the dataset. PyROOT; Some member functions of RooAbsData that take a RooCmdArg as argument also support keyword arguments. This applies to RooAbsData::plotOn, RooAbsData::createHistogram, RooAbsData::reduce, RooAbsData::statOn. For example, the following code is equivalent in PyROOT: # Directly passing a RooCmdArg:; data.plotOn(frame, ROOT.RooFit.CutRange(""r1"")); ; # With keyword arguments:; data.plotOn(frame, CutRange=""r1""). Definition at line 57 of file RooAbsData.h. Classes; struct  PlotOpt;  . Public Types; using CategorySpans = std::map< RooFit::Detail::DataKey, std::span< const RooAbsCategory::value_type > >;  ; enum  ErrorType { ;   Poisson; , SumW2; , None; , Auto; , ;   Expected. };  ; using RealSpans = std::map< RooFit::Detail::DataKey, std::span< const double > >;  ; enum  StorageType { Tree; , Vector; , Composite; };  ;  Public Types inherited from TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:3631,access,access,3631,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['access'],['access']
Security,"e for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TMatrixDSym_cov; TMatrixDSym_covI; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Double_t_det; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; map<int,RooMultiVarGaussian::GenData>_genCache!; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooListProxy_mu; TVectorD_muVec! Do not persist; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:42625,access,access,42625,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,2,['access'],['access']
Security,"e for specified connection If connid == 0, message will be add to all connections. ; Definition at line 1187 of file TWebCanvas.cxx. ◆ AssignStatusBits(). void TWebCanvas::AssignStatusBits ; (; UInt_t ; bits). protected . Assign clients bits. ; Definition at line 1472 of file TWebCanvas.cxx. ◆ BatchImageMode(). void TWebCanvas::BatchImageMode ; (; UInt_t ; n = 100). static . Configure batch image mode for web graphics. ; Allows to process many images with single headless browser invocation and increase performance of image production. When many canvases are stored as image in difference places, they first collected in batch and then processed when at least n images are prepared. Only then headless browser invoked and create all these images at once. This allows to significantly increase performance of image production in web mode ; Definition at line 156 of file TWebCanvas.cxx. ◆ CalculateColorsHash(). UInt_t TWebCanvas::CalculateColorsHash ; (; ). protected . Calculate hash function for all colors and palette. ; Definition at line 559 of file TWebCanvas.cxx. ◆ CanCreateObject(). virtual Bool_t TWebCanvas::CanCreateObject ; (; const std::string & ; ). inlineprotectedvirtual . Definition at line 170 of file TWebCanvas.h. ◆ CheckCanvasModified(). Bool_t TWebCanvas::CheckCanvasModified ; (; bool ; force_modified = false). protected . Check if any pad on the canvas was modified If yes, increment version of correspondent pad Returns true when canvas really modified. ; Definition at line 2244 of file TWebCanvas.cxx. ◆ CheckDataToSend(). Bool_t TWebCanvas::CheckDataToSend ; (; unsigned ; connid = 0). protected . Check if any data should be send to client If connid != 0, only selected connection will be checked. ; Definition at line 1200 of file TWebCanvas.cxx. ◆ CheckPadModified(). void TWebCanvas::CheckPadModified ; (; TPad * ; pad). protected . Returns true if any pad in the canvas were modified Reset modified flags, increment canvas version (if inc_version is true) ; De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:21574,hash,hash,21574,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['hash'],['hash']
Security,"e form var[nelem], where nelem is alphanumeric, then; if nelem is a leaf name, it is used as the variable size of the array,; otherwise return 0.; If leaf name has the form var[nelem], where nelem is a digit, then; it is used as the fixed size of the array.; If leaf name has the form of a multi dimenantion array (eg var[nelem][nelem2]); where nelem and nelem2 are digits) then; it is used as a 2 dimensional array of fixed size.; Any of other form is not supported. Note that the TTree will assume that all the item are contiguous in memory.; On some platform, this is not always true of the member of a struct or a class,; due to padding and alignment. Sorting your data member in order of decreasing; sizeof usually leads to their being contiguous in memory. * bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (eg 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* Branch(const char* name, const char* classname, void** obj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new branch with the object of class classname at address addobj. WARNING:; Starting with Root version 3.01, the Branch function uses the new style; branches (TBranchElement). To get the old behaviour, you can:; - call BranchOld or; - call TTree::SetBranchStyle(0). Note that with the new style, classname does not need to derive from TObject.; It must derived from TObject if the branch style has been set to 0 (old). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addobj parameter in; the case of new-style branches. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:48117,access,access,48117,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['access'],['access']
Security,"e format descriptor.Definition TString.cxx:2356; TString::Classstatic TClass * Class(); TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition TViewPubDataMembers.h:28; TViewPubDataMembers::Loadvoid Load()Load all the DataMembers known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubDataMembers.cxx:298; TViewPubDataMembers::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubDataMembers.cxx:78; TViewPubFunctionsView implementing the TList interface and giving access all the TFunction describing public methods i...Definition TViewPubFunctions.h:28; TViewPubFunctions::Loadvoid Load()Load all the functions known to the interpreter for the scope 'fClass' and all its bases classes.Definition TViewPubFunctions.cxx:298; TViewPubFunctions::Deletevoid Delete(Option_t *option="""") overrideDelete is not allowed in this class.Definition TViewPubFunctions.cxx:78; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::Sizeofvirtual UInt_t Sizeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:369076,access,access,369076,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['access'],['access']
Security,"e in which the file is opened ; [in]ftitleThe title of the file ; [in]compressSpecifies the compression algorithm and level. It is recommended to specify fname1 as ""<file>.root"". The suffix "".root"" will be used by object browsers to automatically identify the file as a ROOT file. If the constructor fails in any way IsZombie() will return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that will take care of opening the files using the correct remote file access plugin. Option Description . NEW or CREATE Create a new file and open it for writing, if the file already exists the file is not opened. . RECREATE Create a new file, if the file already exists it will be overwritten. . UPDATE Open an existing file for writing. If no file exists, it is created. . READ Open an existing file for reading (default). . NET Used by derived remote file access classes, not a user callable option. . WEB Used by derived remote http access class, not a user callable option. . READ_WITHOUT_GLOBALREGISTRATION Used by TTreeProcessorMT, not a user callable option. . If option = """" (default), READ is assumed. The file can be specified as a URL of the form: file:///user/rdm/bla.root or file:/user/rdm/bla.root; The file can also be a member of an archive, in which case it is specified as: multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip archive or member 1 from the archive. For more on archive file support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any file, i.e. also non ROOT files, using: file.tar?filetype=raw; This is convenient because the many remote file access plugins allow easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may contain objects and directories. There are no restrictions for the number of leve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:48521,access,access,48521,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['access'],['access']
Security,"e info;; 7160 return nullptr;; 7161 }; 7162 ; 7163 if (!info->IsCompiled()) {; 7164 // Streamer info has not been compiled, but exists.; 7165 // Therefore it was read in from a file and we have to do schema evolution?; 7166 // Or it didn't have a dictionary before, but does now?; 7167 info->BuildOld();; 7168 }; 7169 ; 7170 //----------------------------------------------------------------------------; 7171 // Cache this streamer info; 7172 /////////////////////////////////////////////////////////////////////////////; 7173 ; 7174 if (!arr) {; 7175 arr = new TObjArray(version+10, -1);; 7176 if (!fConversionStreamerInfo.load()) {; 7177 fConversionStreamerInfo = new std::map<std::string, TObjArray*>();; 7178 }; 7179 (*fConversionStreamerInfo)[cl->GetName()] = arr;; 7180 }; 7181 if (arr->At(info->GetClassVersion())) {; 7182 Error(""GetConversionStreamerInfo"", ""Conversion StreamerInfo from %s to %s version %d has already been created"",; 7183 this->GetName(), info->GetName(), info->GetClassVersion());; 7184 delete arr->At(info->GetClassVersion());; 7185 }; 7186 arr->AddAtAndExpand( info, info->GetClassVersion() );; 7187 return info;; 7188}; 7189 ; 7190////////////////////////////////////////////////////////////////////////////////; 7191/// Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.; 7192 ; 7193TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const; 7194{; 7195 TClass *cl = TClass::GetClass( classname );; 7196 if( !cl ); 7197 return nullptr;; 7198 return FindConversionStreamerInfo( cl, checksum );; 7199}; 7200 ; 7201////////////////////////////////////////////////////////////////////////////////; 7202/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7203 ; 7204TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 720",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:276072,checksum,checksum,276072,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"e info;; 7227 return nullptr;; 7228 }; 7229 ; 7230 if (!info->IsCompiled()) {; 7231 // Streamer info has not been compiled, but exists.; 7232 // Therefore it was read in from a file and we have to do schema evolution?; 7233 // Or it didn't have a dictionary before, but does now?; 7234 info->BuildOld();; 7235 }; 7236 ; 7237 //----------------------------------------------------------------------------; 7238 // Cache this streamer info; 7239 /////////////////////////////////////////////////////////////////////////////; 7240 ; 7241 if (!arr) {; 7242 arr = new TObjArray(version+10, -1);; 7243 if (!fConversionStreamerInfo.load()) {; 7244 fConversionStreamerInfo = new std::map<std::string, TObjArray*>();; 7245 }; 7246 (*fConversionStreamerInfo)[cl->GetName()] = arr;; 7247 }; 7248 if (arr->At(info->GetClassVersion())) {; 7249 Error(""GetConversionStreamerInfo"", ""Conversion StreamerInfo from %s to %s version %d has already been created"",; 7250 this->GetName(), info->GetName(), info->GetClassVersion());; 7251 delete arr->At(info->GetClassVersion());; 7252 }; 7253 arr->AddAtAndExpand( info, info->GetClassVersion() );; 7254 return info;; 7255}; 7256 ; 7257////////////////////////////////////////////////////////////////////////////////; 7258/// Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any.; 7259 ; 7260TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const char* classname, UInt_t checksum ) const; 7261{; 7262 TClass *cl = TClass::GetClass( classname );; 7263 if( !cl ); 7264 return nullptr;; 7265 return FindConversionStreamerInfo( cl, checksum );; 7266}; 7267 ; 7268////////////////////////////////////////////////////////////////////////////////; 7269/// Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any.; 7270 ; 7271TVirtualStreamerInfo *TClass::FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ) const; 727",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:278823,checksum,checksum,278823,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['checksum'],['checksum']
Security,"e input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegMod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:2433,access,accessed,2433,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,1,['access'],['accessed']
Security,"e input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDeltaSysBackgroundScale() corresponds to (e); The error sources (a) and (d) originate from many uncorrelated errors,; which in general are NOT uncorrelated on the result vector.; Thus, there is no corresponding shift of the output vector, only error; matrices are available. Method to get error matrix corresponds to error sources. GetEmatrixSysUncorr() (a); GetEmatrixSysSource() (b); GetEmatrixSysTau() (c); GetEmatrixSysBackgroundUncorr() (d); GetEmatrixSysBackgroundScale() (e); GetEmatrixInput() (i); GetEmatrix() (i)+(d)+(e); GetEmatrixTotal() (i)+(a)+(b)+(c)+(d)+(e). Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the GetEmatrixXXX() methods is set to kFALSE,; the histogram is not cleared, but the error matrix is simply added to the; existing histogram. Function Members (Methods); public:. virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldSys.html:2457,access,accessed,2457,root/html602/TUnfoldSys.html,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html,2,['access'],['accessed']
Security,"e is ignored, when the name is followed by; 4130/// binning information as described in the previous paragraph.; 4131/// ~~~ {.cpp}; 4132/// tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); 4133/// ~~~; 4134/// will not reset `hsqrt`, but will continue filling. This works for 1-D, 2-D; 4135/// and 3-D histograms.; 4136///; 4137/// ### Accessing collection objects; 4138///; 4139/// TTree::Draw default's handling of collections is to assume that any; 4140/// request on a collection pertain to it content. For example, if fTracks; 4141/// is a collection of Track objects, the following:; 4142/// ~~~ {.cpp}; 4143/// tree->Draw(""event.fTracks.fPx"");; 4144/// ~~~; 4145/// will plot the value of fPx for each Track objects inside the collection.; 4146/// Also; 4147/// ~~~ {.cpp}; 4148/// tree->Draw(""event.fTracks.size()"");; 4149/// ~~~; 4150/// would plot the result of the member function Track::size() for each; 4151/// Track object inside the collection.; 4152/// To access information about the collection itself, TTree::Draw support; 4153/// the '@' notation. If a variable which points to a collection is prefixed; 4154/// or postfixed with '@', the next part of the expression will pertain to; 4155/// the collection object. For example:; 4156/// ~~~ {.cpp}; 4157/// tree->Draw(""event.@fTracks.size()"");; 4158/// ~~~; 4159/// will plot the size of the collection referred to by `fTracks` (i.e the number; 4160/// of Track objects).; 4161///; 4162/// ### Drawing 'objects'; 4163///; 4164/// When a class has a member function named AsDouble or AsString, requesting; 4165/// to directly draw the object will imply a call to one of the 2 functions.; 4166/// If both AsDouble and AsString are present, AsDouble will be used.; 4167/// AsString can return either a char*, a std::string or a TString.s; 4168/// For example, the following; 4169/// ~~~ {.cpp}; 4170/// tree->Draw(""event.myTTimeStamp"");; 4171/// ~~~; 4172/// will draw the same histogram as; 4173/// ~~~ {.cpp}; 4174/// tree->Draw(""event.myTTimeSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:165996,access,access,165996,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security,"e iteration over contained elements. ; NoteThese iterators are slow. Use begin() and end() or range-based for loop instead. . ◆ DeclFileName(). static const char * RooAbsCollection::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 455 of file RooAbsCollection.h. ◆ defaultPrintContents(). Int_t RooAbsCollection::defaultPrintContents ; (; Option_t * ; opt); const. overridevirtual . Define default RooPrinable print options for given Print() flag string For inline printing only show value of objects, for default print show name,class name value and extras of each object. ; In verbose mode also add object address, argument and title ; Reimplemented from RooPrintable.; Definition at line 1189 of file RooAbsCollection.cxx. ◆ deleteList(). void RooAbsCollection::deleteList ; (; ). protected . Delete contents of the list. ; The RooAbsArg destructor ensures clients and servers can be deleted in any order. Also cleans the hash-map for fast lookups if present. ; Definition at line 190 of file RooAbsCollection.cxx. ◆ dump(). void RooAbsCollection::dump ; (; ); const. Base contents dumper for debugging purposes. ; Definition at line 1268 of file RooAbsCollection.cxx. ◆ empty(). bool RooAbsCollection::empty ; (; ); const. inline . Definition at line 296 of file RooAbsCollection.h. ◆ end() [1/4]. TIterator RooAbsCollection::end ; (; ). inline . Definition at line 257 of file RooAbsCollection.h. ◆ end() [2/4]. RooLinkedListIter RooAbsCollection::end ; (; ). inline . Definition at line 265 of file RooAbsCollection.h. ◆ end() [3/4]. RooFIter RooAbsCollection::end ; (; ). inline . Definition at line 272 of file RooAbsCollection.h. ◆ end() [4/4]. const_iterator RooAbsCollection::end ; (; ); const. inline . Definition at line 280 of file RooAbsCollection.h. ◆ equals(). bool RooAbsCollection::equals ; (; const RooAbsCollection & ; otherColl); const. Check if this and other collection have identically-named contents. ; Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:39829,hash,hash-map,39829,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['hash'],['hash-map']
Security,"e list. ;  ; void AddFirst (TObject *obj) override;  Add object at the beginning of the list. ;  ; void AddFirst (TObject *obj, Option_t *opt) override;  Add object at the beginning of the list and also store option. ;  ; void AddLast (TObject *obj) override;  Add object at the end of the list. ;  ; void AddLast (TObject *obj, Option_t *opt) override;  Add object at the end of the list and also store option. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; void Clear (Option_t *option="""") override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the list AND delete all heap based objects. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:2678,hash,hash,2678,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['hash'],['hash']
Security,"e must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsReal.html:79162,access,accessors,79162,root/html532/RooAbsReal.html,https://root.cern,https://root.cern/root/html532/RooAbsReal.html,1,['access'],['accessors']
Security,"e must have errors defined for the chi-2 to; be well defined. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Create integral over observables in iset in range named rangeNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsReal.html:78289,access,accessors,78289,root/html528/RooAbsReal.html,https://root.cern,https://root.cern/root/html528/RooAbsReal.html,2,['access'],['accessors']
Security,"e object will imply a call to one of the 2 functions. If both AsDouble and AsString are present, AsDouble will be used. AsString can return either a char*, a std::string or a TString.s For example, the following tree->Draw(""event.myTTimeStamp"");; will draw the same histogram as tree->Draw(""event.myTTimeStamp.AsDouble()"");; In addition, when the object is a type TString or std::string, TTree::Draw will call respectively TString::Data and std::string::c_str(); If the object is a TBits, the histogram will contain the index of the bit that are turned on. Retrieving information about the tree itself.; You can refer to the tree (or chain) containing the data by using the string 'This'. You can then could any TTree methods. For example: tree->Draw(""This->GetReadEntry()"");; will display the local entry numbers be read. tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; will display the name of the first 'user info' object. Special functions and variables; Entry$: A TTree::Draw formula can use the special variable Entry$ to access the entry number being read. For example to draw every other entry use: tree.Draw(""myvar"",""Entry$%2==0"");. Entry$ : return the current entry number (== TTree::GetReadEntry()); LocalEntry$ : return the current entry number in the current tree of a chain (== GetTree()->GetReadEntry()); Entries$ : return the total number of entries (== TTree::GetEntries()); LocalEntries$ : return the total number of entries in the current tree of a chain (== GetTree()->TTree::GetEntries()); Length$ : return the total number of element of this formula for this entry (==TTreeFormula::GetNdata()); Iteration$ : return the current iteration over this formula for this entry (i.e. varies from 0 to Length$).; Length$(formula ) : return the total number of element of the formula given as a parameter.; Sum$(formula ) : return the sum of the value of the elements of the formula given as a parameter. For example the mean for all the elements in one entry can be calculated with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:124134,access,access,124134,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['access']
Security,"e of configuration file for lighttpd server is:; server.modules += ( ""mod_fastcgi"" ); fastcgi.server = (; ""/root.app"" =>; (( ""host"" => ""192.168.1.11"",; ""port"" => 9000,; ""check-local"" => ""disable"",; ""docroot"" => ""/""; )); ); Be aware, that with lighttpd one should specify IP address of the host, where ROOT application is running. Address of the ROOT application will be following: http://lighttpd_host_name/root.app/. Example of authorization configuration for FastCGI connection:; auth.require = ( ""/root.app"" => (; ""method"" => ""digest"",; ""realm"" => ""root"",; ""require"" => ""valid-user""; ) ); 1.8 Integration with existing applications; In many practical cases no change of existing code is required. Opened files (and all objects inside), existing canvas and histograms are automatically scanned by the server and will be available to the users. If necessary, any object can be registered directly to the server with a THttpServer::Register() call.; Central point of integration - when and how THttpServer get access to data from a running application. By default it is done during the gSystem->ProcessEvents() call - THttpServer uses a synchronous timer which is activated every 100 ms. Such approach works perfectly when running macros in an interactive ROOT session.; If an application runs in compiled code and does not contain gSystem->ProcessEvents() calls, two method are available.; 1.8.1 Asynchronous timer; The first method is to configure an asynchronous timer for the server, like for example:; serv->SetTimer(100, kFALSE);; Then, the timer will be activated even without any gSystem->ProcessEvents() method call. The main advantage of such method is that the application code can be used without any modifications. But there is no control when access to the application data is performed. It could happen just in-between of TH1::Fill() calls and an histogram object may be incomplete. Therefore such method is not recommended.; 1.8.2 Regular calls of THttpServer::ProcessRequests() metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:12085,access,access,12085,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['access'],['access']
Security,"e of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be printed. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Configure mapping of Print() arguments to RooPrintable print styles. void Streamer(TBuffer& b); Stream an object of class RooFitResult. TObject* Clone(const char* newname = 0) const. TObject* clone() const; { return new RooFitResult(*this); }. void Print(Option_t* options = 0) const; Printing interface. Int_t status() const; Accessors. Int_t covQual() const; Return MINUIT quality code of covariance matrix. Int_t numInvalidNLL() const; Return number of NLL evaluations with problems. Double_t edm() const; Return estimated distance to minimum. Double_t minNll() const; Return minimized -log(L) value. const RooArgList& constPars() const; Return list of constant parameters. const RooArgList& floatParsInit() const; Return list of floating parameters before fit. const RooArgList& floatParsFinal() const; Return list of floarting parameters after fit. Double_t correlation(const RooAbsArg& par1, const RooAbsArg& par2) const; Return correlation between par1 and par2. return correlation(par1.GetName(),par2.GetName()). Double_t globalCorr(const RooAbsArg& par); Global correlation accessors. { return globalCorr(par.GetName()) ; }. RooPlot * plotOn(RooPlot* frame, const RooAbsArg& par1, const RooAbsArg& par2, const char* options = ""ME"") const; Add objects to a 2D plot. void setMinNLL(Double_t val); { _minNLL = val ; }. void setEDM(Double_t val); { _edm = val ; }. void setStatus(Int_t val); { _status = val ; }. void setCovQual(Int_t val); { _covQual = val ; }. void setNumInvalidNLL(Int_t val); { _numBadNLL=val ; }. » Last changed: Mon Oct 11 11:18:53 2010 » Last generated: 2010-10-11 11:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFitResult.html:16903,access,accessors,16903,root/html528/RooFitResult.html,https://root.cern,https://root.cern/root/html528/RooFitResult.html,1,['access'],['accessors']
Security,"e precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTreeDataStore.html:17264,access,access,17264,root/html534/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html,3,['access'],['access']
Security,"e return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetabeta parameter for AdaBoost algorithm; TStringfAdaBoostR2Lossloss type used in AdaBoostR2 (Linear,Quadratic or Exponential); Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Bool_tfBaggedBoostturn bagging in combination with boost on/off; Bool_tfBaggedGradBoostturn bagging in combination with grad boost on/off; Double_tfBaggedSampleFractionrelative size of bagged event sample to original sample size; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightntuple var: boost weight; vector<double>fBoostWeightsthe weights applied in the individual boosts; Double_tfCbbCost factor; Double_tfCssCost factor; Double_tfCtb_ssCost factor; Double_tfCts_sbCost factor; Bool_tfDoBoostMonitorcreate control plot with ROC integral vs tree number; Bool_tfDoPreselectiondo or do not perform automatic pre-selection of 100% eff. cuts; Double_tfErrorFractionntuple var: misclassification error fraction; vector<const TMVA::Event*>fEventSamplethe training events; Double_tfFValidationEventsfraction of events to use for pruning; vector<TMVA::DecisionTree*,allocator<TMVA::DecisionTree*> >fForestthe collection of decision trees; vector<Double_t>fHighBkgCut; vector<Double_t>fHighSigCut; Bool_tfHistoricBoolhistoric variable, only needed for ""CompatibilityOptions"" ; Int_tfITreentuple var: ith tree; Bool_tfInverseBoostNegWeightsboost ev. with neg. weights with 1/boostweight ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodBDT.html:21832,validat,validation,21832,root/html534/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodBDT.html,1,['validat'],['validation']
Security,"e return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetabeta parameter for AdaBoost algorithm; TStringfAdaBoostR2Lossloss type used in AdaBoostR2 (Linear,Quadratic or Exponential); Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Bool_tfBaggedBoostturn bagging in combination with boost on/off; Bool_tfBaggedGradBoostturn bagging in combination with grad boost on/off; Double_tfBaggedSampleFractionrelative size of bagged event sample to original sample size; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightntuple var: boost weight; vector<double>fBoostWeightsthe weights applied in the individual boosts; Double_tfCbbCost factor; Double_tfCssCost factor; Double_tfCtb_ssCost factor; Double_tfCts_sbCost factor; Bool_tfDoBoostMonitorcreate control plot with ROC integral vs tree number; Bool_tfDoPreselectiondo or do not perform automatic pre-selection of 100% eff. cuts; Double_tfErrorFractionntuple var: misclassification error fraction; vector<const TMVA::Event*>fEventSamplethe training events; Double_tfFValidationEventsfraction of events to use for pruning; vector<TMVA::DecisionTree*>fForestthe collection of decision trees; vector<Double_t>fHighBkgCut; vector<Double_t>fHighSigCut; Bool_tfHistoricBoolhistoric variable, only needed for ""CompatibilityOptions""; Int_tfITreentuple var: ith tree; Bool_tfInverseBoostNegWeightsboost ev. with neg. weights with 1/boostweight rathre than boostweight; vector<B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodBDT.html:22992,validat,validation,22992,root/html602/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodBDT.html,2,['validat'],['validation']
Security,e returned socket must be deleted by the user. The socket is also added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. In case of error 0 is returned and in case non-blocking I/O is enabled and no connections are available -1 is returned.; The opt can be used to require client authentication; valid options are; kSrvAuth = require client authentication kSrvNoAuth = force no client authentication; Example: use Opt = kSrvAuth to require client authentication.; Default options are taken from fgAcceptOpt and are initially equivalent to kSrvNoAuth; they can be changed with the static method TServerSocket::SetAcceptOptions(Opt). The active defaults can be visualized using the static method TServerSocket::ShowAcceptOptions(). ; Reimplemented in TPServerSocket.; Definition at line 204 of file TServerSocket.cxx. ◆ Authenticate(). Bool_t TServerSocket::Authenticate ; (; TSocket * ; sock). private . Check authentication request from the client on new open connection. ; Definition at line 300 of file TServerSocket.cxx. ◆ Class(). static TClass * TServerSocket::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TServerSocket::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TServerSocket::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 95 of file TServerSocket.h. ◆ DeclFileName(). static const char * TServerSocket::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 95 of file TServerSocket.h. ◆ GetAcceptOptions(). UChar_t TServerSocket::GetAcceptOptions ; (; ). static . Return default options for Accept. ; Definition at line 272 of file TServerSocket.cxx. ◆ GetLocalInetAddress(). TInetAddress TServerSocket::GetLocalInetAddress ; (; ). overridevirtual . Return internet address of host to which the server socket,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTServerSocket.html:23280,authenticat,authentication,23280,doc/master/classTServerSocket.html,https://root.cern,https://root.cern/doc/master/classTServerSocket.html,1,['authenticat'],['authentication']
Security,"e semaphore count is incremented. Counting semaphores are useful for coordinating access to a limited pool of some resource.; Readers/Writer Lock - a multiple-reader, single-writer lock is one that allows simultaneous read access by many threads while restricting write access to only one thread at a time. When any thread holds the lock for reading, other threads can also acquire the lock reading. If one thread holds the lock for writing, or is waiting to acquire the lock for writing, other threads must wait to acquire the lock for either reading or writing.; Use a condition variable in conjunction with a mutex lock to automatically block threads until a particular condition is true.; Multithread Safe Levels - a possible classification scheme to describe thread-safety of libraries:. All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within a library. The developer must explicitly lock access to objects shared between threads. No other thread can write to a locked object unless it is unlocked. The developer needs to lock local objects. The spirit, if not the letter of this definition, requires the user of the library only to be familiar with the semantic content of the objects in use. Locking access to objects that are being shared due to extra-semantic details of implementation (for example, copy-on-write) should remain the responsibility of the library.; All public and protected functions are reentrant. The library provides protection against multiple threads trying to modify static and global data used within the library. The preferred way of providing this protection is to use mutex locks. The library also locks an object before writing to it. The developer is not required to explicitly lock or unlock a class object (static, global or local) to perform a single operation on the object. Note that even multithread safe level II hardly relieves the user of the library ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1123317,access,access,1123317,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"e server. This; is useful when the file is set an access control that allows for; any unidentified user to read the file. Bool_t ParseOptions(Option_t* options, TString& accessKey, TString& secretKey); Extracts the S3 authentication key pair (access key and secret key); from the options. The authentication credentials can be specified in; the options provided to the constructor of this class as a string; containing: ""AUTH=<access key>:<secret key>"" and can include other; options, for instance ""NOPROXY"" for not using the HTTP proxy for; accessing this file's contents.; For instance:; ""NOPROXY AUTH=F38XYZABCDeFgHiJkLm:V+frt4re7J1euSNFnmaf8wwmI401234E7kzxZ/TTM+"". Int_t GetHead(); Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this; file. Uses TS3HTTPRequest to generate an HTTP HEAD request which includes; the authorization header expected by the S3 server. void SetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); Overwrites TWebFile::SetMsgReadBuffer10() for setting the HTTP GET; request compliant to the authentication mechanism used by the S3; protocol. The GET request must contain an ""Authorization"" header with; the signature of the request, generated using the user's secret access; key. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf). void ProcessHttpHeader(const TString& headerLine); This method is called by the super-class TWebFile when a HTTP header; for this file is retrieved. We scan the 'Server' header to detect the; type of S3 server this file is hosted on and to determine if it is; known to support multi-range HTTP GET requests. Some S3 servers (for; instance Amazon's) do not support that feature and when they; receive a multi-range request they sent back the whole file contents.; For this class, if the server do not support multirange requests; we issue multiple single-range requests instead. Bool_t GetCredentialsFromEnv(const char* accessKeyEnv, const char* secretKeyEnv, TString& outAcce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:30581,authenticat,authentication,30581,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,3,['authenticat'],['authentication']
Security,"e setting the file name; 9153 ; 9154void TTree::SetFileNumber(Int_t number); 9155{; 9156 if (fFileNumber < 0) {; 9157 Warning(""SetFileNumber"", ""file number must be positive. Set to 0"");; 9158 fFileNumber = 0;; 9159 return;; 9160 }; 9161 fFileNumber = number;; 9162}; 9163 ; 9164////////////////////////////////////////////////////////////////////////////////; 9165/// Set all the branches in this TTree to be in decomposed object mode; 9166/// (also known as MakeClass mode).; 9167///; 9168/// For MakeClass mode 0, the TTree expects the address where the data is stored; 9169/// to be set by either the user or the TTree to the address of a full object; 9170/// through the top level branch.; 9171/// For MakeClass mode 1, this address is expected to point to a numerical type; 9172/// or C-style array (variable or not) of numerical type, representing the; 9173/// primitive data members.; 9174/// The function's primary purpose is to allow the user to access the data; 9175/// directly with numerical type variable rather than having to have the original; 9176/// set of classes (or a reproduction thereof).; 9177 ; 9178void TTree::SetMakeClass(Int_t make); 9179{; 9180 fMakeClass = make;; 9181 ; 9182 Int_t nb = fBranches.GetEntriesFast();; 9183 for (Int_t i = 0; i < nb; ++i) {; 9184 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 9185 branch->SetMakeClass(make);; 9186 }; 9187}; 9188 ; 9189////////////////////////////////////////////////////////////////////////////////; 9190/// Set the maximum size in bytes of a Tree file (static function).; 9191/// The default size is 100000000000LL, ie 100 Gigabytes.; 9192///; 9193/// In TTree::Fill, when the file has a size > fgMaxTreeSize,; 9194/// the function closes the current file and starts writing into; 9195/// a new file with a name of the style ""file_1.root"" if the original; 9196/// requested file name was ""file.root"".; 9197 ; 9198void TTree::SetMaxTreeSize(Long64_t maxsize); 9199{; 9200 fgMaxTreeSize = maxsize;; 9201}; 9202 ; 9",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:354848,access,access,354848,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['access'],['access']
Security,"e single element in fElems. example with the class TAttLine; TClass::GetClass(""TAttLine"")->GetStreamerInfo()->ls(); produces;; StreamerInfo for class: TAttLine, version=1; short fLineColor offset= 4 type= 2 line color; short fLineStyle offset= 6 type= 2 line style; short fLineWidth offset= 8 type= 2 line width; i= 0, fLineColor type= 22, offset= 4, len=3, method=0; For I/O implementations (eg. XML) , one has to know the original name; of the data member. This function can be used to return a pointer; to the original TStreamerElement object corresponding to the j-th; element of a compressed array in fElems. parameters description:; - i: the serial number in array fElem; - j: the element number in the array of consecutive types; In the above example the class TAttLine has 3 consecutive data members; of the same type ""short"". Compile makes one single array of 3 elements.; To access the TStreamerElement for the second element; of this array, one can call:; TStreamerElement *el = GetStreamerElementReal(0,1);; const char* membername = el->GetName();; This function is typically called from TBuffer, TXmlBuffer. void InsertArtificialElements(const TObjArray* rules); Insert new members as expressed in the array of TSchemaRule(s). void ls(Option_t* option = """") const; List the TStreamerElement list and also the precomputed tables; if option contains the string ""incOrig"", also prints the original; (non-optimized elements in the list of compiled elements. void* New(void* obj = 0); An emulated object is created at address obj, if obj is null we; allocate memory for the object. void* NewArray(Long_t nElements, void* ary = 0); An array of emulated objects is created at address ary, if ary is null,; we allocate memory for the array. void DestructorImpl(void* p, Bool_t dtorOnly); Internal part of the destructor.; Destruct each of the datamembers in the same order; as the implicit destructor would. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Emulated destructor for this class.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStreamerInfo.html:22256,access,access,22256,root/html534/TStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TStreamerInfo.html,3,['access'],['access']
Security,"e single element in fElems. example with the class TAttLine; TClass::GetClass(""TAttLine"")->GetStreamerInfo()->ls(); produces;; StreamerInfo for class: TAttLine, version=1; short fLineColor offset= 4 type= 2 line color; short fLineStyle offset= 6 type= 2 line style; short fLineWidth offset= 8 type= 2 line width; i= 0, fLineColor type= 22, offset= 4, len=3, method=0; For I/O implementations (eg. XML) , one has to know the original name; of the data member. This function can be used to return a pointer; to the original TStreamerElement object corresponding to the j-th; element of a compressed array in fElems. parameters description:; - i: the serial number in array fElem; - j: the element number in the array of consecutive types; In the above example the class TAttLine has 3 consecutive data members; of the same type ""short"". Compile makes one single array of 3 elements.; To access the TStreamerElement for the second element; of this array, one can call:; TStreamerElement *el = GetStreamerElementReal(0,1);; const char* membername = el->GetName();; This function is typically called from Tbuffer, TXmlBuffer. Double_t GetValueAux(Int_t type, void* ladd, int k, Int_t len); Get the value from inside a collection. Double_t GetValue(char* pointer, Int_t i, Int_t j, Int_t len) const; return value of element i in object at pointer.; The function may be called in two ways:; -method1 len < 0; i is assumed to be the TStreamerElement number i in StreamerInfo; -method2 len >= 0; i is the type; address of variable is directly pointer. Double_t GetValueClones(TClonesArray* clones, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; return value of element i in object number j in a TClonesArray and eventually; element k in a sub-array. Double_t GetValueSTL(TVirtualCollectionProxy* cont, Int_t i, Int_t j, Int_t k, Int_t eoffset) const; return value of element i in object number j in a TClonesArray and eventually; element k in a sub-array. Double_t GetValueSTLP(TVirtualCollectionProxy* cont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerInfo.html:20342,access,access,20342,root/html528/TStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TStreamerInfo.html,3,['access'],['access']
Security,"e some hierarchy, one has to create several other volumes and the matrices to position them. Once this is done, use the volume editor interface to:. add/remove daughters, change shape, edit position of daughters; change visualization settings; divide the volume (only if there are no daughters yet). Close the geometry from the “General” category. 19 Python Interface. Python is a popular, open-source, dynamic programming language with an interactive interpreter. Its interoperability with other programming languages, both for extending Python as well as embedding it, is excellent and many existing third-party applications and libraries have therefore so-called “Python bindings.” PyROOT provides Python bindings for ROOT: it enables cross-calls from ROOT/Cling into Python and vice versa, the intermingling of the two interpreters, and the transport of user-level objects from one interpreter to the other. PyROOT enables access from ROOT to any application or library that itself has Python bindings, and it makes all ROOT functionality directly available from the python interpreter.; 19.1 PyROOT Overview; The Python scripting language is widely used for scientific programming, including high performance and distributed parallel code (see http://www.scipy.org). It is the second most popular scripting language (after Perl) and enjoys a wide-spread use as a “glue language”: practically every library and application these days comes with Python bindings (and if not, they can be easily written or generated).; PyROOT, a Python extension module, provides the bindings for the ROOT class library in a generic way using the Cling dictionary. This way, it allows the use of any ROOT classes from the Python interpreter, and thus the “glue-ing” of ROOT libraries with any non-ROOT library or applications that provide Python bindings. Further, PyROOT can be loaded into the Cling interpreter to allow (as of now still rudimentary) access to Python classes. The best way to understand the benefit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1041741,access,access,1041741,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"e strategy; 344 void SetStrategy(int strategyLevel) { fOptions.SetStrategy(strategyLevel); }; 345 ; 346 /// set scale for calculating the errors; 347 void SetErrorDef(double up) { fOptions.SetErrorDef(up); }; 348 ; 349 /// flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit); 350 void SetValidError(bool on) { fValidError = on; }; 351 ; 352 /// set all options in one go; 353 void SetOptions(const MinimizerOptions & opt) {; 354 fOptions = opt;; 355 }; 356 ; 357 /// set only the extra options; 358 void SetExtraOptions(const IOptions & extraOptions) { fOptions.SetExtraOptions(extraOptions); }; 359 ; 360 /// reset the default options (defined in MinimizerOptions); 361 void SetDefaultOptions() {; 362 fOptions.ResetToDefaultOptions();; 363 }; 364 ; 365protected:; 366 ; 367 // keep protected to be accessible by the derived classes; 368 ; 369 bool fValidError = false; ///< flag to control if errors have been validated (Hesse has been run in case of Minuit); 370 MinimizerOptions fOptions; ///< minimizer options; 371 int fStatus = -1; ///< status of minimizer; 372};; 373 ; 374 } // end namespace Math; 375 ; 376} // end namespace ROOT; 377 ; 378 ; 379#endif /* ROOT_Math_Minimizer */; IFunction.h; MinimizerOptions.h; RSpan.hxx; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ROOT::Fit::ParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::IB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:16259,access,accessible,16259,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,2,"['access', 'validat']","['accessible', 'validated']"
Security,"e streaming.Definition TStreamerInfo.h:109; TStreamerInfo::fNslotsInt_t fNslots!total number of slots in fComp.Definition TStreamerInfo.h:95; TStreamerInfo::fOldVersionVersion_t fOldVersion! Version of the TStreamerInfo object read from the fileDefinition TStreamerInfo.h:101; TStreamerInfo::fWriteTextTStreamerInfoActions::TActionSequence * fWriteText! List of text write action resulting for the compilation, used for JSON.Definition TStreamerInfo.h:111; TStreamerInfo::GetReadMemberWiseActionsTStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Bool_t forCollection)Definition TStreamerInfo.h:167; TStringBasic string class.Definition TString.h:139; TString::StripTSubString Strip(EStripType s=kTrailing, char c=' ') constReturn a substring of self stripped at beginning and/or end.Definition TString.cxx:1163; TString::Dataconst char * Data() constDefinition TString.h:376; TString::kTrailing@ kTrailingDefinition TString.h:276; TVirtualArrayWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualArray.h:27; TVirtualArray::fSizeUInt_t fSizeDefinition TVirtualArray.h:33; TVirtualArray::fClassTClassRef fClassDefinition TVirtualArray.h:31; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::GetIncrementvirtual ULong_t GetIncrement() const =0Return the offset between two consecutive in-memory values (which depends on the sizeof() and alignme...; TVirtualCollectionProxy::GetReadMemberWiseActionsvir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:242940,access,access,242940,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['access'],['access']
Security,"e the Tribune de Geneve. You create a subscription - that's the TBranch in ROOT's world. You can of course have as many subscriptions as you need. Pick a subscription!; The subscription manager is called the TTreeReader. You subscribe to a branch by creating a TTreeReaderValue (or TTreeReaderArray for arrays of any sort) and register it with the TTreeReader:; // Our subscription manager:; TTreeReader subscriptionManager(theTree);; // Tell the manager that we want to subscribe to the branch ""TribuneDeGeneve"",; // and that we expect to get an object of type Newspaper.; TTreeReaderValue<Newspaper> myTribuneDeGeneve(subscriptionManager, ""TribuneDeGeneve"");. TTreeReader::Next(); You would not want to have all issues of the Tribune de Geneve at once, but only one, say today's. You do that by requesting delivery of an issue from the subscription manager: Data delivery; // In this example, we loop over all entries on the TTree.; while (subscriptionManager.Next()) {; // Now myTribuneDeGeneve has loaded its data and we can access it.; // TTreeReaderValue behaves like an iterator; you need to use ""->"" on; // it to access the data it refers to.; myTribuneDeGeneve->read();; ...; }. Summary; As you saw, TTree is about. Chunking up similar, disconnected entries of which typically only one needs to be available, just like newspaper issues or data from High Energy Physics collisions, also known as the entries of a TTree; Selecting which data the TTree should provide, i.e. subscribing to certain branches only. Branches can be nested, so depending on the tree you could even subscribe to only the sports section or even only an article, reducing data transfer. A precedure like this is actually what most physicists do to analyze data from a series of TTrees. So let's try it in practice!; . ‹ Using TTree::Draw() to access a TTree; up; Using a Macro to Read a TTree ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/ttree-and-its-data.html:3582,access,access,3582,d/ttree-and-its-data.html,https://root.cern,https://root.cern/d/ttree-and-its-data.html,1,['access'],['access']
Security,"e the bucket name in thr resource. For example, we don't use; http://mybucket.s3.amazonaws.com/path/to/my/file but instead; http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request; will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1""; Also note that the path must include the leading '/'. TString MakeHostHeader() const; Returns the 'Host' header to include in the HTTP request. TString MakeDateHeader() const; Returns the date header for this HTTP request. TString MakeAuthPrefix() const; Returns the authentication prefix. TString MakeAuthHeader(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the authentication header for this HTTP request. TString GetRequest(TS3HTTPRequest::EHTTPVerb httpVerb, Bool_t appendCRLF = kTRUE); Returns the HTTP request ready to be sent to the server. TS3HTTPRequest& SetHost(const TString& host). TS3HTTPRequest& SetBucket(const TString& bucket). TS3HTTPRequest& SetObjectKey(const TString& objectKey). TS3HTTPRequest& SetAuthKeys(const TString& accessKey, const TString& secretKey). TS3HTTPRequest& SetAuthType(TS3HTTPRequest::EAuthType authType). TS3HTTPRequest& SetAccessKey(const TString& accessKey). TS3HTTPRequest& SetSecretKey(const TString& secretKey). virtual ~TS3HTTPRequest(); { }. EHTTPVerb GetHTTPVerb() const; { return fVerb; }. const TString& GetHost() const; { return fHost; }. const TString& GetBucket() const; { return fBucket; }. const TString& GetObjectKey() const; { return fObjectKey; }. const TString& GetTimeStamp() const; { return fTimeStamp; }. const TString& GetAccessKey() const; { return fAccessKey; }. const TString& GetSecretKey() const; { return fSecretKey; }. TString GetAuthType() const; { return fAuthType; }. » Author: Fabio Hernandez 30/01/2013 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3HTTPRequest.html:9632,access,accessKey,9632,root/html534/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html534/TS3HTTPRequest.html,1,['access'],['accessKey']
Security,"e the bucket name in thr resource. For example, we don't use; http://mybucket.s3.amazonaws.com/path/to/my/file but instead; http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request; will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1""; Also note that the path must include the leading '/'. TString MakeHostHeader() const; Returns the 'Host' header to include in the HTTP request. TString MakeDateHeader() const; Returns the date header for this HTTP request. TString MakeAuthPrefix() const; Returns the authentication prefix. TString MakeAuthHeader(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the authentication header for this HTTP request. TString GetRequest(TS3HTTPRequest::EHTTPVerb httpVerb, Bool_t appendCRLF = kTRUE); Returns the HTTP request ready to be sent to the server. TS3HTTPRequest& SetHost(const TString& host). TS3HTTPRequest& SetBucket(const TString& bucket). TS3HTTPRequest& SetObjectKey(const TString& objectKey). TS3HTTPRequest& SetAuthKeys(const TString& accessKey, const TString& secretKey). TS3HTTPRequest& SetAuthType(TS3HTTPRequest::EAuthType authType). TS3HTTPRequest& SetAccessKey(const TString& accessKey). TS3HTTPRequest& SetSecretKey(const TString& secretKey). virtual ~TS3HTTPRequest(); { }. EHTTPVerb GetHTTPVerb() const; { return fVerb; }. const TString& GetHost() const; { return fHost; }. const TString& GetBucket() const; { return fBucket; }. const TString& GetObjectKey() const; { return fObjectKey; }. const TString& GetTimeStamp() const; { return fTimeStamp; }. const TString& GetAccessKey() const; { return fAccessKey; }. const TString& GetSecretKey() const; { return fSecretKey; }. TString GetAuthType() const; { return fAuthType; }. » Author: Fabio Hernandez 30/01/2013 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TS3HTTPRequest.html:10358,access,accessKey,10358,root/html604/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html604/TS3HTTPRequest.html,1,['access'],['accessKey']
Security,"e the bucket name in thr resource. For example, we don't use; http://mybucket.s3.amazonaws.com/path/to/my/file but instead; http://s3.amazonaws.com/mybucket/path/to/my/file so the HTTP request; will be of the form ""GET /mybucket/path/to/my/file HTTP/1.1""; Also note that the path must include the leading '/'. TString MakeHostHeader() const; Returns the 'Host' header to include in the HTTP request. TString MakeDateHeader() const; Returns the date header for this HTTP request. TString MakeAuthPrefix() const; Returns the authentication prefix. TString MakeAuthHeader(TS3HTTPRequest::EHTTPVerb httpVerb) const; Returns the authentication header for this HTTP request. TString GetRequest(TS3HTTPRequest::EHTTPVerb httpVerb, Bool_t appendCRLF = kTRUE); Returns the HTTP request ready to be sent to the server. TS3HTTPRequest& SetHost(const TString& host). TS3HTTPRequest& SetBucket(const TString& bucket). TS3HTTPRequest& SetObjectKey(const TString& objectKey). TS3HTTPRequest& SetAuthKeys(const TString& accessKey, const TString& secretKey). TS3HTTPRequest& SetAuthType(TS3HTTPRequest::EAuthType authType). TS3HTTPRequest& SetAccessKey(const TString& accessKey). TS3HTTPRequest& SetSecretKey(const TString& secretKey). virtual ~TS3HTTPRequest(); { }. EHTTPVerb GetHTTPVerb() const; { return fVerb; }. const TString& GetHost() const; { return fHost; }. const TString& GetBucket() const; { return fBucket; }. const TString& GetObjectKey() const; { return fObjectKey; }. const TString& GetTimeStamp() const; { return fTimeStamp; }. const TString& GetAccessKey() const; { return fAccessKey; }. const TString& GetSecretKey() const; { return fSecretKey; }. TString GetAuthType() const; { return fAuthType; }. » Author: Fabio Hernandez 30/01/2013 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3HTTPRequest.html:10358,access,accessKey,10358,root/html602/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html602/TS3HTTPRequest.html,1,['access'],['accessKey']
Security,"e to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Int_t fArrayLimit;  ! limit for array size. when array bigger, its content converted to raw format ;  ; const char ** fBasicTypes;  ! pointer on list of basic types specific for currently connected SQL server ;  ; Bool_t fCanChangeConfig;  ! variable indicates can be basic configuration changed or not ;  ; Bool_t fIdsTableExists;  ! indicate if IdsTable exists ;  ; std::ofstream * fLogFile;  ! log file with SQL statements ;  ; Int_t fModifyCounter;  ! indicates how many changes was done with database tables ;  ; const char ** fOtherTypes;  ! pointer on list of other SQL types like TEXT or blob ;  ; Int_t fQuerisCounter;  ! how many query was applied ;  ; TSQLServer * fSQL;  ! interface to SQL database ;  ; TList * fSQLClassInfos;  ! list of SQL class infos ;  ; Int_t fSQLIOversion;  ! version of SQL I/O which is stored in configurations ;  ; Int_t fStmtCounter;  ! count numbers of active statements ;  ; TString fTablesType;  ! type, used in CREATE TABLE statements ;  ; Int_t fUseIndexes;  ! use indexes for tables: 0 - off, 1 - only for basic tables, 2 + normal class tables, 3 - all tables ;  ; TString fUserName;  ! user name, used to access objects from database ;  ; Bool_t fUseSuffixes;  ! use suffixes in column names like fValue:Int_t or fObject:pointer ;  ; Int_t fUseTransactions;  ! use transaction statements for writing data into the tables ;  ;  Protected Attributes inherited from TFile; TArchiveFile * fArchive {nullptr};  !Archive file from which we read this file ;  ; Long64_t fArchiveOffset {0};  !Offset at which file starts in archive ;  ; TFileOpenHandle * fAsyncHandle {nullptr};  !For proper automatic cleanup ;  ; EAsyncOpenStatus fAsyncOpenStatus {kAOSNotAsync};  !Status of an asynchronous open request ;  ; Long64_t fBEGIN {0};  First used byte in file. ;  ; Long64_t fBytesRead {0};  Number of bytes read from this file. ;  ; Long64_t fBytesReadExtra {0};  Number of extra byt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:52813,access,access,52813,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['access'],['access']
Security,"e user must call IsA()->SetStreamerInfo(info) from this function. Bool_t MatchLegacyCheckSum(UInt_t checksum) const; Return true if the checksum passed as argument is one of the checksum; value produced by the older checksum calulcation algorithm. UInt_t GetCheckSum(ECheckSum code); Call GetCheckSum with validity check. UInt_t GetCheckSum(Bool_t& isvalid) const; Return GetCheckSum(kCurrentCheckSum,isvalid);. UInt_t GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; Compute and/or return the class check sum. isvalid is set to false, if the function is unable to calculate the; checksum. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Original algorithm from Victor Perevovchikov (perev@bnl.gov). The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility. WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void AdoptReferenceProxy(TVirtualRefProxy* proxy); Adopt the Reference proxy pointer to indicate that this class; represents a reference.; When a new proxy is adopted, the old one is deleted. void AdoptMemberStreamer(const char* name, TMemberStreamer* strm); Adopt the TMemberStreamer pointer to by p and use it to Stream non basic; member name. void SetMemberStreamer(const char* name, MemberStreamerFunc_t strm); Install a new member streamer (p will be copied). Int_t ReadBu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:57504,checksum,checksum,57504,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['checksum'],['checksum']
Security,"e user name.; Returns user name (which must be deleted by caller) or 0.; If non-interactive run (eg ProofServ) returns default user. char * PromptPasswd(const char* prompt = ""Password: ""); Static method to prompt for the user's passwd to be used for; authentication to rootd or proofd. Uses non-echoing command line; to get passwd. Returns passwd (which must de deleted by caller) or 0.; If non-interactive run (eg ProofServ) returns -1. GlobusAuth_t GetGlobusAuthHook(); Static method returning the globus authorization hook. const char * GetRSAPubExport(Int_t key = 0); Static method returning the RSA public keys. Int_t GetRSAInit(); Static method returning the RSA initialization flag. void SetDefaultRSAKeyType(Int_t key); Static method setting the default type of RSA key. void SetRSAInit(Int_t init = 1); Static method setting RSA initialization flag. TList * GetAuthInfo(); Static method returning the list with authentication details. TList * GetProofAuthInfo(); Static method returning the list with authentication directives; to be sent to proof. void AuthError(const char* where, Int_t error); Print error string depending on error code. void SetGlobalUser(const char* user); Set global user name to be used for authentication to rootd or proofd. void SetGlobalPasswd(const char* passwd); Set global passwd to be used for authentication to rootd or proofd. void SetGlobalPwHash(Bool_t pwhash); Set global passwd hash flag to be used for authentication to rootd or proofd. void SetGlobalSRPPwd(Bool_t srppwd); Set global SRP passwd flag to be used for authentication to rootd or proofd. void SetReadHomeAuthrc(Bool_t readhomeauthrc); Set flag controlling the reading of $HOME/.rootauthrc.; In PROOF the administrator may want to switch off private settings.; Always true, may only be set false via option to proofd. void SetGlobalExpDate(TDatime expdate); Set default expiring date for new validity contexts. void SetDefaultUser(const char* defaultuser); Set default user name. void SetTim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:15098,authenticat,authentication,15098,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"e& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,3>SVector<double,3>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,3U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,3>::(anonymous)kSize. private:. Double32_tfArray[3]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_3_.html:4626,access,access,4626,root/html602/ROOT__Math__SVector_Double32_t_3_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_3_.html,2,['access'],['access']
Security,"e& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,4>SVector<double,4>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,4U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,4>::(anonymous)kSize. private:. Double32_tfArray[4]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_4_.html:4626,access,access,4626,root/html602/ROOT__Math__SVector_Double32_t_4_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_4_.html,2,['access'],['access']
Security,"e& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,5>SVector<double,5>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,5U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,5>::(anonymous)kSize. private:. Double32_tfArray[5]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_5_.html:4626,access,access,4626,root/html602/ROOT__Math__SVector_Double32_t_5_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_5_.html,2,['access'],['access']
Security,"e& a5, const double& a6, const double& a7, const double& a8); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9); ROOT::Math::SVector<double,6>SVector<double,6>(const double& a1, const double& a2, const double& a3, const double& a4, const double& a5, const double& a6, const double& a7, const double& a8, const double& a9, const double& a10); ROOT::Math::SVector<double,6U>&Unit(). Data Members; public:. static ROOT::Math::SVector<double,6>::(anonymous)kSize. private:. Double32_tfArray[6]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVector<T,D>& operator=(const T& a1); assignment from a scalar (only for size 1 vector). SVector<T,D>& operator=(const VecExpr<A,T,D>& rhs); assignment from Vector Expression. unsigned int Dim(); return dimension $D$. { return D; }. T apply(unsigned int i) const; access the parse tree. Index starts from zero. const T* Array() const; return read-only pointer to internal array. T* Array(); return non-const pointer to internal array. iterator begin(); @name --- STL-like interface --- ; STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i) const; read-only access of vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_6_.html:4626,access,access,4626,root/html602/ROOT__Math__SVector_Double32_t_6_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SVector_Double32_t_6_.html,2,['access'],['access']
Security,"e());. This 2 functions are run in a context such that the branch names are; available as local variables of the correct (read-only) type. Note that if you use the same 'variable' twice, it is more efficient; to 'cache' the value. For example; Int_t n = fEventNumber; // Read fEventNumber; if (n<10 || n>10) { ... }; is more efficient than; if (fEventNumber<10 || fEventNumber>10). Access to TClonesArray. If a branch (or member) is a TClonesArray (let's say fTracks), you; can access the TClonesArray itself by using ->:; fTracks->GetLast();; However this will load the full TClonesArray object and its content.; To quickly read the size of the TClonesArray use (note the dot):; fTracks.GetEntries();; This will read only the size from disk if the TClonesArray has been; split.; To access the content of the TClonesArray, use the [] operator:; float px = fTracks[i].fPx; // fPx of the i-th track. Warning:; The variable actually use for access are 'wrapper' around the; real data type (to add autoload for example) and hence getting to; the data involves the implicit call to a C++ conversion operator.; This conversion is automatic in most case. However it is not invoked; in a few cases, in particular in variadic function (like printf).; So when using printf you should either explicitly cast the value or; use any intermediary variable:; fprintf(stdout,""trs[%d].a = %d\n"",i,(int)trs.a[i]);. Also, optionally, the generated selector will also call methods named; macrofilename_methodname in each of 6 main selector methods if the method; macrofilename_methodname exist (Where macrofilename is stripped of its; extension). Concretely, with the script named h1analysisProxy.C,. The method calls the method (if it exist); Begin -> void h1analysisProxy_Begin(TTree*);; SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; Notify -> Bool_t h1analysisProxy_Notify();; Process -> Bool_t h1analysisProxy_Process(Long64_t);; SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; Terminate -> void h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:45737,access,access,45737,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,6,['access'],['access']
Security,"e());; 2141 return;; 2142 }; 2143 } else {; 2144 targetClass = cl;; 2145 }; 2146 if (cl) {; 2147 //---------------------------------------------------------------------; 2148 // Get the streamer info for given version; 2149 ///////////////////////////////////////////////////////////////////////; 2150 ; 2151 {; 2152 if ( (cl->Property() & kIsAbstract) && cl == targetClass) {; 2153 TBranchElement *parent = (TBranchElement*)GetMother()->GetSubBranch(this);; 2154 if (parent && parent != this && !parent->GetClass()->IsLoaded() ) {; 2155 // Our parent's class is emulated and we represent an abstract class.; 2156 // and the target class has not been set explicitly.; 2157 TString target = cl->GetName();; 2158 target += ""@@emulated"";; 2159 fTargetClass.SetName(target);; 2160 ; 2161 if (!fTargetClass) {; 2162 cl->GetStreamerInfoAbstractEmulated(fClassVersion);; 2163 }; 2164 targetClass = fTargetClass;; 2165 }; 2166 }; 2167 if( targetClass != cl ) {; 2168 fInfo = (TStreamerInfo*)targetClass->GetConversionStreamerInfo( cl, fClassVersion );; 2169 } else {; 2170 fInfo = (TStreamerInfo*)cl->GetStreamerInfo(fClassVersion);; 2171 }; 2172 }; 2173 ; 2174 // FIXME: Check that the found streamer info checksum matches our branch class checksum here.; 2175 // Check to see if the class code was unloaded/reloaded; 2176 // since we were created.; 2177 R__LOCKGUARD(gInterpreterMutex);; 2178 if (fCheckSum && (cl->IsForeign() || (!cl->IsLoaded() && (fClassVersion == 1) && cl->GetStreamerInfos()->At(1) && (fCheckSum != ((TVirtualStreamerInfo*) cl->GetStreamerInfos()->At(1))->GetCheckSum())))) {; 2179 // Try to compensate for a class that got unloaded on us.; 2180 // Search through the streamer infos by checksum; 2181 // and take the first match.; 2182 ; 2183 TStreamerInfo* info;; 2184 if( targetClass != cl ); 2185 info = (TStreamerInfo*)targetClass->FindConversionStreamerInfo( cl, fCheckSum );; 2186 else {; 2187 info = (TStreamerInfo*)cl->FindStreamerInfo( fCheckSum );; 2188 if (info) {; 2189 // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:77509,checksum,checksum,77509,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,2,['checksum'],['checksum']
Security,"e(). static const char * THashTable::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t THashTable::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 82 of file THashTable.h. ◆ Clear(). void THashTable::Clear ; (; Option_t * ; option = """"). overridevirtual . Remove all objects from the table. ; Does not delete the objects unless the THashTable is the owner (set via SetOwner()). ; Implements TCollection.; Definition at line 167 of file THashTable.cxx. ◆ Collisions() [1/2]. Int_t THashTable::Collisions ; (; const char * ; name); const. Returns the number of collisions for an object with a certain name (i.e. ; number of objects in same slot in the hash table, i.e. length of linked list). ; Definition at line 191 of file THashTable.cxx. ◆ Collisions() [2/2]. Int_t THashTable::Collisions ; (; TObject * ; obj); const. Returns the number of collisions for an object (i.e. ; number of objects in same slot in the hash table, i.e. length of linked list). ; Definition at line 205 of file THashTable.cxx. ◆ DeclFileName(). static const char * THashTable::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 82 of file THashTable.h. ◆ Delete(). void THashTable::Delete ; (; Option_t * ; option = """"). overridevirtual . Remove all objects from the table AND delete all heap based objects. ; Implements TCollection.; Definition at line 220 of file THashTable.cxx. ◆ Empty(). Bool_t THashTable::Empty ; (; ); const. inline . Definition at line 66 of file THashTable.h. ◆ FindObject() [1/2]. TObject * THashTable::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from TCollection.; Reimplemented in TListOfTypes, and TListOfTypes.; Definition at line 238 of file THashTable.cxx. ◆ FindObject() [2/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:19660,hash,hash,19660,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hash']
Security,"e(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = __null); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = __null); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = __null, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event* ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventConstList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = __null); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__DecisionTree.html:11578,validat,validation,11578,root/html602/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__DecisionTree.html,2,['validat'],['validation']
Security,"e();; 2158 target += ""@@emulated"";; 2159 fTargetClass.SetName(target);; 2160 ; 2161 if (!fTargetClass) {; 2162 cl->GetStreamerInfoAbstractEmulated(fClassVersion);; 2163 }; 2164 targetClass = fTargetClass;; 2165 }; 2166 }; 2167 if( targetClass != cl ) {; 2168 fInfo = (TStreamerInfo*)targetClass->GetConversionStreamerInfo( cl, fClassVersion );; 2169 } else {; 2170 fInfo = (TStreamerInfo*)cl->GetStreamerInfo(fClassVersion);; 2171 }; 2172 }; 2173 ; 2174 // FIXME: Check that the found streamer info checksum matches our branch class checksum here.; 2175 // Check to see if the class code was unloaded/reloaded; 2176 // since we were created.; 2177 R__LOCKGUARD(gInterpreterMutex);; 2178 if (fCheckSum && (cl->IsForeign() || (!cl->IsLoaded() && (fClassVersion == 1) && cl->GetStreamerInfos()->At(1) && (fCheckSum != ((TVirtualStreamerInfo*) cl->GetStreamerInfos()->At(1))->GetCheckSum())))) {; 2179 // Try to compensate for a class that got unloaded on us.; 2180 // Search through the streamer infos by checksum; 2181 // and take the first match.; 2182 ; 2183 TStreamerInfo* info;; 2184 if( targetClass != cl ); 2185 info = (TStreamerInfo*)targetClass->FindConversionStreamerInfo( cl, fCheckSum );; 2186 else {; 2187 info = (TStreamerInfo*)cl->FindStreamerInfo( fCheckSum );; 2188 if (info) {; 2189 // Now that we found it, we need to make sure it is initialize (Find does not initialize the StreamerInfo).; 2190 info = (TStreamerInfo*)cl->GetStreamerInfo(info->GetClassVersion());; 2191 }; 2192 }; 2193 if( info ) {; 2194 fInfo = info;; 2195 // We no longer reset the class version so that in case the user is passing us later; 2196 // the address of a class that require (another) Conversion we can find the proper; 2197 // StreamerInfo.; 2198 // fClassVersion = fInfo->GetClassVersion();; 2199 }; 2200 }; 2201 }; 2202}; 2203 ; 2204 ; 2205////////////////////////////////////////////////////////////////////////////////; 2206/// Init the streamer info for the branch class, try to compensate for cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:78012,checksum,checksum,78012,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['checksum'],['checksum']
Security,"e(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. RooAbsArg* findArg(const RooAbsArg* ) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. RooLinkedListIter iterator(Bool_t dir = kTRUE) const. RooFIter fwdIterator() const. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE). void Streamer(TBuffer& ); Custom streaming handling schema evolution w.r.t past implementations. TObject* Clone(const char* = 0) const. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; const char* GetName() const { return """" ; /*_name.Data() ; */ }; void SetName(const char* /*name*/) { /*_name = name ; */ }. { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. void useNptr(Bool_t flag); needed for using it in THashList/THashTable. { _useNptr = flag ; }. ULong_t Hash() const; ULong_t Hash() const { return TString().Hash(); }. { return _name.Hash(); }. » Last changed: Mon Jun 22 16:42:21 2015 » Last generated: 2015-06-22 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLinkedList.html:9479,hash,hash,9479,root/html534/RooLinkedList.html,https://root.cern,https://root.cern/root/html534/RooLinkedList.html,1,['hash'],['hash']
Security,"e(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. RooAbsArg* findArg(const RooAbsArg* ) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. RooLinkedListIter iterator(Bool_t dir = kTRUE) const. RooFIter fwdIterator() const. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE). void Streamer(TBuffer& ); Custom streaming handling schema evolution w.r.t past implementations. TObject* Clone(const char* = 0) const. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; const char* GetName() const { return """" ; /*_name.Data() ; */ }; void SetName(const char* /*name*/) { /*_name = name ; */ }. { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. void useNptr(Bool_t flag); needed for using it in THashList/THashTable. { _useNptr = flag ; }. ULong_t Hash() const; ULong_t Hash() const { return TString().Hash(); }. { return _name.Hash(); }. » Last changed: Mon Jun 22 17:34:09 2015 » Last generated: 2015-06-22 17:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooLinkedList.html:9928,hash,hash,9928,root/html604/RooLinkedList.html,https://root.cern,https://root.cern/root/html604/RooLinkedList.html,1,['hash'],['hash']
Security,"e(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. RooAbsArg* findArg(const RooAbsArg* ) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. RooLinkedListIter iterator(Bool_t dir = kTRUE) const. RooFIter fwdIterator() const. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE). void Streamer(TBuffer& ); Custom streaming handling schema evolution w.r.t past implementations. TObject* Clone(const char* = 0) const. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; const char* GetName() const { return """" ; /*_name.Data() ; */ }; void SetName(const char* /*name*/) { /*_name = name ; */ }. { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. void useNptr(Bool_t flag); needed for using it in THashList/THashTable. { _useNptr = flag ; }. ULong_t Hash() const; ULong_t Hash() const { return TString().Hash(); }. { return _name.Hash(); }. » Last changed: Tue Jun 30 14:33:48 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLinkedList.html:9928,hash,hash,9928,root/html602/RooLinkedList.html,https://root.cern,https://root.cern/root/html602/RooLinkedList.html,1,['hash'],['hash']
Security,"e(nameStr.c_str());; 2913 const char *tmpName(tmpNameStr.c_str());; 2914 ; 2915 m_names.push_back(nameStr);; 2916 m_tempNames.push_back(tmpNameStr);; 2917 ROOT::TMetaUtils::Info(nullptr, ""File %s added to the tmp catalog.\n"", name);; 2918 ; 2919 // This is to allow update of existing files; 2920 if (0 == std::rename(name , tmpName)) {; 2921 ROOT::TMetaUtils::Info(nullptr, ""File %s existing. Preserved as %s.\n"", name, tmpName);; 2922 }; 2923 ; 2924 // To change the name to its tmp version; 2925 nameStr = tmpNameStr;; 2926 ; 2927 m_size++;; 2928 ; 2929 }; 2930 ; 2931 /////////////////////////////////////////////////////////////////////////////; 2932 ; 2933 int clean() {; 2934 int retval = 0;; 2935 // rename the temp files into the normal ones; 2936 for (unsigned int i = 0; i < m_size; ++i) {; 2937 const char *tmpName = m_tempNames[i].c_str();; 2938 // Check if the file exists; 2939 std::ifstream ifile(tmpName);; 2940 if (!ifile); 2941 ROOT::TMetaUtils::Error(nullptr, ""Cannot find %s!\n"", tmpName);; 2942 // Make sure the file is closed, mostly for Windows FS, also when; 2943 // accessing it from a Linux VM via a shared folder; 2944 if (ifile.is_open()); 2945 ifile.close();; 2946 if (0 != std::remove(tmpName)) {; 2947 ROOT::TMetaUtils::Error(nullptr, ""Removing %s!\n"", tmpName);; 2948 retval++;; 2949 }; 2950 }; 2951 return retval;; 2952 }; 2953 ; 2954 /////////////////////////////////////////////////////////////////////////////; 2955 ; 2956 int commit() {; 2957 int retval = 0;; 2958 // rename the temp files into the normal ones; 2959 for (unsigned int i = 0; i < m_size; ++i) {; 2960 const char *tmpName = m_tempNames[i].c_str();; 2961 const char *name = m_names[i].c_str();; 2962 // Check if the file exists; 2963 std::ifstream ifile(tmpName);; 2964 if (!ifile); 2965 ROOT::TMetaUtils::Error(nullptr, ""Cannot find %s!\n"", tmpName);; 2966 // Make sure the file is closed, mostly for Windows FS, also when; 2967 // accessing it from a Linux VM via a shared folder; 2968 if (ifile.i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:117095,access,accessing,117095,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['access'],['accessing']
Security,"e(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableUpperLimit(unsigned int ivar, double upper); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector&); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. private:. TLinearMinimizer(const TLinearMinimizer&); TLinearMinimizer&operator=(const TLinearMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; TLinearFitter*fFitter; doublefMinVal; unsigned intfNFree; const ROOT::Math::IGradientFunctionMultiDim*fObjFunc; vector<double>fParams; boolfRobust. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLinearMinimizer(int type = 0); Default constructor implementation.; type is not used - needed for consistency with other minimizer plug-ins. TLinearMinimizer(const char* type); constructor passing a type of algorithm, (supported now robust via LTS regression). ~TLinearMinimizer(); Destructor implementation. TLinearMinimizer(const TLinearMinimizer& ); Implementation of copy constructor. void SetFunction(const ROOT::Math::IMultiGenFunction & ); Set function to be minimized. Flag an error since only support Gradient objective functions. void SetFunction(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLinearMinimizer.html:5669,validat,validated,5669,root/html534/TLinearMinimizer.html,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html,1,['validat'],['validated']
Security,"e(zmin,zmax); The argument option (default=""QNR"") can be used to change the fit options.; ""Q"" means Quiet mode; ""N"" means do not show the result of the fit; ""R"" means fit the function in the specified function range. Note that the generated histograms are added to the list of objects; in the current directory. It is the user's responsability to delete; these histograms. Example: Assume a 3-d histogram h3; Root > h3->FitSlicesZ(); produces 4 TH2D histograms; with h3_0 containing parameter 0(Constant) for a Gaus fit; of each cell in X,Y projected along Z; with h3_1 containing parameter 1(Mean) for a gaus fit; with h3_2 containing parameter 2(RMS) for a gaus fit; with h3_chi2 containing the chisquare/number of degrees of freedom for a gaus fit. Root > h3->Fit(0,15,22,0,0,10);; same as above, but only for bins 15 to 22 along X; and only for cells in X,Y for which the corresponding projection; along Z has more than cut bins filled. NOTE: To access the generated histograms in the current directory, do eg:; TH2D *h3_1 = (TH2D*)gDirectory->Get(""h3_1"");. Double_t GetBinWithContent3(Double_t c, Int_t& binx, Int_t& biny, Int_t& binz, Int_t firstx = 0, Int_t lastx = 0, Int_t firsty = 0, Int_t lasty = 0, Int_t firstz = 0, Int_t lastz = 0, Double_t maxdiff = 0) const; compute first cell (binx,biny,binz) in the range [firstx,lastx](firsty,lasty][firstz,lastz] for which; diff = abs(cell_content-c) <= maxdiff; In case several cells in the specified range with diff=0 are found; the first cell found is returned in binx,biny,binz.; In case several cells in the specified range satisfy diff <=maxdiff; the cell with the smallest difference is returned in binx,biny,binz.; In all cases the function returns the smallest difference. NOTE1: if firstx <= 0, firstx is set to bin 1; if (lastx < firstx then firstx is set to the number of bins in X; ie if firstx=0 and lastx=0 (default) the search is on all bins in X.; if firsty <= 0, firsty is set to bin 1; if (lasty < firsty then firsty is set to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH3.html:32219,access,access,32219,root/html528/TH3.html,https://root.cern,https://root.cern/root/html528/TH3.html,4,['access'],['access']
Security,"e(zmin,zmax); The argument option (default=""QNR"") can be used to change the fit options.; ""Q"" means Quiet mode; ""N"" means do not show the result of the fit; ""R"" means fit the function in the specified function range. Note that the generated histograms are added to the list of objects; in the current directory. It is the user's responsability to delete; these histograms. Example: Assume a 3-d histogram h3; Root > h3->FitSlicesZ(); produces 4 TH2D histograms; with h3_0 containing parameter 0(Constant) for a Gaus fit; of each cell in X,Y projected along Z; with h3_1 containing parameter 1(Mean) for a gaus fit; with h3_2 containing parameter 2(RMS) for a gaus fit; with h3_chi2 containing the chisquare/number of degrees of freedom for a gaus fit. Root > h3->Fit(0,15,22,0,0,10);; same as above, but only for bins 15 to 22 along X; and only for cells in X,Y for which the corresponding projection; along Z has more than cut bins filled. NOTE: To access the generated histograms in the current directory, do eg:; TH2D *h3_1 = (TH2D*)gDirectory->Get(""h3_1"");. Int_t GetBin(Int_t binx, Int_t biny, Int_t binz) const; See comments in TH1::GetBin. Double_t GetBinWithContent3(Double_t c, Int_t& binx, Int_t& biny, Int_t& binz, Int_t firstx = 0, Int_t lastx = 0, Int_t firsty = 0, Int_t lasty = 0, Int_t firstz = 0, Int_t lastz = 0, Double_t maxdiff = 0) const; Compute first cell (binx,biny,binz) in the range [firstx,lastx](firsty,lasty][firstz,lastz] for which; diff = abs(cell_content-c) <= maxdiff; In case several cells in the specified range with diff=0 are found; the first cell found is returned in binx,biny,binz.; In case several cells in the specified range satisfy diff <=maxdiff; the cell with the smallest difference is returned in binx,biny,binz.; In all cases the function returns the smallest difference. NOTE1: if firstx <= 0, firstx is set to bin 1; if (lastx < firstx then firstx is set to the number of bins in X; ie if firstx=0 and lastx=0 (default) the search is on all bins in X",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH3.html:36588,access,access,36588,root/html602/TH3.html,https://root.cern,https://root.cern/root/html602/TH3.html,1,['access'],['access']
Security,"e);  ; virtual void SetTreeNumber (Int_t index);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEntryListArray.html:9643,hash,hash,9643,doc/master/classTEntryListArray.html,https://root.cern,https://root.cern/doc/master/classTEntryListArray.html,1,['hash'],['hash']
Security,"e);; 11912 }; 11913 ; 11914 } else {; 11915 mg_cry_internal(conn, ""Bad SSI #include: [%s]"", tag);; 11916 return;; 11917 }; 11918 ; 11919 if (truncated) {; 11920 mg_cry_internal(conn, ""SSI #include path length overflow: [%s]"", tag);; 11921 return;; 11922 }; 11923 ; 11924 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11925 mg_cry_internal(conn,; 11926 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11927 tag,; 11928 path,; 11929 strerror(ERRNO));; 11930 } else {; 11931 fclose_on_exec(&file.access, conn);; 11932 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11933 > 0) {; 11934 send_ssi_file(conn, path, &file, include_level + 1);; 11935 } else {; 11936 send_file_data(conn, &file, 0, INT64_MAX);; 11937 }; 11938 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11939 }; 11940}; 11941 ; 11942 ; 11943#if !defined(NO_POPEN); 11944static void; 11945do_ssi_exec(struct mg_connection *conn, char *tag); 11946{; 11947 char cmd[1024] = """";; 11948 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11949 ; 11950 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11951 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11952 } else {; 11953 cmd[1023] = 0;; 11954 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11955 mg_cry_internal(conn,; 11956 ""Cannot SSI #exec: [%s]: %s"",; 11957 cmd,; 11958 strerror(ERRNO));; 11959 } else {; 11960 send_file_data(conn, &file, 0, INT64_MAX);; 11961 pclose(file.access.fp);; 11962 }; 11963 }; 11964}; 11965#endif /* !NO_POPEN */; 11966 ; 11967 ; 11968static int; 11969mg_fgetc(struct mg_file *filep); 11970{; 11971 if (filep == NULL) {; 11972 return EOF;; 11973 }; 11974 ; 11975 if (filep->access.fp != NULL) {; 11976 return fgetc(filep->access.fp);; 11977 } else {; 11978 return EOF;; 11979 }; 11980}; 11981 ; 11982 ; 11983static void; 11984send_ssi_file(struct mg_connection *conn,; 11985 const char *path,; 11986 struct mg_file *filep,; 11987 int include_level); 11988{; 11989 char buf[MG_BUF_LEN];; 11990 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:345802,access,access,345802,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"e);; 11913 }; 11914 ; 11915 } else {; 11916 mg_cry_internal(conn, ""Bad SSI #include: [%s]"", tag);; 11917 return;; 11918 }; 11919 ; 11920 if (truncated) {; 11921 mg_cry_internal(conn, ""SSI #include path length overflow: [%s]"", tag);; 11922 return;; 11923 }; 11924 ; 11925 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, &file)) {; 11926 mg_cry_internal(conn,; 11927 ""Cannot open SSI #include: [%s]: fopen(%s): %s"",; 11928 tag,; 11929 path,; 11930 strerror(ERRNO));; 11931 } else {; 11932 fclose_on_exec(&file.access, conn);; 11933 if (match_prefix_strlen(conn->dom_ctx->config[SSI_EXTENSIONS], path); 11934 > 0) {; 11935 send_ssi_file(conn, path, &file, include_level + 1);; 11936 } else {; 11937 send_file_data(conn, &file, 0, INT64_MAX);; 11938 }; 11939 (void)mg_fclose(&file.access); /* Ignore errors for readonly files */; 11940 }; 11941}; 11942 ; 11943 ; 11944#if !defined(NO_POPEN); 11945static void; 11946do_ssi_exec(struct mg_connection *conn, char *tag); 11947{; 11948 char cmd[1024] = """";; 11949 struct mg_file file = STRUCT_FILE_INITIALIZER;; 11950 ; 11951 if (sscanf(tag, "" \""%1023[^\""]\"""", cmd) != 1) {; 11952 mg_cry_internal(conn, ""Bad SSI #exec: [%s]"", tag);; 11953 } else {; 11954 cmd[1023] = 0;; 11955 if ((file.access.fp = popen(cmd, ""r"")) == NULL) {; 11956 mg_cry_internal(conn,; 11957 ""Cannot SSI #exec: [%s]: %s"",; 11958 cmd,; 11959 strerror(ERRNO));; 11960 } else {; 11961 send_file_data(conn, &file, 0, INT64_MAX);; 11962 pclose(file.access.fp);; 11963 }; 11964 }; 11965}; 11966#endif /* !NO_POPEN */; 11967 ; 11968 ; 11969static int; 11970mg_fgetc(struct mg_file *filep); 11971{; 11972 if (filep == NULL) {; 11973 return EOF;; 11974 }; 11975 ; 11976 if (filep->access.fp != NULL) {; 11977 return fgetc(filep->access.fp);; 11978 } else {; 11979 return EOF;; 11980 }; 11981}; 11982 ; 11983 ; 11984static void; 11985send_ssi_file(struct mg_connection *conn,; 11986 const char *path,; 11987 struct mg_file *filep,; 11988 int include_level); 11989{; 11990 char buf[MG_BUF_LEN];; 11991 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:345835,access,access,345835,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"e, int > = 0> . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Define ; (; std::string_view ; name, . F ; expression, . const ColumnNames_t & ; columns = {} . ). inline . Define a new column. ; Parameters. [in]nameThe name of the defined column. ; [in]expressionFunction, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column. ; [in]columnsNames of the columns/branches in input to the producer function. . Returnsthe first node of the computation graph for which the new quantity is defined.; Define a column that will be visible from all subsequent nodes of the functional chain. The expression is only evaluated for entries that pass all the preceding filters. A new variable is created called name, accessible as if it was contained in the dataset from subsequent transformations/actions.; Use cases include:; caching the results of complex calculations for easy and efficient multiple access; extraction of quantities of interest from complex objects. An exception is thrown if the name of the new column is already in use in this branch of the computation graph. Example usage:; // assuming a function with signature:; double myComplexCalculation(const RVec<float> &muon_pts);; // we can pass it directly to Define; auto df_with_define = df.Define(""newColumn"", myComplexCalculation, {""muon_pts""});; // alternatively, we can pass the body of the function as a string, as in Filter:; auto df_with_define = df.Define(""newColumn"", ""x*x + y*y"");; ROOT::VecOps::RVecA ""std::vector""-like collection of values implementing handy operation to analyse them.Definition RVec.hxx:1529; NoteIf the body of the string expression contains an explicit return statement (even if it is in a nested scope), RDataFrame will not add another one in front of the expression. So this will not work: df.Define(""x2"", ""Map(v, [](float e) { return e*e; })""); but instead this will: df.Define(""x2"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:50073,access,access,50073,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['access'],['access']
Security,"e, used in SavePrimitive methods. ;  ; const TGWindow * GetParent () const;  ; virtual Bool_t HandleExpose (Event_t *event);  ; virtual Bool_t HandleIdleEvent (TGIdleHandler *);  ; Bool_t HandleTimer (TTimer *) override;  Execute action in response of a timer timing out. ;  ; virtual void IconifyWindow ();  iconify window ;  ; virtual Bool_t IsMapped ();  Returns kTRUE if window is mapped on screen, kFALSE otherwise. ;  ; virtual void LowerWindow ();  lower window ;  ; void Print (Option_t *option="""") const override;  Print window id. ;  ; virtual void RequestFocus ();  request focus ;  ; virtual void SetBackgroundPixmap (Pixmap_t pixmap);  set background pixmap ;  ; virtual void SetName (const char *name);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGObject;  TGObject ();  ;  TGObject (const TGObject &tgo);  ;  ~TGObject () override;  TGObject destructor. ;  ; TGClient * GetClient () const;  ; Handle_t GetId () const;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison (TGObjects are equal if they have the same window identifier). ;  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Write this TGObject to a file using TImage, if filename's extension signals a valid TImage::EImageFileType, as defined by TImage::GetImageFileTypeFromFilename(). ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootCanvas.html:17834,hash,hash,17834,doc/master/classTRootCanvas.html,https://root.cern,https://root.cern/doc/master/classTRootCanvas.html,1,['hash'],['hash']
Security,"e,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const double& rhs); ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >SMatrix<double,2,2,ROOT::Math::MatRepStd<double,2,2> >(const ROOT::Math::SVector<double,2*(2+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,2*(2+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,2,2>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:5343,access,access,5343,root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,8,['access'],"['access', 'accessing']"
Security,"e,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,2,2,ROOT::Math::MatRepSym<double,2> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html:5860,access,access,5860,root/html602/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_2_2_-p1MatRepSym_double_2___.html,2,['access'],['access']
Security,"e,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const double& rhs); ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >SMatrix<double,3,3,ROOT::Math::MatRepStd<double,3,3> >(const ROOT::Math::SVector<double,3*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html:5343,access,access,5343,root/html528/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_3_3_-p1MatRepStd_double_3_3___.html,8,['access'],"['access', 'accessing']"
Security,"e,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,3,3,ROOT::Math::MatRepSym<double,3> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html:5888,access,access,5888,root/html602/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepSym_Double32_t_3___.html,4,['access'],['access']
Security,"e,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const double& rhs); ROOT::Math::SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >SMatrix<double,3,4,ROOT::Math::MatRepStd<double,3,4> >(const ROOT::Math::SVector<double,3*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,3*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,3,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html:5233,access,access,5233,root/html528/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_3_4_-p1MatRepStd_double_3_4___.html,8,['access'],"['access', 'accessing']"
Security,"e,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const double& rhs); ROOT::Math::SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >SMatrix<double,4,3,ROOT::Math::MatRepStd<double,4,3> >(const ROOT::Math::SVector<double,4*(3+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(3+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,3>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html:5233,access,access,5233,root/html528/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_4_3_-p1MatRepStd_double_4_3___.html,8,['access'],"['access', 'accessing']"
Security,"e,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const double& rhs); ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >SMatrix<double,4,4,ROOT::Math::MatRepStd<double,4,4> >(const ROOT::Math::SVector<double,4*(4+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,4*(4+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,4,4>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html:5343,access,access,5343,root/html528/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_4_4_-p1MatRepStd_double_4_4___.html,8,['access'],"['access', 'accessing']"
Security,"e,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,4,4,ROOT::Math::MatRepSym<double,4> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html:5888,access,access,5888,root/html602/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_4_4_-p1MatRepSym_Double32_t_4___.html,4,['access'],['access']
Security,"e,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const double& rhs); ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >SMatrix<double,5,5,ROOT::Math::MatRepStd<double,5,5> >(const ROOT::Math::SVector<double,5*(5+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,5*(5+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,5,5>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html:5343,access,access,5343,root/html528/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_5_5_-p1MatRepStd_double_5_5___.html,8,['access'],"['access', 'accessing']"
Security,"e,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,5,5,ROOT::Math::MatRepSym<double,5> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html:5888,access,access,5888,root/html602/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_5_5_-p1MatRepSym_Double32_t_5___.html,4,['access'],['access']
Security,"e,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const double& rhs); ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >SMatrix<double,6,6,ROOT::Math::MatRepStd<double,6,6> >(const ROOT::Math::SVector<double,6*(6+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,6*(6+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,6,6>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html:5343,access,access,5343,root/html528/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_6_6_-p1MatRepStd_double_6_6___.html,8,['access'],"['access', 'accessing']"
Security,"e,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,6,6,ROOT::Math::MatRepSym<double,6> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html:5888,access,access,5888,root/html602/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_Double32_t_6_6_-p1MatRepSym_Double32_t_6___.html,4,['access'],['access']
Security,"e,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const double& rhs); ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >SMatrix<double,7,7,ROOT::Math::MatRepStd<double,7,7> >(const ROOT::Math::SVector<double,7*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,7*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,7,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html:5343,access,access,5343,root/html528/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_7_7_-p1MatRepStd_double_7_7___.html,8,['access'],"['access', 'accessing']"
Security,"e,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kRows; static ROOT::Math::SMatrix<double,7,7,ROOT::Math::MatRepSym<double,7> >::(anonymous)kSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator!=(const SMatrix<T,D1,D2,R>& rhs); element wise comparison. bool operator>(const double& rhs) const; element wise comparison. bool operator<(const double& rhs) const; element wise comparison. const T& operator()(unsigned int i, unsigned in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html:5860,access,access,5860,root/html602/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__SMatrix_double_7_7_-p1MatRepSym_double_7___.html,2,['access'],['access']
Security,"e,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const double& rhs); ROOT::Math::SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >SMatrix<double,9,7,ROOT::Math::MatRepStd<double,9,7> >(const ROOT::Math::SVector<double,9*(7+1)/2>& v, bool lower = true); doubleTrace() const; ROOT::Math::SVector<double,9*(7+1)/2>UpperBlock() const. Data Members; public:. enum { kRows; kCols; kSize; };. public:. ROOT::Math::MatRepStd<double,9,7>fRep. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SMatrix<T,D1,D2,R>& operator=(const M& rhs). Assign from another compatible matrix.; Possible Symmetirc to general but NOT vice-versa. SMatrix<T,D1,D2,R>& operator=(const Expr<A,T,D1,D2,R2>& rhs). Assign from a matrix expression. SMatrix<T,D1,D2,R> & operator=(ROOT::Math::SMatrixIdentity ). Assign from an identity matrix. T apply(unsigned int i) const; @name --- Access functions --- ; access the parse tree with the index starting from zero and; following the C convention for the order in accessing; the matrix elements.; Same convention for general and symmetric matrices. const T* Array() const; return read-only pointer to internal array. T* Array(); return pointer to internal array. iterator begin(); @name --- STL-like interface ---; The iterators access the matrix element in the order how they are; stored in memory. The C (row-major) convention is used, and in the; case of symmetric matrices the iterator spans only the lower diagonal; block. For example for a symmetric 3x3 matrices the order of the 6; elements \f${a_0,...a_5}\f$ is:; \f[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \f]. STL iterator interface. . iterator end(); STL iterator interface. . const_iterator begin() const; STL const_iterator interface. . const_iterator end() const; STL const_iterator interface. . bool operator==(const double& rhs) const; @name --- Operators ---",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html:5264,access,access,5264,root/html528/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_double_9_7_-p1MatRepStd_double_9_7___.html,8,['access'],"['access', 'accessing']"
Security,"e. . bool operator==(const T& rhs); @name --- Operators --- ; element wise comparison. bool operator!=(const T& rhs); element wise comparison. bool operator==(const SVector<T,D>& rhs); element wise comparison. bool operator!=(const SVector<T,D>& rhs); element wise comparison. bool operator>(const T& rhs); element wise comparison. bool operator<(const T& rhs); element wise comparison. bool operator>(const SVector<T,D>& rhs); element wise comparison. bool operator<(const SVector<T,D>& rhs); element wise comparison. const T& operator[](unsigned int i); read-only access of vector elements. Index starts from 0. const T& operator()(unsigned int i); read-only access of vector elements. Index starts from 0. const T& At(unsigned int i); read-only access of vector elements with check on index. Index starts from 0. T& operator[](unsigned int i); read/write access of vector elements. Index starts from 0. T& operator()(unsigned int i); read/write access of vector elements. Index starts from 0. T& At(unsigned int i); read/write access of vector elements with check on index. Index starts from 0. SVector<T,D>& operator+=(const T& rhs); self addition with a scalar. SVector<T,D>& operator-=(const T& rhs); self subtraction with a scalar. SVector<T,D>& operator*=(const double& rhs); self multiplication with a scalar. SVector<T,D>& operator/=(const double& rhs); self division with a scalar. SVector<T,D>& operator+=(const SVector<T,D>& rhs); self addition with another vector. SVector<T,D>& operator-=(const SVector<T,D>& rhs); self subtraction with another vector. SVector<T,D>& Unit(); @name --- Expert functions --- ; transform vector into a vector of lenght 1. std::ostream& Print(ostream& os) const; used by operator<<(). » Last changed: root/smatrix:$Id: SVector.h 21553 2007-12-21 10:55:46Z moneta $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SVector_double_2_.html:5940,access,access,5940,root/html526/ROOT__Math__SVector_double_2_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SVector_double_2_.html,6,['access'],['access']
Security,"e. ; Parameters. [in]fname1The name of the file ; [in]optionSpecifies the mode in which the file is opened ; [in]ftitleThe title of the file ; [in]compressSpecifies the compression algorithm and level. It is recommended to specify fname1 as ""<file>.root"". The suffix "".root"" will be used by object browsers to automatically identify the file as a ROOT file. If the constructor fails in any way IsZombie() will return true. Use IsOpen() to check if the file is (still) open. To open non-local files use the static TFile::Open() method, that will take care of opening the files using the correct remote file access plugin. Option Description . NEW or CREATE Create a new file and open it for writing, if the file already exists the file is not opened. . RECREATE Create a new file, if the file already exists it will be overwritten. . UPDATE Open an existing file for writing. If no file exists, it is created. . READ Open an existing file for reading (default). . NET Used by derived remote file access classes, not a user callable option. . WEB Used by derived remote http access class, not a user callable option. . READ_WITHOUT_GLOBALREGISTRATION Used by TTreeProcessorMT, not a user callable option. . If option = """" (default), READ is assumed. The file can be specified as a URL of the form: file:///user/rdm/bla.root or file:/user/rdm/bla.root; The file can also be a member of an archive, in which case it is specified as: multi.zip#file.root or multi.zip#0; which will open file.root which is a member of the file multi.zip archive or member 1 from the archive. For more on archive file support see the TArchiveFile class. TFile and its remote access plugins can also be used to open any file, i.e. also non ROOT files, using: file.tar?filetype=raw; This is convenient because the many remote file access plugins allow easy access to/from the many different mass storage systems. The title of the file (ftitle) will be shown by the ROOT browsers. A ROOT file (like a Unix file system) may cont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:48443,access,access,48443,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['access'],['access']
Security,"e. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TFolder Class ReferenceCore ROOT classes » Base ROOT classes. ; Legacy Code TFolder is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TFolder might still be a valid solution. ; A TFolder object is a collection of objects and folders. Folders have a name and a title and are identified in the folder hierarchy by a ""Unix-like"" naming mechanism. The root of all folders is //root. New folders can be dynamically added or removed to/from a folder. The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects are posted. Other classes/tasks can access these objects by specifying only a string pathname. This whiteboard facility greatly improves the modularity of an application, minimizing the class relationship problem that penalizes large applications.; Pointers are efficient to communicate between classes. However, one has interest to minimize direct coupling between classes in the form of direct pointers. One better uses the naming and search service provided by the Root folders hierarchy. This makes the classes loosely coupled and also greatly facilitates I/O operations. In a client/server environment, this mechanism facilitates the access to any kind of object in //root stores running on different processes.; A TFolder is created by invoking the TFolder constructor. It is placed inside an existing folder via the TFolder::AddFolder method. One can search for a folder or an object in a folder using the FindObject method. FindObject analyses the string passed as its argument and searches in the hierarchy until it finds an object or folder ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFolder.html:1014,access,access,1014,doc/master/classTFolder.html,https://root.cern,https://root.cern/doc/master/classTFolder.html,1,['access'],['access']
Security,"e. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Symlink (const char *from, const char *to) override;  Create a symlink from file1 to file2. ;  ; void Syslog (ELogLevel level, const char *mess) override;  Send mess to syslog daemon. ;  ; const char * TempDirectory () const override;  Return a user configured or systemwide directory to create temporary files in. ;  ; FILE * TempFileName (TString &base, const char *dir=nullptr, const char *suffix=nullptr) override;  Create a secure temporary file by appending a unique 6 letter string to base. ;  ; int Umask (Int_t mask) override;  Set the process file creation mode mask. ;  ; int Unlink (const char *name) override;  Unlink, i.e. ;  ; void Unload (const char *module) override;  Unload a shared library. ;  ; void Unsetenv (const char *name) override;  Unset environment variable. ;  ; int Utime (const char *file, Long_t modtime, Long_t actime) override;  Set a files modification and access times. ;  ; const char * WorkingDirectory () override;  Return working directory. ;  ;  Public Member Functions inherited from TSystem;  TSystem (const char *name=""Generic"", const char *title=""Generic System"");  Create a new OS interface. ;  ; virtual ~TSystem ();  Delete the OS interface. ;  ; virtual void AddIncludePath (const char *includePath);  Add a directory to the already set include path. ;  ; virtual void AddLinkedLibs (const char *linkedLib);  Add linkedLib to already set linked libs. ;  ; virtual void AddStdExceptionHandler (TStdExceptionHandler *eh);  Add an exception handler to list of system exception handlers. ;  ; virtual const char * BaseName (const char *pathname);  Base name of a file name. Base name of /user/root is root. ;  ; void Beep (Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE);  Beep for duration milliseconds with a tone of frequency freq. ;  ; Bool_t cd (const char *path);  ; virtual void Cle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacOSXSystem.html:12520,access,access,12520,doc/master/classTMacOSXSystem.html,https://root.cern,https://root.cern/doc/master/classTMacOSXSystem.html,2,['access'],['access']
Security,"e. A semicolon-separated list of values defining the source class data members that need to be cached and accessible via object proxy when the rule is executed. The values are either the names of the data members or the type-name pairs (separated by a space). If types are specified then the ondisk structure can be generated and used in the code snippet defined by the user. version. A list of versions of the source class that can be an input for this rule. The list has to be enclosed in a square bracket and be a comma-separated list of versions or version ranges. The version is an integer number, whereas the version range is one of the following:; “a-b”: a and b are integers and the expression means all the numbers between and including a and b; “-a”: a is an integer and the expression means all the version numbers smaller than or equal to a; “a-”: a is an integer and the expression means all the version numbers greater than or equal to a. checksum. A list of checksums of the source class that can be an input for this rule. The list has to be enclosed in a square brackets and is a comma-separated list of integers. targetClass. The field is obligatory and defines the name of the in-memory class that this rule can be applied to. target. A comma-separated list of target class data member names that this rule is capable of calculating. embed. This property tells the system if the rule should be written in the output file is some objects of this class are serialized. include. A list of header files that should be included in order to provide the functionality used in the code snippet; the list is comma delimited. code. An user specified code snippet. The user can assume that in the provided code snippet the following variables will be defined:; The user provided code snippets have to consist of valid C++ code. The system can do; some preprocessing before wrapping the code into function calls and declare some variables to facilitate the rule definitions. The user can expec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:501993,checksum,checksums,501993,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['checksum'],['checksums']
Security,"e. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TS3WebFile. class TS3WebFile: public TWebFile. TS3WebFile. A TS3WebFile is a TWebFile which retrieves the file contents from a; web server implementing the REST API of the Amazon S3 protocol. This; class is meant to be as generic as possible to be used with files; hosted not only by Amazon S3 servers but also by other providers; implementing the core of the S3 protocol. The S3 protocol works on top of HTTPS (and HTTP) and imposes that; each HTTP request be signed using a specific convention: the request; must include an 'Authorization' header which contains the signature; of a concatenation of selected request fields. For signing the; request, an 'Access Key Id' and a 'Secret Access Key' need to be; known. These keys are used by the S3 servers to identify the client; and to authenticate the request as genuine. As an end user, you must know the Access Key and Secret Access Key; in order to access each S3 file. They are provided to you by your S3; service provider. Those two keys can be provided to ROOT when; initializing an object of this class by two means:; a) by using the environmental variables S3_ACCESS_KEY and; S3_SECRET_KEY, or; b) by specifying them when opening each file. The first method is convenient if all the S3 files you want to; access are hosted by a single provider. The second one is more; flexible as it allows you to specify which credentials to use; on a per-file basis. See the documentation of the constructor of; this class for details on the syntax. For generating and signing the HTTP request, this class uses; TS3HTTPRequest. For more information on the details of S3 protocol please refer to:; ""Amazon Simple Storage Service Developer Guide"":; http://docs.amazonwebservices.com/AmazonS3/latest/dev/Welcome.html. ""Amazon S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:1028,authenticat,authenticate,1028,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,1,['authenticat'],['authenticate']
Security,"e...;  ; class  TFileInfo;  Class describing a generic file including meta information. More...;  ; class  TFolder;   Legacy Code TFolder is a legacy interface: there will be no bug fixes nor new developments. Therefore it is not recommended to use it in new long-term production code. But, depending on the context, using TFolder might still be a valid solution. More...;  ; class  TGuiFactory;  This ABC is a factory for GUI components. More...;  ; class  TInetAddress;  This class represents an Internet Protocol (IP) address. More...;  ; class  TInspectorImp;  ABC describing GUI independent object inspector (abstraction mainly needed for Win32. More...;  ; class  TListOfTypes;  A collection of TDataType designed to hold the typedef information and numerical type information. More...;  ; class  TMacro;  Class supporting a collection of lines with C++ code. More...;  ; class  TMD5;  This code implements the MD5 message-digest algorithm. More...;  ; class  TMemberInspector;  Abstract base class for accessing the data-members of a class. More...;  ; class  TMessageHandler;  Handle messages that might be generated by the system. More...;  ; class  TNamed;  The TNamed class is the base class for all named ROOT classes. More...;  ; class  TNotifyLink< Type >;  A node in a doubly linked list of subscribers to TChain notifications. More...;  ; class  TObject;  Mother of all ROOT objects. More...;  ; class  TObjectSpy;  Monitors objects for deletion and reflects the deletion by reverting the internal pointer to zero. More...;  ; class  TObjString;  Collectable string class. More...;  ; class  TParameter< AParamType >;  Named parameter, streamable and storable. More...;  ; class  TPluginManager;  This class implements a plugin library manager. More...;  ; class  TProcessID;  A TProcessID identifies a ROOT job in a unique way in time and space. More...;  ; class  TProcessUUID;  This class is a specialized TProcessID managing the list of UUIDs. More...;  ; class  TQCommand;  The Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Base.html:5224,access,accessing,5224,doc/master/group__Base.html,https://root.cern,https://root.cern/doc/master/group__Base.html,1,['access'],['accessing']
Security,"e.; Definition at line 670 of file TGHtmlForm.cxx. ◆ ProcessScript(). virtual char * TGHtml::ProcessScript ; (; TGHtmlScript * ; ). inlinevirtual . Definition at line 958 of file TGHtml.h. ◆ ProcessToken(). virtual int TGHtml::ProcessToken ; (; TGHtmlElement * ; , . const char * ; , . int ;  . ). inlinevirtual . Definition at line 928 of file TGHtml.h. ◆ PushStyleStack(). void TGHtml::PushStyleStack ; (; int ; tag, . SHtmlStyle_t ; style . ). protected . Push a new rendering style onto the stack. ; tag - Tag for this style. Normally the end-tag such as </h3> or </em>. style - The style to push ; Definition at line 66 of file TGHtmlSizer.cxx. ◆ RadioChanged(). void TGHtml::RadioChanged ; (; const char * ; name, . const char * ; val . ). virtual . Emit RadioChanged() signal. ; Definition at line 1313 of file TGHtml.cxx. ◆ Redraw(). void TGHtml::Redraw ; (; ). protected . This routine is invoked in order to redraw all or part of the HTML widget. ; This might happen because the display has changed, or in response to an expose event. In all cases, though, this routine is called by an idle handler. ; Definition at line 544 of file TGHtml.cxx. ◆ RedrawArea(). void TGHtml::RedrawArea ; (; int ; left, . int ; top, . int ; right, . int ; bottom . ). protected . If any part of the screen needs to be redrawn, then call this routine with the values of a box (in window coordinates) that needs to be redrawn. ; This routine will schedule an idle handler to do the redraw.; The box coordinates are relative to the clipping window (fCanvas). ; Definition at line 789 of file TGHtml.cxx. ◆ RedrawBlock(). void TGHtml::RedrawBlock ; (; TGHtmlBlock * ; p). protected . Redraw the TGHtmlBlock given. ; Definition at line 866 of file TGHtml.cxx. ◆ RedrawEverything(). void TGHtml::RedrawEverything ; (; ). protected . Call this routine to force the entire widget to be redrawn. ; Definition at line 877 of file TGHtml.cxx. ◆ RedrawText(). void TGHtml::RedrawText ; (; int ; y). protected . Call this",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtml.html:82439,expose,expose,82439,doc/master/classTGHtml.html,https://root.cern,https://root.cern/doc/master/classTGHtml.html,1,['expose'],['expose']
Security,"e.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by LoadTree() when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry number in the masterTree.; If we have no index, our entry number and the masterTree entry number are the sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:171021,access,access,171021,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['access'],['access']
Security,"e.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 587 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by LoadTree() when the masterTree looks for the entry number in a friend tree (us) corresponding to the passed entry number in the masterTree.; If we have no index, our entry number and the masterTree entry number are the sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:173209,access,access,173209,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['access'],['access']
Security,"e32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const; ----- Other fundamental properties -----. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. DisplacementVector2D Unit() const. return unit vector parallel to this. DisplacementVector2D<CoordSystem, Tag>& SetX(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. Displaceme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:9514,access,access,9514,root/html526/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"e::DavixReadBuffer ; (; Davix_fd * ; fd, . char * ; buf, . Int_t ; len . ). private . Definition at line 911 of file TDavixFile.cxx. ◆ DavixReadBuffers(). Long64_t TDavixFile::DavixReadBuffers ; (; Davix_fd * ; fd, . char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). private . Definition at line 971 of file TDavixFile.cxx. ◆ DavixStat(). Int_t TDavixFile::DavixStat ; (; struct stat * ; st); const. private . ◆ DavixWriteBuffer(). Long64_t TDavixFile::DavixWriteBuffer ; (; Davix_fd * ; fd, . const char * ; buf, . Int_t ; len . ). private . Definition at line 931 of file TDavixFile.cxx. ◆ DeclFileName(). static const char * TDavixFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 128 of file TDavixFile.h. ◆ DiscoverToken(). std::string TDavixFile::DiscoverToken ; (; ). ◆ enableGridMode(). void TDavixFile::enableGridMode ; (; ). Enable the grid mode The grid Mode configure automatically all grid-CA path, VOMS authentication and grid related extension for a grid analysis usage. ; Definition at line 834 of file TDavixFile.cxx. ◆ eventStart(). Double_t TDavixFile::eventStart ; (; ). private . Definition at line 882 of file TDavixFile.cxx. ◆ eventStop(). void TDavixFile::eventStop ; (; Double_t ; t, . Long64_t ; len, . bool ; read = true . ). private . set TFile state info ; Definition at line 892 of file TDavixFile.cxx. ◆ GetNewUrl(). TString TDavixFile::GetNewUrl ; (; ). virtual . Reimplemented from TFile.; Definition at line 693 of file TDavixFile.cxx. ◆ GetSize(). Long64_t TDavixFile::GetSize ; (; ); const. virtual . Returns the current file size. ; Returns -1 in case the file could not be stat'ed. ; Reimplemented from TFile.; Definition at line 868 of file TDavixFile.cxx. ◆ Init(). void TDavixFile::Init ; (; Bool_t ; create). privatevirtual . Initialize a TFile object. ; Parameters. [in]createCreate a new file. TFile implementations providing asynchronous open functionality need to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:44204,authenticat,authentication,44204,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['authenticat'],['authentication']
Security,"e::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooLinkedList_altBinning! Optional alternative ranges and binnings; RooAbsBinning*_binning! Pointer to default binning definition; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooErrorVar.html:35689,validat,validate,35689,root/html532/RooErrorVar.html,https://root.cern,https://root.cern/root/html532/RooErrorVar.html,2,"['access', 'validat']","['access', 'validate']"
Security,"e::WriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidDeclareOptions(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. virtual ~FitterBase(); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: FitterBase.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__FitterBase.html:7300,access,accessor,7300,root/html532/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html532/TMVA__FitterBase.html,1,['access'],['accessor']
Security,"e::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in input variable histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; Int_tTMVA::MethodBase::fNbinsMVAoutputnumber of bins in MVA output histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample ; Double_tfDeltaPruneStrengthstep size in pruning, is adjusted according to experience of previous trees ; Double_tfErrorFractionntuple var: misclassification error fraction ; vector<TMVA::Event*,allocator<TMVA::Event*> >fEventSamplethe training events; UInt_tfMaxDepthmax depth; Int_tfNCutsgrid used in cut applied in node splitting; UInt_tfNNodesMaxmax # of nodes; Int_tfNodeMinEventsmin number of events in node ; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostwhether to prune right after the training (before the boosting); TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig ; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; TMVA::DecisionTree*fTreethe decision tree; Int_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<Double_t>fVariableImportancethe relative importance of the different variables ; static const Int_tfgDebugLeve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodDT.html:19160,validat,validation,19160,root/html530/TMVA__MethodDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodDT.html,2,['validat'],['validation']
Security,"e::~TS3WebFile ; (; ). inlinevirtual . Definition at line 93 of file TS3WebFile.h. Member Function Documentation. ◆ Class(). static TClass * TS3WebFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TS3WebFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TS3WebFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 105 of file TS3WebFile.h. ◆ DeclFileName(). static const char * TS3WebFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 105 of file TS3WebFile.h. ◆ GetAccessKey(). const TString & TS3WebFile::GetAccessKey ; (; ); const. inline . Definition at line 96 of file TS3WebFile.h. ◆ GetBucket(). const TString & TS3WebFile::GetBucket ; (; ); const. inline . Definition at line 98 of file TS3WebFile.h. ◆ GetCredentialsFromEnv(). Bool_t TS3WebFile::GetCredentialsFromEnv ; (; const char * ; accessKeyEnv, . const char * ; secretKeyEnv, . const char * ; tokenEnv, . TString & ; outAccessKey, . TString & ; outSecretKey, . TString & ; outToken . ). private . Sets the access and secret keys from the environmental variables, if they are both set. ; Sets the security session token if it is given. ; Definition at line 366 of file TS3WebFile.cxx. ◆ GetHead(). Int_t TS3WebFile::GetHead ; (; ). overrideprotectedvirtual . Overwrites TWebFile::GetHead() for retrieving the HTTP headers of this file. ; Uses TS3HTTPRequest to generate an HTTP HEAD request which includes the authorization header expected by the S3 server. ; Reimplemented from TWebFile.; Definition at line 287 of file TS3WebFile.cxx. ◆ GetObjectKey(). const TString & TS3WebFile::GetObjectKey ; (; ); const. inline . Definition at line 99 of file TS3WebFile.h. ◆ GetSecretKey(). const TString & TS3WebFile::GetSecretKey ; (; ); const. inline . Definition at line 97 of file TS3WebFile.h. ◆ GetUrl(). const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:52498,access,accessKeyEnv,52498,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['access'],['accessKeyEnv']
Security,"e; 29collections of collections.; 30 ; 31In a later release the collections may become templatized.; 32*/; 33 ; 34#include ""TCollection.h""; 35#include ""Varargs.h""; 36#include ""TBuffer.h""; 37#include ""TClass.h""; 38#include ""TROOT.h""; 39#include ""TBrowser.h""; 40#include ""TObjectTable.h""; 41#include ""TRegexp.h""; 42#include ""TPRegexp.h""; 43#include ""TVirtualMutex.h""; 44#include ""TError.h""; 45#include ""TSystem.h""; 46#include ""TObjArray.h""; 47#include <iostream>; 48#include <sstream>; 49 ; 50#include ""TSpinLockGuard.h""; 51 ; 52TVirtualMutex *gCollectionMutex = nullptr;; 53 ; 54TCollection *TCollection::fgCurrentCollection = nullptr;; 55TObjectTable *TCollection::fgGarbageCollection = nullptr;; 56Bool_t TCollection::fgEmptyingGarbage = kFALSE;; 57Int_t TCollection::fgGarbageStack = 0;; 58 ; 59ClassImp(TCollection);; 60ClassImp(TIter);; 61 ; 62#ifdef R__CHECK_COLLECTION_MULTI_ACCESS; 63 ; 64void TCollection::TErrorLock::ConflictReport(std::thread::id holder, const char *accesstype,; 65 const TCollection *collection, const char *function); 66{; 67 ; 68 auto local = std::this_thread::get_id();; 69 std::stringstream cur, loc;; 70 if (holder == std::thread::id()); 71 cur << ""None"";; 72 else; 73 cur << ""0x"" << std::hex << holder;; 74 loc << ""0x"" << std::hex << local;; 75 ; 76 // std::cerr << ""Error in "" << function << "": Access ("" << accesstype << "") to a collection ("" <<; 77 // collection->IsA()->GetName() << "":"" << collection <<; 78 // "") from multiple threads at a time. holder="" << ""0x"" << std::hex << holder << "" readers="" << fReadSet.size() <<; 79 // ""0x"" << std::hex << local << std::endl;; 80 ; 81 ::Error(function,; 82 ""Access (%s) to a collection (%s:%p) from multiple threads at a time. holder=%s readers=%lu intruder=%s"",; 83 accesstype, collection->IsA()->GetName(), collection, cur.str().c_str(), fReadSet.size(), loc.str().c_str());; 84 ; 85 std::set<std::thread::id> tmp;; 86 for (auto r : fReadSet) tmp.insert(r);; 87 for (auto r : tmp) {; 88 std::stringstream reader;; 89",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:2513,access,accesstype,2513,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,2,['access'],['accesstype']
Security,"e; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TStri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashTable.html:9102,hash,hash,9102,root/html528/THashTable.html,https://root.cern,https://root.cern/root/html528/THashTable.html,3,['hash'],['hash']
Security,"e; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTable.html:9310,hash,hash,9310,root/html534/THashTable.html,https://root.cern,https://root.cern/root/html534/THashTable.html,3,['hash'],['hash']
Security,"e; fDeleteTClassprivate; fDeleteArrayTClassprivate; fDestructorTClassprivate; fDirAutoAddTClassprivate; fEnumsTClassprivate; fFuncTemplateTClassprivate; fgClassCountTClassprivatestatic; fgClassTypedefHashTClassprivatestatic; fgDtorOnlyTObjectprivatestatic; fGlobalIsATClassprivate; fgObjectStatTObjectprivatestatic; fHasCustomStreamerMemberTClassprivate; fHasRootPcmInfoTClassprivate; FillBuffer(char *&buffer)TNamedvirtual; fImplFileLineTClassprivate; fImplFileNameTClassprivate; FindClassOrBaseMethodWithId(DeclId_t faddr)TClassprivate; FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constTClass; FindConversionStreamerInfo(const TClass *onfile_cl, UInt_t checksum) constTClass; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; FindStreamerInfo(TObjArray *arr, UInt_t checksum) constTClassprotected; FindStreamerInfo(UInt_t checksum, Bool_t isTransient=kFALSE) constTClass; FindStreamerInfoAbstractEmulated(UInt_t checksum) constTClass; fInstanceCountTClassprivate; fIsATClassprivate; fIsAMethodTClassmutableprivate; fIsOffsetStreamerSetTClassmutableprivate; fIsSyntheticPairTClassprivate; fLastReadInfoTClassmutableprivate; fMergeTClassprivate; fMethodTClassprivate; fNameTNamedprotected; fNewTClassprivate; fNewArrayTClassprivate; fNoInfoOrEmuOrFwdDeclNameRegistryTClassprivatestatic; fObjectVersionRepositoryTClassmutableprivate; fOffsetStreamerTClassmutableprivate; fOnHeapTClassprivate; ForceReload(TClass *oldcl)TClass; fOVRMutexTClassmutableprivate; fPersistentRefTClassprivate; fPropertyTClassmutableprivate; fRealDataTClassprivate; fRefProxyTClassprivate; fResetAfterMergeTClassprivate; fRuntimePropertiesTClassmutableprivate; fSchemaRulesTClassprivate; fSharedLibsTClassprivate; fShowMembersTClassprivate; fSizeofTClassprivate; fStateTClassprivate; fStreamerTClassprivate; fStreamerFuncTClassprivate; fStreamerImplTClassmutableprivate; fStreamerInfoTClassmutableprivate; fStreamerTypeTClassprivate; fTitleTNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass-members.html:5334,checksum,checksum,5334,doc/master/classTClass-members.html,https://root.cern,https://root.cern/doc/master/classTClass-members.html,1,['checksum'],['checksum']
Security,"e; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddition.html:31024,validat,validate,31024,root/html532/RooAddition.html,https://root.cern,https://root.cern/root/html532/RooAddition.html,2,"['access', 'validat']","['access', 'validate']"
Security,"e; of the client-server links. It should be zero in calls initiated by users. void printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); Print tree structure of expression tree on given ostream, only branch nodes are printed.; Lead nodes (variables) will not be shown. If namePat is not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:34535,hash,hash,34535,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,6,['hash'],['hash']
Security,"e; they will be replaced with '_'.; To avoid item name duplication, additional id number can be appended. void CreateNode(const char* _node_name); creates new node with specified name; if special symbols like ""[]&<>"" are used, node name; will be replaced by default name like ""extra_item_N"" and; original node name will be recorded as ""_original_name"" field; Optionally, object name can be recorded as ""_realname"" field. void CloseNode(); close started node. void SetRootClass(TClass* cl); set root class name as node kind; in addition, path to master item (streamer info) specified; Such master item required to correctly unstream data on JavaScript. Bool_t Done() const; returns true if scanning is done; Can happen when searched element is found. Bool_t IsReadyForResult() const; Checks if result will be accepted.; Used to verify if sniffer should read object from the file. Bool_t SetResult(void* obj, TClass* cl, TDataMember* member = 0, Int_t chlds = -1); set results of scanning. Int_t Depth() const; returns current depth of scanned hierarchy. Int_t ExtraFolderLevel(); return level depth till folder, marked with extra flag; Objects in such folder can be 'expanded' -; one can get access to all class members; If no extra folder found, -1 is returned. Bool_t CanExpandItem(); returns true if current item can be expanded - means one could explore; objects members. Bool_t GoInside(TRootSnifferScanRec& super, TObject* obj, const char* obj_name = 0); Method verifies if new level of hierarchy; should be started with provided object.; If required, all necessary nodes and fields will be created; Used when different collection kinds should be scanned. TRootSnifferScanRec(). Bool_t CanSetFields(); return true when fields could be set to the hierarchy item . » Last changed: Tue Jun 30 15:29:44 2015 » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootSnifferScanRec.html:3610,access,access,3610,root/html602/TRootSnifferScanRec.html,https://root.cern,https://root.cern/root/html602/TRootSnifferScanRec.html,1,['access'],['access']
Security,"e; };. protected:. RooLinkedList**_arr! Array of linked lists storing elements in each slot; Int_t_entriesNumber of entries stored; RooHashTable::HashMethod_hashMethodHashing method; Int_t_sizeTotal number of slots; Int_t_usedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooHashTable(Int_t initSize = 17, RooHashTable::HashMethod hashMethod = Name); Construct a hash table with given capacity and hash method. RooHashTable(const RooHashTable& other); Copy constructor. void add(TObject* arg, TObject* hashArg = 0); Add given object to table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Bool_t remove(TObject* arg, TObject* hashArg = 0); Remove given object from table. If hashArg is given, hash will be calculation; on that rather than on 'arg'. Double_t avgCollisions() const; Calculate the average number of collisions (table slots with >1 filled entry). Bool_t replace(const TObject* oldArg, const TObject* newArg, const TObject* oldHashArg = 0); Replace oldArg with newArg in the table. If oldHashArg is given, use that to calculate; the hash associated with oldArg. TObject* find(const char* name) const; Return the object with given name from the table. TObject* find(const TObject* arg) const; Return object with the given pointer from the table. RooLinkedListElem* findLinkTo(const TObject* arg) const; Return RooLinkedList element link to object 'hashArg'. RooSetPair* findSetPair(const RooArgSet* set1, const RooArgSet* set2) const; Return RooSetPair with given pointers in table. ~RooHashTable(); Destructor. Int_t size() const; { return _size ; }. ULong_t hash(const TObject* arg) const; Return hash value calculated by method chosen in constructor. » Last changed: Thu Sep 23 19:59:54 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHashTable.html:7030,hash,hash,7030,root/html528/RooHashTable.html,https://root.cern,https://root.cern/root/html528/RooHashTable.html,4,['hash'],"['hash', 'hashArg']"
Security,"e;  Insert object before object before in the list. ;  ; void AddBefore (TObjLink *before, TObject *obj) override;  Insert object before object before in the list. ;  ; void AddFirst (TObject *obj) override;  Add object at the beginning of the list. ;  ; void AddFirst (TObject *obj, Option_t *opt) override;  Add object at the beginning of the list and also store option. ;  ; void AddLast (TObject *obj) override;  Add object at the end of the list. ;  ; void AddLast (TObject *obj, Option_t *opt) override;  Add object at the end of the list and also store option. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; void Clear (Option_t *option="""") override;  Remove all objects from the list. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the list AND delete all heap based objects. ;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; TClass * IsA () const override;  ; void RecursiveRemove (TObject *obj) override;  Remove object from this collection and recursively remove the object from all other objects (and collections). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; TObject * Remove (TObject *obj) override;  Remove object from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:2494,hash,hash,2494,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['hash'],['hash']
Security,"e=0)TStreamerInfo; ReadBufferArtificial(TBuffer &b, const T &arrptr, TStreamerElement *aElement, Int_t narr, Int_t eoffset)TStreamerInfo; ReadBufferClones(TBuffer &b, TClonesArray *clones, Int_t nc, Int_t first, Int_t eoffset)TStreamerInfo; ReadBufferConv(TBuffer &b, const T &arrptr, const TCompInfo *compinfo, Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset)TStreamerInfo; ReadBufferSkip(TBuffer &b, const T &arrptr, const TCompInfo *compinfo, Int_t kase, TStreamerElement *aElement, Int_t narr, Int_t eoffset)TStreamerInfo; ReadBufferSTL(TBuffer &b, TVirtualCollectionProxy *cont, Int_t nc, Int_t eoffset, Bool_t v7=kTRUE)TStreamerInfo; RecursiveRemove(TObject *obj)TObjectvirtual; ResetBit(UInt_t f)TObjectinline; ResetIsCompiled()TVirtualStreamerInfoinlineprotected; SaveAs(const char *filename="""", Option_t *option="""") constTObjectvirtual; SavePrimitive(std::ostream &out, Option_t *option="""")TObjectvirtual; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetCanDelete(Bool_t opt=kTRUE)TVirtualStreamerInfostatic; SetCheckSum(UInt_t checksum) overrideTStreamerInfoinlinevirtual; SetClass(TClass *cl) overrideTStreamerInfovirtual; SetClassVersion(Int_t vers) overrideTStreamerInfoinlinevirtual; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetFactory(TVirtualStreamerInfo *factory)TVirtualStreamerInfostatic; SetIsCompiled()TVirtualStreamerInfoinlineprotected; SetName(const char *name)TNamedvirtual; SetNameTitle(const char *name, const char *title)TNamedvirtual; SetObjectStat(Bool_t stat)TObjectstatic; SetOnFileClassVersion(Int_t vers)TStreamerInfoinline; SetStreamMemberWise(Bool_t enable=kTRUE)TVirtualStreamerInfostatic; SetTitle(const char *title="""")TNamedvirtual; SetUniqueID(UInt_t uid)TObjectvirtual; Sizeof() constTNamedvirtual; Streamer(TBuffer &) overrideTStreamerInfovirtual; StreamerNVirtual(TBuffer &ClassDef_StreamerNVirtual_b)TStreamerInfoinline; SysError(const char *method, const char *msgfmt,.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerInfo-members.html:16149,checksum,checksum,16149,doc/master/classTStreamerInfo-members.html,https://root.cern,https://root.cern/doc/master/classTStreamerInfo-members.html,1,['checksum'],['checksum']
Security,"e=kTRUE)Hides folder or element from web gui.Definition THttpServer.cxx:1436; THttpServer::IsCorsCredentialsBool_t IsCorsCredentials() constReturns kTRUE if Access-Control-Allow-Credentials header should be used.Definition THttpServer.h:121; THttpServer::AddLocationvoid AddLocation(const char *prefix, const char *path)Add files location, which could be used in the server.Definition THttpServer.cxx:332; THttpServer::fLocationsstd::map< std::string, std::string > fLocations! list of local directories, which could be accessed via serverDefinition THttpServer.h:48; THttpServer::SubmitHttpBool_t SubmitHttp(std::shared_ptr< THttpCallArg > arg, Bool_t can_run_immediately=kFALSE)Submit HTTP request.Definition THttpServer.cxx:681; THttpServer::fMainThrdIdLong_t fMainThrdId! id of the thread for processing requestsDefinition THttpServer.h:38; THttpServer::fJSROOTSYSTString fJSROOTSYS! location of local JSROOT filesDefinition THttpServer.h:44; THttpServer::fTimerstd::unique_ptr< THttpTimer > fTimer! timer used to access main threadDefinition THttpServer.h:35; THttpServer::fWSOnlyBool_t fWSOnly! when true, handle only websockets / longpoll engineDefinition THttpServer.h:42; THttpServer::RegisterBool_t Register(const char *subfolder, TObject *obj)Register object in subfolder.Definition THttpServer.cxx:1243; THttpServer::fEnginesTList fEngines! engines which runs http serverDefinition THttpServer.h:34; THttpServer::SetCorsvoid SetCors(const std::string &domain=""*"")Enable CORS header to ProcessRequests() responses Specified location (typically ""*"") add as ""Access-C...Definition THttpServer.h:109; THttpServer::IsCorsBool_t IsCors() constReturns kTRUE if CORS was configured.Definition THttpServer.h:112; THttpServer::GetCorsCredentialsconst char * GetCorsCredentials() constReturns specified CORS credentials value - if any.Definition THttpServer.h:124; THttpServer::fArgsstd::queue< std::shared_ptr< THttpCallArg > > fArgs! submitted argumentsDefinition THttpServer.h:58; THttpServer::Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:61767,access,access,61767,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['access'],['access']
Security,"e> >::Scalarz() const. Data Members; private:. ROOT::Math::PxPyPzE4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:14292,access,access,14292,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,4,['access'],['access']
Security,"e> >::Scalarz() const. Data Members; private:. ROOT::Math::PxPyPzE4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const Scalar[] src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(Scalar[] dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar zz, ROOT::Math::Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:10936,access,access,10936,root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,2,['access'],['access']
Security,"e> >::Scalarz() const. Data Members; private:. ROOT::Math::PxPyPzE4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html:14293,access,access,14293,root/html534/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzE4D_double___.html,1,['access'],['access']
Security,"e> >::Scalarz() const. Data Members; private:. ROOT::Math::PxPyPzM4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:12686,access,access,12686,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,4,['access'],['access']
Security,"e> >::Scalarz() const. Data Members; private:. ROOT::Math::PxPyPzM4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. LorentzVector<CoordSystem>& SetCoordinates(const Scalar[] src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(Scalar[] dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar zz, ROOT::Math::Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:10936,access,access,10936,root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,2,['access'],['access']
Security,"e> >::Scalarz() const. Data Members; private:. ROOT::Math::PxPyPzM4D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; LorentzVector & operator=( const LorentzVector<OtherCoords> & v); ------ assignment ------. Assignment operator from a lorentz vector of arbitrary type. SetXYZT(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar yy, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar zz, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar tt). fCoordinates. SetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar d). const CoordSystem & Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a const reference to the coordinates object. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& a, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& b, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& c, ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar& d) const. get internal data into 4 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c, d); }. void GetCoordinates(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. LorentzVector<CoordSystem>& SetCoordinates(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar* src). Set internal data based on an array of 4 Scalar numbers. fCoordinates. SetPxPyPzE(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<double> >::Scalar xx, ROOT::Math::LorentzVector<ROOT::Math::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html:12687,access,access,12687,root/html534/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__LorentzVector_-p1PxPyPzM4D_double___.html,1,['access'],['access']
Security,"eArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& b); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defTreeBufSize ; }. » Last changed: Mon Jul 4 15:24:43 2011 » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooTreeDataStore.html:17766,access,access,17766,root/html530/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html530/RooTreeDataStore.html,1,['access'],['access']
Security,"eArray());; 639 fBinContent.AddLast(chunk);; 640 return chunk;; 641}; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// Initialize the storage of a histogram created via Init(); 645 ; 646void THnSparse::InitStorage(Int_t* nbins, Int_t chunkSize); 647{; 648 fChunkSize = chunkSize;; 649 fCompactCoord = new THnSparseCompactBinCoord(fNdimensions, nbins);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653///We have been streamed; set up fBins; 654 ; 655void THnSparse::FillExMap(); 656{; 657 TIter iChunk(&fBinContent);; 658 THnSparseArrayChunk* chunk = nullptr;; 659 THnSparseCoordCompression compactCoord(*GetCompactCoord());; 660 Long64_t idx = 0;; 661 if (2 * GetNbins() > fBins.Capacity()); 662 fBins.Expand(3 * GetNbins());; 663 while ((chunk = (THnSparseArrayChunk*) iChunk())) {; 664 const Int_t chunkSize = chunk->GetEntries();; 665 Char_t* buf = chunk->fCoordinates;; 666 const Int_t singleCoordSize = chunk->fSingleCoordinateSize;; 667 const Char_t* endbuf = buf + singleCoordSize * chunkSize;; 668 for (; buf < endbuf; buf += singleCoordSize, ++idx) {; 669 Long64_t hash = compactCoord.GetHashFromBuffer(buf);; 670 Long64_t linidx = fBins.GetValue(hash);; 671 if (linidx) {; 672 Long64_t nextidx = linidx;; 673 while (nextidx) {; 674 // must be a collision, so go to fBinsContinued.; 675 linidx = nextidx;; 676 nextidx = fBinsContinued.GetValue(linidx);; 677 }; 678 fBinsContinued.Add(linidx, idx + 1);; 679 } else {; 680 fBins.Add(hash, idx + 1);; 681 }; 682 }; 683 }; 684}; 685 ; 686////////////////////////////////////////////////////////////////////////////////; 687/// Initialize storage for nbins; 688 ; 689void THnSparse::Reserve(Long64_t nbins) {; 690 if (!fBins.GetSize() && fBinContent.GetSize()) {; 691 FillExMap();; 692 }; 693 if (2 * nbins > fBins.Capacity()) {; 694 fBins.Expand(3 * nbins);; 695 }; 696}; 697 ; 698//////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:25437,hash,hash,25437,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,1,['hash'],['hash']
Security,"eCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Double_t_cutOffCutoff parameter for running product; RooArgSet_defNormSetDefault normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Int_t_extendedIndexIndex of extended PDF (if any) ; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAICRegistry_genCode! Registry of composite direct generator codes; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:43669,access,access,43669,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,1,['access'],['access']
Security,"eCollection);; 719 }; 720}; 721 ; 722////////////////////////////////////////////////////////////////////////////////; 723/// Add to the list of things to be cleaned up.; 724 ; 725void TCollection::GarbageCollect(TObject *obj); 726{; 727 {; 728 R__LOCKGUARD2(gCollectionMutex);; 729 if (fgGarbageCollection) {; 730 if (!fgEmptyingGarbage) {; 731 fgGarbageCollection->Add(obj);; 732 return;; 733 }; 734 }; 735 }; 736 delete obj;; 737}; 738 ; 739////////////////////////////////////////////////////////////////////////////////; 740/// Set whether this collection is the owner (enable==true); 741/// of its content. If it is the owner of its contents,; 742/// these objects will be deleted whenever the collection itself; 743/// is deleted. The objects might also be deleted or destructed when Clear; 744/// is called (depending on the collection).; 745 ; 746void TCollection::SetOwner(Bool_t enable); 747{; 748 if (enable); 749 SetBit(kIsOwner);; 750 else; 751 ResetBit(kIsOwner);; 752}; 753 ; 754////////////////////////////////////////////////////////////////////////////////; 755/// Set this collection to use a RW lock upon access, making it thread safe.; 756/// Return the previous state.; 757///; 758/// Note: To test whether the usage is enabled do:; 759/// collection->TestBit(TCollection::kUseRWLock);; 760 ; 761bool TCollection::UseRWLock(Bool_t enable); 762{; 763 bool prev = TestBit(TCollection::kUseRWLock);; 764 if (enable) {; 765 SetBit(TCollection::kUseRWLock);; 766 } else {; 767 ResetBit(TCollection::kUseRWLock);; 768 }; 769 return prev;; 770}; 771 ; 772////////////////////////////////////////////////////////////////////////////////; 773/// Copy a TIter. This involves allocating a new TIterator of the right; 774/// sub class and assigning it with the original.; 775 ; 776TIter::TIter(const TIter &iter); 777{; 778 if (iter.fIterator) {; 779 fIterator = iter.GetCollection()->MakeIterator();; 780 fIterator->operator=(*iter.fIterator);; 781 } else; 782 fIterator = nullptr;; 783}; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:25230,access,access,25230,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['access'],['access']
Security,"eDirectiveOutput(). void TDocParser::DeleteDirectiveOutput ; (; ); const. virtual . Delete output generated by prior runs of all known directives; the output file names might have changes. ; Definition at line 884 of file TDocParser.cxx. ◆ ExpandCPPLine(). void TDocParser::ExpandCPPLine ; (; TString & ; line, . Ssiz_t & ; pos . ). protectedvirtual . Expand preprocessor statements. ; Input: line - line containing the CPP statement, pos - position of '#'; NOTE: Looks for the #include statements and creates link to the corresponding file if such file exists ; Definition at line 911 of file TDocParser.cxx. ◆ GetCurrentClass(). TClass * TDocParser::GetCurrentClass ; (; ); const. inline . Definition at line 171 of file TDocParser.h. ◆ GetCurrentModule(). void TDocParser::GetCurrentModule ; (; TString & ; out_module); const. Return the name of module for which sources are currently parsed. ; Definition at line 967 of file TDocParser.cxx. ◆ GetDataMembers(). const TList * TDocParser::GetDataMembers ; (; EAccess ; access); const. inline . Definition at line 175 of file TDocParser.h. ◆ GetDocOutput(). TDocOutput * TDocParser::GetDocOutput ; (; ); const. inline . Definition at line 173 of file TDocParser.h. ◆ GetEnums(). const TList * TDocParser::GetEnums ; (; EAccess ; access); const. inline . Definition at line 176 of file TDocParser.h. ◆ GetLineNumber(). Long_t TDocParser::GetLineNumber ; (; ); const. inline . Definition at line 174 of file TDocParser.h. ◆ GetMethods(). const TList * TDocParser::GetMethods ; (; EAccess ; access); const. inline . Definition at line 170 of file TDocParser.h. ◆ GetSourceInfo(). const char * TDocParser::GetSourceInfo ; (; ESourceInfo ; type); const. inline . Definition at line 177 of file TDocParser.h. ◆ HandleDirective(). Bool_t TDocParser::HandleDirective ; (; TString & ; keyword, . Ssiz_t & ; pos, . TString & ; word, . Ssiz_t & ; copiedToCommentUpTo . ). protectedvirtual . Process directives to the documentation engine, like ""Begin_Html"" / """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDocParser.html:22531,access,access,22531,doc/master/classTDocParser.html,https://root.cern,https://root.cern/doc/master/classTDocParser.html,1,['access'],['access']
Security,"eEngine(). Bool_t THttpServer::CreateEngine ; (; const char * ; engine). Factory method to create different http engines. ; At the moment two engine kinds are supported:. civetweb or http (default); fastcgi. Examples: // creates civetweb web server with http port 8080; serv->CreateEngine(""http:8080"");; serv->CreateEngine(""civetweb:8080"");; serv->CreateEngine("":8080"");; // creates fastcgi server with port 9000; serv->CreateEngine(""fastcgi:9000"");; One could apply additional parameters, using URL syntax: serv->CreateEngine(""http:8080?thrds=10""); . Definition at line 419 of file THttpServer.cxx. ◆ CreateItem(). Bool_t THttpServer::CreateItem ; (; const char * ; fullname, . const char * ; title . ). Create item in sniffer. ; Definition at line 1455 of file THttpServer.cxx. ◆ CreateServerThread(). void THttpServer::CreateServerThread ; (; ). Creates special thread to process all requests, directed to http server. ; Should be used with care - only dedicated instance of TRootSniffer is allowed By default THttpServer allows to access global lists pointers gROOT or gFile. To be on the safe side, all kind of such access performed from the main thread. Therefore usage of specialized thread means that no any global pointers will be accessible by THttpServer ; Definition at line 515 of file THttpServer.cxx. ◆ DeclFileName(). static const char * THttpServer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 198 of file THttpServer.h. ◆ ExecuteHttp(). Bool_t THttpServer::ExecuteHttp ; (; std::shared_ptr< THttpCallArg > ; arg). Execute HTTP request. ; Executes http request, specified in THttpCallArg structure.; Method can be called from any thread Actual execution will be done in main ROOT thread, where analysis code is running. ; Definition at line 642 of file THttpServer.cxx. ◆ ExecuteWS(). Bool_t THttpServer::ExecuteWS ; (; std::shared_ptr< THttpCallArg > & ; arg, . Bool_t ; external_thrd = kFALSE, . Bool_t ; wait_p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:23667,access,access,23667,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['access'],['access']
Security,"eID"" : 0,; ""fBits"" : 0,; ""fName"" : ""obj"",; ""fTitle"" : ""title""; }; The following requests can be performed:. Name; Description. root.bin; binary data produced by object streaming with TBufferFile. root.json; ROOT JSON representation for object and objects members. file.root; Creates TMemFile with the only object, from ROOT 6.32. root.xml; ROOT XML representation. root.png; PNG image (if object drawing implemented). root.gif; GIF image. root.jpeg; JPEG image. exe.json; method execution in the object. exe.bin; method execution, return result in binary form. cmd.json; command execution. item.json; item (object) properties, specified on the server. multi.json; perform several requests at once. multi.bin; perform several requests at once, return result in binary form. All data will be automatically zipped if ‘.gz’ extension is appended. Like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:14927,access,access,14927,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,2,"['access', 'authenticat']","['access', 'authentication']"
Security,"eListOfMethods(TClass *cl) const finalCreate list of pointers to methods for TClass cl.Definition TCling.cxx:4498; TCling::RescanLibraryMapInt_t RescanLibraryMap() finalScan again along the dynamic path for library maps.Definition TCling.cxx:5925; TCling::SpecialObjectLookupCtx_tvoid * SpecialObjectLookupCtx_tDefinition TCling.h:151; TCling::fTransactionHeadersMapstd::map< const cling::Transaction *, size_t > fTransactionHeadersMapDefinition TCling.h:120; TCling::ReportDiagnosticsToErrorHandlervoid ReportDiagnosticsToErrorHandler(bool enable=true) finalReport diagnostics to the ROOT error handler (see TError.h).Definition TCling.cxx:7615; TCling::MethodInfo_GetMangledNameconst char * MethodInfo_GetMangledName(MethodInfo_t *minfo) const finalDefinition TCling.cxx:9118; TCling::fHeaderParsingOnDemandBool_t fHeaderParsingOnDemandDefinition TCling.h:181; TCling::IsIntegerTypebool IsIntegerType(const void *QualTypePtr) constDefinition TCling.cxx:9547; TCling::fStringHashFunctionstd::hash< std::string > fStringHashFunctionDefinition TCling.h:124; TCling::fMapfileTEnv * fMapfileDefinition TCling.h:117; TCling::RemoveAndInvalidateObjectstatic void RemoveAndInvalidateObject(List &L, Object *O)Definition TCling.h:591; TCling::GetInterfaceMethodWithPrototypevoid * GetInterfaceMethodWithPrototype(TClass *cl, const char *method, const char *proto, Bool_t objectIsConst=kFALSE, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) finalReturn pointer to cling interface function for a method of a class with a certain prototype,...Definition TCling.cxx:5110; TCling::ClassInfo_Newvoid * ClassInfo_New(ClassInfo_t *info) const finalDefinition TCling.cxx:8360; TCling::DisplayClassint DisplayClass(FILE *fout, const char *name, int base, int start) const finalDefinition TCling.cxx:7410; TCling::GetFunctionNamevirtual void GetFunctionName(const clang::Decl *decl, std::string &name) constDefinition TCling.cxx:8761; TCling::CreateListOfMethodArgsvoid CreateListOfMethodArgs(TFunction *m) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:72283,hash,hash,72283,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['hash'],['hash']
Security,eOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_t_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; RooRefCountListRooAbsArg::_serverList,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategory.html:22215,access,access,22215,root/html602/RooAbsCategory.html,https://root.cern,https://root.cern/root/html602/RooAbsCategory.html,2,['access'],['access']
Security,"eOwnership(). void RooAbsCollection::takeOwnership ; (; ). inline . Definition at line 356 of file RooAbsCollection.h. ◆ throwAddTypedException(). void RooAbsCollection::throwAddTypedException ; (; TClass * ; klass, . RooAbsArg * ; arg . ). staticprivate . Definition at line 1651 of file RooAbsCollection.cxx. ◆ typedStructureTag(). TNamed * RooAbsCollection::typedStructureTag ; (; ). inlineprotected . Definition at line 387 of file RooAbsCollection.h. ◆ uniqueId(). RooFit::UniqueId< RooAbsCollection > const & RooAbsCollection::uniqueId ; (; ); const. inline . Returns a unique ID that is different for every instantiated RooAbsCollection. ; This ID can be used to check whether two collections are the same object, which is safer than memory address comparisons that might result in false positives when memory is recycled. ; Definition at line 98 of file RooAbsCollection.h. ◆ useHashMapForFind(). void RooAbsCollection::useHashMapForFind ; (; bool ; flag); const. Parameters. [in]flagSwitch hash map on or off. . Definition at line 1614 of file RooAbsCollection.cxx. Member Data Documentation. ◆ _allRRV. bool RooAbsCollection::_allRRV = true. protected . All contents are RRV. ; Definition at line 382 of file RooAbsCollection.h. ◆ _hashAssistedFind. HashAssistedFind* RooAbsCollection::_hashAssistedFind = nullptr. mutableprivate . ! ; Definition at line 423 of file RooAbsCollection.h. ◆ _list. Storage_t RooAbsCollection::_list. protected . Actual object storage. ; Definition at line 377 of file RooAbsCollection.h. ◆ _name. TString RooAbsCollection::_name. protected . Our name. ; Definition at line 381 of file RooAbsCollection.h. ◆ _ownCont. bool RooAbsCollection::_ownCont = false. protected . Flag to identify a list that owns its contents. ; Definition at line 380 of file RooAbsCollection.h. ◆ _sizeThresholdForMapSearch. std::size_t RooAbsCollection::_sizeThresholdForMapSearch = 100. private . ! ; Definition at line 424 of file RooAbsCollection.h. ◆ _structureTag. TNamed* RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:61279,hash,hash,61279,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['hash'],['hash']
Security,"eOwnership(). void RooAbsCollection::takeOwnership ; (; ). inline . Definition at line 379 of file RooAbsCollection.h. ◆ throwAddTypedException(). void RooAbsCollection::throwAddTypedException ; (; TClass * ; klass, . RooAbsArg * ; arg . ). staticprivate . Definition at line 1638 of file RooAbsCollection.cxx. ◆ typedStructureTag(). TNamed * RooAbsCollection::typedStructureTag ; (; ). inlineprotected . Definition at line 410 of file RooAbsCollection.h. ◆ uniqueId(). RooFit::UniqueId< RooAbsCollection > const & RooAbsCollection::uniqueId ; (; ); const. inline . Returns a unique ID that is different for every instantiated RooAbsCollection. ; This ID can be used to check whether two collections are the same object, which is safer than memory address comparisons that might result in false positives when memory is recycled. ; Definition at line 98 of file RooAbsCollection.h. ◆ useHashMapForFind(). void RooAbsCollection::useHashMapForFind ; (; bool ; flag); const. Parameters. [in]flagSwitch hash map on or off. . Definition at line 1604 of file RooAbsCollection.cxx. Member Data Documentation. ◆ _allRRV. bool RooAbsCollection::_allRRV = true. protected . All contents are RRV. ; Definition at line 405 of file RooAbsCollection.h. ◆ _hashAssistedFind. std::unique_ptr<HashAssistedFind> RooAbsCollection::_hashAssistedFind. mutableprivate . ! ; Definition at line 446 of file RooAbsCollection.h. ◆ _list. Storage_t RooAbsCollection::_list. protected . Actual object storage. ; Definition at line 400 of file RooAbsCollection.h. ◆ _name. TString RooAbsCollection::_name. protected . Our name. ; Definition at line 404 of file RooAbsCollection.h. ◆ _ownCont. bool RooAbsCollection::_ownCont = false. protected . Flag to identify a list that owns its contents. ; Definition at line 403 of file RooAbsCollection.h. ◆ _sizeThresholdForMapSearch. std::size_t RooAbsCollection::_sizeThresholdForMapSearch = 100. private . ! ; Definition at line 447 of file RooAbsCollection.h. ◆ _structureTag. TNamed*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:63062,hash,hash,63062,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['hash'],['hash']
Security,"eReaderValueBase::kSetupMissingCompiledCollectionProxy; static ROOT::TTreeReaderValueBase::ESetupStatusROOT::TTreeReaderValueBase::kSetupMissingCounterBranch; static ROOT::TTreeReaderValueBase::ESetupStatusROOT::TTreeReaderValueBase::kSetupNoCheck; static ROOT::TTreeReaderValueBase::ESetupStatusROOT::TTreeReaderValueBase::kSetupNotSetup; static ROOT::TTreeReaderValueBase::ESetupStatusROOT::TTreeReaderValueBase::kSetupTreeDestructed; static ROOT::TTreeReaderValueBase::ESetupStatusROOT::TTreeReaderValueBase::kSetupVoidPtr. protected:. TStringROOT::TTreeReaderValueBase::fBranchNamename of the branch to read data from.; TDictionary*ROOT::TTreeReaderValueBase::fDicttype that the branch should contain; ROOT::TVirtualCollectionReader*fImplCommon interface to collections; TLeaf*ROOT::TTreeReaderValueBase::fLeaf; TStringROOT::TTreeReaderValueBase::fLeafName; ROOT::TBranchProxy*ROOT::TTreeReaderValueBase::fProxyproxy for this branch, owned by TTreeReader; ROOT::TTreeReaderValueBase::EReadStatusROOT::TTreeReaderValueBase::fReadStatusread status of this data access; ROOT::TTreeReaderValueBase::ESetupStatusROOT::TTreeReaderValueBase::fSetupStatussetup status of this data access; vector<Long64_t>ROOT::TTreeReaderValueBase::fStaticClassOffsets; Long64_tROOT::TTreeReaderValueBase::fTreeLastOffset; TTreeReader*ROOT::TTreeReaderValueBase::fTreeReadertree reader we belong to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void CreateProxy(); Create the proxy object for our branch. const char* GetBranchContentDataType(TBranch* branch, TString& contentTypeName, TDictionary*& dict) const; Access a branch's collection content (not the collection itself); through a proxy.; Retrieve the type of data contained in the collection stored by branch;; put its dictionary into dict, If there is no dictionary, put its type; name into contentTypeName.; The contentTypeName is set to NULL if the branch does not; contain a collection; in that case, the type of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__TTreeReaderArrayBase.html:4730,access,access,4730,root/html602/ROOT__TTreeReaderArrayBase.html,https://root.cern,https://root.cern/root/html602/ROOT__TTreeReaderArrayBase.html,4,['access'],['access']
Security,"eSet*nameSet2ByIndex(Int_t index) const; RooCacheManager<RooAbsCacheElement>&operator=(const RooCacheManager<RooAbsCacheElement>&); virtual voidoperModeHook(); virtual voidRooAbsCache::optimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector&); virtual voidsterilize(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidwireCache(). Data Members; protected:. Int_t_lastIndex! Last slot accessed; Int_t_maxSize! Maximum size; vector<RooNormSetCache>_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_size! Actual use; Bool_t_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html:3064,access,accessed,3064,root/html534/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html534/RooCacheManager_RooAbsCacheElement_.html,1,['access'],['accessed']
Security,"eTSocket::kROOTD; static TSocket::EInterestTSocket::kRead; static TSocket::EServiceTypeTSocket::kSOCKD; static TObject::(anonymous)TObject::kSingleKey; static TXSocket::EUrgentMsgTypekStopProcess; static TSocket::EInterestTSocket::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompressCompression level and algorithm; TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; Bool_tfAWaitkTRUE if waiting at the async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:11482,authenticat,authentication,11482,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,2,['authenticat'],['authentication']
Security,"eTree (const char *name, TFile *f, Bool_t islocal);  Default ctor. ;  ;  ~TFileTree () override;  Default dtor. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIterTree_1_1TFileTree.html:1355,hash,hash,1355,doc/master/classTEventIterTree_1_1TFileTree.html,https://root.cern,https://root.cern/doc/master/classTEventIterTree_1_1TFileTree.html,1,['hash'],['hash']
Security,"eWrapper::CheckEvent ; (; const TMVA::Event & ; e, . Bool_t ; useYesNoLeaf = false . ). return the decision tree output for an event ; Definition at line 226 of file CCTreeWrapper.cxx. ◆ GetRoot(). CCTreeNode * TMVA::CCTreeWrapper::GetRoot ; (; ). inline . Definition at line 148 of file CCTreeWrapper.h. ◆ InitTree(). void TMVA::CCTreeWrapper::InitTree ; (; CCTreeNode * ; t). initialize the node t and all its descendants ; Definition at line 123 of file CCTreeWrapper.cxx. ◆ PruneNode(). void TMVA::CCTreeWrapper::PruneNode ; (; CCTreeNode * ; t). remove the branch rooted at node t ; Definition at line 160 of file CCTreeWrapper.cxx. ◆ TestTreeQuality() [1/2]. Double_t TMVA::CCTreeWrapper::TestTreeQuality ; (; const DataSet * ; validationSample). return the misclassification rate of a pruned tree for a validation event sample using the DataSet ; Definition at line 203 of file CCTreeWrapper.cxx. ◆ TestTreeQuality() [2/2]. Double_t TMVA::CCTreeWrapper::TestTreeQuality ; (; const EventList * ; validationSample). return the misclassification rate of a pruned tree for a validation event sample using an EventList ; Definition at line 183 of file CCTreeWrapper.cxx. Member Data Documentation. ◆ fDTParent. DecisionTree* TMVA::CCTreeWrapper::fDTParent. private . ! pointer to underlying DecisionTree ; Definition at line 151 of file CCTreeWrapper.h. ◆ fQualityIndex. SeparationBase* TMVA::CCTreeWrapper::fQualityIndex. private . ! pointer to the used quality index calculator ; Definition at line 150 of file CCTreeWrapper.h. ◆ fRoot. CCTreeNode* TMVA::CCTreeWrapper::fRoot. private . ! the root node of the (wrapped) decision Tree ; Definition at line 152 of file CCTreeWrapper.h. Libraries for TMVA::CCTreeWrapper:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/CCTreeWrapper.h; tmva/tmva/src/CCTreeWrapper.cxx. TMVACCTreeWrapper. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CCTreeWrapper.html:3134,validat,validation,3134,doc/master/classTMVA_1_1CCTreeWrapper.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CCTreeWrapper.html,1,['validat'],['validation']
Security,"eWrite memory objects to this file.Definition TFile.cxx:2436; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::FillInt_t Fill(const Double_t *v)Definition TProfile.h:55; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandom3::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom3.cxx:99; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; TStringBasic string class.Definition TString.h:139; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; c1return c1Definition legend1.C:41; hsimpleDefinition hsimple.py:1; AuthorRene Brun ; Definition in file hsimple.C. tutorialshsimple.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8C.html:7200,access,access,7200,doc/master/hsimple_8C.html,https://root.cern,https://root.cern/doc/master/hsimple_8C.html,2,['access'],['access']
Security,"e_t mean=0, Double_t sigma=1, Bool_t norm=kFALSE);  Calculates a gaussian function with mean and sigma. ;  ; constexpr Double_t Gcgs ();  \( cm^{3} g^{-1} s^{-2} \) ;  ; template<typename Iterator > ; Double_t GeomMean (Iterator first, Iterator last);  Returns the geometric mean of an array defined by the iterators. ;  ; template<typename T > ; Double_t GeomMean (Long64_t n, const T *a);  Returns the geometric mean of an array a of size n. ;  ; constexpr Double_t GhbarC ();  \( \frac{G}{\hbar C} \) in \( (GeV/c^{2})^{-2} \) ;  ; constexpr Double_t GhbarCUncertainty ();  \( \frac{G}{\hbar C} \) uncertainty. ;  ; constexpr Double_t Gn ();  Standard acceleration of gravity in \( m s^{-2} \). ;  ; constexpr Double_t GnUncertainty ();  Standard acceleration of gravity uncertainty. ;  ; constexpr Double_t GUncertainty ();  Gravitational constant uncertainty. ;  ; constexpr Double_t H ();  Planck's constant in \( J s \): \( h \). ;  ; ULong_t Hash (const char *str);  ; ULong_t Hash (const void *txt, Int_t ntxt);  Calculates hash index from any char string. ;  ; constexpr Double_t Hbar ();  \( \hbar \) in \( J s \): \( \hbar = \frac{h}{2\pi} \) ;  ; constexpr Double_t Hbarcgs ();  \( erg s \) ;  ; constexpr Double_t HbarUncertainty ();  \( \hbar \) uncertainty. ;  ; constexpr Double_t HC ();  \( hc \) in \( J m \) ;  ; constexpr Double_t HCcgs ();  \( erg cm \) ;  ; constexpr Double_t Hcgs ();  \( erg s \) ;  ; constexpr Double_t HUncertainty ();  Planck's constant uncertainty. ;  ; Double_t Hypot (Double_t x, Double_t y);  Returns sqrt(x*x + y*y) ;  ; Long_t Hypot (Long_t x, Long_t y);  Returns sqrt(x*x + y*y) ;  ; Double_t Infinity ();  Returns an infinity as defined by the IEEE standard. ;  ; constexpr Double_t InvPi ();  \( \frac{1.}{\pi}\) ;  ; template<typename T > ; Bool_t IsInside (T xp, T yp, Int_t np, T *x, T *y);  Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in arrays x and y, kFALSE otherwise. ;  ; Bool_t IsNaN (Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:9276,hash,hash,9276,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['hash'],['hash']
Security,"e_t);  Set the value for this slice. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPieSlice.html:2395,hash,hash,2395,doc/master/classTPieSlice.html,https://root.cern,https://root.cern/doc/master/classTPieSlice.html,1,['hash'],['hash']
Security,"e_tfWeightTree weight (see TTree::SetWeight); static TSelectorDraw::(anonymous)kWarn. Class Charts. Inheritance Chart:. TObject. ←; TSelector. ←; TSelectorDraw. ←. TEvePointSelector. TEveSelectorToEventList. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Return the last values corresponding to the i-th component; of the formula being processed (where the component are ':' separated).; The actual number of entries is:; GetSelectedRows() % tree->GetEstimate(); Note GetSelectedRows currently returns the actual number of values plotted; and thus if the formula contains arrays, this number might be greater than; the number of entries in the trees.; By default TTree::Draw creates the arrays obtained; with all GetVal and GetW with a length corresponding to the; parameter fEstimate. By default fEstimate=10000 and can be modified; via TTree::SetEstimate. A possible recipee is to do; tree->SetEstimate(tree->GetEntries());; You must call SetEstimate if the expected number of selected rows; is greater than 10000.; See TTree::Draw for additional details. TTreeFormula* GetVar(Int_t i) const; Return the TTreeFormula corresponding to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSelectorDraw.html:10816,authoriz,authorized,10816,root/html602/TSelectorDraw.html,https://root.cern,https://root.cern/root/html602/TSelectorDraw.html,2,['authoriz'],['authorized']
Security,"e_t AvgIO ();  ; Double_t AvgRate ();  ; Int_t Compare (const TObject *o) const override;  Compare two TNamed objects. ;  ; void Print (Option_t *="""") const override;  Print TNamed name and title. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPerfAnalysis_1_1TWrkInfo.html:1447,hash,hash,1447,doc/master/classTProofPerfAnalysis_1_1TWrkInfo.html,https://root.cern,https://root.cern/doc/master/classTProofPerfAnalysis_1_1TWrkInfo.html,1,['hash'],['hash']
Security,"e`) or not (`false`). It should perform ""read-only"" operations on the; 501columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; 502when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; 503names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; 504certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; 505loop. See the paragraph about ""Just-in-time compilation"" below for more information.; 506 ; 507RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; 508in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; 509entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; 510each entry: after the first access it simply serves a cached result.; 511 ; 512\anchor named-filters-and-cutflow-reports; 513#### Named filters and cutflow reports; 514An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; 515work as usual, but also keep track of how many entries they accept and reject.; 516 ; 517Statistics are retrieved through a call to the Report() method:; 518 ; 519- when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; 520named filters declared up to that point; 521- when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; 522relative all named filters in the section of the chain between the main RDataFrame and that node (included).; 523 ; 524Stats are stored in the same order as named filters have been added to the graph, and *refer to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:31181,access,access,31181,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"e`) or not (`false`). It should perform ""read-only"" operations on the; 541columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; 542when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; 543names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; 544certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; 545loop. See the paragraph about ""Just-in-time compilation"" below for more information.; 546 ; 547RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; 548in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; 549entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; 550each entry: after the first access it simply serves a cached result.; 551 ; 552\anchor named-filters-and-cutflow-reports; 553#### Named filters and cutflow reports; 554An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; 555work as usual, but also keep track of how many entries they accept and reject.; 556 ; 557Statistics are retrieved through a call to the Report() method:; 558 ; 559- when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; 560named filters declared up to that point; 561- when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; 562relative all named filters in the section of the chain between the main RDataFrame and that node (included).; 563 ; 564Stats are stored in the same order as named filters have been added to the graph, and *refer to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:32821,access,access,32821,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"each variable ; Definition at line 125 of file BinarySearchTree.h. ◆ NormalizeTree() [1/2]. void TMVA::BinarySearchTree::NormalizeTree ; (; ). Normalisation of tree. ; Definition at line 343 of file BinarySearchTree.cxx. ◆ NormalizeTree() [2/2]. void TMVA::BinarySearchTree::NormalizeTree ; (; std::vector< std::pair< Double_t, const TMVA::Event * > >::iterator ; leftBound, . std::vector< std::pair< Double_t, const TMVA::Event * > >::iterator ; rightBound, . UInt_t ; actDim . ). private . normalises the binary-search tree to reduce the branch length and hence speed up the search procedure (on average). ; Definition at line 286 of file BinarySearchTree.cxx. ◆ RMS() [1/2]. Float_t TMVA::BinarySearchTree::RMS ; (; Types::ESBType ; sb, . UInt_t ; var . ). inline . access to RMS for signal and background for each variable ; Definition at line 122 of file BinarySearchTree.h. ◆ RMS() [2/2]. Float_t TMVA::BinarySearchTree::RMS ; (; UInt_t ; var). inline . access to RMS for each variable ; Definition at line 133 of file BinarySearchTree.h. ◆ Search() [1/2]. TMVA::BinarySearchTreeNode * TMVA::BinarySearchTree::Search ; (; Event * ; event, . Node * ; node . ); const. private . Private, recursive, function for searching. ; Definition at line 201 of file BinarySearchTree.cxx. ◆ Search() [2/2]. TMVA::BinarySearchTreeNode * TMVA::BinarySearchTree::Search ; (; Event * ; event); const. search the tree to find the node matching ""event"" ; Definition at line 193 of file BinarySearchTree.cxx. ◆ SearchVolume() [1/2]. Double_t TMVA::BinarySearchTree::SearchVolume ; (; Node * ; t, . Volume * ; volume, . Int_t ; depth, . std::vector< const TMVA::BinarySearchTreeNode * > * ; events . ). private . recursively walk through the daughter nodes and add up all weights of events that lie within the given volume ; Definition at line 380 of file BinarySearchTree.cxx. ◆ SearchVolume() [2/2]. Double_t TMVA::BinarySearchTree::SearchVolume ; (; Volume * ; volume, . std::vector< const TMVA::BinarySearchTreeN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html:13845,access,access,13845,doc/master/classTMVA_1_1BinarySearchTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html,1,['access'],['access']
Security,"ead () const;  Returns true if this branch supports bulk IO, false otherwise. ;  ; virtual void UpdateAddress ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchClones.html:10875,hash,hash,10875,doc/master/classTBranchClones.html,https://root.cern,https://root.cern/doc/master/classTBranchClones.html,2,['hash'],['hash']
Security,"ead n-tuples in distinct workers, fill histograms, merge them and fit ;  mp103_processSelector.C Illustrate the usage of the multiproc TSelector interfaces with the h1 analysis example ;  mp201_parallelHistoFill.C Parallel fill of a histogram This tutorial shows how a histogram can be filled in parallel with a multiprocess approach ;  mt001_fillHistos.CFill histograms in parallel and write them on file ;  mt101_fillNtuples.CFill n-tuples in distinct workers ;  mt102_readNtuplesFillHistosAndFit.CRead n-tuples in distinct workers, fill histograms, merge them and fit ;  mt201_parallelHistoFill.CParallel fill of a histogram ;  mtbb001_fillHistos.CFill histograms in parallel and write them on file ;  mtbb101_fillNtuples.CFill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.CParallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:133685,authenticat,authentication,133685,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['authenticat'],['authentication']
Security,"ead of passing the data interval and the number of bins, you have to pass an array (single or double precision) of bin edges. When the histogram has n bins, then there are n+1 distinct edges, so the array you pass must be of size n+1.; const Int_t NBINS = 5;; Double_t edges[NBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; // Bin 1 corresponds to range [0.0, 0.2]; // Bin 2 corresponds to range [0.2, 0.3] etc... TH1* h = new TH1D(; /* name */ ""h1"",; /* title */ ""Hist with variable bin width"",; /* number of bins */ NBINS,; /* edge array */ edges; );; Each histogram object contains three TAxis objects: fXaxis , fYaxis, and fZaxis, but for one-dimensional histograms only the X-axis is relevant, while for two-dimensional histograms the X-axis and Y-axis are relevant. See the class TAxis for a description of all the access methods. The bin edges are always stored internally in double precision.; You can examine the actual edges / limits of the histogram bins by accessing the axis parameters, like in the example below:; const Int_t XBINS = 5; const Int_t YBINS = 5;; Double_t xEdges[XBINS + 1] = {0.0, 0.2, 0.3, 0.6, 0.8, 1.0};; Double_t yEdges[YBINS + 1] = {-1.0, -0.4, -0.2, 0.5, 0.7, 1.0};. TH2* h = new TH2D(""h2"", ""h2"", XBINS, xEdges, YBINS, yEdges);; TAxis* xAxis = h->GetXaxis(); TAxis* yAxis = h->GetYaxis();. cout << ""Third bin on Y-dimension: "" << endl; // corresponds to; // [-0.2, 0.5]; cout << ""\tLower edge: "" << yAxis->GetBinLowEdge(3) << endl;; cout << ""\tCenter: "" << yAxis->GetBinCenter(3) << endl;; cout << ""\tUpper edge: "" << yAxis->GetBinUpEdge(3) << endl;; 3.3 Bin Numbering; All histogram types support fixed or variable bin sizes. 2-D histograms may have fixed size bins along X and variable size bins along Y or vice-versa. The functions to fill, manipulate, draw, or access histograms are identical in both cases.; 3.3.1 Convention; For all histogram types: nbins , xlow , xup; Bin# 0 contains the underflow.; Bin# 1 contains the first bin with low-edge ( xlow INCLUDED).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:74704,access,accessing,74704,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessing']
Security,"ead(). bool ROOT::RWebWindowsManager::IsUseHttpThread ; (; ); const. inlineprivate . Returns true if http server use special thread for requests processing (default off) ; Definition at line 60 of file RWebWindowsManager.hxx. ◆ IsUseSenderThreads(). bool ROOT::RWebWindowsManager::IsUseSenderThreads ; (; ); const. inlineprivate . Returns true if extra threads to send data via websockets will be used (default off) ; Definition at line 63 of file RWebWindowsManager.hxx. ◆ SetDeleteCallback(). void ROOT::RWebWindowsManager::SetDeleteCallback ; (; WebWindowDeleteCallback_t ; func). inline . Assign show callback which can catch window showing, used by RBrowser. ; Definition at line 98 of file RWebWindowsManager.hxx. ◆ SetLoopbackMode(). void RWebWindowsManager::SetLoopbackMode ; (; bool ; on = true). static . Set loopback mode for THttpServer used for web widgets By default is on. ; Only local communication via localhost address is possible Disable it only if really necessary - it may open unauthorized access to your application from external nodes!! ; Definition at line 129 of file RWebWindowsManager.cxx. ◆ SetShowCallback(). void ROOT::RWebWindowsManager::SetShowCallback ; (; WebWindowShowCallback_t ; func). inline . Assign show callback which can catch window showing, used by RBrowser. ; Definition at line 95 of file RWebWindowsManager.hxx. ◆ SetUseConnectionKey(). void RWebWindowsManager::SetUseConnectionKey ; (; bool ; on = true). static . Enable or disable usage of connection key (default on) If enabled, each connection (and reconnection) to widget requires unique key Connection key used together with session key to calculate hash sum of each packet send to or from server This protects ROOT http server from anauthorized usage. ; Definition at line 168 of file RWebWindowsManager.cxx. ◆ SetUseSessionKey(). void RWebWindowsManager::SetUseSessionKey ; (; bool ; on = true). static . Enable or disable usage of session key (default on) If enabled, secrete session key used ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html:16236,access,access,16236,doc/master/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindowsManager.html,1,['access'],['access']
Security,"eadInClusterImplvoid ReadInClusterImpl(RClusterIndex clusterIndex, void *to) finalDefinition RField.cxx:1923; ROOT::Experimental::RClassField::kPrefixInheritedstatic constexpr const char * kPrefixInheritedPrefix used in the subfield names generated for base classes.Definition RField.hxx:110; ROOT::Experimental::RClassField::Attachvoid Attach(std::unique_ptr< RFieldBase > child, RSubFieldInfo info)Definition RField.cxx:1874; ROOT::Experimental::RClassField::OnConnectPageSourcevoid OnConnectPageSource() finalCalled by ConnectPageSource() once connected; derived classes may override this as appropriate.Definition RField.cxx:1930; ROOT::Experimental::RClassField::AppendImplstd::size_t AppendImpl(const void *from) finalOperations on values of complex types, e.g.Definition RField.cxx:1907; ROOT::Experimental::RClassField::ReadGlobalImplvoid ReadGlobalImpl(NTupleSize_t globalIndex, void *to) finalDefinition RField.cxx:1916; ROOT::Experimental::RClassField::GetTypeChecksumstd::uint32_t GetTypeChecksum() const finalReturn the current TClass reported checksum of this class. Only valid if kTraitTypeChecksum is set.Definition RField.cxx:1991; ROOT::Experimental::RClassField::CloneImplstd::unique_ptr< RFieldBase > CloneImpl(std::string_view newName) const finalCalled by Clone(), which additionally copies the on-disk ID.Definition RField.cxx:1902; ROOT::Experimental::RClassField::AddReadCallbacksFromIORulesvoid AddReadCallbacksFromIORules(const std::span< const TSchemaRule * > rules, TClass *classp=nullptr)Register post-read callbacks corresponding to a list of ROOT I/O customization rules.Definition RField.cxx:1881; ROOT::Experimental::RClassField::ConstructValuevoid ConstructValue(void *where) const finalConstructs value in a given location of size at least GetValueSize(). Called by the base class' Creat...Definition RField.cxx:1957; ROOT::Experimental::RClassField::GetAlignmentsize_t GetAlignment() const finalAs a rule of thumb, the alignment is equal to the size of the type.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RField_8hxx_source.html:24790,checksum,checksum,24790,doc/master/RField_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RField_8hxx_source.html,1,['checksum'],['checksum']
Security,"eadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSQLFile(); default TSQLFile constructor. TSQLFile(const char* dbname, Option_t* option = ""read"", const char* user = ""user"", const char* pass = ""pass""); Connects to SQL server with provided arguments.; If the constructor fails in any way IsZombie() will; return true. Use IsOpen() to check if the file is (still) open. If option = NEW or CREATE create a ROOT tables in database; if the tables already exists connection is; not opened.; = RECREATE create completely new tables. Any existing tables; will be deleted; = UPDATE open an existing database for writing.; If data base open by other TSQLFile instance for writing,; write access will be rejected; = BREAKLOCK Special case when lock was not correctly released; by TSQLFile instance. This may happen if program crashed when; TSQLFile was open with write access mode.; = READ or OPEN open an existing data base for reading. For more details see comments for TFile::TFile() constructor. For a moment TSQLFile does not support TTree objects and subdirectories. void StartLogFile(const char* fname); start logging of all SQL statements in specified file. void StopLogFile(); close logging file. Bool_t IsMySQL() const; checks, if MySQL database. Bool_t IsOracle() const; checks, if Oracle database. Bool_t IsODBC() const; checks, if ODBC driver used for database connection. void SetUseSuffixes(Bool_t on = kTRUE); enable/disable uasge of suffixes in columns names; can be changed before first object is saved into file. void SetArrayLimit(Int_t limit = 20); Defines maximum number of columns for array representation; If array size bigger than limit, array data will be converted to raw format; This is usefull to prevent tables with very big number of columns; If limit==0, all arrays will be stored in raw format; If limit<0, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:34088,access,access,34088,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,3,['access'],['access']
Security,"eader followed by the (optionally) compressed data; the local; header describes the member, including its file name and compressed; and real sizes. The central directory includes the member details; again, plus allows an extra member comment to be added. The last; member in the central directory is an end marker that can contain; a comment for the whole archive. Both the local header and the; central directory can also carry extra member-specific data; the; data in the local and global parts can be different.; The fact that the archive has a global directory makes it efficient; and allows for only the reading of the desired data, one does not; have to scan through the whole file to find the desired sub-file.; The Zip64 extensions are supported so files larger than 2GB can be; stored in archives larger than 4 GB. Once the archive has been opened, the client can query the members; and read their contents by asking the archive for an offset where; the sub-file starts. The members can be accessed in any order. Function Members (Methods); public:. TZIPFile(); TZIPFile(const char* archive, const char* member, TFile* file); virtual~TZIPFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TZIPFile.html:2435,access,accessed,2435,root/html530/TZIPFile.html,https://root.cern,https://root.cern/root/html530/TZIPFile.html,3,['access'],['accessed']
Security,"eader followed by the (optionally) compressed data; the local; header describes the member, including its file name and compressed; and real sizes. The central directory includes the member details; again, plus allows an extra member comment to be added. The last; member in the central directory is an end marker that can contain; a comment for the whole archive. Both the local header and the; central directory can also carry extra member-specific data; the; data in the local and global parts can be different.; The fact that the archive has a global directory makes it efficient; and allows for only the reading of the desired data, one does not; have to scan through the whole file to find the desired sub-file.; The Zip64 extensions are supported so files larger than 2GB can be; stored in archives larger than 4 GB. Once the archive has been opened, the client can query the members; and read their contents by asking the archive for an offset where; the sub-file starts. The members can be accessed in any order. Function Members (Methods); public:. TZIPMember(); TZIPMember(const char* name); TZIPMember(const TZIPMember& member); virtual~TZIPMember(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TZIPMember.html:2443,access,accessed,2443,root/html530/TZIPMember.html,https://root.cern,https://root.cern/root/html530/TZIPMember.html,3,['access'],['accessed']
Security,"eader followed by the (optionally) compressed data; the local; header describes the member, including its file name and compressed; and real sizes. The central directory includes the member details; again, plus allows an extra member comment to be added. The last; member in the central directory is an end marker that can contain; a comment for the whole archive. Both the local header and the; central directory can also carry extra member-specific data; the; data in the local and global parts can be different.; The fact that the archive has a global directory makes it efficient; and allows for only the reading of the desired data, one does not; have to scan through the whole file to find the desired sub-file.; The Zip64 extensions are supported so files larger than 2GB can be; stored in archives larger than 4 GB. Once the archive has been opened, the client can query the members; and read their contents by asking the archive for an offset where; the sub-file starts. The members can be accessed in any order. Function Members (Methods); public:. virtual~TZIPFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TZIPFile.html:2459,access,accessed,2459,root/html602/TZIPFile.html,https://root.cern,https://root.cern/root/html602/TZIPFile.html,2,['access'],['accessed']
Security,"eader followed by the (optionally) compressed data; the local; header describes the member, including its file name and compressed; and real sizes. The central directory includes the member details; again, plus allows an extra member comment to be added. The last; member in the central directory is an end marker that can contain; a comment for the whole archive. Both the local header and the; central directory can also carry extra member-specific data; the; data in the local and global parts can be different.; The fact that the archive has a global directory makes it efficient; and allows for only the reading of the desired data, one does not; have to scan through the whole file to find the desired sub-file.; The Zip64 extensions are supported so files larger than 2GB can be; stored in archives larger than 4 GB. Once the archive has been opened, the client can query the members; and read their contents by asking the archive for an offset where; the sub-file starts. The members can be accessed in any order. Function Members (Methods); public:. virtual~TZIPMember(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TZIPMember.html:2467,access,accessed,2467,root/html602/TZIPMember.html,https://root.cern,https://root.cern/root/html602/TZIPMember.html,2,['access'],['accessed']
Security,"eader starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t GetSeekFree () const;  ; virtual Long64_t GetSeekInfo () const;  ; virtual Long64_t GetSize () const;  Returns the current file size. ;  ; const TList * GetStreamerInfoCache ();  Returns the cached list of StreamerInfos used in this file. ;  ; virtual TList * GetStreamerInfoList () final;  Read the list of TStreamerInfo objects written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; TClass * IsA () const override;  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; virtual Bool_t IsOpen () const;  Returns kTRUE in case file is open and kFALSE if file is not open. ;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Int_t len);  Read a buffer from the file. ;  ; virtual Bool_t ReadBuffer (char *buf, Long64_t pos, Int_t len);  Read a buffer from the file at the offset 'pos' in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual Bool_t ReadBuffers (char *buf, Long64_t *pos, Int_t *len, Int_t nbuf);  Read the nbuf blocks described in arrays pos and len. ;  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:11247,access,access,11247,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['access'],['access']
Security,"eader starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t GetSeekFree () const;  ; virtual Long64_t GetSeekInfo () const;  ; virtual Long64_t GetSize () const;  Returns the current file size. ;  ; const TList * GetStreamerInfoCache ();  Returns the cached list of StreamerInfos used in this file. ;  ; virtual TList * GetStreamerInfoList () final;  Read the list of TStreamerInfo objects written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; TClass * IsA () const override;  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; virtual Bool_t IsOpen () const;  Returns kTRUE in case file is open and kFALSE if file is not open. ;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:7683,access,access,7683,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['access'],['access']
Security,"eaderValueBase::MarkTreeReaderUnavailablevoid MarkTreeReaderUnavailable()Definition TTreeReaderValue.h:117; ROOT::Internal::TTreeReaderValueBase::fLeafTLeaf * fLeafDefinition TTreeReaderValue.h:133; ROOT::Internal::TTreeReaderValueBase::GetProxyDetail::TBranchProxy * GetProxy() constDefinition TTreeReaderValue.h:115; ROOT::Internal::TTreeReaderValueBase::fHaveStaticClassOffsetsbool fHaveStaticClassOffsetsWhether !fStaticClassOffsets.empty()Definition TTreeReaderValue.h:125; ROOT::Internal::TTreeReaderValueBase::GetAddressvoid * GetAddress()Returns the memory address of the object being read.Definition TTreeReaderValue.cxx:255; ROOT::Internal::TTreeReaderValueBase::EReadStatusEReadStatusDefinition TTreeReaderValue.h:68; ROOT::Internal::TTreeReaderValueBase::kReadError@ kReadErrorProblem reading data.Definition TTreeReaderValue.h:71; ROOT::Internal::TTreeReaderValueBase::kReadSuccess@ kReadSuccessData read okay.Definition TTreeReaderValue.h:69; ROOT::Internal::TTreeReaderValueBase::kReadNothingYet@ kReadNothingYetData now yet accessed.Definition TTreeReaderValue.h:70; ROOT::Internal::TTreeReaderValueBase::GetElementTypeNamestatic std::string GetElementTypeName(const std::type_info &ti)Stringify the template argument.Definition TTreeReaderValue.cxx:217; ROOT::Internal::TTreeReaderValueBase::fSetupStatusESetupStatus fSetupStatusSetup status of this data access.Definition TTreeReaderValue.h:127; ROOT::Internal::TTreeReaderValueBase::IsValidbool IsValid() constReturn true if the branch was setup and read correctly.Definition TTreeReaderValue.h:84; ROOT::Internal::TTreeReaderValueBase::GetDerivedTypeNamevirtual const char * GetDerivedTypeName() const =0; ROOT::Internal::TTreeReaderValueBase::fBranchNameTString fBranchNameName of the branch to read data from.Definition TTreeReaderValue.h:128; ROOT::Internal::TTreeReaderValueBase::ProxyReadTemplateROOT::Internal::TTreeReaderValueBase::EReadStatus ProxyReadTemplate()Try to read the value from the TBranchProxy, returns the sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:15200,access,accessed,15200,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,1,['access'],['accessed']
Security,"eadraw \; sourceClass=""TAxis"" \; source=""fXbins"" \; targetClass=""TAxis"" \; target=""fXbins"" \; version=""[-5]"" \; include=""TAxis.h"" \; code=""\; {\; Float_t * xbins=0; \; Int_t n = buffer.ReadArray( xbins ); \; fXbins.Set( xbins ); \; }"". For REFLEX dictionaries:. <ioread sourceClass=""ClassA""; source=""double m_a; double m_b; double m_c""; version=""[4-5,7,9,12-]""; checksum=""[12345,123456]""; targetClass=""ClassB""; target=""m_x""; embed=""true""; include=""iostream,cstdlib"">; <![CDATA[; m_x = onfile.m_a * onfile.m_b * onfile.m_c;; ]] >; </ioread>. <ioreadraw sourceClass=""TAxis""; source=""fXbins""; targetClass=""TAxis""; target=""fXbins""; version=""[-5]""; include=""TAxis.h"">; <![CDATA[; Float_t *xbins = 0;; Int_t n = buffer.ReadArray( xbins ) ;; fXbins.Set( xbins );; ]] >; </ioreadraw>; The variables in the rules have the following meaning:. sourceClass. The field defines the on-disk class that is the input for the rule. source. A semicolon-separated list of values defining the source class data members that need to be cached and accessible via object proxy when the rule is executed. The values are either the names of the data members or the type-name pairs (separated by a space). If types are specified then the ondisk structure can be generated and used in the code snippet defined by the user. version. A list of versions of the source class that can be an input for this rule. The list has to be enclosed in a square bracket and be a comma-separated list of versions or version ranges. The version is an integer number, whereas the version range is one of the following:; “a-b”: a and b are integers and the expression means all the numbers between and including a and b; “-a”: a is an integer and the expression means all the version numbers smaller than or equal to a; “a-”: a is an integer and the expression means all the version numbers greater than or equal to a. checksum. A list of checksums of the source class that can be an input for this rule. The list has to be enclosed in a square br",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:501126,access,accessible,501126,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessible']
Security,"eads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callbacks instead) and API functions like mg_send_file are not; 165 * available.; 166 * If NO_FILESYSTEM is set, NO_FILES must be set as well.; 167 */; 168#error ""Inconsistent build flags, NO_FILESYSTEMS requires NO_FILES""; 169#endif; 170 ; 171/* DTL -- including winsock2.h works better if lean and mean */; 172#if !defined(WIN32_LEAN_AND_MEAN); 173#define WIN32_LEAN_AND_MEAN; 174#endif; 175 ; 176#if defined(__SYMBIAN32__); 177/* According to https://en.wikipedia.org/wiki/Symbian#History,; 178 * Symbian is no longer maintained since 2014-01-01.; 179 * Support for Symbian has been removed from CivetWeb; 180 */; 181#error ""Symbian is no longer maintained. CivetWeb no longer supports Symbian.""; 182#endif /* __SYMBIAN32__ */; 183 ; 184#if defined(__ZEPHYR__); 185#include <time.h>; 186 ; 187#include <ctype.h>; 188#include <net/socket.h>; 189#include <posix/pthread",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:6884,access,access,6884,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['access'],['access']
Security,"eamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7086; TClass::GetImplFileLineShort_t GetImplFileLine() constDefinition TClass.h:457; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4384; TClass::fRuntimePropertiesstd::atomic< UChar_t > fRuntimePropertiesDefinition TClass.h:273; TClass::EStateEStateDefinition TClass.h:121; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kLoaded@ kLoadedDefinition TClass.h:130; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7193; TClass::GetBaseClassOffsetRecurseInt_t GetBaseClassOffsetRecurse(const TClass *toBase)Return data member offset to the base class ""cl"".Definition TClass.cxx:2705; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7463; TClass::LoadClassDefaultstatic TClass * LoadClassDefault(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5771; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindClassOrBaseMethodWithIdTMethod * FindClassOrBaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4440; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:337661,checksum,checksum,337661,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['checksum'],['checksum']
Security,"eamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::GetImplFileLineShort_t GetImplFileLine() constDefinition TClass.h:457; TClass::GetMethodAllAnyTMethod * GetMethodAllAny(const char *method)Return pointer to method without looking at parameters.Definition TClass.cxx:4451; TClass::fRuntimePropertiesstd::atomic< UChar_t > fRuntimePropertiesDefinition TClass.h:273; TClass::EStateEStateDefinition TClass.h:121; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::kHasTClassInit@ kHasTClassInitDefinition TClass.h:127; TClass::kEmulated@ kEmulatedDefinition TClass.h:125; TClass::kNoInfo@ kNoInfoDefinition TClass.h:122; TClass::kLoaded@ kLoadedDefinition TClass.h:130; TClass::kForwardDeclared@ kForwardDeclaredDefinition TClass.h:124; TClass::kNamespaceForMeta@ kNamespaceForMetaDefinition TClass.h:131; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::GetBaseClassOffsetRecurseInt_t GetBaseClassOffsetRecurse(const TClass *toBase)Return data member offset to the base class ""cl"".Definition TClass.cxx:2772; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7530; TClass::LoadClassDefaultstatic TClass * LoadClassDefault(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5838; TClass::SetClassSizevoid SetClassSize(Int_t sizof)Definition TClass.h:307; TClass::FindClassOrBaseMethodWithIdTMethod * FindClassOrBaseMethodWithId(DeclId_t faddr)Find a method with decl id in this class or its bases.Definition TClass.cxx:4507; TClass::StreamerExternalstatic void StreamerExternal(const TClass *pThis, void *object, TBuffer &b, const TClass *onfile_class)There is special stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:340299,checksum,checksum,340299,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['checksum'],['checksum']
Security,"eamerInfo object writing/reading the buffer. ;  ; InfoList_t fInfoStack;  Stack of pointers to the TStreamerInfos. ;  ;  Protected Attributes inherited from TBufferIO; TExMap * fClassMap {nullptr};  Map containing object,class pairs for reading. ;  ; Int_t fDisplacement {0};  Value to be added to the map offsets. ;  ; TExMap * fMap {nullptr};  Map containing object,offset pairs for reading/writing. ;  ; Int_t fMapCount {0};  Number of objects or classes in map. ;  ; Int_t fMapSize {0};  Default size of map. ;  ; UShort_t fPidOffset {0};  Offset to be added to the pid index in this key/buffer. ;  ;  Protected Attributes inherited from TBuffer; char * fBufCur;  ; char * fBuffer;  ; char * fBufMax;  ; Int_t fBufSize;  ; CacheList_t fCacheStack;  Realloc function to be used when extending the buffer. ;  ; Bool_t fMode;  ; TObject * fParent;  ; ReAllocCharFun_t fReAllocFunc;  ; Int_t fVersion;  . Additional Inherited Members;  Static Protected Member Functions inherited from TBufferIO; static R__ALWAYS_INLINE ULong_t Void_Hash (const void *ptr);  Return hash value for provided object. ;  ;  Static Protected Attributes inherited from TBufferIO; static Int_t fgMapSize = kMapSize;  Default map size for all TBuffer objects. ;  . #include <TBufferFile.h>. Inheritance diagram for TBufferFile:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ InfoList_t. typedef std::vector<TStreamerInfo*> TBufferFile::InfoList_t. protected . Definition at line 50 of file TBufferFile.h. Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkStreamedMemberWise . Definition at line 69 of file TBufferFile.h. Constructor & Destructor Documentation. ◆ TBufferFile() [1/5]. TBufferFile::TBufferFile ; (; ). inlineprotected . Definition at line 56 of file TBufferFile.h. ◆ TBufferFile() [2/5]. TBufferFile::TBufferFile ; (; const TBufferFile & ; ). protecteddelete . not implemented . ◆ TBufferFile() [3/5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferFile.html:37357,hash,hash,37357,doc/master/classTBufferFile.html,https://root.cern,https://root.cern/doc/master/classTBufferFile.html,1,['hash'],['hash']
Security,"ean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxyRooSimultaneous::_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html:41874,access,access,41874,root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__HistFactorySimultaneous.html,1,['access'],['access']
Security,"ean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooPolyVar.html:33355,access,access,33355,root/html534/RooPolyVar.html,https://root.cern,https://root.cern/root/html534/RooPolyVar.html,1,['access'],['access']
Security,"ean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TMatrixDSym_cov; TMatrixDSym_covI; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Double_t_det; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; map<int,GenData>_genCache!; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooListProxy_mu; TVectorD_muVec! Do not persist; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMultiVarGaussian.html:39368,access,access,39368,root/html532/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html532/RooMultiVarGaussian.html,1,['access'],['access']
Security,"eap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfSize; TExMap::Assoc_t*fTable; Int_tfTally. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TExMap(Int_t mapSize = 100); Create a TExMap. TExMap(const TExMap& map); Copy constructor. TExMap& operator=(const TExMap& ); Assignement operator. ~TExMap(); Delete TExMap. void Add(ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique. void AddAt(UInt_t slot, ULong64_t hash, Long64_t key, Long64_t value); Add an (key,value) pair to the table. The key should be unique.; If the 'slot' is open, use it to store the value,; otherwise revert to Add(hash,key,value); This is usually used in conjuction with GetValue wiht 3 parameters:; if ((idx = (ULong64_t)fMap->GetValue(hash, key, slot)) != 0) {. } else {; fMap->AddAt(slot,hash,key,value);; }. Long64_t & operator()(ULong64_t hash, Long64_t key); Return a reference to the value belonging to the key with the; specified hash value. If the key does not exist it will be added.; NOTE: the reference will be invalidated an Expand() triggered by; an Add() or another operator() call. void Delete(Option_t* opt = """"); Delete all entries stored in the TExMap. Long64_t GetValue(ULong64_t hash, Long64_t key); Return the value belonging to specified key and hash value. If key not; found return 0. Long64_t GetValue(ULong64_t hash, Long64_t key, UInt_t& slot); Return the value belonging to specified key and hash value. If key not; found return 0.; In 'slot', return the index of the slot used or the first empty slot.; (to be used with AddAt). void Remove(ULong64_t hash, Long64_t key); Remove entry with specified key from the TExMap. Int_t FindElement(ULong64_t hash, Long64_t key); Find an entry with specified hash and key in the TExMap.; Returns the slot of the key or the next empty slot. void FixCollisions(Int_t index); Rehash the map in case an entry has bee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TExMap.html:6708,hash,hash,6708,root/html528/TExMap.html,https://root.cern,https://root.cern/root/html528/TExMap.html,8,['hash'],['hash']
Security,"ear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the class being proxied. ;  ; Method fNext;  Container accessors: generic iteration: next. ;  ; TClass * fOnFileClass;  On file class. ;  ; Bool_t fPointers;  Flag to indicate if containee has pointers (key or value) ;  ; Proxies_t fProxyKept;  Optimization: Keep proxies once they were created. ;  ; Proxies_t fProxyList;  Stack of recursive proxies. ;  ; TObjArray * fReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) ;  ; Sizing_t fResize;  Container accessors: resize container. ;  ; Method fSize;  Container accessors: size of container. ;  ; Staged_t fStaged;  Optimization: Keep staged array once they were created. ;  ; int fSTL_type;  STL container type. ;  ; Info_t fTypeinfo;  Type information. ;  ; Value * fVal;  Descriptor of the Value_type. ;  ; int fValDiff;  Offset between two consecutive value_types (memory layout). ;  ; int fValOffset;  Offset from key to value (in maps) ;  ; std::atomic< Value * > fValue;  Descriptor of the container value type. ;  ; TStreamerInfoActions::TActionSequence * fWriteMemberWi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:12273,access,accessors,12273,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,10,['access'],['accessors']
Security,"earching purposes); TStringfTargetTarget data mamber string; TObjArray*fTargetVect! Target data member vector (for searching purposes); TStringfVersionSource version string; vector<std::pair<Int_t,Int_t> >*fVersionVect! Source version vector (for searching purposes). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRule(); Default Constructor. ~TSchemaRule(); Destructor. TSchemaRule(const ROOT::TSchemaRule& rhs); Copy Constructor. void ls(Option_t* option = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump(). Bool_t SetVersion(const TString& version); Set the version string - returns kFALSE if the format is incorrect. Bool_t TestVersion(Int_t version) const; Check if given version number is defined in this rule. Bool_t SetChecksum(const TString& checksum); Set the checksum string - returns kFALSE if the format is incorrect. Bool_t TestChecksum(UInt_t checksum) const; Check if given checksum is defined in this rule. void SetSourceClass(const TString& classname); Set the source class of this rule (i.e. the onfile class). TString GetSourceClass() const; Set the source class of this rule (i.e. the onfile class). void SetTarget(const TString& target); Set the target class of this rule (i.e. the in memory class). const TObjArray* GetTarget() const; Get the target class of this rule (i.e. the in memory class). void SetSource(const TString& source); Set the list of source members. This should be in the form of a declaration:; Int_t fOldMember; TNamed fName;. const TObjArray* GetSource() const; Get the list of source members as a TObjArray of TNamed object,; with the name being the member name and the title being its type. void SetInclude(const TString& include); Set the comma separated list of header files to include to be able; to compile this rule. const TObjArray* GetInclude() const; Return the list of header files to include to be able to; compile this r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__TSchemaRule.html:8214,checksum,checksum,8214,root/html526/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html526/ROOT__TSchemaRule.html,2,['checksum'],['checksum']
Security,"eate a new file and open it for writing,; if the file already exists the file is; not opened.; = RECREATE create a new file, if the file already; exists it will be overwritten.; = 2xoo create a new file with specified xml settings; for more details see TXMLSetup class; = UPDATE open an existing file for writing.; if no file exists, it is created.; = READ open an existing file for reading. For more details see comments for TFile::TFile() constructor. For a moment TXMLFile does not support TTree objects and subdirectories. void InitXmlFile(Bool_t create); initialize xml file and correspondent structures; identical to TFile::Init() function. void Close(Option_t* option = """"); Close a XML file; For more comments see TFile::Close() function. ~TXMLFile(); destructor of TXMLFile object. void operator=(const TXMLFile& ); make private to exclude copy operator. Bool_t IsOpen() const; return kTRUE if file is opened and can be accessed. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; See TFile::Open() for details. TKey* CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); create XML key, which will store object in xml structures. TKey* CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); create XML key, which will store object in xml structures. void ProduceFileNames(const char* filename, TString& fname, TString& dtdname); function produces pair of xml and dtd file names. void SaveToFile(); Saves xml structures to file; xml elements are kept in list of TKeyXML objects; When saving, all this elements are linked to root xml node; In the end StreamerInfo structures are added; After xml document is saved, all nodes will be unlinked from root node; and kept in memory.; Only Close() or destructor relase memory, used by xml structures. void CombineNodesTree(TDirectory* dir, XMLNodePointer_t topnode, Bool_t dolink); Connect/disconnect all file nodes to single tree b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLFile.html:27154,access,access,27154,root/html528/TXMLFile.html,https://root.cern,https://root.cern/root/html528/TXMLFile.html,6,['access'],['access']
Security,"eb web server with http port 8080; serv->CreateEngine(""http:8080"");; serv->CreateEngine(""civetweb:8080"");; serv->CreateEngine("":8080"");; // creates fastcgi server with port 9000; serv->CreateEngine(""fastcgi:9000"");; One could apply additional parameters, using URL syntax: serv->CreateEngine(""http:8080?thrds=10""); . Definition at line 419 of file THttpServer.cxx. ◆ CreateItem(). Bool_t THttpServer::CreateItem ; (; const char * ; fullname, . const char * ; title . ). Create item in sniffer. ; Definition at line 1455 of file THttpServer.cxx. ◆ CreateServerThread(). void THttpServer::CreateServerThread ; (; ). Creates special thread to process all requests, directed to http server. ; Should be used with care - only dedicated instance of TRootSniffer is allowed By default THttpServer allows to access global lists pointers gROOT or gFile. To be on the safe side, all kind of such access performed from the main thread. Therefore usage of specialized thread means that no any global pointers will be accessible by THttpServer ; Definition at line 515 of file THttpServer.cxx. ◆ DeclFileName(). static const char * THttpServer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 198 of file THttpServer.h. ◆ ExecuteHttp(). Bool_t THttpServer::ExecuteHttp ; (; std::shared_ptr< THttpCallArg > ; arg). Execute HTTP request. ; Executes http request, specified in THttpCallArg structure.; Method can be called from any thread Actual execution will be done in main ROOT thread, where analysis code is running. ; Definition at line 642 of file THttpServer.cxx. ◆ ExecuteWS(). Bool_t THttpServer::ExecuteWS ; (; std::shared_ptr< THttpCallArg > & ; arg, . Bool_t ; external_thrd = kFALSE, . Bool_t ; wait_process = kFALSE . ). Execute WS request. ; Execute WS related operation. ; Definition at line 1299 of file THttpServer.cxx. ◆ FindWS(). std::shared_ptr< THttpWSHandler > THttpServer::FindWS ; (; const char * ; name). Find web-socket ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:23872,access,accessible,23872,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['access'],['accessible']
Security,"echanism used by the S3; protocol. The GET request must contain an ""Authorization"" header with; the signature of the request, generated using the user's secret access; key. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf). void ProcessHttpHeader(const TString& headerLine); This method is called by the super-class TWebFile when a HTTP header; for this file is retrieved. We scan the 'Server' header to detect the; type of S3 server this file is hosted on and to determine if it is; known to support multi-range HTTP GET requests. Some S3 servers (for; instance Amazon's) do not support that feature and when they; receive a multi-range request they sent back the whole file contents.; For this class, if the server do not support multirange requests; we issue multiple single-range requests instead. Bool_t GetCredentialsFromEnv(const char* accessKeyEnv, const char* secretKeyEnv, TString& outAccessKey, TString& outSecretKey); Sets the access and secret keys from the environmental variables, if; they are both set. TS3WebFile(). void SetAccessKey(const TString& accessKey); Modifiers of data members (to be used mainly by subclasses). { fS3Request.SetAccessKey(accessKey); }. void SetSecretKey(const TString& secretKey); { fS3Request.SetSecretKey(secretKey); }. virtual ~TS3WebFile(); {}. const TString& GetAccessKey() const; Selectors. { return fS3Request.GetAccessKey(); }. const TString& GetSecretKey() const; { return fS3Request.GetSecretKey(); }. const TString& GetBucket() const; { return fS3Request.GetBucket(); }. const TString& GetObjectKey() const; { return fS3Request.GetObjectKey(); }. const TUrl& GetUrl() const; { return fUrl; }. » Author: Fabio Hernandez 22/01/2013 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id: TS3WebFile.h$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:31682,access,accessKey,31682,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,2,['access'],['accessKey']
Security,"ecified by filename. ;  ; void SetNpx (Int_t n);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this met",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1TSpline1.html:2941,hash,hash,2941,doc/master/classTMVA_1_1TSpline1.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1TSpline1.html,2,['hash'],['hash']
Security,"ecified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. The preferred interface to this; constructor is via TFile::Open(). TWebFile(TUrl url, Option_t* opt = """"); Create a Web file object. A web file is the same as a read-only; TFile except that it is being read via a HTTP server. Make sure url; is a valid TUrl object.; The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell; variable. The proxy can be specified as (in sh, or equivalent csh):; export http_proxy=http://pcsalo.cern.ch:3128; The proxy can also be specified via the static method TWebFile::SetProxy().; Basic authentication (AuthType Basic) is supported. The user name and; passwd can be specified in the url like this:; http://username:mypasswd@pcsalo.cern.ch/files/aap.root; If the file specified in the URL does not exist or is not accessible; the kZombie bit will be set in the TWebFile object. Use IsZombie(); to see if the file is accessible. ~TWebFile(); Cleanup. void Init(Bool_t readHeadOnly); Initialize a TWebFile object. void SetMsgReadBuffer10(const char* redirectLocation = 0, Bool_t tempRedirect = kFALSE); Set GET command for use by ReadBuffer(s)10(), handle redirection if; needed. Give full URL so Apache's virtual hosts solution works. void CheckProxy(); Check if shell var ""http_proxy"" has been set and should be used. Bool_t IsOpen() const; A TWebFile that has been correctly constructed is always considered open. Int_t ReOpen(Option_t* mode); Reopen a file with a different access mode, like from READ to; UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the; mode argument can be either ""READ"" or ""UPDATE"". The method returns; 0 in case the mode was successfully modified, 1 in case the mode; did not change (was already as requested or wrong input arguments); and -1 in case of failure, in which case the file cannot be used; anymore. A TWebFile cannot be reopened in update mode. Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TWebFile.html:24529,access,accessible,24529,root/html528/TWebFile.html,https://root.cern,https://root.cern/root/html528/TWebFile.html,6,['access'],['accessible']
Security,"ecisionTreeNode::SetLeft ; (; Node * ; l). inlinevirtual . Reimplemented from TMVA::Node.; Definition at line 288 of file DecisionTreeNode.h. ◆ SetNBkgEvents(). void TMVA::DecisionTreeNode::SetNBkgEvents ; (; Float_t ; b). inline . set the sum of the backgr weights in the node, if traininfo defined ; Definition at line 188 of file DecisionTreeNode.h. ◆ SetNBkgEvents_unboosted(). void TMVA::DecisionTreeNode::SetNBkgEvents_unboosted ; (; Float_t ; b). inline . set the sum of the unboosted backgr events in the node, if traininfo defined ; Definition at line 206 of file DecisionTreeNode.h. ◆ SetNBkgEvents_unweighted(). void TMVA::DecisionTreeNode::SetNBkgEvents_unweighted ; (; Float_t ; b). inline . set the sum of the unweighted backgr events in the node, if traininfo defined ; Definition at line 197 of file DecisionTreeNode.h. ◆ SetNBValidation(). void TMVA::DecisionTreeNode::SetNBValidation ; (; Double_t ; b). inline . set number of background events from the pruning validation sample, if traininfo defined ; Definition at line 321 of file DecisionTreeNode.h. ◆ SetNEvents(). void TMVA::DecisionTreeNode::SetNEvents ; (; Float_t ; nev). inline . set the number of events that entered the node (during training), if traininfo defined ; Definition at line 191 of file DecisionTreeNode.h. ◆ SetNEvents_unboosted(). void TMVA::DecisionTreeNode::SetNEvents_unboosted ; (; Float_t ; nev). inline . set the number of unboosted events that entered the node (during training), if traininfo defined ; Definition at line 209 of file DecisionTreeNode.h. ◆ SetNEvents_unweighted(). void TMVA::DecisionTreeNode::SetNEvents_unweighted ; (; Float_t ; nev). inline . set the number of unweighted events that entered the node (during training), if traininfo defined ; Definition at line 200 of file DecisionTreeNode.h. ◆ SetNFisherCoeff(). void TMVA::DecisionTreeNode::SetNFisherCoeff ; (; Int_t ; nvars). inline . Definition at line 134 of file DecisionTreeNode.h. ◆ SetNodeR(). void TMVA::DecisionTreeNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html:31926,validat,validation,31926,doc/master/classTMVA_1_1DecisionTreeNode.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html,1,['validat'],['validation']
Security,"eclval<ForeignLorentzVector>().x(); 141 + std::declval<ForeignLorentzVector>().y(); 142 + std::declval<ForeignLorentzVector>().z(); 143 + std::declval<ForeignLorentzVector>().t())>; 144 LorentzVector & operator = ( const ForeignLorentzVector & v) {; 145 SetXYZT( v.x(), v.y(), v.z(), v.t() );; 146 return *this;; 147 }; 148 ; 149#ifdef LATER; 150 /**; 151 assign from a generic linear algebra vector implementing operator []; 152 and with a size of at least 4; 153 In this case v[0] is the first data member; 154 ( Px for a PxPyPzE4D base); 155 \param v LA vector; 156 \param index0 index of first vector element (Px); 157 */; 158 template< class LAVector >; 159 LorentzVector & AssignFrom(const LAVector & v, size_t index0=0 ) {; 160 fCoordinates.SetCoordinates( v[index0], v[index0+1], v[index0+2], v[index0+3] );; 161 return *this;; 162 }; 163#endif; 164 ; 165 // ------ Set, Get, and access coordinate data ------; 166 ; 167 /**; 168 Retrieve a const reference to the coordinates object; 169 */; 170 const CoordSystem & Coordinates() const {; 171 return fCoordinates;; 172 }; 173 ; 174 /**; 175 Set internal data based on an array of 4 Scalar numbers; 176 */; 177 LorentzVector<CoordSystem>& SetCoordinates( const Scalar src[] ) {; 178 fCoordinates.SetCoordinates(src);; 179 return *this;; 180 }; 181 ; 182 /**; 183 Set internal data based on 4 Scalar numbers; 184 */; 185 LorentzVector<CoordSystem>& SetCoordinates( Scalar a, Scalar b, Scalar c, Scalar d ) {; 186 fCoordinates.SetCoordinates(a, b, c, d);; 187 return *this;; 188 }; 189 ; 190 /**; 191 Set internal data based on 4 Scalars at *begin to *end; 192 */; 193 template< class IT >; 194 LorentzVector<CoordSystem>& SetCoordinates( IT begin, IT end ) {; 195 IT a = begin; IT b = ++begin; IT c = ++begin; IT d = ++begin;; 196 (void)end;; 197 assert (++begin==end);; 198 SetCoordinates (*a,*b,*c,*d);; 199 return *this;; 200 }; 201 ; 202 /**; 203 get internal data into 4 Scalar numbers; 204 */; 205 void GetCoordinates( Scalar& a, Scalar& b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html:6078,access,access,6078,doc/master/GenVector_2LorentzVector_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2LorentzVector_8h_source.html,1,['access'],['access']
Security,ecorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to a TObject; TRefArray An array of references to TObjects; TRefArrayIter Object array iterator; TRefCnt ; TRefTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRootSniffer Sniffer of ROOT objects; TRootSnifferScanRec Scan record for objects sniffer; TRootSnifferStore structure for results store of objects sniffer; TRootSnifferStoreJson json results store of objects sniffer; TRootSnifferStoreXml xml results store of objects sniffer; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TS3HTTPRequest Create generic HTTP request for Amazon S3 and Google Storage services; TS3WebFile Read a ROOT file from a S3 server; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:129074,authenticat,authentication,129074,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['authenticat'],['authentication']
Security,"ect * THashList::FindObject ; (; const char * ; name); const. overridevirtual . Find object using its name. ; Uses the hash value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from TCollection.; Reimplemented in TListOfEnums, TListOfDataMembers, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TListOfFunctionTemplates.; Definition at line 262 of file THashList.cxx. ◆ FindObject() [2/2]. TObject * THashList::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 272 of file THashList.cxx. ◆ GetListForObject() [1/2]. const TList * THashList::GetListForObject ; (; const char * ; name); const. Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ; Definition at line 283 of file THashList.cxx. ◆ GetListForObject() [2/2]. const TList * THashList::GetListForObject ; (; const TObject * ; obj); const. Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ; Definition at line 294 of file THashList.cxx. ◆ IsA(). TClass * THashList::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TCollection.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 72 of file THashList.h. ◆ operator=(). THashList & THashList::operator= ; (; const THashList & ; ). privatedelete . ◆ RecursiveRemove(). void THashList::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:30431,hash,hash,30431,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['hash'],['hash']
Security,"ect *obj, Bool_t autoadd=kTRUE)Clone an object.Definition TDirectory.cxx:364; TDirectory::IsBuiltBool_t IsBuilt() constDefinition TDirectory.h:234; TDirectory::Removevirtual TObject * Remove(TObject *)Remove an object from the in-memory list.Definition TDirectory.cxx:1212; TDirectory::RegisterContextvoid RegisterContext(TContext *ctxt)Register a TContext pointing to this TDirectory object.Definition TDirectory.cxx:1365; TDirectory::fListTList * fListDefinition TDirectory.h:142; TDirectory::Paintvoid Paint(Option_t *option="""") overridePaint all objects in the directory.Definition TDirectory.cxx:1179; TDirectory::FindObjectAnyvirtual TObject * FindObjectAny(const char *name) constFind object by name in the list of memory objects of the current directory or its sub-directories.Definition TDirectory.cxx:796; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TIterDefinition TCollection.h:235; TList::Clearvoid Clear(Option_t *option="""") overrideRemove all objects from the list.Definition TList.cxx:400; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRemove object from this collection and recursively remove the object from all other objects (and coll...Definition TList.cxx:762; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::RemoveTObject * Remove(TObject *obj) overrideRemove object from the list.Definition TList.cxx:820; TList::FirstLinkvirtual TObjLink * FirstLink() constDefinition TList.h:104; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TMethodEach ROOT class (see TClass) has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:67535,hash,hash,67535,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['hash'],['hash']
Security,"ect * ; parent). virtual . Find the action to be executed in the dictionary of the parent class and store the corresponding exec number into fBits. ; This function searches a data member in the class of parent with an offset corresponding to this. If a comment ""TEXEC:"" is found in the comment field of the data member, the function stores the exec identifier of the exec statement following this keyword. ; Definition at line 449 of file TRef.cxx. ◆ SetObject(). void TRef::SetObject ; (; TObject * ; obj). static . static Obsolete function kept for back compatibility. ; In the near future will print a Warning, then will be deleted. ; Definition at line 466 of file TRef.cxx. ◆ SetStaticObject(). void TRef::SetStaticObject ; (; TObject * ; obj). static . Static function to set the object found on the Action on Demand function. ; This function may be called by the user in the function called when a ""EXEC:"" keyword is specified in the data member field of the TRef. The function can get access to the dereferencing TRef (i.e. this)using the static function GetStaticObject(). ; Definition at line 478 of file TRef.cxx. ◆ Streamer(). void TRef::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TRef. ; Reimplemented from TObject.; Definition at line 486 of file TRef.cxx. ◆ StreamerNVirtual(). void TRef::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 64 of file TRef.h. Friends And Related Symbol Documentation. ◆ operator!=. Bool_t operator!= ; (; const TRef & ; r1, . const TRef & ; r2 . ). friend . Return kTRUE if r1 and r2 do not point to the same object. ; Definition at line 329 of file TRef.cxx. ◆ operator==. Bool_t operator== ; (; const TRef & ; r1, . const TRef & ; r2 . ). friend . Return kTRUE if r1 and r2 point to the same object. ; Definition at line 320 of file TRef.cxx. Member Data Documentation. ◆ fgExecs. TObjArray * TRef::fgExecs = nullptr. staticprotected . Pointer to ProcessID when TRef was writ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRef.html:25797,access,access,25797,doc/master/classTRef.html,https://root.cern,https://root.cern/doc/master/classTRef.html,1,['access'],['access']
Security,"ect event; 160 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 161 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 162 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 163 std::thread fWindowThrd; ///<! special thread for that window; 164 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 165 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 166 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 167 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 168 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 169 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 170 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 171 int fProtocolCnt{-1}; ///<! counter for protocol recording; 172 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 173 std::string fProtocolPrefix; ///<! prefix for created files names; 174 std::string fProtocol; ///<! protocol; 175 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 176 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 177 ; 178 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 179 ; 180 bool ProcessWS(THttpCallArg &arg);; 181 ; 182 void CompleteWSSend(unsigned wsid);; 183 ; 184 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 185 ; 186 /// Find connection with specified websocket id; 187 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 188 ; 189 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 190 ; 191 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:9003,access,accessible,9003,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['access'],['accessible']
Security,"ect event; 163 std::thread::id fCallbacksThrdId; ///<! thread id where callbacks should be invoked; 164 bool fCallbacksThrdIdSet{false}; ///<! flag indicating that thread id is assigned; 165 bool fHasWindowThrd{false}; ///<! indicate if special window thread was started; 166 std::thread fWindowThrd; ///<! special thread for that window; 167 std::queue<QueueEntry> fInputQueue; ///<! input queue for all callbacks; 168 std::mutex fInputQueueMutex; ///<! mutex to protect input queue; 169 unsigned fWidth{0}, fHeight{0}; ///<! initial window width and height when displayed, zeros are ignored; 170 int fX{-1}, fY{-1}; ///<! initial window position, -1 ignored; 171 float fOperationTmout{50.}; ///<! timeout in seconds to perform synchronous operation, default 50s; 172 std::string fClientVersion; ///<! configured client version, used as prefix in scripts URL; 173 std::string fProtocolFileName; ///<! local file where communication protocol will be written; 174 int fProtocolCnt{-1}; ///<! counter for protocol recording; 175 unsigned fProtocolConnId{0}; ///<! connection id, which is used for writing protocol; 176 std::string fProtocolPrefix; ///<! prefix for created files names; 177 std::string fProtocol; ///<! protocol; 178 std::string fUserArgs; ///<! arbitrary JSON code, which is accessible via conn.getUserArgs() method; 179 std::shared_ptr<void> fClearOnClose; ///<! entry which is cleared when last connection is closed; 180 ; 181 std::shared_ptr<RWebWindowWSHandler> CreateWSHandler(std::shared_ptr<RWebWindowsManager> mgr, unsigned id, double tmout);; 182 ; 183 bool ProcessWS(THttpCallArg &arg);; 184 ; 185 void CompleteWSSend(unsigned wsid);; 186 ; 187 ConnectionsList_t GetWindowConnections(unsigned connid = 0, bool only_active = false) const;; 188 ; 189 /// Find connection with specified websocket id; 190 std::shared_ptr<WebConn> FindConnection(unsigned wsid);; 191 ; 192 std::shared_ptr<WebConn> RemoveConnection(unsigned wsid);; 193 ; 194 bool _CanTrustIn(std::shared_ptr<WebC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:9154,access,accessible,9154,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['access'],['accessible']
Security,"ect from the list. ;  ; TObject * Remove (TObjLink *lnk) override;  Remove object via its objlink from the list. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from THashList;  THashList (Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  Create a THashList object. ;  ;  THashList (TObject *parent, Int_t capacity=TCollection::kInitHashTableCapacity, Int_t rehash=0);  For backward compatibility only. Use other ctor. ;  ; virtual ~THashList ();  Delete a hashlist. ;  ; Float_t AverageCollisions () const;  Return the average collision rate. ;  ; const TList * GetListForObject (const char *name) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the THashTable's list (bucket) in which obj can be found based on its hash; see THashTable::GetListForObject(). ;  ; void Rehash (Int_t newCapacity);  Rehash the hashlist. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; bool UseRWLock (Bool_t enable=true) override;  Set this collection to use a RW lock upon access, making it thread safe. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void Add (TObject *obj) override;  ; virtual void Add (TObject *obj, Option_t *opt);  ; TObject * After (const TObject *obj) const override;  Returns the object after object obj. ;  ; TObject * At (Int_t idx) const override;  Returns the object at position idx. Returns 0 if idx is out of range. ;  ; TObject * Before (const TObject *obj) const override;  Returns the object before object obj. ;  ; TObject * First () const override;  Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfEnums.html:4645,hash,hash,4645,doc/master/classTListOfEnums.html,https://root.cern,https://root.cern/doc/master/classTListOfEnums.html,1,['hash'],['hash']
Security,"ect it is pointing to:; 1876/// HepMC::GenVertex m_event attributes=NotOwner; 1877///; 1878/// Semantic of the tags:; 1879/// - type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; 1880/// - sourceClass : the name of the class as it is on the rule file; 1881/// - targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; 1882/// - source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; 1883/// - oldtype: in the short form only, indicates the type on disk of the data member.; 1884/// - target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; 1885/// - attributes : list of possible qualifiers among: Owner, NotOwner; 1886/// - version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; 1887/// - checksum : comma delimited list of the checksums of the class layout that this rule applies to.; 1888/// - code={...} : code to be executed for the rule or name of the function implementing it.; 1889 ; 1890Bool_t TClass::AddRule( const char *rule ); 1891{; 1892 ROOT::TSchemaRule *ruleobj = new ROOT::TSchemaRule();; 1893 if (! ruleobj->SetFromRule( rule ) ) {; 1894 delete ruleobj;; 1895 return kFALSE;; 1896 }; 1897 ; 1898 R__LOCKGUARD(gInterpreterMutex);; 1899 ; 1900 TClass *cl = TClass::GetClass( ruleobj->GetTargetClass() );; 1901 if (!cl) {; 1902 // Create an empty emulated class for now.; 1903 cl = gInterpreter->GenerateTClass(ruleobj->GetTargetClass(), /* emulation = */ kTRUE, /*silent = */ kTRUE);; 1904 }; 1905 ROOT::Detail::TSchemaRuleSet* rset = cl->GetSchemaRules( kTRUE );; 1906 ; 1907 TString errmsg;; 1908 if( !rset->AddRule( ruleobj, ROOT::Detail::TSchemaRuleSet::kCheckConflict, &errmsg ) ) {; 1909 ::Warning( ""TClass::AddRule"", ""The rule for class: \""%s\"": version, \""%s\"" and data members: \""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:71208,checksum,checksum,71208,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['checksum'],"['checksum', 'checksums']"
Security,"ect it is pointing to:; 1943/// HepMC::GenVertex m_event attributes=NotOwner; 1944///; 1945/// Semantic of the tags:; 1946/// - type : the type of the rule, valid values: Read, ReadRaw, Write, WriteRaw, the default is 'Read'.; 1947/// - sourceClass : the name of the class as it is on the rule file; 1948/// - targetClass : the name of the class as it is in the current code ; defaults to the value of sourceClass; 1949/// - source : the types and names of the data members from the class on file that are needed, the list is separated by semi-colons ';'; 1950/// - oldtype: in the short form only, indicates the type on disk of the data member.; 1951/// - target : the names of the data members updated by this rule, the list is separated by semi-colons ';'; 1952/// - attributes : list of possible qualifiers among: Owner, NotOwner; 1953/// - version : list of the version of the class layout that this rule applies to. The syntax can be [1,4,5] or [2-] or [1-3] or [-3]; 1954/// - checksum : comma delimited list of the checksums of the class layout that this rule applies to.; 1955/// - code={...} : code to be executed for the rule or name of the function implementing it.; 1956 ; 1957Bool_t TClass::AddRule( const char *rule ); 1958{; 1959 ROOT::TSchemaRule *ruleobj = new ROOT::TSchemaRule();; 1960 if (! ruleobj->SetFromRule( rule ) ) {; 1961 delete ruleobj;; 1962 return kFALSE;; 1963 }; 1964 ; 1965 R__LOCKGUARD(gInterpreterMutex);; 1966 ; 1967 TClass *cl = TClass::GetClass( ruleobj->GetTargetClass() );; 1968 if (!cl) {; 1969 // Create an empty emulated class for now.; 1970 cl = gInterpreter->GenerateTClass(ruleobj->GetTargetClass(), /* emulation = */ kTRUE, /*silent = */ kTRUE);; 1971 }; 1972 ROOT::Detail::TSchemaRuleSet* rset = cl->GetSchemaRules( kTRUE );; 1973 ; 1974 TString errmsg;; 1975 if( !rset->AddRule( ruleobj, ROOT::Detail::TSchemaRuleSet::kCheckConflict, &errmsg ) ) {; 1976 ::Warning( ""TClass::AddRule"", ""The rule for class: \""%s\"": version, \""%s\"" and data members: \""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:73959,checksum,checksum,73959,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['checksum'],"['checksum', 'checksums']"
Security,"ect of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; RooWorkspace & ws ();  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output buffer. ;  ; const char * GetName () const override;  Returns name of object. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; ULong_t Hash () const override;  Return hash value for this object. ;  ; TClass * IsA () const override;  ; Bool_t IsSortable () const override;  ; void ls (Option_t *option="""") const override;  List TNamed name and title. ;  ; TNamed & operator= (const TNamed &rhs);  TNamed assignment operator. ;  ; void Print (Option_t *option="""") const override;  Print TNamed name and title. ;  ; virtual void SetName (const char *name);  Set the name of the TNamed. ;  ; virtual void SetNameTitle (const char *name, const char *title);  Set all the TNamed parameters (name and title). ;  ; virtual void SetTitle (const char *title="""");  Set the title of the TNamed. ;  ; virtual Int_t Sizeof () const;  Return size of the TNamed part of the TObject. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:6022,hash,hash,6022,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,1,['hash'],['hash']
Security,"ect with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; void MayNotUse (const char *metho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMapFile.html:8629,hash,hash,8629,doc/master/classTMapFile.html,https://root.cern,https://root.cern/doc/master/classTMapFile.html,1,['hash'],['hash']
Security,"ect->clear();; 865 ; 866 //---------------------------------------------------------------------------; 867 // Check the validity of each list element; 868 /////////////////////////////////////////////////////////////////////////////; 869 ; 870 std::list<std::string>::iterator it;; 871 for( it = versions.begin(); it != versions.end(); ++it ) {; 872 std::pair<Int_t, Int_t> verpair;; 873 if( !Internal::TSchemaRuleProcessor::ProcessVersion( *it, verpair ) ); 874 {; 875 delete fVersionVect;; 876 fVersionVect = nullptr;; 877 return kFALSE;; 878 }; 879 fVersionVect->push_back( verpair );; 880 }; 881 return kTRUE;; 882}; 883 ; 884////////////////////////////////////////////////////////////////////////////////; 885/// Check if specified checksum string is correct and build checksum vector.; 886 ; 887Bool_t TSchemaRule::ProcessChecksum( const TString& checksum ) const; 888{; 889 //---------------------------------------------------------------------------; 890 // Check if we have valid list; 891 /////////////////////////////////////////////////////////////////////////////; 892 ; 893 if (!checksum[0]); 894 return kFALSE;; 895 std::string chk = (const char*)checksum;; 896 if( chk[0] != '[' || chk[chk.size()-1] != ']' ); 897 return kFALSE;; 898 ; 899 std::list<std::string> checksums;; 900 Internal::TSchemaRuleProcessor::SplitList( chk.substr( 1, chk.size()-2), checksums );; 901 ; 902 if( checksums.empty() ) {; 903 delete fChecksumVect;; 904 fChecksumVect = nullptr;; 905 return kFALSE;; 906 }; 907 ; 908 if( !fChecksumVect ); 909 fChecksumVect = new std::vector<UInt_t>;; 910 fChecksumVect->clear();; 911 ; 912 //---------------------------------------------------------------------------; 913 // Check the validity of each list element; 914 /////////////////////////////////////////////////////////////////////////////; 915 ; 916 for( const auto& checksumStr : checksums ) {; 917 auto chksum = ParseChecksum( checksumStr.c_str() );; 918 if (chksum == 0u) {; 919 delete fChecksumVect;; 920",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSchemaRule_8cxx_source.html:28905,checksum,checksum,28905,doc/master/TSchemaRule_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSchemaRule_8cxx_source.html,3,['checksum'],['checksum']
Security,"ect. ;  ; virtual ~THashTable ();  Delete a hashtable. ;  ; void Add (TObject *obj) override;  Add object to the hash table. ;  ; void AddAll (const TCollection *col) override;  Add all objects from collection col to this collection. ;  ; void AddBefore (const TObject *before, TObject *obj);  Add object to the hash table. ;  ; Float_t AverageCollisions () const;  ; void Clear (Option_t *option="""") override;  Remove all objects from the table. ;  ; Int_t Collisions (const char *name) const;  Returns the number of collisions for an object with a certain name (i.e. ;  ; Int_t Collisions (TObject *obj) const;  Returns the number of collisions for an object (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the table AND delete all heap based objects. ;  ; Bool_t Empty () const;  ; const TList * GetListForObject (const char *name) const;  Return the TList corresponding to object's name based hash value. ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the TList corresponding to object's hash value. ;  ; TObject ** GetObjectRef (const TObject *obj) const override;  Return address of pointer to obj. ;  ; Int_t GetRehashLevel () const;  ; Int_t GetSize () const override;  Return the capacity of the collection, i.e. ;  ; TClass * IsA () const override;  ; TIterator * MakeIterator (Bool_t dir=kIterForward) const override;  Returns a hash table iterator. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; void Print (Option_t *option, Int_t recurse) const override;  Print the collection header and its elements. ;  ; virtual void Print (Option_t *option, TPRegexp &regexp, Int_t recurse=1) const;  Print the collection header and its elements that match the regexp. ;  ; void Print (Option_t *option="""") const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfTypes.html:2221,hash,hash,2221,doc/master/classTListOfTypes.html,https://root.cern,https://root.cern/doc/master/classTListOfTypes.html,1,['hash'],['hash']
Security,"ect. void SetNew(ROOT::NewFunc_t newFunc); Install a new wrapper around 'new'. void SetNewArray(ROOT::NewArrFunc_t newArrayFunc); Install a new wrapper around 'new []'. void SetDelete(ROOT::DelFunc_t deleteFunc); Install a new wrapper around 'delete'. void SetDeleteArray(ROOT::DelArrFunc_t deleteArrayFunc); Install a new wrapper around 'delete []'. void SetDestructor(ROOT::DesFunc_t destructorFunc); Install a new wrapper around the destructor. void SetDirectoryAutoAdd(ROOT::DirAutoAdd_t dirAutoAddFunc); Install a new wrapper around the directory auto add function..; The function autoAddFunc has the signature void (*)(void *obj, TDirectory dir); and should register 'obj' to the directory if dir is not null; and unregister 'obj' from its current directory if dir is null. TVirtualStreamerInfo * FindStreamerInfo(UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * FindStreamerInfo(TObjArray* arr, UInt_t checksum) const; Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. TVirtualStreamerInfo * GetConversionStreamerInfo( const char* classname, Int_t version ); Return a Conversion StreamerInfo from the class 'classname' for version number 'version' to this class, if any. TVirtualStreamerInfo * GetConversionStreamerInfo( const TClass* cl, Int_t version ); Return a Conversion StreamerInfo from the class represened by cl for version number 'version' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo( const char* classname, UInt_t checksum ); Return a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' to this class, if any. TVirtualStreamerInfo * FindConversionStreamerInfo( const TClass* cl, UInt_t checksum ); Return a Conversion StreamerInfo from the class represened by cl for the layout represented by 'checksum' to this class, if any. Bool_t HasDefaultConstructor() const; Return true if we have access to a default c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:40381,checksum,checksum,40381,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,2,['checksum'],['checksum']
Security,"ect.; Definition at line 50 of file TDrawFeedback.h. ◆ Hash(). ULong_t TDrawFeedback::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TDrawFeedback::HashULong_t Hash() const overrideReturn hash value for this object.Definition TDrawFeedback.h:51; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 51 of file TDrawFeedback.h. ◆ IsA(). TClass * TDrawFeedback::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 54 of file TDrawFeedback.h. ◆ SetOption(). void TDrawFeedback::SetOption ; (; Option_t * ; option). inline . Definition at line 52 of file TDrawFeedback.h. ◆ Streamer(). void TDrawFeedback::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TDrawFeedback:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDrawFeedback.html:17450,hash,hash,17450,doc/master/classTDrawFeedback.html,https://root.cern,https://root.cern/doc/master/classTDrawFeedback.html,1,['hash'],['hash']
Security,"ect::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_t*fCoords[fDim] Coordinates; Int_tfDimDimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamVect(); Default constructor for streamer. TFoamVect(Int_t ); User constructor creating n-dimensional vector; and allocating dynamically array of components. TFoamVect(const TFoamVect& ); Copy constructor. ~TFoamVect(); Destructor. Double_t & operator[](Int_t ); [] is for access to elements as in ordinary matrix like a[j]=b[j]; (Perhaps against some strict rules but rather practical.); Range protection is built in, consequently for substitution; one should use rather use a=b than explicit loop!. TFoamVect& operator*=(const Double_t& ); unary multiplication operator *=. TFoamVect& operator+=(const TFoamVect& ); unary addition operator +=; adding vector c*=x,. TFoamVect& operator-=(const TFoamVect& ); unary subtraction operator -=. TFoamVect operator+(const TFoamVect& ); addition operator +; sum of 2 vectors: c=a+b, a=a+b,; NEVER USE IT, VERY SLOW!!!. TFoamVect operator-(const TFoamVect& ); subtraction operator -; difference of 2 vectors; c=a-b, a=a-b,; NEVER USE IT, VERY SLOW!!!. void Print(Option_t* option) const; Printout of all vector components on ""std::cout"". Int_t GetDim() const; { return fDim; }. Double_t GetCoord(Int_t i) const; {return fCoords[i];}. » Last changed: root/foam:$Id$ » Last generated: 2015-06-02 15:48; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFoamVect.html:6431,access,access,6431,root/html604/TFoamVect.html,https://root.cern,https://root.cern/root/html604/TFoamVect.html,1,['access'],['access']
Security,"ect::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Double_t*fCoords[fDim] Coordinates; Int_tfDimDimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFoamVect(); Default constructor for streamer. TFoamVect(Int_t ); User constructor creating n-dimensional vector; and allocating dynamically array of components. TFoamVect(const TFoamVect& ); Copy constructor. ~TFoamVect(); Destructor. Double_t & operator[](Int_t ); [] is for access to elements as in ordinary matrix like a[j]=b[j]; (Perhaps against some strict rules but rather practical.); Range protection is built in, consequently for substitution; one should use rather use a=b than explicit loop!. TFoamVect& operator*=(const Double_t& ); unary multiplication operator *=. TFoamVect& operator+=(const TFoamVect& ); unary addition operator +=; adding vector c*=x,. TFoamVect& operator-=(const TFoamVect& ); unary subtraction operator -=. TFoamVect operator+(const TFoamVect& ); addition operator +; sum of 2 vectors: c=a+b, a=a+b,; NEVER USE IT, VERY SLOW!!!. TFoamVect operator-(const TFoamVect& ); subtraction operator -; difference of 2 vectors; c=a-b, a=a-b,; NEVER USE IT, VERY SLOW!!!. void Print(Option_t* option) const; Printout of all vector components on ""std::cout"". Int_t GetDim() const; { return fDim; }. Double_t GetCoord(Int_t i) const; {return fCoords[i];}. » Last changed: root/foam:$Id$ » Last generated: 2015-06-30 14:49; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFoamVect.html:6431,access,access,6431,root/html602/TFoamVect.html,https://root.cern,https://root.cern/root/html602/TFoamVect.html,1,['access'],['access']
Security,"ect::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TRegexpRegular expression class.Definition TRegexp.h:31; TStringBasic string class.Definition TString.h:139; TString::InsertTString & Insert(Ssiz_t pos, const char *s)Definition TString.h:661; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::LastSsiz_t Last(char c) constFind last occurrence of a character c.Definition TString.cxx:931; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::pwdconst char * pwd()Definition TSystem.h:424; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEntryList_8cxx_source.html:72174,hash,hash,72174,doc/master/TEntryList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEntryList_8cxx_source.html,1,['hash'],['hash']
Security,"ect::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual Int_tWritePDGTable(const char* filename). protected:. TDatabasePDG(const TDatabasePDG& db); voidBuildPdgMap() const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TDatabasePDG&operator=(const TDatabasePDG& db). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*fListOfClasseslist of classes (leptons etc.); TStringTNamed::fNameobject identifier; THashList*fParticleListlist of PDG particles; TExMap*fPdgMap!hash-map from pdg-code to particle; TStringTNamed::fTitleobject title; static TDatabasePDG*fgInstanceprotect against multiple instances. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDatabasePDG(); Create PDG database. Initialization of the DB has to be done via explicit; call to ReadDataBasePDG (also done by GetParticle methods). ~TDatabasePDG(); Cleanup the PDG database. TDatabasePDG* Instance(); static function. void BuildPdgMap() const; Build fPdgMap mapping pdg-code to particle. Initial size is set so as to be able to hold at least 600; particles: 521 in default table, ALICE adds 54 more.; To be revisited after LHC discovers SUSY. TParticlePDG* AddParticle(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t DecayWidth, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti = -1, Int_t TrackingCode = 0). Particle definition normal constructor. If the particle is set to be; stable, the decay width parameter does hav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDatabasePDG.html:6932,hash,hash-map,6932,root/html528/TDatabasePDG.html,https://root.cern,https://root.cern/root/html528/TDatabasePDG.html,4,['hash'],['hash-map']
Security,"ect::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ROOT::TSchemaRule&operator=(const ROOT::TSchemaRule& rhs); Bool_toperator==(const ROOT::TSchemaRule& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidSetAttributes(const TString& attributes); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); Bool_tSetChecksum(const TString& checksum); voidSetCode(const TString& code); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEmbed(Bool_t embed); Bool_tSetFromRule(const char* rule); voidSetInclude(const TString& include); static voidTObject::SetObjectStat(Bool_t stat); voidSetReadFunctionPointer(ROOT::TSchemaRule::ReadFuncPtr_t ptr); voidSetReadRawFunctionPointer(ROOT::TSchemaRule::ReadRawFuncPtr_t ptr); voidSetRuleType(ROOT::TSchemaRule::RuleType_t type); voidSetSource(const TString& source); voidSetSourceClass(const TString& classname); voidSetTarget(const TString& target); voidSetTargetClass(const TString& classname); virtual voidTObject::SetUniqueID(UInt_t uid); Bool_tSetVersion(const TString& version); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::Test",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__TSchemaRule.html:4698,checksum,checksum,4698,root/html528/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html528/ROOT__TSchemaRule.html,1,['checksum'],['checksum']
Security,"ected basis function; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static RooFormulaVar*_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooResolutionModel.html:40610,access,access,40610,root/html532/RooResolutionModel.html,https://root.cern,https://root.cern/root/html532/RooResolutionModel.html,1,['access'],['access']
Security,"ected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*fTableHashtable used for quick lookup of objects. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashList(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashList object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehash is the value at which a rehash will be triggered. I.e. when the; average size of the linked lists at a slot becomes longer than rehash; then the hashtable will be resized and refilled to reduce the collision; rate to about 1. The higher the collision rate, i.e. the longer the; linked lists, the longer lookup will take. If rehash=0 the table will; NOT automatically be rehashed. Use Rehash() for manual rehashing.; WARNING !!!; If the name of an object in the HashList is modified, The hashlist; must be Rehashed. THashList(TObject* parent, Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); For backward compatibility only. Use other ctor. ~THashList(); Delete a hashlist. Objects are not deleted unless the THashList is the; owner (set via SetOwner()). void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashList.html:10864,hash,hashtable,10864,root/html528/THashList.html,https://root.cern,https://root.cern/root/html528/THashList.html,4,['hash'],['hashtable']
Security,ection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2891; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3078; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3052; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2962; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the l,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:160419,inject,inject,160419,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['inject'],['inject']
Security,ection * GetListOfTypes(Bool_t load=kFALSE)Return a dynamic list giving access to all TDataTypes (typedefs) currently defined.Definition TROOT.cxx:1865; TROOT::fgDirLevelstatic Int_t fgDirLevelIndentation level for ls()Definition TROOT.h:102; TROOT::IsRootFileBool_t IsRootFile(const char *filename) constReturn true if the file is local and is (likely) to be a ROOT file.Definition TROOT.cxx:2230; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::GetDocDirstatic const TString & GetDocDir()Get the documentation directory in the installation. Static utility function.Definition TROOT.cxx:3082; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetNclassesInt_t GetNclasses() constGet number of classes.Definition TROOT.cxx:1876; TROOT::GetExtraInterpreterArgsstatic const char **& GetExtraInterpreterArgs()INTERNAL function! Used by rootcling to inject interpreter arguments through a C-interface layer.Definition TROOT.cxx:2966; TROOT::SetMacroPathstatic void SetMacroPath(const char *newpath)Set or extend the macro search path.Definition TROOT.cxx:2788; TROOT::InitThreadsvoid InitThreads()Initialize threads library.Definition TROOT.cxx:2053; TROOT::fUUIDsTProcessUUID * fUUIDsPointer to TProcessID managing TUUIDs.Definition TROOT.h:166; TROOT::fConfigFeaturesTString fConfigFeaturesROOT ./configure detected build features.Definition TROOT.h:112; TROOT::GetFunctionTemplateTFunctionTemplate * GetFunctionTemplate(const char *name)Definition TROOT.cxx:1618; TROOT::fPluginManagerTPluginManager * fPluginManagerKeeps track of plugin library handlers.Definition TROOT.h:169; TROOT::GetGeometryTObject * GetGeometry(const char *name) constReturn pointer to Geometry with name.Definition TROOT.cxx:1747; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the l,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:160595,inject,inject,160595,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['inject'],['inject']
Security,"ectionProxy::CheckFunctions() const; virtual voidTGenCollectionProxy::DeleteItem(Bool_t force, void* ptr) const; voidExpand(UInt_t nCurr, UInt_t left); TGenCollectionProxy*TGenCollectionProxy::Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent); voidReadItems(int nElements, TBuffer& b); voidShrink(UInt_t nCurr, UInt_t left, Bool_t force); voidWriteItems(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedCollectionProxy.html:4329,access,accessors,4329,root/html532/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedCollectionProxy.html,2,['access'],['accessors']
Security,"ectionStreamer.; Definition at line 1427 of file TGenCollectionProxy.cxx. ◆ Streamer() [2/2]. void TGenCollectionProxy::Streamer ; (; TBuffer & ; refBuffer, . void * ; pObject, . int ; siz . ). virtual . Streamer I/O overload. ; Reimplemented in TEmulatedCollectionProxy, TEmulatedMapProxy, and TGenCollectionStreamer.; Definition at line 1439 of file TGenCollectionProxy.cxx. Friends And Related Symbol Documentation. ◆ TCollectionProxyFactory. friend class TCollectionProxyFactory. friend . Definition at line 34 of file TGenCollectionProxy.h. Member Data Documentation. ◆ fClear. Method TGenCollectionProxy::fClear. protected . Method cache for container accessors: clear container. ; Definition at line 301 of file TGenCollectionProxy.h. ◆ fCollect. Collectfunc_t TGenCollectionProxy::fCollect. protected . Method to collect objects from container. ; Definition at line 309 of file TGenCollectionProxy.h. ◆ fConstruct. ArrIterfunc_t TGenCollectionProxy::fConstruct. protected . Container accessors: block construct. ; Definition at line 306 of file TGenCollectionProxy.h. ◆ fConversionReadMemberWise. std::map<std::string, TObjArray*>* TGenCollectionProxy::fConversionReadMemberWise. mutableprotected . Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ; Definition at line 292 of file TGenCollectionProxy.h. ◆ fCreateEnv. Method0 TGenCollectionProxy::fCreateEnv. protected . Method to allocate an Environment holder. ; Definition at line 310 of file TGenCollectionProxy.h. ◆ fDestruct. Sizing_t TGenCollectionProxy::fDestruct. protected . Container accessors: block destruct. ; Definition at line 307 of file TGenCollectionProxy.h. ◆ fEnv. EnvironBase_t* TGenCollectionProxy::fEnv. protected . Address of the currently proxied object. ; Definition at line 314 of file TGenCollectionProxy.h. ◆ fFeed. Feedfunc_t TGenCollectionProxy::fFeed. protected . Container accessors: block feed. ; Definition at line 308 of file TGenCollectionProxy.h. ◆ fFirst. Method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionProxy.html:27483,access,accessors,27483,doc/master/classTGenCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionProxy.html,1,['access'],['accessors']
Security,"ectly execute an executable statement (e.g. ""func()"", ""3+5"", etc.; however not declarations, like ""Int_t x;""). void PrintIntro(); Print CINT introduction and help message. void SetGetline(char *(*)(const char* prompt) getlineFunc, void (*)(char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); Delete obj from CINT symbol table so it cannot be accessed anymore.; Returns 1 in case of success and 0 in case object was not in table. void SaveContext(); Save the current CINT state. void SaveGlobalsContext(); Save the current CINT state of global objects. void UpdateListOfGlobals(); Update the list of pointers to global variables. This function; is called by TROOT::GetListOfGlobals(). void UpdateListOfGlobalFunctions(); Update the list of pointers to global functions. This function; is called by TROOT::GetListOfGlobalFunctions(). void UpdateListOfTypes(); Update the list of pointers to Datatype (typedef) definitions. This; function is called by TROOT::GetListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE); Set pointer to CINT's G__ClassInfo in TClass. Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE); Checks if a class with the specified name is defined in CINT.; Returns kFALSE is class is not defined. void CreateListOfBaseClasses(TClass* cl); Create list of pointers ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:22381,access,accessed,22381,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,2,['access'],['accessed']
Security,"ector containing the lower (upper) triangular part. ;  ;  SMatrix (const T &rhs);  Construct from a scalar value (only for size 1 matrices) ;  ; template<class M > ; SMatrix< T, D1, D2, R > & operator= (const M &rhs);  Assign from another compatible matrix. ;  ; SMatrix< T, D1, D2, R > & operator= (const SMatrix< T, D1, D2, R > &rhs);  ; template<class A , class R2 > ; SMatrix< T, D1, D2, R > & operator= (const Expr< A, T, D1, D2, R2 > &rhs);  Assign from a matrix expression. ;  ; SMatrix< T, D1, D2, R > & operator= (SMatrixIdentity);  Assign from an identity matrix. ;  ; SMatrix< T, D1, D2, R > & operator= (const T &rhs);  Assign from a scalar value (only for size 1 matrices) ;  ; — Access functions —; T apply (unsigned int i) const;  access the parse tree with the index starting from zero and following the C convention for the order in accessing the matrix elements. ;  ; const T * Array () const;  return read-only pointer to internal array ;  ; T * Array ();  return pointer to internal array ;  ; — STL-like interface —; The iterators access the matrix element in the order how they are stored in memory.; The C (row-major) convention is used, and in the case of symmetric matrices the iterator spans only the lower diagonal block. For example for a symmetric 3x3 matrices the order of the 6 elements \({a_0,...a_5}\) is: ; \[; M = \left( \begin{array}{ccc}; a_0 & a_1 & a_3 \\; a_1 & a_2 & a_4 \\; a_3 & a_4 & a_5 \end{array} \right); \]. iterator begin ();  STL iterator interface. ;  ; iterator end ();  STL iterator interface. ;  ; const_iterator begin () const;  STL const_iterator interface. ;  ; const_iterator end () const;  STL const_iterator interface. ;  ; template<class InputIterator > ; void SetElements (InputIterator begin, InputIterator end, bool triang=false, bool lower=true);  Set matrix elements with STL iterator interface. ;  ; template<class InputIterator > ; void SetElements (InputIterator begin, unsigned int size, bool triang=false, bool lower=true);  Cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html:3625,access,access,3625,doc/master/classROOT_1_1Math_1_1SMatrix.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SMatrix.html,1,['access'],['access']
Security,"ector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:15639,access,access,15639,root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"ector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const Scalar[] src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:11534,access,access,11534,root/html602/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,2,['access'],['access']
Security,"ectorized ? ""ROOT::Double_v"" : ""Double_t"";; 2309 ; 2310 // valid input formula - try to put into Cling (in case of no variables but only parameter we need to add the standard signature); 2311 TString argumentsPrototype = TString::Format(""%s%s%s"", ( (hasVariables || hasParameters) ? (argType + "" *x"").Data() : """"),; 2312 (hasParameters ? "","" : """"), (hasParameters ? ""Double_t *p"" : """"));; 2313 ; 2314 // set the name for Cling using the hash_function; 2315 fClingName = gNamePrefix;; 2316 ; 2317 // check if formula exist already in the map; 2318 R__LOCKGUARD(gROOTMutex);; 2319 ; 2320 // std::cout << ""gClingFunctions list"" << std::endl;; 2321 // for (auto thing : gClingFunctions); 2322 // std::cout << ""gClingFunctions : "" << thing.first << std::endl;; 2323 ; 2324 auto funcit = gClingFunctions.find(inputFormulaVecFlag);; 2325 ; 2326 if (funcit != gClingFunctions.end()) {; 2327 fFuncPtr = (TFormula::CallFuncSignature)funcit->second;; 2328 fClingInitialized = true;; 2329 inputIntoCling = false;; 2330 }; 2331 ; 2332 ; 2333 ; 2334 // set the cling name using hash of the static formulae map; 2335 auto hasher = gClingFunctions.hash_function();; 2336 fClingName = TString::Format(""%s__id%zu"", gNamePrefix.Data(), hasher(inputFormulaVecFlag));; 2337 ; 2338 fClingInput = TString::Format(""%s %s(%s){ return %s ; }"", argType.Data(), fClingName.Data(),; 2339 argumentsPrototype.Data(), inputFormula.c_str());; 2340 ; 2341 ; 2342 // std::cout << ""Input Formula "" << inputFormula << "" \t vec formula : "" << inputFormulaVecFlag << std::endl;; 2343 // std::cout << ""Cling functions existing "" << std::endl;; 2344 // for (auto & ff : gClingFunctions); 2345 // std::cout << ff.first << std::endl;; 2346 // std::cout << ""\n"";; 2347 // std::cout << fClingName << std::endl;; 2348 ; 2349 // this is not needed (maybe can be re-added in case of recompilation of identical expressions; 2350 // // check in case of a change if need to re-initialize; 2351 // if (fClingInitialized) {; 2352 // if (oldClingInput ==",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:89569,hash,hash,89569,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,2,['hash'],"['hash', 'hasher']"
Security,"ectory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Returns kTRUE in case of success, kFALSE otherwise. const char * WorkingDirectory(); Return working directory. const char * HomeDirectory(const char* userName = 0); Return the user's home directory. const char * TempDirectory() const; Return a user configured or systemwide directory to create; temporary files in. FILE * TempFileName(TString& base, const char* dir = 0); Create a secure temporary file by appending a unique; 6 letter string to base. The file will be created in; a standard (system) directory or in the directory; provided in dir. The full filename is returned in base; and a filepointer is returned for safely writing to the file; (this avoids certain security problems). Returns 0 in case; of error. const char * PrependPathName(const char* dir, TString& name); Concatenate a directory and a file name. Bool_t AccessPathName(const char* path, EAccessMode mode = kFileExists); Returns FALSE if one can access a file using the specified access mode.; Mode is the same as for the Unix access(2) function.; Attention, bizarre convention of return value!!. int CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); Copy a file. If overwrite is true and file already exists the; file will be overwritten. Returns 0 when successful, -1 in case; of file open failure, -2 in case the file already exists and overwrite; was false and -3 in case of error during copy. int Rename(const char* from, const char* to); Rename a file. Returns 0 when successful, -1 in case of failure. Bool_t IsPathLocal(const char* path); Returns TRUE if the url in 'path' points to the local file system.; This is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:24547,secur,security,24547,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,6,['secur'],['security']
Security,"ectory name or filename.; Do not use the following characters in directory names or filenames, because they are reserved for Windows: < > : "" / \ |; Do not use reserved words, such as aux, con, and prn, as filenames or directory names.; Process a path as a null-terminated string. The maximum length for a path is given by MAX_PATH.; Do not assume case sensitivity. Consider names such as OSCAR, Oscar, and oscar to be the same. . Reimplemented from TSystem.; Definition at line 2536 of file TWinNTSystem.cxx. ◆ Unlink(). int TWinNTSystem::Unlink ; (; const char * ; name). overridevirtual . Unlink, i.e. ; remove, a file or directory.; If the file is currently open by the current or another process Windows does not allow the file to be deleted and the operation is a no-op. ; Reimplemented from TSystem.; Definition at line 2899 of file TWinNTSystem.cxx. ◆ Utime(). int TWinNTSystem::Utime ; (; const char * ; file, . Long_t ; modtime, . Long_t ; actime . ). overridevirtual . Set a files modification and access times. ; If actime = 0 it will be set to the modtime. Returns 0 on success and -1 in case of error. ; Reimplemented from TSystem.; Definition at line 3090 of file TWinNTSystem.cxx. ◆ WinNTUdpConnect(). int TWinNTSystem::WinNTUdpConnect ; (; const char * ; hostname, . int ; port . ). staticprotected . Creates a UDP socket connection Is called via the TSocket constructor. ; Returns -1 in case of error. ; Definition at line 5317 of file TWinNTSystem.cxx. ◆ WinNTUnixConnect() [1/2]. int TWinNTSystem::WinNTUnixConnect ; (; const char * ; path). staticprotected . Connect to a Unix domain socket. Returns -1 in case of error. ; Definition at line 5287 of file TWinNTSystem.cxx. ◆ WinNTUnixConnect() [2/2]. int TWinNTSystem::WinNTUnixConnect ; (; int ; port). staticprotected . Connect to a Unix domain socket. ; Definition at line 5256 of file TWinNTSystem.cxx. ◆ WorkingDirectory() [1/2]. const char * TWinNTSystem::WorkingDirectory ; (; ). overridevirtual . Return the working direct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:76136,access,access,76136,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['access'],['access']
Security,"ects () const;  ; TSeqCollection * GetListOfColors () const;  ; TSeqCollection * GetListOfDataSets () const;  ; TCollection * GetListOfEnums (Bool_t load=kFALSE);  ; TSeqCollection * GetListOfFiles () const;  ; TCollection * GetListOfFunctionOverloads (const char *name) const;  Return the collection of functions named ""name"". ;  ; TCollection * GetListOfFunctions () const;  ; TCollection * GetListOfFunctionTemplates ();  ; TSeqCollection * GetListOfGeometries () const;  ; TCollection * GetListOfGlobalFunctions (Bool_t load=kFALSE);  Return list containing the TFunctions currently defined. ;  ; TCollection * GetListOfGlobals (Bool_t load=kFALSE);  Return list containing the TGlobals currently defined. ;  ; TSeqCollection * GetListOfMappedFiles () const;  ; TSeqCollection * GetListOfMessageHandlers () const;  ; TSeqCollection * GetListOfProofs () const;  ; TSeqCollection * GetListOfSecContexts () const;  ; TSeqCollection * GetListOfSockets () const;  ; TSeqCollection * GetListOfSpecials () const;  ; TSeqCollection * GetListOfStreamerInfo () const;  ; TSeqCollection * GetListOfStyles () const;  ; TSeqCollection * GetListOfTasks () const;  ; TCollection * GetListOfTypes (Bool_t load=kFALSE);  Return a dynamic list giving access to all TDataTypes (typedefs) currently defined. ;  ; Int_t GetNclasses () const;  Get number of classes. ;  ; Int_t GetNtypes () const;  Get number of types. ;  ; TPluginManager * GetPluginManager () const;  ; TFolder * GetRootFolder () const;  ; TVirtualPad * GetSelectedPad () const;  ; const TObject * GetSelectedPrimitive () const;  ; TStyle * GetStyle (const char *name) const;  Return pointer to style with name. ;  ; TDataType * GetType (const char *name, Bool_t load=kFALSE) const;  Return pointer to type with name. ;  ; TProcessUUID * GetUUIDs () const;  ; const char * GetVersion () const;  ; Int_t GetVersionCode () const;  ; Int_t GetVersionDate () const;  ; Int_t GetVersionInt () const;  ; Int_t GetVersionTime () const;  ; const TString & G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:8464,access,access,8464,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['access'],['access']
Security,"ects and folders. Folders have a name and a title and are identified in the folder hierarchy by a ""Unix-like"" naming mechanism. The root of all folders is //root. New folders can be dynamically added or removed to/from a folder. The folder hierarchy can be visualized via the TBrowser. The Root folders hierarchy can be seen as a whiteboard where objects are posted. Other classes/tasks can access these objects by specifying only a string pathname. This whiteboard facility greatly improves the modularity of an application, minimizing the class relationship problem that penalizes large applications.; Pointers are efficient to communicate between classes. However, one has interest to minimize direct coupling between classes in the form of direct pointers. One better uses the naming and search service provided by the Root folders hierarchy. This makes the classes loosely coupled and also greatly facilitates I/O operations. In a client/server environment, this mechanism facilitates the access to any kind of object in //root stores running on different processes.; A TFolder is created by invoking the TFolder constructor. It is placed inside an existing folder via the TFolder::AddFolder method. One can search for a folder or an object in a folder using the FindObject method. FindObject analyses the string passed as its argument and searches in the hierarchy until it finds an object or folder matching the name.; When a folder is deleted, its reference from the parent folder and possible other folders is deleted.; If a folder has been declared the owner of its objects/folders via TFolder::SetOwner, then the contained objects are deleted when the folder is deleted. By default, a folder does not own its contained objects.; NOTE that folder ownership can be set; via TFolder::SetOwner; or via TCollection::SetOwner on the collection specified to TFolder::AddFolder. Standard Root objects are automatically added to the folder hierarchy. For example, the following folders exist: root/F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFolder.html:1617,access,access,1617,doc/master/classTFolder.html,https://root.cern,https://root.cern/doc/master/classTFolder.html,1,['access'],['access']
Security,"ects attached, recursively calling Paint() for all the objects. Pad painting. In some cases a pad need to be painted during a macro execution. To force the pad painting gPad->Update() (see next section) should be performed.; The list of primitives stored in the pad is also used to pick objects and to interact with them.; 9.3.1 The Global Pad: gPad; When an object is drawn, it is always in the so-called active pad. For every day use, it is comfortable to be able to access the active pad, whatever it is. For that purpose, there is a global pointer, called gPad. It is always pointing to the active pad. If you want to change the fill color of the active pad to blue but you do not know its name, do this.; root[] gPad->SetFillColor(38); To get the list of colors, go to the paragraph “Color and color palettes” or if you have an opened canvas, click on the View menu, selecting the Colors item.; 9.3.1.1 Finding an Object in a Pad; Now that we have a pointer to the active pad, gPad and that we know this pad contains some objects, it is sometimes interesting to access one of those objects. The method GetPrimitive() of TPad, i.e. TPad::GetPrimitive(const char* name) does exactly this. Since most of the objects that a pad contains derive from TObject, they have a name. The following statement will return a pointer to the object myobjectname and put that pointer into the variable obj. As you can see, the type of returned pointer is TObject*.; root[] obj = gPad->GetPrimitive(""myobjectname""); (class TObject*)0x1063cba8; Even if your object is something more complicated, like a histogram TH1F, this is normal. A function cannot return more than one type. So the one chosen was the lowest common denominator to all possible classes, the class from which everything derives, TObject. How do we get the right pointer then? Simply do a cast of the function output that will transform the output (pointer) into the right type. For example if the object is a TPaveLabel:; root[] obj = (TPaveLabel*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:304951,access,access,304951,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ectvirtual; ParseChecksum(const char *checksum) constROOT::TSchemaRuleprivate; Pop()TObjectvirtual; Print(Option_t *option="""") constTObjectvirtual; ProcessChecksum(const TString &checksum) constROOT::TSchemaRuleprivate; ProcessDeclaration(TObjArray *array, const TString &list)ROOT::TSchemaRuleprivatestatic; ProcessList(TObjArray *array, const TString &list)ROOT::TSchemaRuleprivatestatic; ProcessVersion(const TString &version) constROOT::TSchemaRuleprivate; Read(const char *name)TObjectvirtual; ReadFuncPtr_t typedefROOT::TSchemaRule; ReadRawFuncPtr_t typedefROOT::TSchemaRule; RecursiveRemove(TObject *obj)TObjectvirtual; ResetBit(UInt_t f)TObjectinline; RuleType_t enum nameROOT::TSchemaRule; SaveAs(const char *filename="""", Option_t *option="""") constTObjectvirtual; SavePrimitive(std::ostream &out, Option_t *option="""")TObjectvirtual; SetAttributes(const TString &attributes)ROOT::TSchemaRule; SetBit(UInt_t f, Bool_t set)TObject; SetBit(UInt_t f)TObjectinline; SetChecksum(const TString &checksum)ROOT::TSchemaRule; SetCode(const TString &code)ROOT::TSchemaRule; SetDrawOption(Option_t *option="""")TObjectvirtual; SetDtorOnly(void *obj)TObjectstatic; SetEmbed(Bool_t embed)ROOT::TSchemaRule; SetFromRule(const char *rule)ROOT::TSchemaRule; SetInclude(const TString &include)ROOT::TSchemaRule; SetObjectStat(Bool_t stat)TObjectstatic; SetReadFunctionPointer(ReadFuncPtr_t ptr)ROOT::TSchemaRule; SetReadRawFunctionPointer(ReadRawFuncPtr_t ptr)ROOT::TSchemaRule; SetRuleType(RuleType_t type)ROOT::TSchemaRule; SetSource(const TString &source)ROOT::TSchemaRule; SetSourceClass(const TString &classname)ROOT::TSchemaRule; SetTarget(const TString &target)ROOT::TSchemaRule; SetTargetClass(const TString &classname)ROOT::TSchemaRule; SetUniqueID(UInt_t uid)TObjectvirtual; SetVersion(const TString &version)ROOT::TSchemaRule; Streamer(TBuffer &) overrideROOT::TSchemaRulevirtual; StreamerNVirtual(TBuffer &ClassDef_StreamerNVirtual_b)ROOT::TSchemaRuleinline; SysError(const char *method, const char *m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TSchemaRule-members.html:6778,checksum,checksum,6778,doc/master/classROOT_1_1TSchemaRule-members.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TSchemaRule-members.html,1,['checksum'],['checksum']
Security,"ed (via TTree::Write), the branch; is saved keeping the information with the pointers to the branches; having referenced objects. TBranch* Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); Create a new TTree BranchElement. WARNING about this new function. This function is designed to replace the function TTree::Branch above.; This function is far more powerful than the Branch function.; It supports the full C++, including STL and has the same behaviour; in split or non-split mode. classname does not have to derive from TObject.; The function is based on the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class classname.; The class dictionary must be available (ClassDef in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:50450,access,access,50450,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['access'],['access']
Security,"ed ;  ; Double_t GetAlphaMinSubtree () const;  return the minimum alpha in the tree rooted at this node, or -1 if traininfo undefined ;  ; Double_t GetCC () const;  return CC, or -1 if traininfo undefined ;  ; Bool_t GetCutType (void) const;  return kTRUE: Cuts select signal, kFALSE: Cuts select bkg ;  ; Float_t GetCutValue (void) const;  return the cut value applied at this node ;  ; Double_t GetFisherCoeff (Int_t ivar) const;  get fisher coefficients ;  ; virtual DecisionTreeNode * GetLeft () const;  ; Float_t GetNBkgEvents (void) const;  return the sum of the backgr weights in the node, or -1 if traininfo undefined ;  ; Float_t GetNBkgEvents_unboosted (void) const;  return the sum of unboosted backgr weights in the node, or -1 if traininfo undefined ;  ; Float_t GetNBkgEvents_unweighted (void) const;  return the sum of unweighted backgr weights in the node, or -1 if traininfo undefined ;  ; Double_t GetNBValidation () const;  return number of background events from the pruning validation sample, or -1 if traininfo undefined ;  ; Float_t GetNEvents (void) const;  return the number of events that entered the node (during training), or -1 if traininfo undefined ;  ; Float_t GetNEvents_unboosted (void) const;  return the number of unboosted events that entered the node (during training), or -1 if traininfo undefined ;  ; Float_t GetNEvents_unweighted (void) const;  return the number of unweighted events that entered the node (during training), or -1 if traininfo undefined ;  ; UInt_t GetNFisherCoeff () const;  ; Double_t GetNodeR () const;  return the node resubstitution estimate, R(t), for Cost Complexity pruning, or -1 if traininfo undefined ;  ; Int_t GetNodeType (void) const;  return node type: 1 signal node, -1 bkg leave, 0 intermediate Node ;  ; Float_t GetNSigEvents (void) const;  return the sum of the signal weights in the node, or -1 if traininfo undefined ;  ; Float_t GetNSigEvents_unboosted (void) const;  return the sum of unboosted signal weights in the no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html:2513,validat,validation,2513,doc/master/classTMVA_1_1DecisionTreeNode.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTreeNode.html,1,['validat'],['validation']
Security,"ed by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified by the user.; Variable with single sided limits: allowed to vary only between one upper or one lower limit specified by the user and unlimited to the other side.; Fixed: originally defined as variable, but now taking on only the value the parameter had at the moment it was fixed, or a value later assigned by the user.; Constant: taking on only one value as specified by the user. When using the minimal required interface, all variable parameters are free and unbound.; The user, in his \(\mbox{FCN}\), must of course be able to “see” all types of defined parameters, and he therefore has access to what we call the external parameter list, that is, the parameters as he defined them. On the other hand, the internal M minimizing routines only want to “see” variable parameters without limits, and so they have access only to the internal parameter list which is created from the external list by the following transformation:. Squeeze out all parameters that are not variable.; Transform all variable parameters with limits, so that the transformed parameter can vary without limits. (See the next section for details concerning this transformation.) Because this transformation is non-linear, it is recommended to avoid putting limits on parameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:11590,access,access,11590,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['access'],['access']
Security,"ed bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual Int_t ReOpen (Option_t *mode);  Reopen a file with a different access mode. ;  ; virtual void ResetErrno () const;  Method resetting the errno. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:6529,access,access,6529,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['access'],['access']
Security,"ed dataset at 'path' and save it to the appropriate file 'md5path'. ; The MD5 string is returned in 'md5sum'. Return 0 on success, -1 on error. ; Definition at line 1512 of file TDataSetManagerFile.cxx. ◆ Class(). static TClass * TDataSetManagerFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDataSetManagerFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDataSetManagerFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 100 of file TDataSetManagerFile.h. ◆ ClearCache(). Int_t TDataSetManagerFile::ClearCache ; (; const char * ; uri = 0). overridevirtual . Clear cached information matching uri. ; Reimplemented from TDataSetManager.; Definition at line 1253 of file TDataSetManagerFile.cxx. ◆ CreateLsFile(). Int_t TDataSetManagerFile::CreateLsFile ; (; const char * ; group, . const char * ; user, . Long_t & ; mtime, . TString & ; checksum . ). protected . Create or recreate the dataset lists for 'uri'. ; The list are saved in text form in 'uri'/ls.txt for fast browsing and in 'uri'/ls.root in form of TMacro for optimized and portable transfer. Return 0 on success, 1 if the file was empty, -1 on error ; Definition at line 474 of file TDataSetManagerFile.cxx. ◆ DeclFileName(). static const char * TDataSetManagerFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 100 of file TDataSetManagerFile.h. ◆ ExistsDataSet() [1/2]. Bool_t TDataSetManagerFile::ExistsDataSet ; (; const char * ; group, . const char * ; user, . const char * ; dsName . ). protected . Checks if the indicated dataset exits. ; Definition at line 1576 of file TDataSetManagerFile.cxx. ◆ ExistsDataSet() [2/2]. Bool_t TDataSetManagerFile::ExistsDataSet ; (; const char * ; uri). overridevirtual . Checks if the indicated dataset exits. ; Reimplemented from TDataSetManager.; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataSetManagerFile.html:23732,checksum,checksum,23732,doc/master/classTDataSetManagerFile.html,https://root.cern,https://root.cern/doc/master/classTDataSetManagerFile.html,1,['checksum'],['checksum']
Security,"ed externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Streamer will not call TObject::Streamer.; This option saves the TObject space overhead on the file.; However, the information (fBits, fUniqueID) of TObject is lost. Note that to be effective for objects streamed object-wise this function; must be called for the class deriving directly from TObject, eg, assuming; that BigTrack derives from Track and Track derives from TObject, one must do:; Track::Class()->IgnoreTObjectStreamer();; and not:; BigTrack::Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:34861,checksum,checksum,34861,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,3,['checksum'],['checksum']
Security,"ed in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTruthModel.html:41658,access,access,41658,root/html534/RooTruthModel.html,https://root.cern,https://root.cern/root/html534/RooTruthModel.html,1,['access'],['access']
Security,"ed in” only while they are clicked, while the radio and check buttons change their appearance when they are selected and keep that appearance afterwards.; A text button is represented by the class TGTextButton. We already used its constructor in the example. The button label indicates the action to be taken when the button is selected or pressed. The text can be a hot string defining a hot key (known as shortcut key also) for this selection. The hot key is an underlined character in a button label that shows the assigned keyboard mnemonic for its choice. A button that prompts more information for users has the label generally followed by ellipsis (…). As we saw the hot strings “&Draw” and “&Exit” define the text labels “Draw” and “Exit” and keyboard mnemonics Alt+D, Alt+E for their selection. The letter D and E appear underlined on the screen. All text buttons should have a unique shortcut key with the exception of OK and Cancel.; These buttons are usually placed within a window to provide fast access to frequently used or critical commands. They help in situations where a command is not available through the menu bar. You already know that a command string can be passed in the text button via the constructor:; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; A button label can be changed by SetText(new_label). There are important guidelines to be followed about a button label. The text has to provide a meaningful description of the performed action. The single-word label should be used whenever possible, only two-three words for clarity, if necessary. Do not number labels. Always follow all platform presentation and usage guidelines for standard button functions. Let’s remember a few standard names and definitions of well known buttons:; OK - any changed information in a window is accepted and the window is closed;; Cancel - closes window without implementing submitted changes;; Reset-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1177678,access,access,1177678,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ed peaks, peaks with amplitude less than; threshold*highest_peak/100 are ignored; backgroundRemove- background_remove-logical variable, true if the removal of; background before deconvolution is desired� ; deconIterations-number of iterations in; deconvolution operation; markov-logical variable, if it is true,; first the source spectrum is replaced by new spectrum calculated using Markov; chains method ; averWindow-width of; averaging smoothing window ;  ; References:; [1]; M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451. . Examples of peak searching; method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the destination spectrum. Based on the output data one can tune the; parameters. ; Example 8 � script Src.c:. Fig.; 20 Two-dimensional spectrum with found peaks denoted by markers (,; threshold=5%, 3 iterations steps in the deconvolution). Fig.; 21 Spectrum from Fig. 20 after background elimination and deconvolution; Script:; // Example to illustrate high resolution peak searching; function (class TSpectrum).; // To execute this example, do; // root > .x Src.C;  ; #include <TSpectrum2>;  ; void Src() {; �� Int_t i, j, nfound;; �� Double_t nbinsx = 64;; �� Double_t nbinsy = 64;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�� ; �� Double_t** source = new Double_t*[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� source[i]=new; Double_t[nbinsy];; �� Double_t** dest = new Double_t*[nbinsx];�� ; �� for (i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum2.html:39377,access,access,39377,root/html602/TSpectrum2.html,https://root.cern,https://root.cern/root/html602/TSpectrum2.html,2,['access'],['access']
Security,"ed peaks, peaks with amplitude less than; threshold*highest_peak/100 are ignored; backgroundRemove- background_remove-logical variable, true if the removal of; background before deconvolution is desired� ; deconIterations-number of iterations in; deconvolution operation; markov-logical variable, if it is true,; first the source spectrum is replaced by new spectrum calculated using Markov; chains method ; averWindow-width of; averaging smoothing window ;  ; References:; [1]; M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967), 309-320.; [2]; �M. Morh�č, J. Kliman, V.; Matou�ek, M. Veselsk�, I. Turzo.:Identification; of peaks in multidimensional coincidence gamma-ray spectra. NIM, A443 (2000); 108-125.; [3]; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM A 376; (1996), 451. . Examples of peak searching; method;  ; SearchHighRes function provides users with the possibility; to vary the input parameters and with the access to the output deconvolved data; in the destination spectrum. Based on the output data one can tune the; parameters. ; Example 8 � script Src.c:. Fig.; 20 Two-dimensional spectrum with found peaks denoted by markers (,; threshold=5%, 3 iterations steps in the deconvolution). Fig.; 21 Spectrum from Fig. 20 after background elimination and deconvolution; Script:; // Example to illustrate high resolution peak searching; function (class TSpectrum).; // To execute this example, do; // root > .x Src.C;  ; #include <TSpectrum2>;  ; void Src() {; �� Int_t i, j, nfound;; �� Double_t nbinsx = 64;; �� Double_t nbinsy = 64;�� ; �� Double_t xmin� = 0;; �� Double_t xmax� = (Double_t)nbinsx;; �� Double_t ymin� = 0;; �� Double_t ymax� = (Double_t)nbinsy;�� ; �� Float_t ** source = new float *[nbinsx];�� ; �� for (i=0;i<nbinsx;i++); ����������������������������������� source[i]=new; float[nbinsy];; �� Float_t ** dest = new float *[nbinsx];�� ; �� for (i=0;i<nb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2.html:38537,access,access,38537,root/html528/TSpectrum2.html,https://root.cern,https://root.cern/root/html528/TSpectrum2.html,4,['access'],['access']
Security,"ed remote file access classes, not a user callable option.; 234/// WEB | Used by derived remote http access class, not a user callable option.; 235/// READ_WITHOUT_GLOBALREGISTRATION | Used by TTreeProcessorMT, not a user callable option.; 236///; 237/// If option = """" (default), READ is assumed.; 238/// The file can be specified as a URL of the form:; 239///; 240/// file:///user/rdm/bla.root or file:/user/rdm/bla.root; 241///; 242/// The file can also be a member of an archive, in which case it is; 243/// specified as:; 244///; 245/// multi.zip#file.root or multi.zip#0; 246///; 247/// which will open file.root which is a member of the file multi.zip; 248/// archive or member 1 from the archive. For more on archive file; 249/// support see the TArchiveFile class.; 250/// TFile and its remote access plugins can also be used to open any; 251/// file, i.e. also non ROOT files, using:; 252///; 253/// file.tar?filetype=raw; 254///; 255/// This is convenient because the many remote file access plugins allow; 256/// easy access to/from the many different mass storage systems.; 257/// The title of the file (ftitle) will be shown by the ROOT browsers.; 258/// A ROOT file (like a Unix file system) may contain objects and; 259/// directories. There are no restrictions for the number of levels; 260/// of directories.; 261/// A ROOT file is designed such that one can write in the file in pure; 262/// sequential mode (case of BATCH jobs). In this case, the file may be; 263/// read sequentially again without using the file index written; 264/// at the end of the file. In case of a job crash, all the information; 265/// on the file is therefore protected.; 266/// A ROOT file can be used interactively. In this case, one has the; 267/// possibility to delete existing objects and add new ones.; 268/// When an object is deleted from the file, the freed space is added; 269/// into the FREE linked list (fFree). The FREE list consists of a chain; 270/// of consecutive free segments on the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:9927,access,access,9927,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['access'],['access']
Security,"ed result. ; Ownership is not transferred to the caller. Triggers event loop and execution of all actions booked in the associated RLoopManager. ; Definition at line 186 of file RResultPtr.hxx. ◆ GetPtr(). template<typename T > . T * ROOT::RDF::RResultPtr< T >::GetPtr ; (; ). inline . Get the pointer to the encapsulated object. ; Triggers event loop and execution of all actions booked in the associated RLoopManager. ; Definition at line 236 of file RResultPtr.hxx. ◆ GetValue(). template<typename T > . const T & ROOT::RDF::RResultPtr< T >::GetValue ; (; ). inline . Get a const reference to the encapsulated object. ; Triggers event loop and execution of all actions booked in the associated RLoopManager. ; Definition at line 228 of file RResultPtr.hxx. ◆ IsReady(). template<typename T > . bool ROOT::RDF::RResultPtr< T >::IsReady ; (; ); const. inline . Check whether the result has already been computed. ; auto res = df.Count();; res.IsReady(); // false, access will trigger event loop; std::cout << *res << std::endl; // triggers event loop; res.IsReady(); // true. Definition at line 386 of file RResultPtr.hxx. ◆ OnPartialResult(). template<typename T > . RResultPtr< T > & ROOT::RDF::RResultPtr< T >::OnPartialResult ; (; ULong64_t ; everyNEvents, . std::function< void(T &)> ; callback . ). inline . Register a callback that RDataFrame will execute ""everyNEvents"" on a partial result. ; Parameters. [in]everyNEventsFrequency at which the callback will be called, as a number of events processed ; [in]callbacka callable with signature void(Value_t&) where Value_t is the type of the value contained in this RResultPtr . Returnsthis RResultPtr, to allow chaining of OnPartialResultSlot with other calls; The callback must be a callable (lambda, function, functor class...) that takes a reference to the result type as argument and returns nothing. RDataFrame will invoke registered callbacks passing partial action results as arguments to them (e.g. a histogram filled with a part of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:8535,access,access,8535,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,1,['access'],['access']
Security,ed shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_t_extended; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_first!; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (wh,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNLLVar.html:37649,access,access,37649,root/html534/RooNLLVar.html,https://root.cern,https://root.cern/root/html534/RooNLLVar.html,1,['access'],['access']
Security,"ed to always use sync timer mode and only change period to adjust server reaction time. Use of async timer requires, that application regularly calls gSystem->ProcessEvents(). It happens automatically in ROOT interactive shell. If milliSec == 0, no timer will be created. In this case application should regularly call ProcessRequests() method.; Async timer allows to use THttpServer in applications, which does not have explicit gSystem->ProcessEvents() calls. But be aware, that such timer can interrupt any system call (like malloc) and can lead to dead locks, especially in multi-threaded applications. ; Definition at line 490 of file THttpServer.cxx. ◆ SetTopName(). void THttpServer::SetTopName ; (; const char * ; top). inline . set name of top item in objects hierarchy ; Definition at line 127 of file THttpServer.h. ◆ SetWSOnly(). void THttpServer::SetWSOnly ; (; Bool_t ; on = kTRUE). Set websocket-only mode. ; If true, server will only handle websockets connection plus serving file requests to access jsroot/ui5 scripts ; Definition at line 318 of file THttpServer.cxx. ◆ StopServerThread(). void THttpServer::StopServerThread ; (; ). protected . Stop server thread. ; Normally called shortly before http server destructor ; Definition at line 547 of file THttpServer.cxx. ◆ Streamer(). void THttpServer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void THttpServer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 198 of file THttpServer.h. ◆ SubmitHttp(). Bool_t THttpServer::SubmitHttp ; (; std::shared_ptr< THttpCallArg > ; arg, . Bool_t ; can_run_immediately = kFALSE . ). Submit HTTP request. ; Submit http request, specified in THttpCallArg structure.; Contrary to ExecuteHttp, it will not block calling thread. User should implement THttpCallArg::HttpReplied() method to react when HTTP request is executed. Method can be called from any th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:37280,access,access,37280,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['access'],['access']
Security,"ed to run GEANT3, GEANT4 and FLUKA-based simulations (*) by using directly a geometry described with ROOT.; The interface methods related to tracking are incorporated into TGeoManager class and implemented in the navigator class TGeoNavigator. In order to be able to start tracking, one has to define the initial state providing the starting point \(\vec{r_0}\) and direction \(\vec{n_0}\) . There are several ways of doing that.; 18.5.1 TGeoNavigator Class; One geometry may have several independent navigators to query to localize points or compute distances. The geometry manager holds a list of active navigators accessible via:; TObjArray *navigators = gGeoManager->GetListOfNavigators();; Upon closing the geometry a default navigator is provided as first one in this list, but one may add its own via:; TGeoNavigator *navig = new TGeoNavigator(gGeoManager);; // Store the index of the user navigator; Int_t inav = gGeoManager->AddNavigator(navig);; // Make its own navigator the active one; gGeoManager->SetCurrentNavigator(inav);; // Switch between navigators; gGeoManager->SetCurrentNavigator(0);; A navigator holds several variables describing the current navigation state: current point position, current direction distance to next boundary, isotropic safety, pointer to current and next nods as well as several tracking flags related to volume boundary conditions or other properties required for track propagation in geometry. Each geometry query affects these variables, so the only way in testing several navigation alternatives and remembering the active navigation state is to use parallel navigation. The following paragraphs will describe the usage of a single navigator. All setters/getters for navigation state parameters as well as navigation queries provided by TGeoNavigator are interfaced by TGeoManager and will act on the current navigator.; 18.5.2 Initializing the Starting Point; The current point (x,y,z) known by the modeller is stored as Double_t fCurrentPoint[3] by t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:972145,access,accessible,972145,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['accessible']
Security,"ed to the title icon; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiTitleIcon(const TGWindow* p, const TGWindow* titlebar, const TGPicture* pic, Int_t w, Int_t h); TGMdiTitleIcon constructor.; the TGMdiTitleIcon is the left icon used also for the MDI; popup menu allowing access to MDI commands as : restore,; move, size, minimize and close. ~TGMdiTitleIcon(); TGMdiTitleIcon destructor. void DoRedraw(); Redraw icon. Bool_t HandleDoubleClick(Event_t* event); Handle double click event on MDI icon (close the window). Bool_t HandleButton(Event_t* event); Handle button event on MDI icon (popup menu). TGPopupMenu * GetPopup() const; { return fPopup; }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMdiDecorFrame.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGMdiTitleIcon.html:17672,access,access,17672,root/html528/TGMdiTitleIcon.html,https://root.cern,https://root.cern/root/html528/TGMdiTitleIcon.html,1,['access'],['access']
Security,"ed to the title icon; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiTitleIcon(const TGWindow* p, const TGWindow* titlebar, const TGPicture* pic, Int_t w, Int_t h); TGMdiTitleIcon constructor.; the TGMdiTitleIcon is the left icon used also for the MDI; popup menu allowing access to MDI commands as : restore,; move, size, minimize and close. ~TGMdiTitleIcon(); TGMdiTitleIcon destructor. void DoRedraw(); Redraw icon. Bool_t HandleDoubleClick(Event_t* event); Handle double click event on MDI icon (close the window). Bool_t HandleButton(Event_t* event); Handle button event on MDI icon (popup menu). TGPopupMenu * GetPopup() const; { return fPopup; }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMdiDecorFrame.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGMdiTitleIcon.html:17772,access,access,17772,root/html530/TGMdiTitleIcon.html,https://root.cern,https://root.cern/root/html530/TGMdiTitleIcon.html,1,['access'],['access']
Security,"ed to the title icon; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGMdiTitleIcon(const TGWindow* p, const TGWindow* titlebar, const TGPicture* pic, Int_t w, Int_t h); TGMdiTitleIcon constructor.; the TGMdiTitleIcon is the left icon used also for the MDI; popup menu allowing access to MDI commands as : restore,; move, size, minimize and close. ~TGMdiTitleIcon(); TGMdiTitleIcon destructor. void DoRedraw(); Redraw icon. Bool_t HandleDoubleClick(Event_t* event); Handle double click event on MDI icon (close the window). Bool_t HandleButton(Event_t* event); Handle button event on MDI icon (popup menu). TGPopupMenu * GetPopup() const; { return fPopup; }. » Author: Bertrand Bellenot 20/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGMdiDecorFrame.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGMdiTitleIcon.html:17772,access,access,17772,root/html532/TGMdiTitleIcon.html,https://root.cern,https://root.cern/root/html532/TGMdiTitleIcon.html,1,['access'],['access']
Security,"ed via this TExec can be specified with:; - a call to the TExec constructor, if the constructor is called before; opening the file.; - a call to TExec::SetAction at any time.; One can compute a pointer to an existing TExec with a name with:; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand); where; - actionCommand is a string containing a CINT instruction. Examples:; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be; automatically executed. In the function/script being executed, one or more; of the following actions can be executed:; - load a file containing the referenced object. This function typically; looks in the file catalog (GRID).; - compute a pointer to the referenced object and communicate this pointer; back to the calling function TRef::GetObject via:; TRef::SetStaticObject(object).; When the TExec is called, it has access to the dereferencing TRef; by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this""; before the call to TExec). This can be useful for accessing the TRef's; fUniqueID.; As soon as an object is returned to GetObject, the fUniqueID of the TRef is set; to the fUniqueID of the referenced object. At the next call to GetObject,; the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is shown in $ROOTSYS/test/Event.h with; the member:; TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject; will automatically invoke a script GetWebHistogram.C via the interpreter.; An example of a GetWebHistogram.C script is shown below; void GetWebHistogram() {; TFile *f= TFile::Open(""http://root.cern.ch/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetStaticObject(h6);; }; In the above example, a call to fWebHistogram.GetObject() executes the; script with the funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRef.html:6685,access,access,6685,root/html528/TRef.html,https://root.cern,https://root.cern/root/html528/TRef.html,6,['access'],['access']
Security,"ed with files; hosted not only by Amazon S3 servers but also by other providers; implementing the core of the S3 protocol. The S3 protocol works on top of HTTPS (and HTTP) and imposes that; each HTTP request be signed using a specific convention: the request; must include an 'Authorization' header which contains the signature; of a concatenation of selected request fields. For signing the; request, an 'Access Key Id' and a 'Secret Access Key' need to be; known. These keys are used by the S3 servers to identify the client; and to authenticate the request as genuine. As an end user, you must know the Access Key and Secret Access Key; in order to access each S3 file. They are provided to you by your S3; service provider. Those two keys can be provided to ROOT when; initializing an object of this class by two means:; a) by using the environmental variables S3_ACCESS_KEY and; S3_SECRET_KEY, or; b) by specifying them when opening each file. The first method is convenient if all the S3 files you want to; access are hosted by a single provider. The second one is more; flexible as it allows you to specify which credentials to use; on a per-file basis. See the documentation of the constructor of; this class for details on the syntax. For generating and signing the HTTP request, this class uses; TS3HTTPRequest. For more information on the details of S3 protocol please refer to:; ""Amazon Simple Storage Service Developer Guide"":; http://docs.amazonwebservices.com/AmazonS3/latest/dev/Welcome.html. ""Amazon Simple Storage Service REST API Reference""; http://docs.amazonwebservices.com/AmazonS3/latest/API/APIRest.html. Function Members (Methods); public:. TS3WebFile(const char* url, Option_t* options = """"); virtual~TS3WebFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3WebFile.html:1506,access,access,1506,root/html534/TS3WebFile.html,https://root.cern,https://root.cern/root/html534/TS3WebFile.html,1,['access'],['access']
Security,"ed with files; hosted not only by Amazon S3 servers but also by other providers; implementing the core of the S3 protocol. The S3 protocol works on top of HTTPS (and HTTP) and imposes that; each HTTP request be signed using a specific convention: the request; must include an 'Authorization' header which contains the signature; of a concatenation of selected request fields. For signing the; request, an 'Access Key Id' and a 'Secret Access Key' need to be; known. These keys are used by the S3 servers to identify the client; and to authenticate the request as genuine. As an end user, you must know the Access Key and Secret Access Key; in order to access each S3 file. They are provided to you by your S3; service provider. Those two keys can be provided to ROOT when; initializing an object of this class by two means:; a) by using the environmental variables S3_ACCESS_KEY and; S3_SECRET_KEY, or; b) by specifying them when opening each file. The first method is convenient if all the S3 files you want to; access are hosted by a single provider. The second one is more; flexible as it allows you to specify which credentials to use; on a per-file basis. See the documentation of the constructor of; this class for details on the syntax. For generating and signing the HTTP request, this class uses; TS3HTTPRequest. For more information on the details of S3 protocol please refer to:; ""Amazon Simple Storage Service Developer Guide"":; http://docs.amazonwebservices.com/AmazonS3/latest/dev/Welcome.html. ""Amazon Simple Storage Service REST API Reference""; http://docs.amazonwebservices.com/AmazonS3/latest/API/APIRest.html. Function Members (Methods); public:. virtual~TS3WebFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:1530,access,access,1530,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,2,['access'],['access']
Security,"ed(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbose and help flags. { return fVerbose; }. Bool_t Help() const; { return fHelp; }. const TString& GetInternalVarName(Int_t ivar) const; ---------- protected event and tree accessors -----------------------------; names of input variables (if the original names are expressions, they are; transformed into regexps). { return (*fInputVars)[ivar]; }. const TString& GetOriginalVarName(Int_t ivar) const; { return DataInfo().GetVariableInfo(ivar).GetExpression(); }. Bool_t HasTrainingTree() const; { return Data()->GetNTrainingEvents() != 0; }. void MakeClassSpecific(ostream& , const TString& = """") const; ---------- protected auxiliary methods ------------------------------------; make ROOT-independent C++ class for classifier response (classifier-specific implementation). {}. void MakeClassSpecificHeader(ostream& , const TString& = """") const; header and auxiliary classes. {}. Bool_t TxtWeightsOnly() const; if TRUE, write weights only to text files. { return kTRUE; }. Float_t GetTWeight(const TMVA::Event* ev) const; access to event information that needs method-specific information. Bool_t IsConstructedFromWeightFile() const; { return fConstructedFromWeightFile; }. void SetCurrentEvent(Long64_t ievt) const. Data(). ECutOrientation GetCutOrientation() const; { return fCutOrientation; }. Bool_t IgnoreEventsWithNegWeightsInTraining() const; { return fIgnoreNegWeightsInTraining; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: MethodBase.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodBase.html:36645,access,access,36645,root/html532/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodBase.html,1,['access'],['access']
Security,"ed(Bool_t norm); { fNormalise = norm; }. Bool_t Verbose() const; set number of input variables (only used by MethodCuts, could perhaps be removed); void SetNvar( Int_t n ) { fNvar = n; }; verbose and help flags. { return fVerbose; }. Bool_t Help() const; { return fHelp; }. const TString& GetInternalVarName(Int_t ivar) const; ---------- protected event and tree accessors -----------------------------; names of input variables (if the original names are expressions, they are; transformed into regexps). { return (*fInputVars)[ivar]; }. const TString& GetOriginalVarName(Int_t ivar) const; { return DataInfo().GetVariableInfo(ivar).GetExpression(); }. Bool_t HasTrainingTree() const; { return Data()->GetNTrainingEvents() != 0; }. void MakeClassSpecific(ostream& , const TString& = """") const; ---------- protected auxiliary methods ------------------------------------; make ROOT-independent C++ class for classifier response (classifier-specific implementation). {}. void MakeClassSpecificHeader(ostream& , const TString& = """") const; header and auxiliary classes. {}. Bool_t TxtWeightsOnly() const; if TRUE, write weights only to text files. { return kTRUE; }. Float_t GetTWeight(const TMVA::Event* ev) const; access to event information that needs method-specific information. Bool_t IsConstructedFromWeightFile() const; { return fConstructedFromWeightFile; }. void SetCurrentEvent(Long64_t ievt) const. Data(). ECutOrientation GetCutOrientation() const; { return fCutOrientation; }. Bool_t IgnoreEventsWithNegWeightsInTraining() const; { return fIgnoreNegWeightsInTraining; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: MethodBase.h 40024 2011-06-27 17:02:37Z stelzer $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBase.html:36645,access,access,36645,root/html530/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBase.html,1,['access'],['access']
Security,"ed. The following named arguments are supported. Options to control construction of the chi^2. YVar(RooRealVar& yvar) -- Designate given column in dataset as Y value; Integrate(Bool_t flag) -- Integrate function over range specified by X errors; rather than take value at bin center. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a function and a dataset. RooFitResult* chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); Internal driver function for chi2 fits. void setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); Set evaluation error logging mode. Options are. PrintErrors - Print each error through RooMsgService() as it occurs; CollectErrors - Accumulate errors, but do not print them. A subsequent call; to printEvalErrors() will print a summary; CountErrors - Accumulate error count, but do not print them. void setParameterizeIntegral(const RooArgSet& paramVars). Double_t getVal(const RooArgSet* set = 0) const; Return value and unit accessors. Double_t getVal(const RooArgSet& set) const; { return _fast ? _value : getValV(&set) ; }. const Text_t * getUnit() const; Return string with unit description. void setUnit(const char* unit); Set unit description to given string. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Interface to force RooRealIntegral to offer given observable for internal integration; even if this is deemed unsafe. This default implementation returns always flase. void forceNumInt(Bool_t flag = kTRUE); If flag is true, all advertised analytical integrals will be ignored; and all integrals are calculated numerically. Bool_t getForceNumInt() const; { return _forceNumInt ; }. RooAbsReal* createIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:81650,access,accessors,81650,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,3,['access'],['accessors']
Security,"ed:. TMatrixD*_M; set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TVectorD*_frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TVectorD*_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo1DMomentMorphFunction.html:34476,validat,validate,34476,root/html602/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo1DMomentMorphFunction.html,4,"['access', 'validat']","['access', 'validate']"
Security,"ed:. set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Poi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddition.html:34184,validat,validate,34184,root/html602/RooAddition.html,https://root.cern,https://root.cern/root/html602/RooAddition.html,4,"['access', 'validat']","['access', 'validate']"
Security,"ed; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBinddnBind name; Bool_tfIsConnectedCurrent connection state; LDAP*fLdLDAP handle of current connection; TStringfPasswordPassword. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLDAPServer(const char* host, Int_t port = LDAP_PORT, const char* binddn = 0, const char* password = 0, Int_t version = LDAP_VERSION2); During construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLDAPServer.html:6532,password,password,6532,root/html528/TLDAPServer.html,https://root.cern,https://root.cern/root/html528/TLDAPServer.html,3,['password'],['password']
Security,"edList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); RooCacheManager<vector<double,allocator<double> > >(Int_t maxSize = 10); RooCacheManager<vector<double,allocator<double> > >(RooAbsArg* owner, Int_t maxSize = 10); RooCacheManager<vector<double,allocator<double> > >(const RooCacheManager<vector<double,allocator<double> > >& other, RooAbsArg* owner = 0); Int_tsetObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; vector<double,allocator<double> >**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0). Int_t setObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCacheManager_vector_double___.html:3086,access,accessed,3086,root/html528/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html528/RooCacheManager_vector_double___.html,1,['access'],['accessed']
Security,"edStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSystem; virtual Bool_t ConsistentWith (const char *path, void *dirptr=nullptr);  Check consistency of this helper with the one required by 'path' or 'dirptr'. ;  ; virtual void DoBeep (Int_t=-1, Int_t=-1) const;  ; virtual const char * ExpandFileName (const char *fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; virtual Bool_t ExpandFileName (TString &fname);  Expand a pathname getting rid of special shell characters like ~. ;  ; TSystem * FindHelper (const char *path, void *dirptr=nullptr);  Create helper TSystem to handle file and directory operations that might be special for remote file access. ;  ; TString & GetLastErrorString ();  Return the thread local storage for the custom last error message. ;  ; const TString & GetLastErrorString () const;  Return the thread local storage for the custom last error message. ;  ; virtual const char * GetLinkedLibraries ();  Get list of shared libraries loaded at the start of the executable. ;  ; virtual void SigAlarmInterruptsSyscalls (Bool_t);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Static Protected Member Functions inherited from TSystem; static const char * StripOffProto (const char *path, const char *proto);  Strip off protocol string from specified path. ;  ;  Protected Attributes inherited from TSystem; EAclicMode fAclicMode {kDefault};  ; Int_t fAclicProperties {0};  ; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheSystem.html:30960,access,access,30960,doc/master/classTDCacheSystem.html,https://root.cern,https://root.cern/doc/master/classTDCacheSystem.html,2,['access'],['access']
Security,"ed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBinddnBind name; Bool_tfIsConnectedCurrent connection state; LDAP*fLdLDAP handle of current connection; TStringfPasswordPassword. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLDAPServer(const char* host, Int_t port = LDAP_PORT, const char* binddn = 0, const char* password = 0, Int_t version = LDAP_VERSION2); During construction TLDAPServer object tries to connect to the; specified server and you should check the connection status by; calling the IsConnected() member function immediately after; creating that object.; const char *host: The name of host to connect. Default is ""localhost"".; Int_t port: Port number to connect. Default is LDAP_PORT (=389).; const char *binddn: Bind DN.; const char *password: Password. Usually you have to specify bind DN and; password to have the write permissions. Default; values for bind DN and password are zero, that means; anonymous connection. Usually it is enough to read; the data from the server.; Int_t version Set LDAP protocol version: LDAP_VERSION1,; LDAP_VERSION2, LDAP_VERSION3. TLDAPServer(const TLDAPServer& ); Copy constructor. TLDAPServer& operator=(const TLDAPServer& ); Equal operator. ~TLDAPServer(); If the object is connected to the server, it disconnects. Int_t Bind(); Binds to the server with specified binddn and password.; Return value: LDAP error code, 0 if successfully bound. void Unbind(); Unbinds from the server with specified binddn and password. const char * GetNamingContexts(); Performs an LDAPSearch with the attribute ""namingContexts"" to be; returned with the result. The value of this attribute is; extracted and returned as const char. const char * GetSubschemaSubentry(); Performs an LDAPSearch with the attribute ""subschemaSubentry"" to; be returned with the result. The value of this attribute is; extracted and returned as const char. TLDAPResult * GetObjectCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLDAPServer.html:6604,password,password,6604,root/html528/TLDAPServer.html,https://root.cern,https://root.cern/root/html528/TLDAPServer.html,3,['password'],['password']
Security,"ed_len = len64;; 6506 }; 6507 body = conn->buf + conn->request_len + conn->consumed_content;; 6508 memcpy(buf, body, (size_t)buffered_len);; 6509 len64 -= buffered_len;; 6510 conn->consumed_content += buffered_len;; 6511 nread += buffered_len;; 6512 buf = (char *)buf + buffered_len;; 6513 }; 6514 ; 6515 /* We have returned all buffered data. Read new data from the remote; 6516 * socket.; 6517 */; 6518 if ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {; 6519 conn->consumed_content += n;; 6520 nread += n;; 6521 } else {; 6522 nread = ((nread > 0) ? nread : n);; 6523 }; 6524 }; 6525 return (int)nread;; 6526}; 6527 ; 6528 ; 6529/* Forward declarations */; 6530static void handle_request(struct mg_connection *);; 6531static void log_access(const struct mg_connection *);; 6532 ; 6533 ; 6534/* Handle request, update statistics and call access log */; 6535static void; 6536handle_request_stat_log(struct mg_connection *conn); 6537{; 6538#if defined(USE_SERVER_STATS); 6539 struct timespec tnow;; 6540 conn->conn_state = 4; /* processing */; 6541#endif; 6542 ; 6543 handle_request(conn);; 6544 ; 6545 ; 6546#if defined(USE_SERVER_STATS); 6547 conn->conn_state = 5; /* processed */; 6548 ; 6549 clock_gettime(CLOCK_MONOTONIC, &tnow);; 6550 conn->processing_time = mg_difftimespec(&tnow, &(conn->req_time));; 6551 ; 6552 mg_atomic_add64(&(conn->phys_ctx->total_data_read), conn->consumed_content);; 6553 mg_atomic_add64(&(conn->phys_ctx->total_data_written),; 6554 conn->num_bytes_sent);; 6555#endif; 6556 ; 6557 DEBUG_TRACE(""%s"", ""handle_request done"");; 6558 ; 6559 if (conn->phys_ctx->callbacks.end_request != NULL) {; 6560 conn->phys_ctx->callbacks.end_request(conn, conn->status_code);; 6561 DEBUG_TRACE(""%s"", ""end_request callback done"");; 6562 }; 6563 log_access(conn);; 6564}; 6565 ; 6566 ; 6567#if defined(USE_HTTP2); 6568#if defined(NO_SSL); 6569#error ""HTTP2 requires ALPN, APLN requires SSL/TLS""; 6570#endif; 6571#define USE_ALPN; 6572#include ""mod_http2.inl""; 6573/* Not sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:190275,access,access,190275,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['access'],['access']
Security,"ed_len = len64;; 6507 }; 6508 body = conn->buf + conn->request_len + conn->consumed_content;; 6509 memcpy(buf, body, (size_t)buffered_len);; 6510 len64 -= buffered_len;; 6511 conn->consumed_content += buffered_len;; 6512 nread += buffered_len;; 6513 buf = (char *)buf + buffered_len;; 6514 }; 6515 ; 6516 /* We have returned all buffered data. Read new data from the remote; 6517 * socket.; 6518 */; 6519 if ((n = pull_all(NULL, conn, (char *)buf, (int)len64)) >= 0) {; 6520 conn->consumed_content += n;; 6521 nread += n;; 6522 } else {; 6523 nread = ((nread > 0) ? nread : n);; 6524 }; 6525 }; 6526 return (int)nread;; 6527}; 6528 ; 6529 ; 6530/* Forward declarations */; 6531static void handle_request(struct mg_connection *);; 6532static void log_access(const struct mg_connection *);; 6533 ; 6534 ; 6535/* Handle request, update statistics and call access log */; 6536static void; 6537handle_request_stat_log(struct mg_connection *conn); 6538{; 6539#if defined(USE_SERVER_STATS); 6540 struct timespec tnow;; 6541 conn->conn_state = 4; /* processing */; 6542#endif; 6543 ; 6544 handle_request(conn);; 6545 ; 6546 ; 6547#if defined(USE_SERVER_STATS); 6548 conn->conn_state = 5; /* processed */; 6549 ; 6550 clock_gettime(CLOCK_MONOTONIC, &tnow);; 6551 conn->processing_time = mg_difftimespec(&tnow, &(conn->req_time));; 6552 ; 6553 mg_atomic_add64(&(conn->phys_ctx->total_data_read), conn->consumed_content);; 6554 mg_atomic_add64(&(conn->phys_ctx->total_data_written),; 6555 conn->num_bytes_sent);; 6556#endif; 6557 ; 6558 DEBUG_TRACE(""%s"", ""handle_request done"");; 6559 ; 6560 if (conn->phys_ctx->callbacks.end_request != NULL) {; 6561 conn->phys_ctx->callbacks.end_request(conn, conn->status_code);; 6562 DEBUG_TRACE(""%s"", ""end_request callback done"");; 6563 }; 6564 log_access(conn);; 6565}; 6566 ; 6567 ; 6568#if defined(USE_HTTP2); 6569#if defined(NO_SSL); 6570#error ""HTTP2 requires ALPN, APLN requires SSL/TLS""; 6571#endif; 6572#define USE_ALPN; 6573#include ""mod_http2.inl""; 6574/* Not sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:190307,access,access,190307,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['access'],['access']
Security,"eds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; Bool_tfAWaitkTRUE if waiting at the async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for exchanging information; Int_tfByteCurcurrent position in the first buffer; Int_tfByteLeftbytes left in the first buffer; XrdProofConn*fConninstance of the underlying connection module; Bool_tfDontTimeoutIf true wait forever for incoming messages; TXHandler*fHandlerHandler of asynchronous events (input, error); TStringfHostRemote host; Bool_tfIForwardWheter the interrupt should be propagated; intfILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; intfSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t PickUpReady(); Manage asynchronous message. TXSockBuf * PopUpSpare(Int_t sz). void PushBackSpare(). void PostMsg(Int_t type, const char* msg = 0); Post a message into the queue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXSocket.html:11168,access,access,11168,root/html530/TXSocket.html,https://root.cern,https://root.cern/root/html530/TXSocket.html,2,['access'],['access']
Security,"educe the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if the number of; : adjustable weights is small compared to the training sample size,; : using a large number of training samples should not lead to overtraining.; : ; : <Suppress this messa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:43328,validat,validation,43328,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['validat'],['validation']
Security,"ee has a branch named ""MET"".; 327 ; 328Histo1D() is an *action*; it returns a smart pointer (a ROOT::RDF::RResultPtr, to be precise) to a TH1D histogram filled; 329with the `MET` of all events. If the quantity stored in the column is a collection (e.g. a vector or an array), the; 330histogram is filled with all vector elements for each event.; 331 ; 332You can use the objects returned by actions as if they were pointers to the desired results. There are many other; 333possible [actions](\ref cheatsheet), and all their results are wrapped in smart pointers; we'll see why in a minute.; 334 ; 335### Applying a filter; 336Let's say we want to cut over the value of branch ""MET"" and count how many events pass this cut. This is one way to do it:; 337~~~{.cpp}; 338RDataFrame d(""myTree"", ""file.root"");; 339auto c = d.Filter(""MET > 4."").Count(); // computations booked, not run; 340std::cout << *c << std::endl; // computations run here, upon first access to the result; 341~~~; 342The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event;; 343the name and types of the columns are inferred automatically. The string expression is required to return a `bool`; 344which signals whether the event passes the filter (`true`) or not (`false`).; 345 ; 346You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to; 347perform actions. Multiple Filter() calls can be chained one after another.; 348 ; 349Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return; 350statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small; 351runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or; 352runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet,; 353but it ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:20262,access,access,20262,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"ee has a branch named ""MET"".; 331 ; 332Histo1D() is an *action*; it returns a smart pointer (a ROOT::RDF::RResultPtr, to be precise) to a TH1D histogram filled; 333with the `MET` of all events. If the quantity stored in the column is a collection (e.g. a vector or an array), the; 334histogram is filled with all vector elements for each event.; 335 ; 336You can use the objects returned by actions as if they were pointers to the desired results. There are many other; 337possible [actions](\ref cheatsheet), and all their results are wrapped in smart pointers; we'll see why in a minute.; 338 ; 339### Applying a filter; 340Let's say we want to cut over the value of branch ""MET"" and count how many events pass this cut. This is one way to do it:; 341~~~{.cpp}; 342RDataFrame d(""myTree"", ""file.root"");; 343auto c = d.Filter(""MET > 4."").Count(); // computations booked, not run; 344std::cout << *c << std::endl; // computations run here, upon first access to the result; 345~~~; 346The filter string (which must contain a valid C++ expression) is applied to the specified columns for each event;; 347the name and types of the columns are inferred automatically. The string expression is required to return a `bool`; 348which signals whether the event passes the filter (`true`) or not (`false`).; 349 ; 350You can think of your data as ""flowing"" through the chain of calls, being transformed, filtered and finally used to; 351perform actions. Multiple Filter() calls can be chained one after another.; 352 ; 353Using string filters is nice for simple things, but they are limited to specifying the equivalent of a single return; 354statement or the body of a lambda, so it's cumbersome to use strings with more complex filters. They also add a small; 355runtime overhead, as ROOT needs to just-in-time compile the string into C++ code. When more freedom is required or; 356runtime performance is very important, a C++ callable can be specified instead (a lambda in the following snippet,; 357but it ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:20704,access,access,20704,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['access'],['access']
Security,"ee->Branch(branchname, &object, bufsize, splitlevel). Note: The 2nd parameter must be the address of a valid object.; The object must not be destroyed (i.e. be deleted) until the TTree; is deleted or TTree::ResetBranchAddress is called. * if splitlevel=0, the object is serialized in the branch buffer.; * if splitlevel=1 (default), this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; * if splitlevel=2 ,this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; it is processed as a TObject*, only one branch. ==> Case D. TBranch *branch = tree->Branch(branchname,clonesarray, bufsize, splitlevel); clonesarray is the address of a pointer to a TClonesArray.; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:6004,access,access,6004,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['access'],['access']
Security,"ee->Branch(branchname, &object, bufsize, splitlevel). Note: The 2nd parameter must be the address of a valid object.; The object must not be destroyed (i.e. be deleted) until the TTree; is deleted or TTree::ResetBranchAddress is called. * if splitlevel=0, the object is serialized in the branch buffer.; * if splitlevel=1 (default), this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; * if splitlevel=2 ,this branch will automatically be split; into subbranches, with one subbranch for each data member or object; of the object itself. In case the object member is a TClonesArray,; it is processed as a TObject*, only one branch. ==> Case D. TBranch *branch = tree->Branch(branchname,clonesarray, bufsize, splitlevel); clonesarray is the address of a pointer to a TClonesArray.; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. ==> Case E. TBranch *branch = tree->Branch( branchname, STLcollection, buffsize, splitlevel);; STLcollection is the address of a pointer to std::vector, std::list,; std::deque, std::set or std::multiset containing pointers to objects.; If the splitlevel is a value bigger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode. Ie. if it contains objects of; any types deriving from TTrack this function will sort the objects; basing on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:5615,access,access,5615,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['access'],['access']
Security,"eeID = 0 . ). constructor specifying the separation type, the min number of events in a no that is still subjected to further splitting, the number of bins in the grid used in applying the cut for the node splitting. ; Definition at line 150 of file DecisionTree.cxx. ◆ DecisionTree() [3/3]. TMVA::DecisionTree::DecisionTree ; (; const DecisionTree & ; d). copy constructor that creates a true copy, i.e. ; a completely independent tree the node copy will recursively copy all the nodes ; Definition at line 200 of file DecisionTree.cxx. ◆ ~DecisionTree(). TMVA::DecisionTree::~DecisionTree ; (; void ; ). virtual . destructor ; Definition at line 236 of file DecisionTree.cxx. Member Function Documentation. ◆ ApplyValidationSample(). void TMVA::DecisionTree::ApplyValidationSample ; (; const EventConstList * ; validationSample); const. run the validation sample through the (pruned) tree and fill in the nodes the variables NSValidation and NBValidadtion (i.e. ; how many of the Signal and Background events from the validation sample. This is then later used when asking for the ""tree quality"" .. ; Definition at line 1029 of file DecisionTree.cxx. ◆ BuildTree(). UInt_t TMVA::DecisionTree::BuildTree ; (; const EventConstList & ; eventSample, . DecisionTreeNode * ; node = nullptr . ). building the decision tree by recursively calling the splitting of one (root-) node into two daughter nodes (returns the number of nodes) ; Definition at line 377 of file DecisionTree.cxx. ◆ CheckEvent(). Double_t TMVA::DecisionTree::CheckEvent ; (; const TMVA::Event * ; e, . Bool_t ; UseYesNoLeaf = kFALSE . ); const. the event e is put into the decision tree (starting at the root node) and the output is NodeType (signal) or (background) of the final node (basket) in which the given events ends up. ; I.e. the result of the classification if the event for this decision tree. ; Definition at line 2690 of file DecisionTree.cxx. ◆ CheckEventWithPrunedTree(). void TMVA::DecisionTree::CheckEventWithPrunedTr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html:15313,validat,validation,15313,doc/master/classTMVA_1_1DecisionTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DecisionTree.html,1,['validat'],['validation']
Security,"eeded to recreate the current ...Definition TSystem.cxx:4205; TSystem::GetWorkingDirectoryvirtual std::string GetWorkingDirectory() constReturn working directory.Definition TSystem.cxx:879; TSystem::fSoExtTString fSoExtDefinition TSystem.h:313; TSystem::SetBuildDirvirtual void SetBuildDir(const char *build_dir, Bool_t isflat=kFALSE)Set the location where ACLiC will create libraries and use as a scratch area.Definition TSystem.cxx:4043; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::Abortvirtual void Abort(int code=0)Abort the application.Definition TSystem.cxx:725; TSystem::ProcessEventsvirtual Bool_t ProcessEvents()Process pending events (GUI, timers, sockets).Definition TSystem.cxx:416; TSystem::GetSoExtvirtual const char * GetSoExt() constGet the shared library extension.Definition TSystem.cxx:4013; TSystem::Utimevirtual int Utime(const char *file, Long_t modtime, Long_t actime)Set the a files modification and access times.Definition TSystem.cxx:1527; TSystem::GetErrorvirtual const char * GetError()Return system error string.Definition TSystem.cxx:254; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::GetFPEMaskvirtual Int_t GetFPEMask()Return the bitmap of conditions that trigger a floating point exception.Definition TSystem.cxx:632; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TSystem::StackTracevirtual void StackTrace()Print a stack trace.Definition TSystem.cxx:734; TSystem::GetUserInfovirtual UserGroup_t * GetUserInfo(Int_t uid)Returns all user info in the UserGroup_t structure.Definition TSystem.cxx:1601; TSystem::ResetSignalsvirtual void ResetSignals()Reset signals hand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:193654,access,access,193654,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['access'],['access']
Security,"ef. void OrtoNorm3(); Orto-norm columns 1 to 3. Double_t Invert(); Invert matrix.; Copied from ROOT's TMatrixFCramerInv. void Streamer(TBuffer& b); Stream an object of class TEveTrans. void Print(Option_t* option = """") const; Print in reasonable format. void SetFrom(Double_t* carr); Initialize from array. void SetFrom(const TGeoMatrix& mat); Initialize from TGeoMatrix. void SetGeoHMatrix(TGeoHMatrix& mat); Set TGeoHMatrix mat. void SetBuffer3D(TBuffer3D& buff); Fill transformation part TBuffer3D core section. Bool_t IsScale(Double_t low = 0.9, Double_t high = 1.1) const; Test if the transformation is a scale.; To be used by ROOT TGLObject descendants that potentially need to; use GL_NORMALIZE.; The low/high limits are expected to be squares of acutal limits. Ideally this should be done by the TGLViewer [but is not]. virtual ~TEveTrans(); {}. TEveTrans& operator=(const TEveTrans& t); { SetTrans(t); return *this; }. void operator*=(const TEveTrans& t); { MultRight(t); }. Double_t* Array(); Element access. Double_t* ArrX(). Double_t* ArrY(). Double_t* ArrZ(). Double_t* ArrT(). Double_t operator[](Int_t i) const; { return fM[i]; }. Double_t& operator[](Int_t i); { return fM[i]; }. Double_t CM(Int_t i, Int_t j) const; { return fM[4*j + i]; }. Double_t& CM(Int_t i, Int_t j); { return fM[4*j + i]; }. Double_t operator()(Int_t i, Int_t j) const; { return fM[4*j + i - 5]; }. Double_t& operator()(Int_t i, Int_t j); { return fM[4*j + i - 5]; }. Bool_t GetUseTrans() const; { return fUseTrans; }. void SetUseTrans(Bool_t v); { fUseTrans = v; }. void SetEditRotation(Bool_t x); { fEditRotation = x; }. void SetEditScale(Bool_t x); { fEditScale = x; }. Bool_t GetEditRotation(); { return fEditRotation; }. Bool_t GetEditScale(); { return fEditScale; }. Bool_t GetEditTrans() const; { return fEditTrans; }. void SetEditTrans(Bool_t v); { fEditTrans = v; }. » Last changed: root/eve:$Id: TEveTrans.h 32931 2010-04-09 16:29:40Z matevz $ » Last generated: 2010-09-23 20:04; This page has been au",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrans.html:16213,access,access,16213,root/html528/TEveTrans.html,https://root.cern,https://root.cern/root/html528/TEveTrans.html,1,['access'],['access']
Security,"ef. void OrtoNorm3(); Orto-norm columns 1 to 3. Double_t Invert(); Invert matrix.; Copied from ROOT's TMatrixFCramerInv. void Streamer(TBuffer& b); Stream an object of class TEveTrans. void Print(Option_t* option = """") const; Print in reasonable format. void SetFrom(Double_t* carr); Initialize from array. void SetFrom(const TGeoMatrix& mat); Initialize from TGeoMatrix. void SetGeoHMatrix(TGeoHMatrix& mat); Set TGeoHMatrix mat. void SetBuffer3D(TBuffer3D& buff); Fill transformation part TBuffer3D core section. Bool_t IsScale(Double_t low = 0.9, Double_t high = 1.1) const; Test if the transformation is a scale.; To be used by ROOT TGLObject descendants that potentially need to; use GL_NORMALIZE.; The low/high limits are expected to be squares of acutal limits. Ideally this should be done by the TGLViewer [but is not]. virtual ~TEveTrans(); {}. TEveTrans& operator=(const TEveTrans& t); { SetTrans(t); return *this; }. void operator*=(const TEveTrans& t); { MultRight(t); }. Double_t* Array(); Element access. Double_t* ArrX(). Double_t* ArrY(). Double_t* ArrZ(). Double_t* ArrT(). Double_t operator[](Int_t i) const; { return fM[i]; }. Double_t& operator[](Int_t i); { return fM[i]; }. Double_t CM(Int_t i, Int_t j) const; { return fM[4*j + i]; }. Double_t& CM(Int_t i, Int_t j); { return fM[4*j + i]; }. Double_t operator()(Int_t i, Int_t j) const; { return fM[4*j + i - 5]; }. Double_t& operator()(Int_t i, Int_t j); { return fM[4*j + i - 5]; }. Bool_t GetUseTrans() const; { return fUseTrans; }. void SetUseTrans(Bool_t v); { fUseTrans = v; }. void SetEditRotation(Bool_t x); { fEditRotation = x; }. void SetEditScale(Bool_t x); { fEditScale = x; }. Bool_t GetEditRotation(); { return fEditRotation; }. Bool_t GetEditScale(); { return fEditScale; }. Bool_t GetEditTrans() const; { return fEditTrans; }. void SetEditTrans(Bool_t v); { fEditTrans = v; }. » Last changed: root/eve:$Id: TEveTrans.h 32931 2010-04-09 16:29:40Z matevz $ » Last generated: 2011-07-04 15:27; This page has been au",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveTrans.html:16282,access,access,16282,root/html530/TEveTrans.html,https://root.cern,https://root.cern/root/html530/TEveTrans.html,1,['access'],['access']
Security,"ef. void OrtoNorm3(); Orto-norm columns 1 to 3. Double_t Invert(); Invert matrix.; Copied from ROOT's TMatrixFCramerInv. void Streamer(TBuffer& b); Stream an object of class TEveTrans. void Print(Option_t* option = """") const; Print in reasonable format. void SetFrom(Double_t* carr); Initialize from array. void SetFrom(const TGeoMatrix& mat); Initialize from TGeoMatrix. void SetGeoHMatrix(TGeoHMatrix& mat); Set TGeoHMatrix mat. void SetBuffer3D(TBuffer3D& buff); Fill transformation part TBuffer3D core section. Bool_t IsScale(Double_t low = 0.9, Double_t high = 1.1) const; Test if the transformation is a scale.; To be used by ROOT TGLObject descendants that potentially need to; use GL_NORMALIZE.; The low/high limits are expected to be squares of acutal limits. Ideally this should be done by the TGLViewer [but is not]. virtual ~TEveTrans(); {}. TEveTrans& operator=(const TEveTrans& t); { SetTrans(t); return *this; }. void operator*=(const TEveTrans& t); { MultRight(t); }. Double_t* Array(); Element access. Double_t* ArrX(). Double_t* ArrY(). Double_t* ArrZ(). Double_t* ArrT(). Double_t operator[](Int_t i) const; { return fM[i]; }. Double_t& operator[](Int_t i); { return fM[i]; }. Double_t CM(Int_t i, Int_t j) const; { return fM[4*j + i]; }. Double_t& CM(Int_t i, Int_t j); { return fM[4*j + i]; }. Double_t operator()(Int_t i, Int_t j) const; { return fM[4*j + i - 5]; }. Double_t& operator()(Int_t i, Int_t j); { return fM[4*j + i - 5]; }. Bool_t GetUseTrans() const; { return fUseTrans; }. void SetUseTrans(Bool_t v); { fUseTrans = v; }. void SetEditRotation(Bool_t x); { fEditRotation = x; }. void SetEditScale(Bool_t x); { fEditScale = x; }. Bool_t GetEditRotation(); { return fEditRotation; }. Bool_t GetEditScale(); { return fEditScale; }. Bool_t GetEditTrans() const; { return fEditTrans; }. void SetEditTrans(Bool_t v); { fEditTrans = v; }. » Last changed: root/eve:$Id: TEveTrans.h 32931 2010-04-09 16:29:40Z matevz $ » Last generated: 2011-11-03 20:12; This page has been au",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveTrans.html:16282,access,access,16282,root/html532/TEveTrans.html,https://root.cern,https://root.cern/root/html532/TEveTrans.html,1,['access'],['access']
Security,efCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of analytical integration codes; RooObjCacheManager_coefNormMgrCoefficient normalization manager; RooArgSet*_convNormSet! Subset of last normalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealProxy_convVarConvolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooRealProxy_modelOriginal model; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:42812,access,access,42812,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,1,['access'],['access']
Security,efTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TRuby Ruby/ROOT interface; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLColumnInfo Summury information about column from SQL table; TSQLMonitoringWriter Sending monitoring data to a SQL DB; TSQLResult SQL query result; TSQLRow One row of an SQL query result; TSQLServer Connection to SQL server; TSQLStatement SQL statement; TSQLTableInfo Summury information about SQL table; TSVDUnfold Data unfolding using Singular Value Decomposition (hep-ph/9509307) ; TSVG SVG driver; TSecContext Class providing host specific authentication information; TSecContextCleanup Update the remote authentication table; TSelector A utility class for tree and object processing; TSelectorCint A utility class for tree and object processing (interpreted version); TSelectorDraw A specialized TSelector for TTree::Draw; TSelectorEntries A specialized TSel,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:120129,authenticat,authentication,120129,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['authenticat'],['authentication']
Security,"efX; doublefY; doublefZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const ROOT::Math::PxPyPzM4D<double>::Scalar* src). Set internal data based on an array of 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar* dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fM; }. void SetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar px, ROOT::Math::PxPyPzM4D<double>::Scalar py, ROOT::Math::PxPyPzM4D<double>::Scalar pz, ROOT::Math::PxPyPzM4D<double>::Scalar m). Set internal data based on 4 Scalar numbers. void GetCoordinates(ROOT::Math::PxPyPzM4D<double>::Scalar& px, ROOT::Math::PxPyPzM4D<double>::Scalar& py, ROOT::Math::PxPyPzM4D<double>::Scalar& pz, ROOT::Math::PxPyPzM4D<double>::Scalar& m) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; m=fM;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar M() const; { return fM; }. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar E() const; other coordinate representation. Energy. { return std::sqrt(E2() ); }. Scalar T() const; { return E();}. Scalar P2() const. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared); In case of negative mass (spacelike particles return negative values). Scalar Mag2() const; { return M2(); }. Scalar Mag() const; { return M(); }. Scalar E2() const. energy squared. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html:5299,access,accessors,5299,root/html526/ROOT__Math__PxPyPzM4D_double_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__PxPyPzM4D_double_.html,5,['access'],['accessors']
Security,"efZ. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetCoordinates(const Scalar[] src). Set internal data based on an array of 4 Scalar numbers. { fX=src[0]; fY=src[1]; fZ=src[2]; fT=src[3]; }. void GetCoordinates(Scalar[] dest) const. get internal data into an array of 4 Scalar numbers. { dest[0] = fX; dest[1] = fY; dest[2] = fZ; dest[3] = fT; }. void SetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar px, ROOT::Math::PxPyPzE4D<double>::Scalar py, ROOT::Math::PxPyPzE4D<double>::Scalar pz, ROOT::Math::PxPyPzE4D<double>::Scalar e). Set internal data based on 4 Scalar numbers. { fX=px; fY=py; fZ=pz; fT=e;}. void GetCoordinates(ROOT::Math::PxPyPzE4D<double>::Scalar& px, ROOT::Math::PxPyPzE4D<double>::Scalar& py, ROOT::Math::PxPyPzE4D<double>::Scalar& pz, ROOT::Math::PxPyPzE4D<double>::Scalar& e) const. get internal data into 4 Scalar numbers. { px=fX; py=fY; pz=fZ; e=fT;}. Scalar Px() const; --------- Coordinates and Coordinate-like Scalar properties -------------; cartesian (Minkowski)coordinate accessors. { return fX;}. Scalar Py() const; { return fY;}. Scalar Pz() const; { return fZ;}. Scalar E() const; { return fT;}. Scalar X() const; { return fX;}. Scalar Y() const; { return fY;}. Scalar Z() const; { return fZ;}. Scalar T() const; { return fT;}. Scalar P2() const; other coordinate representation. squared magnitude of spatial components. { return fX*fX + fY*fY + fZ*fZ; }. Scalar P() const. magnitude of spatial components (magnitude of 3-momentum). { return std::sqrt(P2()); }. Scalar R() const; { return P(); }. Scalar M2() const. vector magnitude squared (or mass squared). { return fT*fT - fX*fX - fY*fY - fZ*fZ;}. Scalar Mag2() const; { return M2(); }. Scalar M() const. invariant mass. Scalar Mag() const; { return M(); }. Scalar Pt2() const. transverse spatial component squared. { return fX*fX + fY*fY;}. Scalar Perp2() const; { return Pt2();}. Scalar Pt() const. Transverse spatial component (P_perp or rho). { return s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__PxPyPzE4D_double_.html:4889,access,accessors,4889,root/html602/ROOT__Math__PxPyPzE4D_double_.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__PxPyPzE4D_double_.html,2,['access'],['accessors']
Security,"efaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html:8096,access,access,8096,root/html526/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,5,['access'],['access']
Security,"eference &other);; 71 void operator=(AFloat value);; 72 void operator+=(AFloat value);; 73 void operator-=(AFloat value);; 74};; 75 ; 76//____________________________________________________________________________; 77//; 78// Cuda Matrix; 79//____________________________________________________________________________; 80 ; 81/** TCudaMatrix Class; 82 *; 83 * The TCudaMatrix class represents matrices on a CUDA device. The elements; 84 * of the matrix are stored in a TCudaDeviceBuffer object which takes care of; 85 * the allocation and freeing of the device memory. TCudaMatrices are lightweight; 86 * object, that means on assignment and copy creation only a shallow copy is; 87 * performed and no new element buffer allocated. To perform a deep copy use; 88 * the static Copy method of the TCuda architecture class.; 89 *; 90 * The TCudaDeviceBuffer has an associated cuda stream, on which the data is; 91 * transferred to the device. This stream can be accessed through the; 92 * GetComputeStream member function and used to synchronize computations.; 93 *; 94 * The TCudaMatrix class also holds static references to CUDA resources.; 95 * Those are the cublas handle, a buffer of curand states for the generation; 96 * of random numbers as well as a vector containing ones, which is used for; 97 * summing column matrices using matrix-vector multiplication. The class also; 98 * has a static buffer for returning results from the device.; 99 *; 100 */; 101template<typename AFloat>; 102class TCudaMatrix; 103{; 104public:; 105 ; 106private:; 107 ; 108 static size_t fInstances; ///< Current number of matrix instances.; 109 static cublasHandle_t fCublasHandle;; 110 static AFloat * fDeviceReturn; ///< Buffer for kernel return values.; 111 static AFloat * fOnes; ///< Vector used for summations of columns.; 112 static size_t fNOnes; ///< Current length of the one vector.; 113 static curandState_t * fCurandStates;; 114 static size_t fNCurandStates;; 115 ; 116 ; 117 size_t fNRows;; 118 size",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/CudaMatrix_8h_source.html:3604,access,accessed,3604,doc/master/CudaMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/CudaMatrix_8h_source.html,1,['access'],['accessed']
Security,"eference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; List of all members ; TS3WebFile Class ReferenceInput/Output Library. ; A TS3WebFile is a TWebFile which retrieves the file contents from a web server implementing the REST API of the Amazon S3 protocol. ; This class is meant to be as generic as possible to be used with files hosted not only by Amazon S3 servers but also by other providers implementing the core of the S3 protocol.; The S3 protocol works on top of HTTPS (and HTTP) and imposes that each HTTP request be signed using a specific convention: the request must include an 'Authorization' header which contains the signature of a concatenation of selected request fields. For signing the request, an 'Access Key Id' and a 'Secret Access Key' need to be known. These keys are used by the S3 servers to identify the client and to authenticate the request as genuine.; As an end user, you must know the Access Key and Secret Access Key in order to access each S3 file. They are provided to you by your S3 service provider. Those two keys can be provided to ROOT when initializing an object of this class by two means: a. by using the environmental variables S3_ACCESS_KEY and S3_SECRET_KEY, or b. by specifying them when opening each file.; You can use AWS temporary security credentials (temporary access key and secret access key), but you must also give the associated session token. The token may be set in the S3_SESSION_TOKEN environmental variable, or on open in the TOKEN option.; The first method is convenient if all the S3 files you want to access are hosted by a single provider. The second one is more flexible as it allows you to specify which credentials to use on a per-file basis. See the documentation of the constructor of this class for details on the syntax.; For generating and signing the HTT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:1074,authenticat,authenticate,1074,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['authenticat'],['authenticate']
Security,"efinition MethodDL.h:272; TMVA::MethodDL::SetBatchHeightvoid SetBatchHeight(size_t batchHeight)Definition MethodDL.h:293; TMVA::MethodDL::GetInputHeightsize_t GetInputHeight() constDefinition MethodDL.h:256; TMVA::MethodDL::GetArchitectureStringTString GetArchitectureString() constDefinition MethodDL.h:278; TMVA::MethodDL::ParseBatchLayoutvoid ParseBatchLayout()Parse the input layout.Definition MethodDL.cxx:482; TMVA::MethodDL::ParseBatchNormLayervoid ParseBatchNormLayer(DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate reshape layer.Definition MethodDL.cxx:890; TMVA::MethodDL::ReadWeightsFromStreamvoid ReadWeightsFromStream(std::istream &)Definition MethodDL.cxx:2330; TMVA::MethodDL::ReadWeightsFromXMLvoid ReadWeightsFromXML(void *wghtnode)Definition MethodDL.cxx:2112; TMVA::MethodDL::fNumValidationStringTString fNumValidationStringThe string defining the number (or percentage) of training data used for validation.Definition MethodDL.h:199; TMVA::MethodDL::KeyValueVector_tstd::vector< std::map< TString, TString > > KeyValueVector_tDefinition MethodDL.h:93; TMVA::MethodDL::fOutputFunctionDNN::EOutputFunction fOutputFunctionThe output function for making the predictions.Definition MethodDL.h:189; TMVA::MethodDL::fWeightInitializationDNN::EInitialization fWeightInitializationThe initialization method.Definition MethodDL.h:188; TMVA::MethodDL::GetBatchDepthsize_t GetBatchDepth() constDefinition MethodDL.h:262; TMVA::MethodDL::ERecurrentLayerTypeERecurrentLayerTypeDefinition MethodDL.h:153; TMVA::MethodDL::kLayerLSTM@ kLayerLSTMDefinition MethodDL.h:153; TMVA::MethodDL::kLayerGRU@ kLayerGRUDefinition MethodDL.h:153; TMVA::MethodDL::kLayerRNN@ kLayerRNNDefinition MethodDL.h:153; TMVA::MethodDL::ParseRecurrentLayervoid ParseRecurrentLayer(ERecurrentLayerType type, DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:107690,validat,validation,107690,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['validat'],['validation']
Security,"efinition TEnv.cxx:793; TEnv::SetRcNamevirtual void SetRcName(const char *name)Definition TEnv.h:145; TEnv::ReadFilevirtual Int_t ReadFile(const char *fname, EEnvLevel level)Read and parse the resource file for a certain level.Definition TEnv.cxx:592; TEnv::SetValuevirtual void SetValue(const char *name, const char *value, EEnvLevel level=kEnvChange, const char *type=nullptr)Set the value of a resource or create a new resource.Definition TEnv.cxx:736; TEnv::Lookupvirtual TEnvRec * Lookup(const char *n) constLoop over all resource records and return the one with name.Definition TEnv.cxx:547; TEnv::Savevirtual void Save()Write the resource files for each level.Definition TEnv.cxx:649; TEnv::DefinedBool_t Defined(const char *name) constDefinition TEnv.h:141; TEnv::fIgnoreDupBool_t fIgnoreDupDefinition TEnv.h:129; TEnv::GetRcNamevirtual const char * GetRcName() constDefinition TEnv.h:144; TEnv::Getvalueconst char * Getvalue(const char *name) constReturns the character value for a named resource.Definition TEnv.cxx:441; TEnv::operator=TEnv & operator=(const TEnv &)=delete; TEnv::SaveLevelvirtual void SaveLevel(EEnvLevel level)Write the resource file for a certain level.Definition TEnv.cxx:664; TEnv::~TEnvvirtual ~TEnv()Delete the resource table.Definition TEnv.cxx:430; TEnv::TEnvTEnv(const TEnv &)=delete; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; TObjectMother of all ROOT objects.Definition TObject.h:41; TReadEnvParserDefinition TEnv.cxx:228; TStringBasic string class.Definition TString.h:139; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TWriteEnvParserDefinition TEnv.cxx:242; bool; int; nconst Int_t nDefinition legend1.C:16; v@ vDefinition rootcling_impl.cxx:3699; lTLine lDefinition textangle.C:4. corebaseincTEnv.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:03 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEnv_8h_source.html:12150,hash,hash,12150,doc/master/TEnv_8h_source.html,https://root.cern,https://root.cern/doc/master/TEnv_8h_source.html,2,['hash'],['hash']
Security,"efinition THashTable.h:35; TInterpreterValueDefinition TInterpreterValue.h:32; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::EReturnTypeEReturnTypeDefinition TInterpreter.h:80; TInterpreter::ECheckClassInfoECheckClassInfoDefinition TInterpreter.h:213; TInterpreter::FwdDeclArgsToKeepCollection_tstd::vector< std::pair< std::string, int > > FwdDeclArgsToKeepCollection_tDefinition TInterpreter.h:133; TInterpreter::DeclId_tTDictionary::DeclId_t DeclId_tDefinition TInterpreter.h:288; TInterpreter::EErrorCodeEErrorCodeDefinition TInterpreter.h:72; TListOfDataMembersA collection of TDataMember objects designed for fast access given a DeclId_t and for keep track of T...Definition TListOfDataMembers.h:33; TListOfEnumsA collection of TEnum objects designed for fast access given a DeclId_t and for keep track of TEnum t...Definition TListOfEnums.h:33; TListOfFunctionTemplatesA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctionTemplates.h:35; TListOfFunctionsA collection of TFunction objects designed for fast access given a DeclId_t and for keep track of TFu...Definition TListOfFunctions.h:35; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjectMother of all ROOT objects.Definition TObject.h:41; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TStringBasic string class.Definition TString.h:139; bool; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; ROOT::Math::IntegrationOneDim::TypeTypeenumeration specifying the integration types.Definition AllIntegrationTypes.h:32; nconst Int_t nDefinition legend1.C:16; ROOTtbb::task_arena is an alias of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:93497,access,access,93497,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['access'],['access']
Security,"efinition TObject.cxx:488; TObject::DrawClassvirtual void DrawClass() constDraw class inheritance tree of the class to which this object belongs.Definition TObject.cxx:295; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Comparevirtual Int_t Compare(const TObject *obj) constCompare abstract method.Definition TObject.cxx:244; TObject::~TObjectvirtual ~TObject()TObject destructor.Definition TObject.cxx:164; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::Paintvirtual void Paint(Option_t *option="""")This method must be overridden if a class wants to paint itself.Definition TObject.cxx:612; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::Popvirtual void Pop()Pop on object drawn in a pad to the top of the display list.Definition TObject.cxx:621; TObject::Hashvirtual ULong_t Hash() constReturn hash value for this object.Definition TObject.cxx:520; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::fgObjectStatstatic Bool_t fgObjectStatif true keep track of objects in TObjectTableDefinition TObject.h:48; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::kIsReferenced@ kIsReferencedif object is referenced by a TRef or TRefArrayDefinition TObject.h:65; TObject::kMustCleanup@ kMustCleanupif object destructor must call RecursiveRemove()Definition TObject.h:64; TObject::Readvirtual Int_t Read(const char *name)Read contents of object with specified name from the current directory.Definition TObject.cxx:654; TObject::AddToTObjectTablestatic void AddToTObjectTable(TObject *)Private helper function which will dispatch to TObjectTable::AddObj.Definition TObject.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:57049,hash,hash,57049,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['hash'],['hash']
Security,"efinition TStreamerElement.h:146; TStreamerElement::GetOffsetInt_t GetOffset() constDefinition TStreamerElement.h:119; TStreamerElement::IsBasevirtual Bool_t IsBase() constReturn kTRUE if the element represent a base class.Definition TStreamerElement.cxx:431; TStreamerSTLDefinition TStreamerElement.h:391; TStreamerSTL::Classstatic TClass * Class(); TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::kNPOSstatic constexpr Ssiz_t kNPOSDefinition TString.h:278; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::BeginsWithBool_t BeginsWith(const char *s, ECaseCompare cmp=kExact) constDefinition TString.h:623; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::Classstatic TClass * Class(); TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TViewPubDataMembersView implementing the TList interface and giving access all the TDictionary describing public data me...Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:367695,hash,hash,367695,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['hash'],['hash']
Security,"efinition TSystem.cxx:1725; TSystem::IsPathLocalvirtual Bool_t IsPathLocal(const char *path)Returns TRUE if the url in 'path' points to the local file system.Definition TSystem.cxx:1305; TSystem::mkdirvirtual int mkdir(const char *name, Bool_t recursive=kFALSE)Make a file system directory.Definition TSystem.cxx:906; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::ChangeDirectoryvirtual Bool_t ChangeDirectory(const char *path)Change directory.Definition TSystem.cxx:862; TSystem::Renamevirtual int Rename(const char *from, const char *to)Rename a file.Definition TSystem.cxx:1350; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::GetFlagsDebugvirtual const char * GetFlagsDebug() constReturn the debug flags.Definition TSystem.cxx:3927; TSystem::IsAbsoluteFileNamevirtual Bool_t IsAbsoluteFileName(const char *dir)Return true if dir is an absolute pathname.Definition TSystem.cxx:951; TSystem::GetObjExtvirtual const char * GetObjExt() constGet the object file extension.Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:249076,access,access,249076,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['access'],['access']
Security,"efinition TVirtualRWMutex.h:154; O_BINARY#define O_BINARYDefinition civetweb.c:912; snprintf#define snprintfDefinition civetweb.c:1540; ROOT::Detail::TSchemaRuleSet::TMatchesDefinition TSchemaRuleSet.h:29; ROOT::Detail::TSchemaRuleSet::FindRulesconst TMatches FindRules(const TString &source) constReturn all the rules that are about the given 'source' class.Definition TSchemaRuleSet.cxx:289; ROOT::Detail::TSchemaRuleSet::GetRulesconst TObjArray * GetRules() constDefinition TSchemaRuleSet.cxx:417; ROOT::Internal::RConcurrentHashColl::HashValueDefinition RConcurrentHashColl.hxx:36; ROOT::Internal::RConcurrentHashCollThis class is a thread-safe associative collection connecting a 256 bits digest/hash to a collection ...Definition RConcurrentHashColl.hxx:30; ROOT::Internal::RConcurrentHashColl::Insertbool Insert(const HashValue &hash, RUidColl &&coll) constIf the hash is there, return false.Definition RConcurrentHashColl.cxx:61; ROOT::Internal::RConcurrentHashColl::Hashstatic HashValue Hash(char *buf, int len)Return the hash object corresponding to the buffer.Definition RConcurrentHashColl.cxx:56; ROOT::Internal::RConcurrentHashColl::Findconst RUidColl * Find(const HashValue &hash) constReturn the collection of UID corresponding to the hash if the hash has already been seen or nullptr o...Definition RConcurrentHashColl.cxx:46; ROOT::TSchemaRuleDefinition TSchemaRule.h:20; ROOT::TSchemaRule::AsStringvoid AsString(TString &out, const char *options="""") constAdd to the string 'out' the string representation of the rule.Definition TSchemaRule.cxx:218; TArchiveFile::GetMemberNameconst char * GetMemberName() constDefinition TArchiveFile.h:56; TArchiveFile::SetCurrentMembervirtual Int_t SetCurrentMember()=0; TArchiveFile::GetArchiveNameconst char * GetArchiveName() constDefinition TArchiveFile.h:55; TArchiveFile::GetMemberTArchiveMember * GetMember() constDefinition TArchiveFile.h:51; TArchiveFile::Openstatic TArchiveFile * Open(const char *url, TFile *file)Return proper archive ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:199626,hash,hash,199626,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['hash'],['hash']
Security,"efinition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ; Definition at line 501 of file TClass.h. ◆ HasCustomStreamerMember(). Bool_t TClass::HasCustomStreamerMember ; (; ); const. inline . The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ; Definition at line 508 of file TClass.h. ◆ HasDataMemberInfo(). Bool_t TClass::HasDataMemberInfo ; (; ); const. inline . Definition at line 407 of file TClass.h. ◆ HasDefaultConstructor(). Bool_t TClass::HasDefaultConstructor ; (; Bool_t ; testio = kFALSE); const. Return true if we have access to a constructor usable for I/O. ; This is typically the default constructor but can also be a constructor specifically marked for I/O (for example a constructor taking a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7393 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:94082,access,access,94082,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['access'],['access']
Security,"efinition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ; Definition at line 501 of file TClass.h. ◆ HasCustomStreamerMember(). Bool_t TClass::HasCustomStreamerMember ; (; ); const. inline . The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ; Definition at line 508 of file TClass.h. ◆ HasDataMemberInfo(). Bool_t TClass::HasDataMemberInfo ; (; ); const. inline . Definition at line 407 of file TClass.h. ◆ HasDefaultConstructor(). Bool_t TClass::HasDefaultConstructor ; (; Bool_t ; testio = kFALSE); const. Return true if we have access to a constructor usable for I/O. ; This is typically the default constructor but can also be a constructor specifically marked for I/O (for example a constructor taking a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7460 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:94083,access,access,94083,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['access'],['access']
Security,"efinition at line 5233 of file TCling.cxx. ◆ Execute() [2/5]. void TCling::Execute ; (; TMethod * ; method, . TObjArray * ; params, . int * ; error = nullptr . ). inlinefinalprivatevirtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Implements TInterpreter.; Definition at line 628 of file TCling.h. ◆ Execute() [3/5]. void TCling::Execute ; (; TObject * ; obj, . TClass * ; cl, . const char * ; method, . const char * ; params, . Bool_t ; objectIsConst, . int * ; error = nullptr . ). Execute a method from class cl with arguments params. ; FIXME: The cint-based version of this code does not check if the SetFunc() call works, and does not do any real checking for errors from the Exec() call. It did fetch the most recent cint security error and return that in error, but this does not really translate well to cling/clang. We should enhance these interfaces so that we can report compilation and runtime errors properly. ; Definition at line 5257 of file TCling.cxx. ◆ Execute() [4/5]. void TCling::Execute ; (; TObject * ; obj, . TClass * ; cl, . const char * ; method, . const char * ; params, . int * ; error = nullptr . ). finalvirtual . Implements TInterpreter.; Definition at line 5277 of file TCling.cxx. ◆ Execute() [5/5]. void TCling::Execute ; (; TObject * ; obj, . TClass * ; cl, . TMethod * ; method, . TObjArray * ; params, . int * ; error = nullptr . ). finalvirtual . Execute a method from class cl with the arguments in array params (params[0] ... params[n] = array of TObjString parameters). ; Convert the TObjArray array of TObjString parameters to a character string of comma separated parameters. The parameters of type 'char' are enclosed in double quotes and all internal quotes are escaped. ; Implements TInterpreter.; Definition at l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:85281,secur,security,85281,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['secur'],['security']
Security,"eft); TGenCollectionProxy*TGenCollectionProxy::Initialize() const; virtual TGenCollectionProxy*TEmulatedCollectionProxy::InitializeEx(); voidTEmulatedCollectionProxy::ReadItems(int nElements, TBuffer& b); voidReadMap(int nElements, TBuffer& b); voidTEmulatedCollectionProxy::Shrink(UInt_t nCurr, UInt_t left, Bool_t force); voidTEmulatedCollectionProxy::WriteItems(int nElements, TBuffer& b); voidWriteMap(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEmulatedMapProxy.html:4533,access,accessors,4533,root/html528/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html528/TEmulatedMapProxy.html,4,['access'],['accessors']
Security,"egin{array}{ccc}; xx & xy & xz \\; yx & yy & yz \\; zx & zy & zz; \end{array}; \right|; \times; \left|; \begin{array}{c}; x \\; y \\; z; \end{array}; \right|; \]; TRotation r;; TVector3 v(1,1,1);; v = r * v;; You can also use the Transform() method or the operator *= of the TVector3 class:; TVector3 v;; TRotation r;; v.Transform(r);; 17.4 TLorentzVector; TLorentzVector is a general four-vector class, which can be used either for the description of position and time (x, y, z, t) or momentum and energy (px, py, pz, E).; 17.4.1 Declaration; TLorentzVector has been implemented as a set a TVector3 and a Double_t variable. By default, all components are initialized by zero.; TLorentzVector v1; // initialized by (0.,0.,0.,0.); TLorentzVector v2(1.,1.,1.,1.);; TLorentzVector v3(v1);; TLorentzVector v4(TVector3(1.,2.,3.),4.);; For backward compatibility there are two constructors from a Double_t and Float_t array.; 17.4.2 Access to Components; There are two sets of access functions to the components of a TLorentzVector: X(), Y(), Z(), T() and Px(), Py(), Pz() and E(). Both sets return the same values but the first set is more relevant for use where TLorentzVector describes a combination of position and time and the second set is more relevant where TLorentzVector describes momentum and energy:; Double_t xx =v.X();; ...; Double_t tt = v.T();; Double_t px = v.Px();; ...; Double_t ee = v.E();; The components of TLorentzVector can also accessed by index:; xx = v(0);orxx = v[0];; yy = v(1);yy = v[1];; zz = v(2);zz = v[2];; tt = v(3);tt = v[3];; You can use the Vect() method to get the vector component of TLorentzVector:; TVector3 p = v.Vect();; For setting components there are two methods: SetX(),.., SetPx(),..:; v.SetX(1.); orv.SetPx(1.);; ......; v.SetT(1.);v.SetE(1.);; To set more the one component by one call you can use the SetVect() function for the TVector3 part or SetXYZT(), SetPxPyPzE(). For convenience there is also a SetXYZM():; v.SetVect(TVector3(1,2,3));; v.SetXYZT(x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:866845,access,access,866845,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"egrals are supported. Double_t coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; Default implementation of function implementing advertised integrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset = 0, const char* rangeName = 0) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coefficient normalization access. Double_t coefficient(Int_t basisIndex) const. RooArgSet* parseIntegrationRequest(const RooArgSet& intSet, Int_t& coefCode, RooArgSet* analVars = 0) const. » Last changed: Thu Sep 23 19:58:03 2010 » Last generated: 2010-09-23 19:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:48139,access,access,48139,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,1,['access'],['access']
Security,"egrals. Only; the pass-through scenario (no integration) is implemented. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; This function forces RooRealIntegral to offer all integration dependents; to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; to hidden Jacobian terms). RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; but feed them to the resolution models integration interface, which will; make the final determination on how to integrate these dependents. Double_t getCoefNorm(Int_t coefIdx, const RooArgSet* nset, const TNamed* rangeName) const; Returns the normalization integral value of the coefficient with number coefIdx over normalization; set nset in range rangeName. void makeCoefVarList(RooArgList& ) const; Build complete list of coefficient variables. RooArgSet* coefVars(Int_t coefIdx) const; Return set of parameters with are used exclusively by the coefficient functions. void printMultiline(ostream& stream, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this object to the specified stream. In addition to the info; from RooAbsPdf::printStream() we add:. Verbose : detailed information on convolution integrals. void setCacheAndTrackHints(RooArgSet& ). Double_t getCoefNorm(Int_t coefIdx, const RooArgSet& nset, const char* rangeName) const; Coefficient normalization access. return getCoefNorm(coefIdx,&nset,rangeName); Returns normalization integral for coefficient coefIdx for observables nset in range rangeNae. Double_t coefficient(Int_t basisIndex) const. RooArgSet* parseIntegrationRequest(const RooArgSet& intSet, Int_t& coefCode, RooArgSet* analVars = 0) const. » Last changed: Sun Sep 6 17:24:18 2015 » Last generated: 2015-09-06 17:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsAnaConvPdf.html:53859,access,access,53859,root/html604/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html604/RooAbsAnaConvPdf.html,1,['access'],['access']
Security,"egy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleROOT::Math::Minimizer::Tolerance() const; static boolUseStaticMinuit(bool on = true); virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. voidDoClear(); voidDoReleaseFixParameter(int ivar); static voidFcn(int&, double*, double& f, double*, int); static voidFcnGrad(int&, double* g, double& f, double*, int); voidInitTMinuit(int ndim); voidRetrieveErrorMatrix(); voidRetrieveParams(). private:. TMinuitMinimizer(const TMinuitMinimizer&); TMinuitMinimizer&operator=(const TMinuitMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuitMinimizer.html:4988,validat,validated,4988,root/html528/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html528/TMinuitMinimizer.html,2,['validat'],['validated']
Security,"ehash=0);  Create a THashTable object. ;  ; virtual ~THashTable ();  Delete a hashtable. ;  ; void Add (TObject *obj) override;  Add object to the hash table. ;  ; void AddAll (const TCollection *col) override;  Add all objects from collection col to this collection. ;  ; void AddBefore (const TObject *before, TObject *obj);  Add object to the hash table. ;  ; Float_t AverageCollisions () const;  ; void Clear (Option_t *option="""") override;  Remove all objects from the table. ;  ; Int_t Collisions (const char *name) const;  Returns the number of collisions for an object with a certain name (i.e. ;  ; Int_t Collisions (TObject *obj) const;  Returns the number of collisions for an object (i.e. ;  ; void Delete (Option_t *option="""") override;  Remove all objects from the table AND delete all heap based objects. ;  ; Bool_t Empty () const;  ; TObject * FindObject (const char *name) const override;  Find object using its name. ;  ; TObject * FindObject (const TObject *obj) const override;  Find object using its hash value (returned by its Hash() member). ;  ; const TList * GetListForObject (const char *name) const;  Return the TList corresponding to object's name based hash value. ;  ; const TList * GetListForObject (const TObject *obj) const;  Return the TList corresponding to object's hash value. ;  ; TObject ** GetObjectRef (const TObject *obj) const override;  Return address of pointer to obj. ;  ; Int_t GetRehashLevel () const;  ; Int_t GetSize () const override;  Return the capacity of the collection, i.e. ;  ; TClass * IsA () const override;  ; TIterator * MakeIterator (Bool_t dir=kIterForward) const override;  Returns a hash table iterator. ;  ; virtual void Print (Option_t *option, const char *wildcard, Int_t recurse=1) const;  Print the collection header and its elements that match the wildcard. ;  ; virtual void Print (Option_t *option, Int_t recurse) const;  Print the collection header and its elements. ;  ; void Print (Option_t *option, Int_t recurse) const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashTable.html:1879,hash,hash,1879,doc/master/classTHashTable.html,https://root.cern,https://root.cern/doc/master/classTHashTable.html,1,['hash'],['hash']
Security,"eight=1.0);  constructor ;  ;  Event (const std::vector< Float_t > &values, const std::vector< Float_t > &targetValues, const std::vector< Float_t > &spectatorValues, UInt_t theClass=0, Double_t weight=1.0, Double_t boostweight=1.0);  constructor ;  ;  Event (const std::vector< Float_t > &values, const std::vector< Float_t > &targetValues, UInt_t theClass=0, Double_t weight=1.0, Double_t boostweight=1.0);  constructor ;  ;  ~Event ();  Event destructor. ;  ; void CopyVarValues (const Event &other);  copies only the variable values ;  ; Double_t GetBoostWeight () const;  ; UInt_t GetClass () const;  ; UInt_t GetNSpectators () const;  accessor to the number of spectators ;  ; UInt_t GetNTargets () const;  accessor to the number of targets ;  ; UInt_t GetNVariables () const;  accessor to the number of variables ;  ; Double_t GetOriginalWeight () const;  ; Float_t GetSpectator (UInt_t ivar) const;  return spectator content ;  ; std::vector< Float_t > & GetSpectators ();  ; const std::vector< Float_t > & GetSpectators () const;  ; Float_t GetTarget (UInt_t itgt) const;  ; std::vector< Float_t > & GetTargets ();  ; const std::vector< Float_t > & GetTargets () const;  ; Float_t GetValue (UInt_t ivar) const;  return value of i'th variable ;  ; Float_t GetValueFast (UInt_t ivar) const;  ; std::vector< Float_t > & GetValues ();  ; const std::vector< Float_t > & GetValues () const;  return value vector ;  ; Double_t GetWeight () const;  return the event weight - depending on whether the flag IgnoreNegWeightsInTraining is or not. ;  ; virtual TClass * IsA () const;  ; Bool_t IsDynamic () const;  ; Event & operator= (const Event &)=default;  ; virtual void Print (Option_t *option="""") const;  This method must be overridden when a class wants to print itself. ;  ; void Print (std::ostream &o) const;  print method ;  ; void ScaleBoostWeight (Double_t s) const;  ; void SetBoostWeight (Double_t w) const;  ; void SetClass (UInt_t t);  ; void SetDoNotBoost () const;  ; void SetSpectato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Event.html:1293,access,accessor,1293,doc/master/classTMVA_1_1Event.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Event.html,3,['access'],['accessor']
Security,"eive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [port] = is the remote port number; [service] = service name used to determine the port; (for backward compatibility, specification of; port as priority); options = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by; TSlave). An already opened connection can be used by passing its socket; in opensock. Example:. TSocket::CreateAuthSocket(""rootds://qwerty@machine.fq.dn:5051""). creates an authenticated socket to a rootd server running; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:19606,authenticat,authenticates,19606,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['authenticat'],['authenticates']
Security,"el and write them on file ;  mt101_fillNtuples.C Fill n-tuples in distinct workers ;  mt102_readNtuplesFillHistosAndFit.C Read n-tuples in distinct workers, fill histograms, merge them and fit ;  mt103_fillNtupleFromMultipleThreads.C Fill the same TNtuple from different threads ;  mt201_parallelHistoFill.C Parallel fill of a histogram ;  mt301_TTaskGroupSimple.C Shows how to run items of work asynchronously with a TTaskGroup ;  mt304_fillHistos.CFill histograms in parallel with automatic binning ;  mtbb001_fillHistos.C Fill histograms in parallel and write them on file ;  mtbb101_fillNtuples.C Fill n-tuples in distinct workers ;  mtbb201_parallelHistoFill.C Parallel fill of a histogram ;  ► net;  alien.C Example of use of the TAlien class (an implementation of TGrid) ;  authclient.CThis macro should be run together with authserv.C to test authentication between two remote ROOT sessions ;  authserv.CThis macro should be run together with authclient.C to test authentication between two remote ROOT sessions ;  fastMergeServer.CThis script shows how to make a simple iterative server that can receive TMemFile from multiple clients and merge them into a single file without block ;  hclient.CClient program which creates and fills a histogram ;  hclientbonj.CClient program which creates and fills a histogram ;  hcons.CHistogram consumer script ;  hprod.CHistogram producer script ;  hserv.CServer program which waits for two clients to connect ;  hserv2.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  hserv2bonj.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  LDAPExample.C;  parallelMergeClient.CClient program which creates and fills 2 histograms and a TTree ;  parallelMergeServer.CThis script shows how to make a simple iterative server that can accept connections while handling currently open connections ;  parallel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:140689,authenticat,authentication,140689,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['authenticat'],['authentication']
Security,"el than before.; 53 auto fullSpectrum =; 54 filteredEvents.Histo1D({""Spectrum"", ""Subset of CMS Run 2010B;#mu#mu mass [GeV];Events"", 1024, 2, 110}, ""m"");; 55 ; 56 // Next we will create the histogram for the J/psi particle, applying first; 57 // the corresponding cut.; 58 double jpsiLow = 2.95;; 59 double jpsiHigh = 3.25;; 60 auto jpsiCut = [jpsiLow, jpsiHigh](double m) { return m < jpsiHigh && m > jpsiLow; };; 61 auto jpsi =; 62 filteredEvents.Filter(jpsiCut, {""m""}); 63 .Histo1D({""jpsi"", ""Subset of CMS Run 2010B: J/#psi window;#mu#mu mass [GeV];Events"", 128, jpsiLow, jpsiHigh},; 64 ""m"");; 65 ; 66 // Finally we draw the two histograms side by side.; 67 auto dualCanvas = new TCanvas(""DualCanvas"", ""DualCanvas"", 800, 512);; 68 dualCanvas->Divide(2, 1);; 69 auto leftPad = dualCanvas->cd(1);; 70 leftPad->SetLogx();; 71 leftPad->SetLogy();; 72 fullSpectrum->DrawClone(""Hist"");; 73 dualCanvas->cd(2);; 74 jpsi->SetMarkerStyle(20);; 75 jpsi->DrawClone(""HistP"");; 76 ; 77 return 0;; 78}; c#define c(i)Definition RSha256.hxx:101; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TCanvasThe Canvas class.Definition TCanvas.h:23; TFile::Cpvirtual Bool_t Cp(const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000)Allows to copy this file to the dst URL.Definition TFile.cxx:5003; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; ROOT::RDF::FromCSVRDataFrame FromCSV(std::string_view fileName, bool readHeaders=true, char delimiter=',', Long64_t linesChunkSize=-1LL, std::unordered_map< std::string, char > &&colTypes={})Factory method to create a CSV RDataFrame.Definition RCsvDS.cxx:558; df014_CSVDataSourceDefinition df014_CSVDataSource.py:1; mTMarker mDefinition textangle.C:8. tutorialsdataframedf014_CSVDataSource.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df014__CSVDataSource_8C_source.html:3978,access,access,3978,doc/master/df014__CSVDataSource_8C_source.html,https://root.cern,https://root.cern/doc/master/df014__CSVDataSource_8C_source.html,2,['access'],['access']
Security,"eless by itself) for helper objects that extend TBranch's browsing support ;  CTVirtualCollectionIteratorsSmall helper class to generically acquire and release iterators ;  ►CTVirtualCollectionProxy;  CTPushPop;  ►CTVirtualCollectionPtrIterators;  CTInternalIterator;  CTVirtualDragManager;  CTVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms ;  CTVirtualFitterAbstract Base Class for Fitting ;  CTVirtualGeoPainter;  CTVirtualGeoTrack;  CTVirtualGLManip;  CTVirtualGLPainter;  CTVirtualGraphPainterAbstract interface to a histogram painter ;  CTVirtualHistPainterAbstract interface to a histogram painter ;  CTVirtualIndexAbstract interface for Tree Index ;  CTVirtualIsAProxy;  CTVirtualMagField;  CTVirtualMC;  CTVirtualMCApplication;  CTVirtualMCDecayer;  CTVirtualMCGeometry;  CTVirtualMCStack;  CTVirtualMonitoringReader;  CTVirtualMonitoringWriter;  CTVirtualMutexThis class implements a mutex interface ;  CTVirtualObjectWrapper around an object and giving indirect access to its content even if the object is not of a class in the Cint/Reflex dictionary ;  ►CTVirtualPacketizer;  CTVirtualSlaveStat;  CTVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes ;  CTVirtualPadEditorAbstract base class used by ROOT graphics editor ;  CTVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas ;  CTVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing ;  CTVirtualProofPlayer;  CTVirtualPSTVirtualPS is an abstract interface to Postscript, PDF, SVG ;  CTVirtualRefProxy;  CTVirtualStreamerInfoAbstract Interface class describing Streamer information for one class ;  CTVirtualTableInterface;  CTVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan, Process, MakeProxy, etc ;  CTVirtualVectorIterators;  CTVirtualViewer3DAbstract 3D shapes viewer ;  CTVirtualXSemi-Abstract base class defining a generic interface to the underl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:164235,access,access,164235,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['access'],['access']
Security,"elete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGenCollectionProxy.html:3877,access,accessors,3877,root/html532/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html,2,['access'],['accessors']
Security,"elete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash ta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashTable.html:8667,hash,hashtable,8667,root/html528/THashTable.html,https://root.cern,https://root.cern/root/html528/THashTable.html,3,['hash'],['hashtable']
Security,"elete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection. private:. TList**fContHash table (table of lists); Int_tfEntriesNumber of objects in table; Int_tfRehashLevelAverage collision rate which triggers rehash; Int_tfUsedSlotsNumber of used slots. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THashTable(Int_t capacity = TCollection::kInitHashTableCapacity, Int_t rehash = 0); Create a THashTable object. Capacity is the initial hashtable capacity; (i.e. number of slots), by default kInitHashTableCapacity = 17, and; rehashlevel is the value at which a rehash will be triggered. I.e. when; the average size of the linked lists at a slot becomes longer than; rehashlevel then the hashtable will be resized and refilled to reduce; the collision rate to about 1. The higher the collision rate, i.e. the; longer the linked lists, the longer lookup will take. If rehashlevel=0; the table will NOT automatically be rehashed. Use Rehash() for manual; rehashing. ~THashTable(); Delete a hashtable. Objects are not deleted unless the THashTable is the; owner (set via SetOwner()). void Add(TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function. void AddBefore(const TObject* before, TObject* obj); Add object to the hash table. Its position in the table will be; determined by the value returned by its Hash() function.; If and only if 'before' is in the same bucket as obj, obj is added; in front of 'before' within the bucket's list. void AddAll(const TCollection* col); Add all objects from collection col to this collection.; Implemented for more efficient rehashing. void Clear(Option_t* optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THashTable.html:8875,hash,hashtable,8875,root/html534/THashTable.html,https://root.cern,https://root.cern/root/html534/THashTable.html,1,['hash'],['hashtable']
Security,"elper helper;; 142 std::string dotGraph = helper.RepresentGraph(node);; 143 ; 144 std::ofstream out(outputFile);; 145 if (!out.is_open()) {; 146 throw std::runtime_error(""Could not open output file \"""" + outputFile + ""\""for reading"");; 147 }; 148 ; 149 out << dotGraph;; 150 out.close();; 151}; 152 ; 153// clang-format off; 154/// Cast a RDataFrame node to the common type ROOT::RDF::RNode; 155/// \param[in] node Any node of a RDataFrame graph; 156// clang-format on; 157template <typename NodeType>; 158RNode AsRNode(NodeType node); 159{; 160 return node;; 161}; 162 ; 163// clang-format off; 164/// Trigger the event loop of multiple RDataFrames concurrently; 165/// \param[in] handles A vector of RResultHandles; 166/// \return The number of distinct computation graphs that have been processed; 167///; 168/// This function triggers the event loop of all computation graphs which relate to the; 169/// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; 170/// RResultPtr is that the event loops will run concurrently. Therefore, the overall; 171/// computation of all results is generally more efficient.; 172/// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; 173///; 174/// ~~~{.cpp}; 175/// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; 176/// auto r1 = df1.Histo1D(""var1"");; 177///; 178/// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; 179/// auto r2 = df2.Sum(""var2"");; 180///; 181/// // RResultPtr -> RResultHandle conversion is automatic; 182/// ROOT::RDF::RunGraphs({r1, r2});; 183/// ~~~; 184// clang-format on; 185unsigned int RunGraphs(std::vector<RResultHandle> handles);; 186 ; 187namespace Experimental {; 188 ; 189/// \brief Produce all required systematic variations for the given result.; 190/// \param[in] resPtr The result for which variations should be produced.; 191/// \return A \ref ROOT::RDF::Experimental::RResul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDFHelpers_8hxx_source.html:7488,access,accessing,7488,doc/master/RDFHelpers_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RDFHelpers_8hxx_source.html,1,['access'],['accessing']
Security,"em directly from Python.; 19.1.8.2 Fitting Histograms; Fitting a histogram with a Python function is no more difficult than plotting: instantiate a TF1 with the Python callable and supply that TF1 as a parameter to the Fit() member function of the histogram. After the fit, you can retrieve the fit parameters from the TF1 instance. For example:; from ROOT import TF1, TH1F, TCanvas. class Linear:; def __call__( self, x, par ):; return par[0] + x[0]*par[1]. # create a linear function for fitting; f = TF1('pyf3',Linear(),-1.,1.,2). # create and fill a histogram; h = TH1F('h','test',100,-1.,1.); f2 = TF1('cf2','6.+x*4.5',-1.,1.); h.FillRandom('cf2',10000). # fit the histo with the python 'linear' function; h.Fit(f). # print results; par = f.GetParameters(); print('fit results: const =', par[0], ',pitch =', par[1]); 19.1.9 Working with Trees; Next to making histograms, working with trees is probably the most common part of any analysis. The TTree implementation uses pointers and dedicated buffers to reduce the memory usage and to speed up access. Consequently, mapping TTree functionality to Python is not straightforward, and most of the following features are implemented in ROOT release 4.01/04 and later only, whereas you will need 5.02 if you require all of them.; 19.1.9.1 Accessing an Existing Tree; Let us assume that you have a file containing TTrees, TChains, or TNtuples and want to read the contents for use in your analysis code. This is commonly the case when you work with the result of the reconstruction software of your experiment (e.g. the combined ntuple in ATLAS). The following example code outlines the main steps (you can run it on the result of the tree1.C macro):; from ROOT import TFile. # open the file; myfile = TFile('tree1.root'). # retrieve the ntuple of interest; mychain = myfile.Get('t1'); entries = mychain.GetEntriesFast(). for jentry in xrange(entries):; # get the next tree in the chain and verify; ientry = mychain.LoadTree(jentry); if ientry < 0:; b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1068646,access,access,1068646,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"em error. Int_t ClearAuth(TString& user, TString& passwd, Bool_t& pwhash); UsrPwd client authentication code.; Returns 0 in case authentication failed; 1 in case of success. THostAuth * GetHostAuth(const char* host, const char* user = """", Option_t* opt = ""R"", Int_t* Exact = 0); Sets fUser=user and search fgAuthInfo for the entry pertaining to; (host,user), setting fHostAuth accordingly.; If opt = ""P"" use fgProofAuthInfo list instead; If no entry is found fHostAuth is not changed. THostAuth * HasHostAuth(const char* host, const char* user, Option_t* opt = ""R""); Checks if a THostAuth with exact match for {host,user} exists; in the fgAuthInfo list; If opt = ""P"" use ProofAuthInfo list instead; Returns pointer to it or 0. void FileExpand(const char* fin, FILE* ftmp); Expands include directives found in fexp files; The expanded, temporary file, is pointed to by 'ftmp'; and should be already open. To be called recursively. char * GetDefaultDetails(Int_t method, Int_t opt, const char* user); Determine default authentication details for method 'sec' and user 'usr'.; Checks .rootrc family files. Returned string must be deleted by the user. void RemoveHostAuth(THostAuth* ha, Option_t* opt = """"); Remove THostAuth instance from the list. void Show(Option_t* opt = ""S""); Print info about the authentication sector.; If 'opt' contains 's' or 'S' prints information about established TSecContext,; else prints information about THostAuth (if 'opt' is 'p' or 'P', prints; Proof related information). Int_t AuthExists(TString User, Int_t method, const char* Options, Int_t* Message, Int_t* Rflag, CheckSecCtx_t funcheck); Check if we have a valid established sec context in memory; Retrieves relevant info and negotiates with server.; options = ""Opt,strlen(username),username.Data()""; message = kROOTD_USER, ... void InitRandom(); Initialize random machine using seed from /dev/urandom; (or current time if /dev/urandom not available). Int_t GenRSAKeys(); Generate a valid pair of private/public RSA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAuthenticate.html:18501,authenticat,authentication,18501,root/html526/TAuthenticate.html,https://root.cern,https://root.cern/root/html526/TAuthenticate.html,7,['authenticat'],['authentication']
Security,"em.cxx. ◆ Unlink(). int TSystem::Unlink ; (; const char * ; name). virtual . Unlink, i.e. ; remove, a file.; If the file is currently open by the current or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name, while Windows does not allow the file to be deleted and the operation is a no-op). ; Reimplemented in TUnixSystem, TWinNTSystem, TDavixSystem, TNetSystem, TWebSystem, and TNetXNGSystem.; Definition at line 1381 of file TSystem.cxx. ◆ Unload(). void TSystem::Unload ; (; const char * ; module). virtual . Unload a shared library. ; Reimplemented in TUnixSystem.; Definition at line 2052 of file TSystem.cxx. ◆ Unsetenv(). void TSystem::Unsetenv ; (; const char * ; name). virtual . Unset environment variable. ; Reimplemented in TUnixSystem.; Definition at line 1657 of file TSystem.cxx. ◆ Utime(). int TSystem::Utime ; (; const char * ; file, . Long_t ; modtime, . Long_t ; actime . ). virtual . Set the a files modification and access times. ; If actime = 0 it will be set to the modtime. Returns 0 on success and -1 in case of error. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1527 of file TSystem.cxx. ◆ Which(). char * TSystem::Which ; (; const char * ; search, . const char * ; wfil, . EAccessMode ; mode = kFileExists . ). virtual . Find location of file in a search path. ; User must delete returned string. Returns 0 in case file is not found. ; Definition at line 1548 of file TSystem.cxx. ◆ WorkingDirectory(). const char * TSystem::WorkingDirectory ; (; ). virtual . Return working directory. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 871 of file TSystem.cxx. Member Data Documentation. ◆ fAclicMode. EAclicMode TSystem::fAclicMode {kDefault}. protected . Definition at line 315 of file TSystem.h. ◆ fAclicProperties. Int_t TSystem::fAclicProperties {0}. protected . Definition at line 319 of file TSystem.h. ◆ fBeepDuration. Int_t TSystem::fBeepDuratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:96872,access,access,96872,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['access'],['access']
Security,"em::Symlink ; (; const char * ; from, . const char * ; to . ). overridevirtual . Create a symlink from file1 to file2. ; Returns 0 when successful, -1 in case of failure. ; Reimplemented from TSystem.; Definition at line 1695 of file TUnixSystem.cxx. ◆ Syslog(). void TUnixSystem::Syslog ; (; ELogLevel ; level, . const char * ; mess . ). overridevirtual . Send mess to syslog daemon. ; Level is the logging level and mess the message that will be written on the log. ; Reimplemented from TSystem.; Definition at line 2654 of file TUnixSystem.cxx. ◆ TempDirectory(). const char * TUnixSystem::TempDirectory ; (; ); const. overridevirtual . Return a user configured or systemwide directory to create temporary files in. ; Reimplemented from TSystem.; Definition at line 1503 of file TUnixSystem.cxx. ◆ TempFileName(). FILE * TUnixSystem::TempFileName ; (; TString & ; base, . const char * ; dir = nullptr, . const char * ; suffix = nullptr . ). overridevirtual . Create a secure temporary file by appending a unique 6 letter string to base. ; The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension "".txt"" or "".html"". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error. ; Reimplemented from TSystem.; Definition at line 1523 of file TUnixSystem.cxx. ◆ Umask(). int TUnixSystem::Umask ; (; Int_t ; mask). overridevirtual . Set the process file creation mode mask. ; Reimplemented from TSystem.; Definition at line 1901 of file TUnixSystem.cxx. ◆ UnixFilestat(). int TUnixSystem::UnixFilestat ; (; const char * ; fpath, . FileStat_t & ; buf . ). staticprotected . Get info about a file. ; Info is returned in the form of a FileStat_t structure (see TSystem.h). The function returns 0 in case of success and 1 if the file could not be stat'ed. ; Definition at line 4039 of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:70699,secur,secure,70699,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['secur'],['secure']
Security,"em::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC; TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheSystem.html:16460,access,access,16460,root/html526/TDCacheSystem.html,https://root.cern,https://root.cern/root/html526/TDCacheSystem.html,1,['access'],['access']
Security,"em::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tTNetSystem::fIsLocalTRUE if the path points to this host; TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTNetSystem::fLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetSystem.html:17439,access,access,17439,root/html528/TXNetSystem.html,https://root.cern,https://root.cern/root/html528/TXNetSystem.html,3,['access'],['access']
Security,"emaRuleSet&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConsistencyCheck { kNoCheck; kCheckAll; kCheckConflict; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArray*fAllRules! Array of all rules; UInt_tfCheckSumTarget class checksum; TClassReffClass! Target class pointer (for consistency checking); TStringfClassNameTarget class name; TObjArray*fPersistentRulesArray of the rules that will be embeded in the file; TObjArray*fRemainingRules! Array of non-persisten rules - just for cleanup purposes - owns the elements; Int_tfVersionTarget class version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRuleSet(). virtual ~TSchemaRuleSet(). Bool_t AddRule(ROOT::TSchemaRule* rule, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll). Bool_t AddRules(ROOT::TSchemaRuleSet* rules, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll). Bool_t HasRuleWithSourceClass(const TString& source) const. const TObjArray* FindRules(const TString& source) const. const TSchemaMatch* FindRules(const TString& source, Int_t version) const. const TSchemaMatch* FindRules(const TString& source, UInt_t checksum) const. const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const. TClass* GetClass(). UInt_t GetClassCheckSum() const. TString GetClassName()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__TSchemaRuleSet.html:6130,checksum,checksum,6130,root/html528/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html528/ROOT__TSchemaRuleSet.html,1,['checksum'],['checksum']
Security,"emaRuleSet&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConsistencyCheck { kNoCheck; kCheckAll; kCheckConflict; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArray*fAllRules! Array of all rules; UInt_tfCheckSumTarget class checksum; TClassReffClass! Target class pointer (for consistency checking); TStringfClassNameTarget class name; TObjArray*fPersistentRulesArray of the rules that will be embeded in the file; TObjArray*fRemainingRules! Array of non-persisten rules - just for cleanup purposes - owns the elements; Int_tfVersionTarget class version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRuleSet(). virtual ~TSchemaRuleSet(). Bool_t AddRule(ROOT::TSchemaRule* rule, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll, TString* errmsg = 0). Bool_t AddRules(ROOT::TSchemaRuleSet* rules, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll, TString* errmsg = 0). Bool_t HasRuleWithSourceClass(const TString& source) const. const TObjArray* FindRules(const TString& source) const. const TSchemaMatch* FindRules(const TString& source, Int_t version) const. const TSchemaMatch* FindRules(const TString& source, UInt_t checksum) const. const TSchemaMatch* FindRules(const TString& source, Int_t version, UInt_t checksum) const. TClass* GetClass(). UInt_t GetCla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__TSchemaRuleSet.html:6243,checksum,checksum,6243,root/html530/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaRuleSet.html,2,['checksum'],['checksum']
Security,"emaRuleSet&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConsistencyCheck { kNoCheck; kCheckAll; kCheckConflict; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TObjArray*fAllRules! Array of all rules; UInt_tfCheckSumTarget class checksum; TClassReffClass! Target class pointer (for consistency checking); TStringfClassNameTarget class name; TObjArray*fPersistentRulesArray of the rules that will be embeded in the file; TObjArray*fRemainingRules! Array of non-persisten rules - just for cleanup purposes - owns the elements; Int_tfVersionTarget class version. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSchemaRuleSet(); Default constructor. ~TSchemaRuleSet(); Destructor. void ls(Option_t* option = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump(). Bool_t AddRules(ROOT::TSchemaRuleSet* rules, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll, TString* errmsg = 0). Bool_t AddRule(ROOT::TSchemaRule* rule, ROOT::TSchemaRuleSet::EConsistencyCheck checkConsistency = kCheckAll, TString* errmsg = 0); The consistency check always fails if the TClass object was not set!; if checkConsistency is:; kNoCheck: no check is done, register the rule as is; kCheckConflict: check only for conflicting rules; kCheckAll: check for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__TSchemaRuleSet.html:6286,checksum,checksum,6286,root/html534/ROOT__TSchemaRuleSet.html,https://root.cern,https://root.cern/root/html534/ROOT__TSchemaRuleSet.html,1,['checksum'],['checksum']
Security,"ember Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Private Types |; Private Member Functions |; Private Attributes |; List of all members ; TDataMember Class Reference. ; All ROOT classes may have RTTI (run time type identification) support added. ; The data is stored in so called DICTIONARY (look at TDictionary). Information about a class is stored in TClass. This information may be obtained via the cling api - see class TCling. TClass has a list of TDataMember objects providing information about all data members of described class. TDataMember provides information about name of data member, its type, and comment field string. It also tries to find the TMethodCall objects responsible for getting/setting a value of it, and gives you pointers to these methods. This gives you a unique possibility to access protected and private (!) data members if only methods for doing that are defined.; These methods could either be specified in a comment field, or found out automatically by ROOT: here's an example: suppose you have a class definition: class MyClass{; private:; Float_t fX1;; ...; public:; void SetX1(Float_t x) {fX1 = x;};; Float_t GetX1() {return fX1;};; ...; }; Float_tfloat Float_tDefinition RtypesCore.h:57; xDouble_t x[n]Definition legend1.C:17; Look at the data member name and method names: a data member name has a prefix letter (f) and has a base name X1 . The methods for getting and setting this value have names which consist of string Get/Set and the same base name. This convention of naming data fields and methods which access them allows TDataMember find this methods by itself completely automatically. To make this description complete, one should know, that names that are automatically recognized may be also: for data fields: either fXXX or fIsXXX; and for getter function GetXXX() or IsXXX() [w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataMember.html:990,access,access,990,doc/master/classTDataMember.html,https://root.cern,https://root.cern/doc/master/classTDataMember.html,1,['access'],['access']
Security,"ember Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; Private Member Functions |; List of all members ; TProcessID Class ReferenceCore ROOT classes » Base ROOT classes. ; A TProcessID identifies a ROOT job in a unique way in time and space. ; The TProcessID title consists of a TUUID object which provides a globally unique identifier (for more see TUUID.h).; A TProcessID is automatically created by the TROOT constructor. When a TFile contains referenced objects (see TRef), the TProcessID object is written to the file. If a file has been written in multiple sessions (same machine or not), a TProcessID is written for each session. These objects are used by the class TRef to uniquely identified any TObject pointed by a TRef.; When a referenced object is read from a file (its bit kIsReferenced is set), this object is entered into the objects table of the corresponding TProcessID. Each TFile has a list of TProcessIDs (see TFile::fProcessIDs) also accessible via TProcessID::fgPIDs (for all files). When this object is deleted, it is removed from the table via the cleanup mechanism invoked by the TObject destructor.; Each TProcessID has a table (TObjArray *fObjects) that keeps track of all referenced objects. If a referenced object has a fUniqueID set, a pointer to this unique object may be found via fObjects->At(fUniqueID). In the same way, when a TRef::GetObject is called, GetObject uses its own fUniqueID to find the pointer to the referenced object. See TProcessID::GetObjectWithID and PutObjectWithID.; When a referenced object is deleted, its slot in fObjects is set to null.; See also TProcessUUID: a specialized TProcessID to manage the single list of TUUIDs. ; Definition at line 74 of file TProcessID.h. Public Member Functions;  TProcessID ();  Default constructor. ;  ; virtual ~TProcessID ();  Destructor. ;  ; void CheckInit ();  Initialize fObjects. ;  ; void Clear (Option_t *option="""") override;  delete the TObjArr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProcessID.html:1157,access,accessible,1157,doc/master/classTProcessID.html,https://root.cern,https://root.cern/doc/master/classTProcessID.html,1,['access'],['accessible']
Security,"ember Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TSecContext; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; Bool_t CleanupSecContext (Bool_t all) override;  Ask remote client to cleanup security context 'ctx' If 'all', all sec context with the same host as ctx are cleaned. ;  . Private Attributes; Int_t fRSAKey;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSecContext;  TSecContext (const TSecContext &);  copy constr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootSecContext.html:11659,secur,security,11659,doc/master/classTRootSecContext.html,https://root.cern,https://root.cern/doc/master/classTRootSecContext.html,1,['secur'],['security']
Security,"emberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTestChecksum(UInt_t checksum) const; Bool_tTestVersion(Int_t version) const; ROOT::TSchemaRuleTSchemaRule(); ROOT::TSchemaRuleTSchemaRule(const ROOT::TSchemaRule& rhs); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. Bool_tProcessChecksum(const TString& checksum) const; static voidProcessDeclaration(TObjArray* array, const TString& list); static voidProcessList(TObjArray* array, const TString& list); Bool_tProcessVersion(const TString& version) const. Data Members; public:. enum RuleType_t { kReadRule; kReadRawRule; kNone; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfChecksumSource checksum string; vector<UInt_t>*fChecksumVect! Source checksum vector (for searching purposes); TStringfCodeUser specified code snippet; Bool_tfEmbedValue determining if the rule should be embedded; TStringfIncludeIncludes string; TObjArray*fIncludeVect! Includes vector; ROOT::TSchemaRule::ReadFuncPtr_tfReadFuncPtr! Conversion function pointer for read rule; ROOT::TSchemaRule::ReadRawFuncPtr_tfReadRawFuncPtr! Conversion function pointer for readraw rule; ROOT::TSchemaRule::RuleType_tfRuleTypeType of the rule; TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__TSchemaRule.html:6024,checksum,checksum,6024,root/html526/ROOT__TSchemaRule.html,https://root.cern,https://root.cern/root/html526/ROOT__TSchemaRule.html,1,['checksum'],['checksum']
Security,"ement::kSTLdeque; static TStreamerElement::ESTLtypeTStreamerElement::kSTLlist; static TStreamerElement::ESTLtypeTStreamerElement::kSTLmap; static TStreamerElement::ESTLtypeTStreamerElement::kSTLmultimap; static TStreamerElement::ESTLtypeTStreamerElement::kSTLmultiset; static TStreamerElement::ESTLtypeTStreamerElement::kSTLset; static TStreamerElement::ESTLtypeTStreamerElement::kSTLstring; static TStreamerElement::ESTLtypeTStreamerElement::kSTLvector; static TObject::(anonymous)TObject::kSingleKey; static TStreamerElement::(anonymous)TStreamerElement::kWholeObject; static TStreamerElement::(anonymous)TStreamerElement::kWrite; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tTStreamerElement::fArrayDimnumber of array dimensions; Int_tTStreamerElement::fArrayLengthcumulative size of all array dims; UInt_t&fBaseCheckSum!checksum of the base class (used during memberwise streaming); TClass*fBaseClass!pointer to base class; Int_tfBaseVersionversion number of the base class (used during memberwise streaming); TClass*TStreamerElement::fClassObject!pointer to class of object; ClassConvStreamerFunc_tfConvStreamerFunc!Pointer to a wrapper around a custom convertion streamer member function.; TStringfErrorMsg!Error message in case of checksum/version mismatch.; Double_tTStreamerElement::fFactor!Conversion factor if a range is specified fFactor = (1<<nbits/(xmax-xmin); Int_tTStreamerElement::fMaxIndex[5]Maximum array index for array dimension ""dim""; TStringTNamed::fNameobject identifier; TClass*fNewBaseClass!pointer to new base class if renamed; TClass*TStreamerElement::fNewClass!new element class when reading; Int_tTStreamerElement::fNewType!new element type when reading; Int_tTStreamerElement::fOffset!element offset in class; Int_tTStreamerElement::fSizesizeof element; TMemberStreamer*TStreamerElement::fStreamer!pointer to element Streamer; ClassStreamerFunc_tfStreamerFunc!Pointer to a wrapper around a custom strea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerBase.html:9612,checksum,checksum,9612,root/html602/TStreamerBase.html,https://root.cern,https://root.cern/root/html602/TStreamerBase.html,1,['checksum'],['checksum']
Security,"emented for more efficient rehashing. void Clear(Option_t* option = """"); Remove all objects from the table. Does not delete the objects; unless the THashTable is the owner (set via SetOwner()). Int_t Collisions(const char* name) const; Returns the number of collisions for an object with a certain name; (i.e. number of objects in same slot in the hash table, i.e. length; of linked list). Int_t Collisions(TObject* obj) const; Returns the number of collisions for an object (i.e. number of objects; in same slot in the hash table, i.e. length of linked list). void Delete(Option_t* option = """"); Remove all objects from the table AND delete all heap based objects. TObject * FindObject(const char* name) const; Find object using its name. Uses the hash value returned by the; TString::Hash() after converting name to a TString. TObject * FindObject(const TObject* obj) const; Find object using its hash value (returned by its Hash() member). TList * GetListForObject(const char* name) const; Return the TList corresponding to object's name based hash value.; One can iterate this list ""manually"" to find, e.g. objects with; the same name. TList * GetListForObject(const TObject* obj) const; Return the TList corresponding to object's hash value.; One can iterate this list ""manually"" to find, e.g. identical; objects. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer to obj. TIterator * MakeIterator(Bool_t dir = kIterForward) const; Returns a hash table iterator. void Rehash(Int_t newCapacity, Bool_t checkObjValidity = kTRUE); Rehash the hashtable. If the collision rate becomes too high (i.e.; the average size of the linked lists become too long) then lookup; efficiency decreases since relatively long lists have to be searched; every time. To improve performance rehash the hashtable. This resizes; the table to newCapacity slots and refills the table. Use; AverageCollisions() to check if you need to rehash. Set checkObjValidity; to kFALSE if you know that all o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THashTable.html:10351,hash,hash,10351,root/html528/THashTable.html,https://root.cern,https://root.cern/root/html528/THashTable.html,6,['hash'],['hash']
Security,"emented from TObject.; Definition at line 250 of file TRootBrowserLite.cxx. ◆ Hash(). ULong_t TIconBoxThumb::Hash ; (; ); const. inlineoverridevirtual . Return hash value for this object. ; Note: If this routine is overloaded in a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TIconBoxThumb::HashULong_t Hash() const overrideReturn hash value for this object.Definition TRootBrowserLite.cxx:249; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 249 of file TRootBrowserLite.cxx. Member Data Documentation. ◆ fLarge. const TGPicture* TIconBoxThumb::fLarge. Definition at line 242 of file TRootBrowserLite.cxx. ◆ fName. TString TIconBoxThumb::fName. Definition at line 240 of file TRootBrowserLite.cxx. ◆ fSmall. const TGPicture* TIconBoxThumb::fSmall. Definition at line 241 of file TRootBrowserLite.cxx. gui/gui/src/TRootBrowserLite.cxx. TIconBoxThumb. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:51 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTIconBoxThumb.html:11319,hash,hash,11319,doc/master/classTIconBoxThumb.html,https://root.cern,https://root.cern/doc/master/classTIconBoxThumb.html,1,['hash'],['hash']
Security,"ements of the class. void ForceWriteInfo(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be called if the class decribed by this; StreamerInfo is 'emulated'. UInt_t GetCheckSum(UInt_t code) const; Recalculate the checksum of this TStreamerInfo based on its code. The class ckecksum is used by the automatic schema evolution algorithm; to uniquely identify a class version.; The check sum is built from the names/types of base classes and; data members.; Algorithm from Victor Perevovchikov (perev@bnl.gov). if code==1 data members of type enum are not counted in the checksum; if code==2 return the checksum of data members and base classes, not including the ranges and array size found in comments.; This is needed for backward compatibility. WARNING: this function must be kept in sync with TClass::GetCheckSum.; They are both used to handle backward compatibility and should both return the same values.; TStreamerInfo uses the information in TStreamerElement while TClass uses the information; from TClass::GetListOfBases and TClass::GetListOfDataMembers. void GenerateDeclaration(FILE* fp, FILE* sfp, const TList* subClasses, Bool_t top = kTRUE); Write the Declaration of class. UInt_t GenerateIncludes(F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerInfo.html:16658,checksum,checksum,16658,root/html528/TStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TStreamerInfo.html,3,['checksum'],['checksum']
Security,"emonstrates how to generate documentation for your classes and for ROOT classes and how to “beautify” a macro.; 28 Appendix A: Install and Build ROOT. 28.1 License; ROOT is made available under the LGPL v2.1 license. For full details see the file LICENSE in the ROOT distribution.; 28.2 Installing ROOT; To install ROOT you will need to go to the ROOT website at: https://root.cern/install/; You have a choice to download the binaries or the source. The source is quicker to transfer since it is only 31 MB, but you will need to compile and link it. The binaries range from 50 MB to 100 MB depending on the target platform.; 28.3 Choosing a Version; The ROOT developers follow the principle of “release early and release often”, however a very large portion of a user base requires a stable product therefore generally three versions of the system is available for download - new, old and pro:. The new version evolves quickly, with weekly or bi-weekly releases. Use this to get access to the latest and greatest, but it may not be stable. By trying out the new version you can help us converge quickly to a stable version that can then become the new pro version. If you are a new user we would advice you to try the new version.; The pro (production) version is a version we feel comfortable with to exposing to a large audience for serious work. The change rate of this version is much lower than for the new version, it is about 3 to 6 months.; The old version is the previous pro version that people might need for some time before switching the new pro version. The old change rate is the same as for pro. 28.4 Installing Precompiled Binaries; The binaries are available for downloading from https://root.cern/install/. Once downloaded you need to unzip and de-tar the file. For example, if you have downloaded ROOT v5.30 for Linux-SLC5:; % gunzip root_v5.30.00.Linux-slc5-gcc4.3.tar.gz; % tar xvf root_v5.30.00.Linux-slc5-gcc4.3.tar; This will create the directory root. Before getting started ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1252314,access,access,1252314,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"emove all items from the container. void RemoveItem(TGFrame* item); Remove item from container. const TGFrame * GetNextSelected(void** current); Return next selected item. void ActivateItem(TGFrameElement* el); Activate item. void DeActivateItem(TGFrameElement* el); DeActivate item. TGPosition GetPagePosition() const; Returns page position. TGDimension GetPageDimension() const; Returns page dimension. void SetPagePosition(const TGPosition& pos); Set page position. void SetPagePosition(Int_t x, Int_t y); Set page position. void SetPageDimension(const TGDimension& dim); Set page dimension. void SetPageDimension(UInt_t w, UInt_t h); Set page dimension. void DoRedraw(); Redraw content of container in the viewport region. void DrawRegion(Int_t x, Int_t y, UInt_t w, UInt_t h); Draw a region of container in viewport.; x, y, w, h are position and dimension of area to be; redrawn in viewport coordinates. void ClearViewPort(); Clear view port and redraw full content. Bool_t HandleExpose(Event_t* event); Handle expose events. Do not use double buffer. Bool_t HandleButton(Event_t* event); Handle mouse button event in container. const TGPicture * GetObjPicture(TGFrame* f); Retrieve icons associated with class ""name"". Association is made; via the user's ~/.root.mimes file or via $ROOTSYS/etc/root.mimes. void SetDragPixmap(const TGPicture* pic); Set drag window pixmaps and hotpoint. Bool_t HandleDoubleClick(Event_t* event); Handle double click mouse event. Bool_t HandleMotion(Event_t* event); Handle mouse motion events. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. TGFrame * FindFrameByName(const char* name); Find frame by name. void Search(Bool_t close = kTRUE); Invokes search dialog. Looks for item with the entered name. void OnAutoScroll(); Autoscroll while close to & beyond The Wall. void SearchPattern(); Search for entry which name begins with pattern. void RepeatSearch(); Repeats search. TGFrameElement * FindFr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGContainer.html:26557,expose,expose,26557,root/html528/TGContainer.html,https://root.cern,https://root.cern/root/html528/TGContainer.html,4,['expose'],['expose']
Security,"emovedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TS3HTTPRequest&operator=(const TS3HTTPRequest&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TS3HTTPRequest&SetAccessKey(const TString& accessKey); TS3HTTPRequest&SetAuthKeys(const TString& accessKey, const TString& secretKey); TS3HTTPRequest&SetAuthType(TS3HTTPRequest::EAuthType authType); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); TS3HTTPRequest&SetBucket(const TString& bucket); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); TS3HTTPRequest&SetHost(const TString& host); TS3HTTPRequest&SetObjectKey(const TString& objectKey); static voidTObject::SetObjectStat(Bool_t stat); TS3HTTPRequest&SetSecretKey(const TString& secretKey); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TS3HTTPRequest.html:5277,access,accessKey,5277,root/html534/TS3HTTPRequest.html,https://root.cern,https://root.cern/root/html534/TS3HTTPRequest.html,1,['access'],['accessKey']
Security,"emplate<class T , unsigned int D> . T ROOT::Math::SVector< T, D >::apply ; (; unsigned int ; i); const. inline . access the parse tree. Index starts from zero ; Definition at line 537 of file SVector.icc. ◆ Array() [1/2]. template<class T , unsigned int D> . T * ROOT::Math::SVector< T, D >::Array. inline . return non-const pointer to internal array ; Definition at line 543 of file SVector.icc. ◆ Array() [2/2]. template<class T , unsigned int D> . const T * ROOT::Math::SVector< T, D >::Array. inline . return read-only pointer to internal array ; Definition at line 540 of file SVector.icc. ◆ At() [1/2]. template<class T , unsigned int D> . T & ROOT::Math::SVector< T, D >::At ; (; unsigned int ; i). inline . read/write access of vector elements with check on index. Index starts from 0. ; Definition at line 602 of file SVector.icc. ◆ At() [2/2]. template<class T , unsigned int D> . const T & ROOT::Math::SVector< T, D >::At ; (; unsigned int ; i); const. inline . read-only access of vector elements with check on index. Index starts from 0. ; Definition at line 596 of file SVector.icc. ◆ begin() [1/2]. template<class T , unsigned int D> . T * ROOT::Math::SVector< T, D >::begin. inline . STL iterator interface. ; Definition at line 550 of file SVector.icc. ◆ begin() [2/2]. template<class T , unsigned int D> . const T * ROOT::Math::SVector< T, D >::begin. inline . STL const_iterator interface. ; Definition at line 553 of file SVector.icc. ◆ Dim(). template<class T , unsigned int D> . static unsigned int ROOT::Math::SVector< T, D >::Dim ; (; ). inlinestatic . return dimension \(D\) ; Definition at line 179 of file SVector.h. ◆ end() [1/2]. template<class T , unsigned int D> . T * ROOT::Math::SVector< T, D >::end. inline . STL iterator interface. ; Definition at line 556 of file SVector.icc. ◆ end() [2/2]. template<class T , unsigned int D> . const T * ROOT::Math::SVector< T, D >::end. inline . STL const_iterator interface. ; Definition at line 559 of file SVector.icc. ◆ IsInU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:13550,access,access,13550,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['access'],['access']
Security,"en name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj); Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg); Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name); Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. RooLinkedListIter iterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Mon Dec 7 13:48:08 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinkedList.html:9086,hash,hash,9086,root/html526/RooLinkedList.html,https://root.cern,https://root.cern/root/html526/RooLinkedList.html,1,['hash'],['hash']
Security,"en parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; virtual ULong_t Hash () const;  Return hash value for this object. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ;  ; virtual Bool_t InheritsFrom (const char *classname) const;  Returns kTRUE if object inherits from class ""classname"". ;  ; virtual Bool_t InheritsFrom (const TClass *cl) const;  Returns kTRUE if object inherits from TClass cl. ;  ; virtual void Inspect () const;  Dump contents of this object in a graphics canvas. ;  ; void InvertBit (UInt_t f);  ; Bool_t IsDestructed () const;  IsDestructed. ;  ; virtual Bool_t IsEqual (const TObject *obj) const;  Default equal comparison (objects are equal if they have the same address in memory). ;  ; R__ALWAYS_INLINE Bool_t IsOnHeap () const;  ; virtual Bool_t IsSortable () const;  ; R__ALWAYS_INLINE Bool_t IsZombie () const;  ; virtual void ls (Option_t *option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoTrack.html:9808,hash,hash,9808,doc/master/classTGeoTrack.html,https://root.cern,https://root.cern/doc/master/classTGeoTrack.html,1,['hash'],['hash']
Security,"en volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__BinarySearchTree.html:8017,access,access,8017,root/html534/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html534/TMVA__BinarySearchTree.html,4,['access'],['access']
Security,"en volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__BinarySearchTree.html:7841,access,access,7841,root/html604/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html604/TMVA__BinarySearchTree.html,4,['access'],['access']
Security,"en volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__BinarySearchTree.html:7833,access,access,7833,root/html602/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html602/TMVA__BinarySearchTree.html,4,['access'],['access']
Security,"en(""s3://host.example.com/bucket/path/to/my/file"",; ""NOPROXY AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f2 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""AUTH=F38XYZABCDeFgH4D0E1F:V+frt4re7J1euSNFnmaf8wwmI4AAAE7kzxZ/TTM+"");; TFile* f3 = TFile::Open(""s3://host.example.com/bucket/path/to/my/file"",; ""TOKEN=AQoDYXdzEM///////////wEa8AHEYmCinjD+TsGEjtgKSMAT6wnY"");; If there is no authentication information in the 'options' argument (i.e. not AUTH=""...."") the values of the environmental variables S3_ACCESS_KEY and S3_SECRET_KEY (if set) are expected to contain the access key id and the secret access key, respectively. You have been provided with these credentials by your S3 service provider.; If neither the AUTH information is provided in the 'options' argument nor the environmental variables are set, we try to open the file without providing any authentication information to the server. This is useful when the file is set an access control that allows for any unidentified user to read the file. ; Definition at line 152 of file TS3WebFile.cxx. ◆ ~TS3WebFile(). virtual TS3WebFile::~TS3WebFile ; (; ). inlinevirtual . Definition at line 93 of file TS3WebFile.h. Member Function Documentation. ◆ Class(). static TClass * TS3WebFile::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TS3WebFile::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TS3WebFile::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 105 of file TS3WebFile.h. ◆ DeclFileName(). static const char * TS3WebFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 105 of file TS3WebFile.h. ◆ GetAccessKey(). const TString & TS3WebFile::GetAccessKey ; (; ); const. inline . Definition at line 96 of file TS3WebFile.h. ◆ GetBucket(). const TString & TS3WebFile::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:51320,access,access,51320,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,1,['access'],['access']
Security,"en,; : this model can be loaded and trained in TMVA.; : ; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Split TMVA training data in 2560 training events and 640 validation events; : Training Model Summary; saved recurrent model model_LSTM.h5; Booking Keras model LSTM; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; =================================================================; reshape (Reshape) (None, 10, 30) 0 ; ; lstm (LSTM) (None, 10, 10) 1640 ; ; flatten (Flatten) (None, 100) 0 ; ; dense (Dense) (None, 64) 6464 ; ; dense_1 (Dense) (None, 2) 130 ; ; =================================================================; Total params: 8234 (32.16 KB); Trainable params: 8234 (32.16 KB); Non-trainable params: 0 (0.00 Byte); _________________________________________________________________; : Option SaveBestOnly: Only model weights with smallest validation loss will be stored; Epoch 1/10; ; 1/26 [>.............................] - ETA: 42s - loss: 0.7326 - accuracy: 0.4600␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 7/26 [=======>......................] - ETA: 0s - loss: 0.7180 - accuracy: 0.4971 ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 14/26 [===============>..............] - ETA: 0s - loss: 0.7130 - accuracy: 0.4957␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 23/26 [=========================>....] - ETA: 0s - loss: 0.7095 - accuracy: 0.4961; Epoch 1: val_loss improved from inf to 0.69938, saving model to trained_model_LSTM.h5; ␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈␈; 26/26 [==============================] - 3s 37ms/step - loss: 0.7096 - accuracy: 0.4922 - val_loss: 0.6994 - val_accuracy: 0.5047; Epoch 2/10; ; 1/26 [>.........",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:21863,validat,validation,21863,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['validat'],['validation']
Security,"enVectorBoolProxyTGenVectorBoolProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:92; TGenVectorBoolProxy::~TGenVectorBoolProxy~TGenVectorBoolProxy() overrideDefinition TGenCollectionProxy.cxx:96; TGenVectorBoolProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:115; TGenVectorProxyLocal optimization class.Definition TGenCollectionProxy.cxx:39; TGenVectorProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:66; TGenVectorProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:50; TGenVectorProxy::~TGenVectorProxy~TGenVectorProxy() overrideDefinition TGenCollectionProxy.cxx:46; TGenVectorProxy::TGenVectorProxyTGenVectorProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:42; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::TypeInfo_Initvirtual void TypeInfo_Init(TypeInfo_t *, const char *) constDefinition TInterpreter.h:528; TInterpreter::TypeInfo_Deletevirtual void TypeInfo_Delete(TypeInfo_t *) constDefinition TInterpreter.h:524; TInterpreter::TypeInfo_Factoryvirtual TypeInfo_t * TypeInfo_Factory() constDefinition TInterpreter.h:525; TInterpreter::TypeInfo_Propertyvirtual Long_t TypeInfo_Property(TypeInfo_t *) constDefinition TInterpreter.h:531; TInterpreter::TypeInfo_Sizevirtual int TypeInfo_Size(TypeInfo_t *) constDefinition TInterpreter.h:533; TInterpreter::TypeInfo_IsValidvirtual Bool_t TypeInfo_IsValid(TypeInfo_t *) constDefinition TInterpreter.h:529; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::Clearvoid Clear(Option_t *option="""") override",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:89132,hash,hash,89132,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['hash'],['hash']
Security,"ence Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Attributes |; Protected Attributes |; List of all members ; ROOT::Experimental::RNTupleWriteOptions Class ReferenceNTuple-related classes. ; Common user-tunable settings for storing ntuples. ; All page sink classes need to support the common options. ; Definition at line 48 of file RNTupleWriteOptions.hxx. Public Types; enum class  EImplicitMT { kOff; , kDefault; };  . Public Member Functions; virtual ~RNTupleWriteOptions ()=default;  ; virtual std::unique_ptr< RNTupleWriteOptions > Clone () const;  ; std::size_t GetApproxZippedClusterSize () const;  ; int GetCompression () const;  ; bool GetEnablePageChecksums () const;  ; std::size_t GetInitialNElementsPerPage () const;  ; std::uint64_t GetMaxKeySize () const;  ; std::size_t GetMaxUnzippedClusterSize () const;  ; std::size_t GetMaxUnzippedPageSize () const;  ; std::size_t GetPageBufferBudget () const;  ; bool GetUseBufferedWrite () const;  ; bool GetUseDirectIO () const;  ; EImplicitMT GetUseImplicitMT () const;  ; std::size_t GetWriteBufferSize () const;  ; void SetApproxZippedClusterSize (std::size_t val);  ; void SetCompression (int val);  ; void SetCompression (RCompressionSetting::EAlgorithm::EValues algorithm, int compressionLevel);  ; void SetEnablePageChecksums (bool val);  Note that turning off page checksums will also turn off the same page merging optimization (see tuning.md) ;  ; void SetInitialNElementsPerPage (std::size_t val);  ; void SetMaxUnzippedClusterSize (std::size_t val);  ; void SetMaxUnzippedPageSize (std::size_t val);  ; void SetPageBufferBudget (std::size_t val);  ; void SetUseBufferedWrite (bool val);  ; void SetUseDirectIO (bool val);  ; void SetUseImplicitMT (EImplicitMT val);  ; void SetWriteBufferSize (std::size_t val);  . Static Public Attributes; static constexpr std::uint64_t kDefaultMaxKeySize = 0x4000'0000;  . Protected Attributes; std::size_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html:1507,checksum,checksums,1507,doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriteOptions.html,1,['checksum'],['checksums']
Security,"ence Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Static Protected Member Functions |; Private Attributes |; Static Private Attributes |; Friends |; List of all members ; TMapFile Class ReferenceInput/Output Library. ; This class implements a shared memory region mapped to a file. ; Objects can be placed into this shared memory area using the Add() member function. To actually place a copy of the object is shared memory call Update() also whenever the mapped object(s) change(s) call Update() to put a fresh copy in the shared memory. This extra step is necessary since it is not possible to share objects with virtual pointers between processes (the vtbl ptr points to the originators unique address space and can not be used by the consumer process(es)). Consumer processes can map the memory region from this file and access the objects stored in it via the Get() method (which returns a copy of the object stored in the shared memory with correct vtbl ptr set). Only objects of classes with a Streamer() member function defined can be shared.; I know the current implementation is not ideal (you need to copy to and from the shared memory file) but the main problem is with the class' virtual_table pointer. This pointer points to a table unique for every process. Therefore, different options are:; One could allocate an object directly in shared memory in the producer, but the consumer still has to copy the object from shared memory into a local object which has the correct vtbl pointer for that process (copy ctor's can be used for creating the local copy).; Another possibility is to only allow objects without virtual functions in shared memory (like simple C structs), or to forbid (how?) the consumer from calling any virtual functions of the objects in shared memory.; A last option is to copy the object internals to shared memory and copy them ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMapFile.html:1020,access,access,1020,doc/master/classTMapFile.html,https://root.cern,https://root.cern/doc/master/classTMapFile.html,1,['access'],['access']
Security,"ence. TRef & operator=(const TRef& ref); TRef assignment operator. Int_t AddExec(const char* name); If Exec with name does not exist in the list of Execs, it is created.; returns the index of the Exec in the list. TObjArray * GetListOfExecs(); Return a pointer to the static TObjArray holding the list of Execs. TObject * GetObject() const; Return a pointer to the referenced object. void SetAction(const char* name); Store the exec number (in the ROOT list of Execs); into the fBits of this TRef. void SetAction(TObject* parent); Find the action to be executed in the dictionary of the parent class; and store the corresponding exec number into fBits.; This function searches a data member in the class of parent with an; offset corresponding to this.; If a comment ""TEXEC:"" is found in the comment field of the data member,; the function stores the exec identifier of the exec statement; following this keyword. TObject * GetStaticObject(); Returns the static object. void SetObject(TObject* obj); static Obsolete function kept for back compatibility.; In the near future will print a Warning, then will be deleted. void SetStaticObject(TObject* obj); Static function to set the object found on the Action on Demand function.; This function may be called by the user in the function called; when a ""EXEC:"" keyword is specified in the data member field of the TRef.; The function can get access to the dereferencing TRef (i.e. this)using; the static function GetStaticObject(). void Streamer(TBuffer& ); Stream an object of class TRef. TRef(); { }. virtual ~TRef(); { }. TProcessID * GetPID() const; {return fPID;}. Bool_t IsValid() const; {return GetUniqueID()!=0 ? kTRUE : kFALSE;}. » Author: Rene Brun 28/09/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRef.html:16724,access,access,16724,root/html534/TRef.html,https://root.cern,https://root.cern/root/html534/TRef.html,1,['access'],['access']
Security,"ence. TRef & operator=(const TRef& ref); TRef assignment operator. Int_t AddExec(const char* name); If Exec with name does not exist in the list of Execs, it is created.; returns the index of the Exec in the list. TObjArray * GetListOfExecs(); Return a pointer to the static TObjArray holding the list of Execs. TObject * GetObject() const; Return a pointer to the referenced object. void SetAction(const char* name); Store the exec number (in the ROOT list of Execs); into the fBits of this TRef. void SetAction(TObject* parent); Find the action to be executed in the dictionary of the parent class; and store the corresponding exec number into fBits.; This function searches a data member in the class of parent with an; offset corresponding to this.; If a comment ""TEXEC:"" is found in the comment field of the data member,; the function stores the exec identifier of the exec statement; following this keyword. TObject * GetStaticObject(); Returns the static object. void SetObject(TObject* obj); static Obsolete function kept for back compatibility.; In the near future will print a Warning, then will be deleted. void SetStaticObject(TObject* obj); Static function to set the object found on the Action on Demand function.; This function may be called by the user in the function called; when a ""EXEC:"" keyword is specified in the data member field of the TRef.; The function can get access to the dereferencing TRef (i.e. this)using; the static function GetStaticObject(). void Streamer(TBuffer& ); Stream an object of class TRef. TRef(); { }. virtual ~TRef(); { }. TProcessID * GetPID() const; {return fPID;}. Bool_t IsValid() const; {return GetUniqueID()!=0 ? kTRUE : kFALSE;}. » Author: Rene Brun 28/09/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-02 16:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRef.html:17207,access,access,17207,root/html604/TRef.html,https://root.cern,https://root.cern/root/html604/TRef.html,1,['access'],['access']
Security,"ence. TRef & operator=(const TRef& ref); TRef assignment operator. Int_t AddExec(const char* name); If Exec with name does not exist in the list of Execs, it is created.; returns the index of the Exec in the list. TObjArray * GetListOfExecs(); Return a pointer to the static TObjArray holding the list of Execs. TObject * GetObject() const; Return a pointer to the referenced object. void SetAction(const char* name); Store the exec number (in the ROOT list of Execs); into the fBits of this TRef. void SetAction(TObject* parent); Find the action to be executed in the dictionary of the parent class; and store the corresponding exec number into fBits.; This function searches a data member in the class of parent with an; offset corresponding to this.; If a comment ""TEXEC:"" is found in the comment field of the data member,; the function stores the exec identifier of the exec statement; following this keyword. TObject * GetStaticObject(); Returns the static object. void SetObject(TObject* obj); static Obsolete function kept for back compatibility.; In the near future will print a Warning, then will be deleted. void SetStaticObject(TObject* obj); Static function to set the object found on the Action on Demand function.; This function may be called by the user in the function called; when a ""EXEC:"" keyword is specified in the data member field of the TRef.; The function can get access to the dereferencing TRef (i.e. this)using; the static function GetStaticObject(). void Streamer(TBuffer& ); Stream an object of class TRef. TRef(); { }. virtual ~TRef(); { }. TProcessID * GetPID() const; {return fPID;}. Bool_t IsValid() const; {return GetUniqueID()!=0 ? kTRUE : kFALSE;}. » Author: Rene Brun 28/09/2001 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRef.html:17207,access,access,17207,root/html602/TRef.html,https://root.cern,https://root.cern/root/html602/TRef.html,1,['access'],['access']
Security,"enceabstractNTuple-related classes. ; Abstract interface to read data from an ntuple. ; The page source is initialized with the columns of interest. Alias columns from projected fields are mapped to the corresponding physical columns. Pages from the columns of interest can then be mapped into memory. The page source also gives access to the ntuple's meta-data. ; Definition at line 549 of file RPageStorage.hxx. Classes; class  RActivePhysicalColumns;  Keeps track of the requested physical column IDs. More...;  ; struct  RClusterInfo;  Summarizes cluster-level information that are necessary to load a certain page. More...;  ; struct  RCounters;  Default I/O performance counters that get registered in fMetrics More...;  ; struct  REntryRange;  Used in SetEntryRange / GetEntryRange. More...;  ; class  RExclDescriptorGuard;  An RAII wrapper used for the writable access to RPageSource::fDescriptor. See GetSharedDescriptorGuard(). More...;  ; class  RSharedDescriptorGuard;  An RAII wrapper used for the read-only access to RPageSource::fDescriptor. See GetExclDescriptorGuard()`. More...;  . Public Member Functions;  RPageSource (const RPageSource &)=delete;  ;  RPageSource (RPageSource &&)=delete;  ;  RPageSource (std::string_view ntupleName, const RNTupleReadOptions &fOptions);  ;  ~RPageSource () override;  ; ColumnHandle_t AddColumn (DescriptorId_t fieldId, RColumn &column) override;  Register a new column. ;  ; void Attach ();  Open the physical storage container and deserialize header and footer. ;  ; std::unique_ptr< RPageSource > Clone () const;  Open the same storage multiple time, e.g. ;  ; void DropColumn (ColumnHandle_t columnHandle) override;  Unregisters a column. ;  ; REntryRange GetEntryRange () const;  ; NTupleSize_t GetNElements (ColumnHandle_t columnHandle);  ; NTupleSize_t GetNEntries ();  ; const RNTupleReadOptions & GetReadOptions () const;  ; const RSharedDescriptorGuard GetSharedDescriptorGuard () const;  Takes the read lock for the descriptor. ;  ; EP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:1415,access,access,1415,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['access'],['access']
Security,"end]; Constructor & Destructor Documentation. ◆ TWebFile() [1/3]. TWebFile::TWebFile ; (; ). inlineprivate . Definition at line 39 of file TWebFile.h. ◆ TWebFile() [2/3]. TWebFile::TWebFile ; (; const char * ; url, . Option_t * ; opt = """" . ). Create a Web file object. ; A web file is the same as a read-only TFile except that it is being read via a HTTP server. The url argument must be of the form: http://host.dom.ain/file.root. The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell variable. The proxy can be specified as (in sh, or equivalent csh): export http_proxy=http://pcsalo.cern.ch:3128 The proxy can also be specified via the static method TWebFile::SetProxy(). Basic authentication (AuthType Basic) is supported. The user name and passwd can be specified in the url like this: http://username:mypasswd@pcsalo.cern.ch/files/aap.root If the file specified in the URL does not exist or is not accessible the kZombie bit will be set in the TWebFile object. Use IsZombie() to see if the file is accessible. The preferred interface to this constructor is via TFile::Open(). ; Definition at line 146 of file TWebFile.cxx. ◆ TWebFile() [3/3]. TWebFile::TWebFile ; (; TUrl ; url, . Option_t * ; opt = """" . ). Create a Web file object. ; A web file is the same as a read-only TFile except that it is being read via a HTTP server. Make sure url is a valid TUrl object. The opt can be ""NOPROXY"", to bypass any set ""http_proxy"" shell variable. The proxy can be specified as (in sh, or equivalent csh): export http_proxy=http://pcsalo.cern.ch:3128 The proxy can also be specified via the static method TWebFile::SetProxy(). Basic authentication (AuthType Basic) is supported. The user name and passwd can be specified in the url like this: http://username:mypasswd@pcsalo.cern.ch/files/aap.root If the file specified in the URL does not exist or is not accessible the kZombie bit will be set in the TWebFile object. Use IsZombie() to see if the file is accessible. ; Definition at line 181 o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebFile.html:44539,access,accessible,44539,doc/master/classTWebFile.html,https://root.cern,https://root.cern/doc/master/classTWebFile.html,1,['access'],['accessible']
Security,"endl;; ; // Apply model as part of an RDataFrame workflow; ROOT::RDataFrame df(""Events"", ""root://eospublic.cern.ch//eos/root-eos/cms_opendata_2012_nanoaod/SMHiggsToZZTo4L.root"");; auto df2 = df.Filter(""nMuon >= 2""); .Filter(""nElectron >= 2""); .Define(""Muon_pt_1"", ""Muon_pt[0]""); .Define(""Muon_pt_2"", ""Muon_pt[1]""); .Define(""Electron_pt_1"", ""Electron_pt[0]""); .Define(""Electron_pt_2"", ""Electron_pt[1]""); .Define(""y"",; Compute<4, float>(bdt),; {""Muon_pt_1"", ""Muon_pt_2"", ""Electron_pt_1"", ""Electron_pt_2""});; ; std::cout << ""Mean response on the signal sample: "" << *df2.Mean(""y"") << std::endl;; }; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TMVA::Experimental::RBDTDefinition RBDT.hxx:37; TMVA::Experimental::RTensorRTensor is a container with contiguous memory and shape information.Definition RTensor.hxx:162; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; xDouble_t x[n]Definition legend1.C:17; TMVA::ExperimentalDefinition RModelParser_Keras.h:40; ; DateDecember 2018 ; AuthorStefan Wunsch ; Definition in file tmva103_Application.C. tutorialstmvatmva103_Application.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva103__Application_8C.html:2747,access,access,2747,doc/master/tmva103__Application_8C.html,https://root.cern,https://root.cern/doc/master/tmva103__Application_8C.html,2,['access'],['access']
Security,"enerateIncludeForTemplatestatic UInt_t GenerateIncludeForTemplate(FILE *fp, const char *clname, char *inclist, Bool_t forward, const TList *extrainfos)Add to the header file, the #include needed for the argument of this template.Definition TMakeProject.cxx:455; TMakeProject::GeneratePostDeclarationstatic void GeneratePostDeclaration(FILE *fp, const TVirtualStreamerInfo *info, char *inclist)Add to the header file anything that need to appear after the class declaration (this includes some #...Definition TMakeProject.cxx:608; TMakeProject::GenerateClassPrefixstatic UInt_t GenerateClassPrefix(FILE *fp, const char *clname, Bool_t top, TString &protoname, UInt_t *numberOfClasses, Int_t implementEmptyClass=kFALSE, Bool_t needGenericTemplate=kFALSE)Write the start of the class (forward) declaration.Definition TMakeProject.cxx:163; TMakeProject::UpdateAssociativeToVectorstatic TString UpdateAssociativeToVector(const char *name)Definition TMakeProject.cxx:659; TMemberInspectorAbstract base class for accessing the data-members of a class.Definition TMemberInspector.h:31; TMemberInspector::GetParentconst char * GetParent() constDefinition TMemberInspector.cxx:75; TMemberInspector::Inspectvirtual void Inspect(TClass *cl, const char *parent, const char *name, const void *addr)Definition TMemberInspector.cxx:99; TMemberInspector::InspectMembervoid InspectMember(const T &obj, const char *name, Bool_t isTransient)Definition TMemberInspector.h:63; TMemberStreamerDefinition TMemberStreamer.h:26; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::CloneTObject * Clone(const char *newname="""") const overrideMake a clone of an object using the Streamer facility.Definition TNamed.cxx:74; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::Streamervoid Streamer(TBuffer &) overr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:263144,access,accessing,263144,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['access'],['accessing']
Security,"engines which runs http server; 35 std::unique_ptr<THttpTimer> fTimer; ///<! timer used to access main thread; 36 std::unique_ptr<TRootSniffer> fSniffer; ///<! sniffer provides access to ROOT objects hierarchy; 37 Bool_t fTerminated{kFALSE}; ///<! termination flag, disables all requests processing; 38 Long_t fMainThrdId{0}; ///<! id of the thread for processing requests; 39 Long_t fProcessingThrdId{0}; ///<! id of the thread where events are recently processing; 40 Bool_t fOwnThread{kFALSE}; ///<! true when specialized thread allocated for processing requests; 41 std::thread fThrd; ///<! own thread; 42 Bool_t fWSOnly{kFALSE}; ///<! when true, handle only websockets / longpoll engine; 43 ; 44 TString fJSROOTSYS; ///<! location of local JSROOT files; 45 TString fTopName{""ROOT""}; ///<! name of top folder, default - ""ROOT""; 46 TString fJSROOT; ///<! location of external JSROOT files; 47 ; 48 std::map<std::string, std::string> fLocations; ///<! list of local directories, which could be accessed via server; 49 ; 50 std::string fDefaultPage; ///<! file name for default page name; 51 std::string fDefaultPageCont; ///<! content of default html page; 52 std::string fDrawPage; ///<! file name for drawing of single element; 53 std::string fDrawPageCont; ///<! content of draw html page; 54 std::string fCors; ///<! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responses; 55 std::string fCorsCredentials; ///<! CORS: add Access-Control-Allow-Credentials: true response header; 56 ; 57 std::mutex fMutex; ///<! mutex to protect list with arguments; 58 std::queue<std::shared_ptr<THttpCallArg>> fArgs; ///<! submitted arguments; 59 ; 60 std::mutex fWSMutex; ///<! mutex to protect WS handler lists; 61 std::vector<std::shared_ptr<THttpWSHandler>> fWSHandlers; ///<! list of WS handlers; 62 ; 63 virtual void MissedRequest(THttpCallArg *arg);; 64 ; 65 virtual void ProcessRequest(std::shared_ptr<THttpCallArg> arg);; 66 ; 67 virtual void ProcessBatchHolder(std::shared_ptr<THtt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8h_source.html:2047,access,accessed,2047,doc/master/THttpServer_8h_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8h_source.html,1,['access'],['accessed']
Security,"ength parameter in Cost Complexity pruning \( (R_{\alpha}(T) = R(T) + \alpha*|\sim T|) \). There are two running modes in CCPruner: (i) one may select a prune strength and prune back the tree \( T_{max}\) until the criterion: ; \[; \alpha < \frac{R(T) - R(t)}{|\sim T_t| - 1}; \]. is true for all nodes t in \( T \), or (ii) the algorithm finds the sequence of critical points \( \alpha_k < \alpha_{k+1} ... < \alpha_K \) such that \( T_K = root(T_{max}) \) and then selects the optimally-pruned subtree, defined to be the subtree with the best quality index for the validation sample. ; Definition at line 62 of file CCPruner.h. Public Types; typedef std::vector< Event * > EventList;  . Public Member Functions;  CCPruner (DecisionTree *t_max, const DataSet *validationSample, SeparationBase *qualityIndex=nullptr);  constructor ;  ;  CCPruner (DecisionTree *t_max, const EventList *validationSample, SeparationBase *qualityIndex=nullptr);  constructor ;  ;  ~CCPruner ();  ; std::vector< TMVA::DecisionTreeNode * > GetOptimalPruneSequence () const;  return the prune strength (=alpha) corresponding to the prune sequence ;  ; Float_t GetOptimalPruneStrength () const;  ; Float_t GetOptimalQualityIndex () const;  ; void Optimize ();  determine the pruning sequence ;  ; void SetPruneStrength (Float_t alpha=-1.0);  . Private Attributes; Float_t fAlpha;  ! regularization parameter in CC pruning ;  ; Bool_t fDebug;  ! debug flag ;  ; Int_t fOptimalK;  ! index of the optimal tree in the pruned tree sequence ;  ; Bool_t fOwnQIndex;  ! flag indicates if fQualityIndex is owned by this ;  ; std::vector< TMVA::DecisionTreeNode * > fPruneSequence;  ! map of weakest links (i.e., branches to prune) -> pruning index ;  ; std::vector< Float_t > fPruneStrengthList;  ! map of alpha -> pruning index ;  ; SeparationBase * fQualityIndex;  ! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) } ;  ; std::vector< Float_t > fQualityIndexList;  ! map of R(T) -> pruning index ;  ; DecisionTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CCPruner.html:1530,validat,validationSample,1530,doc/master/classTMVA_1_1CCPruner.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CCPruner.html,2,['validat'],['validationSample']
Security,"ent > & ; source). Definition at line 1414 of file TMatrixTSym.cxx. ◆ operator=() [2/4]. template<class Element > . template<class Element2 > . TMatrixTSym< Element > & TMatrixTSym< Element >::operator= ; (; const TMatrixTSym< Element2 > & ; source). inline . Definition at line 148 of file TMatrixTSym.h. ◆ operator=() [3/4]. template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::operator= ; (; const TMatrixTSymLazy< Element > & ; source). Definition at line 1431 of file TMatrixTSym.cxx. ◆ operator=() [4/4]. template<class Element > . TMatrixTSym< Element > & TMatrixTSym< Element >::operator= ; (; Element ; val). Assign val to every element of the matrix. ; Definition at line 1450 of file TMatrixTSym.cxx. ◆ operator[]() [1/2]. template<class Element > . TMatrixTRow< Element > TMatrixTSym< Element >::operator[] ; (; Int_t ; rown). inline . Access row a_i where i=rown. ; NoteA concatenated call to [coln] allows to access element a_ij where i=rown and j=coln ; WarningModifying this row by the caller breaks the symmetry of the matrix if a_j is not modified accordingly. ; Definition at line 144 of file TMatrixTSym.h. ◆ operator[]() [2/2]. template<class Element > . const TMatrixTRow_const< Element > TMatrixTSym< Element >::operator[] ; (; Int_t ; rown); const. inline . Definition at line 143 of file TMatrixTSym.h. ◆ Plus(). template<class Element > . void TMatrixTSym< Element >::Plus ; (; const TMatrixTSym< Element > & ; a, . const TMatrixTSym< Element > & ; b . ). Symmetric matrix summation. Replace this matrix with C such that C = A + B. ; Definition at line 312 of file TMatrixTSym.cxx. ◆ Randomize(). template<class Element > . TMatrixTBase< Element > & TMatrixTSym< Element >::Randomize ; (; Element ; alpha, . Element ; beta, . Double_t & ; seed . ). overridevirtual . randomize matrix element values but keep matrix symmetric ; Reimplemented from TMatrixTBase< Element >.; Definition at line 1608 of file TMatrixTSym.cxx. ◆ RandomizePD(). template<clas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSym.html:37675,access,access,37675,doc/master/classTMatrixTSym.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSym.html,1,['access'],['access']
Security,"ent boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; RooCategoryProxyRooSimultaneous::_indexCatIndex category; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html:43607,access,access,43607,root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__HistFactorySimultaneous.html,2,['access'],['access']
Security,"ent file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode. ; Reimplemented in TTreeSQL.; Definition at line 2074 of file TTree.cxx. ◆ BranchRef(). TBranch * TTree::BranchRef ; (; ). virtual . Build the optional branch supporting the TRefTable. ; This branch will keep all the information to find the branches containing referenced objects.; At each Tree::Fill, the branch numbers containing the referenced objects are saved to the TBranchRef basket. When the Tree header is saved (via TTree::Write), the branch is saved keeping the information with the pointers to the branches having referenced objects. ; Definition at line 2328 of file TTree.cxx. ◆ Bronch(). TBranch * TTree::Bronch ; (; const char * ; name, . const char * ; classname, . void * ; addr, . Int_t ; bufsize = 32000, . Int_t ; splitlevel = 99 . ). virtual . Create a new TTree BranchElement. . WARNING about this new function; This function is designed to replace the internal implementation o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:94256,access,access,94256,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['access']
Security,"ent file; IMPORTANT NOTE about branch names:; And in general, in case two or more master branches contain subbranches with identical names, one must add a ""."" (dot) character at the end of the master branch name. This will force the name of the subbranches to be of the form master.subbranch instead of simply subbranch. This situation happens when the top level object has two or more members referencing the same class. For example, if a Tree has two branches B1 and B2 corresponding to objects of the same class MyClass, one can do: tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; bufsize is the buffer size in bytes for this branch The default value is 32000 bytes and should be ok for most cases. You can specify a larger value (e.g. 256000) if your Tree is not split and each entry is large (Megabytes) A small value for bufsize is optimum if you intend to access the entries in the Tree randomly and your Tree is in split mode.; Use splitlevel < 0 instead of splitlevel=0 when the class has a custom Streamer; Note: if the split level is set to the default (99), TTree::Branch will not issue a warning if the class can not be split. ; Reimplemented in TTreeSQL.; Definition at line 2404 of file TTree.cxx. ◆ BronchExec(). TBranch * TTree::BronchExec ; (; const char * ; name, . const char * ; classname, . void * ; addobj, . bool ; isptrptr, . Int_t ; bufsize, . Int_t ; splitlevel . ). protectedvirtual . Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);. ; Definition at line 2412 of file TTree.cxx. ◆ Browse(). void TTree::Browse ; (; TBrowser * ; b). overridevirtual . Browse content of the TTree. ; Reimplemented from TObject.; Definition at line 2609 of file TTree.cxx. ◆ BuildIndex(). Int_t TTree::BuildIndex ; (; const char * ; majorname, . const char * ; minorname = ""0"" . ). virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:97541,access,access,97541,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['access'],['access']
Security,"ent loop with a different mechanism depending on IMT/no IMT, data source/no data source. ; Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...). The jitting phase is skipped if the jit parameter is false (unsafe, use with care). ; Definition at line 889 of file RLoopManager.cxx. ◆ RunAndCheckFilters(). void RLoopManager::RunAndCheckFilters ; (; unsigned int ; slot, . Long64_t ; entry . ). private . Execute actions and make sure named filters are called for each event. ; Named filters must be called even if the analysis logic would not require it, lest they report confusing results. ; Definition at line 708 of file RLoopManager.cxx. ◆ RunDataSource(). void RLoopManager::RunDataSource ; (; ). private . Run event loop over data accessed through a DataSource, in sequence. ; Definition at line 635 of file RLoopManager.cxx. ◆ RunDataSourceMT(). void RLoopManager::RunDataSourceMT ; (; ). private . Run event loop over data accessed through a DataSource, in parallel. ; Definition at line 666 of file RLoopManager.cxx. ◆ RunEmptySource(). void RLoopManager::RunEmptySource ; (; ). private . Run event loop with no source files, in sequence. ; Definition at line 505 of file RLoopManager.cxx. ◆ RunEmptySourceMT(). void RLoopManager::RunEmptySourceMT ; (; ). private . Run event loop with no source files, in parallel. ; Definition at line 458 of file RLoopManager.cxx. ◆ RunTreeProcessorMT(). void RLoopManager::RunTreeProcessorMT ; (; ). private . Run event loop over one or multiple ROOT files, in parallel. ; Definition at line 549 of file RLoopManager.cxx. ◆ RunTreeReader(). void RLoopManager::RunTreeReader ; (; ). private . Run event loop over one or multiple ROOT files, in sequence. ; Definition at line 597 of file RLoopManager.cxx. ◆ SetEmptyEntryRange(). void RLoopManager::SetEmptyEntryRange ; (; std::pair< ULong64_t, ULong64_t > && ; newRange). Definition at line 1158 of file RLoopManager.cxx. ◆ SetTree(). void RLoop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:24743,access,accessed,24743,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['access'],['accessed']
Security,"ent wise comparison ;  ; bool operator> (const T &rhs) const;  element wise comparison ;  ; bool operator< (const T &rhs) const;  element wise comparison ;  ; bool operator> (const SVector< T, D > &rhs) const;  element wise comparison ;  ; bool operator< (const SVector< T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator> (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; template<class A > ; bool operator< (const VecExpr< A, T, D > &rhs) const;  element wise comparison ;  ; const T & operator[] (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & operator() (unsigned int i) const;  read-only access of vector elements. Index starts from 0. ;  ; const T & At (unsigned int i) const;  read-only access of vector elements with check on index. Index starts from 0. ;  ; T & operator[] (unsigned int i);  read/write access of vector elements. Index starts from 0. ;  ; T & operator() (unsigned int i);  read/write access of vector elements. Index starts from 0. ;  ; T & At (unsigned int i);  read/write access of vector elements with check on index. Index starts from 0. ;  ; SVector< T, D > & operator+= (const T &rhs);  self addition with a scalar ;  ; SVector< T, D > & operator-= (const T &rhs);  self subtraction with a scalar ;  ; SVector< T, D > & operator*= (const T &rhs);  self multiplication with a scalar ;  ; SVector< T, D > & operator/= (const T &rhs);  self division with a scalar ;  ; SVector< T, D > & operator+= (const SVector< T, D > &rhs);  self addition with another vector ;  ; SVector< T, D > & operator-= (const SVector< T, D > &rhs);  self subtraction with another vector ;  ; template<class A > ; SVector< T, D > & operator+= (const VecExpr< A, T, D > &rhs);  self addition with a vector expression ;  ; template<class A > ; SVector< T, D > & operator-= (const VecExpr< A, T, D > &rhs);  self subtraction with a vector expression ;  ; — Expert functions —; SVector< T, D > & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html:5207,access,access,5207,doc/master/classROOT_1_1Math_1_1SVector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1SVector.html,1,['access'],['access']
Security,"ent)Helper function used by TClass::GetClass().Definition TClass.cxx:5749; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3770; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kClassNew@ kClassNewDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4327; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6922; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5704; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5696; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3422; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7455; TClass::RepoCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:59698,access,accessor,59698,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['access'],['accessor']
Security,"ent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::fSharedLibsTString fSharedLibsDefinition TClass.h:227; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::ENewTypeENewTypeDefinition TClass.h:107; TClass::kClassNew@ kClassNewDefinition TClass.h:107; TClass::kRealNew@ kRealNewDefinition TClass.h:107; TClass::kDummyNew@ kDummyNewDefinition TClass.h:107; TClass::Movevoid Move(void *arenaFrom, void *arenaTo) constRegister the fact that an object was moved from the memory location 'arenaFrom' to the memory locatio...Definition TClass.cxx:4394; TClass::GetDeclIdMapstatic DeclIdMap_t * GetDeclIdMap()Definition TClass.cxx:480; TClass::GetDeclFileLineShort_t GetDeclFileLine() constDefinition TClass.h:429; TClass::SetStreamerFuncvoid SetStreamerFunc(ClassStreamerFunc_t strm)Set a wrapper/accessor function around this class custom streamer.Definition TClass.cxx:6989; TClass::GetImplFileNameconst char * GetImplFileName() constDefinition TClass.h:456; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::SizeInt_t Size() constReturn size of object of this class.Definition TClass.cxx:5771; TClass::SetCurrentStreamerInfovoid SetCurrentStreamerInfo(TVirtualStreamerInfo *info)Set pointer to current TVirtualStreamerInfo.Definition TClass.cxx:5763; TClass::GetDictstatic DictFuncPtr_t GetDict(const char *cname)Return a pointer to the dictionary loading function generated by rootcint.Definition TClass.cxx:3489; TClass::fOffsetStreamerLongptr_t fOffsetStreamerProperties that can only be evaluated at run-time.Definition TClass.h:275; TClass::fSizeofInt_t fSizeofDefinition TClass.h:243; TClass::GetNewArrayROOT::NewArrFunc_t GetNewArray() constReturn the wrapper around new ThisClass[].Definition TClass.cxx:7522; TClass::RepoCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:59526,access,accessor,59526,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,1,['access'],['accessor']
Security,"ent. ~TProofMgr(); Destroy a TProofMgr instance. TProof * AttachSession(Int_t , Bool_t = kFALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. The boolena 'gui' should be kTRUE when invoked from the GUI. TProof * AttachSession(TProofDesc* , Bool_t = kFALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. void DetachSession(Int_t , Option_t* = """"); Detach session with 'id' from its proofserv. The 'id' is the number; shown by QuerySessions. The correspondent TProof object is deleted.; If id == 0 all the known sessions are detached.; Option opt=""S"" or ""s"" forces session shutdown. void DetachSession(TProof* , Option_t* = """"); Detach session 'p' from its proofserv. The instance 'p' is invalidated; and should be deleted by the caller. TList * QuerySessions(Option_t* opt = ""S""); Get list of sessions accessible to this manager. Int_t SendMsgToUsers(const char* , const char* = 0); Send a message to connected users. Only superusers can do this.; The first argument specifies the message or the file from where to take; the message.; The second argument specifies the user to which to send the message: if; empty or null the message is send to all the connected users.; return 0 in case of success, -1 in case of error. Int_t Reset(Bool_t hard = kFALSE, const char* usr = 0); Send a cleanup request for the sessions associated with the current; user.; Not supported. void ShowWorkers(); Show available workers. TProofDesc * GetProofDesc(Int_t id); Get TProofDesc instance corresponding to 'id'. TProofDesc * GetProofDesc(TProof* p); Get TProofDesc instance corresponding to TProof object 'p'. void DiscardSession(TProof* p); Discard TProofDesc of session 'p' from the internal list. TProof * CreateSession(const char* = 0, const char* = 0, Int_t = -1); Create a new remote session (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofMgr.html:9569,access,accessible,9569,root/html528/TProofMgr.html,https://root.cern,https://root.cern/root/html528/TProofMgr.html,6,['access'],['accessible']
Security,"ent=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::PropertyLong_t Property() const overrideReturns the properties of the TClass as a bit field stored as a Long_t value.Definition TClass.cxx:6153; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::IsVersionedBool_t IsVersioned() constDefinition TClass.h:522; TClass::FindStreamerInfoTVirtualStreamerInfo * FindStreamerInfo(TObjArray *arr, UInt_t checksum) constFind the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum.Definition TClass.cxx:7133; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetRealDataTRealData * GetRealData(const char *name) constReturn pointer to TRealData element with name ""name"".Definition TClass.cxx:3570; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::ExpandCreateFastvirtual void ExpandCreateFast(Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:284808,checksum,checksum,284808,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,2,['checksum'],['checksum']
Security,entListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooAbsTestStatistic**RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance ; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsOptTestStatistic.html:36527,access,access,36527,root/html534/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsOptTestStatistic.html,1,['access'],['access']
Security,"ented by a box filled with a color index, which is a function of the cell content. If the cell content is N, the color index used will be the color number in colors[N] . If the maximum cell content is greater than ncolors , all cell contents are scaled to ncolors. If ncolors<=0, a default palette of 50 colors is defined. This palette is recommended for pads, labels. It defines:. Index 0 to 9: shades of gray; Index 10 to 19:shades of brown; Index 20 to 29:shades of blue; Index 30 to 39: shades of red; Index 40 to 49:basic colors. The color numbers specified in this palette can be viewed by selecting the menu entry Colors in the View menu of the canvas menu bar. The color’s red, green, and blue values can be changed via TColor::SetRGB.; If ncolors == 1 && colors == 0, then a Pretty Palette with a spectrum violet to red is created with 50 colors. That’s the default rain bow palette.; Other predefined palettes with 255 colors are available when colors == 0. The following value of ncolors (with colors = 0) give access to:. ncolors = 51 : Deep Sea palette.; ncolors = 52 : Grey Scale palette.; ncolors = 53 : Dark Body Radiator palette.; ncolors = 54 : Two-color hue palette palette. (dark blue through neutral gray to bright yellow); ncolors = 55 : Rain Bow palette.; ncolors = 56 : Inverted Dark Body Radiator palette. The color numbers specified in the palette can be viewed by selecting the item “colors” in the “VIEW” menu of the canvas toolbar. The color parameters can be changed via TColor::SetRGB.; Note that when drawing a 2D histogram h2 with the option “COL” or “COLZ” or with any “CONT” options using the color map, the number of colors used is defined by the number of contours n specified with: h2->SetContour(n); 3.8.2.13 TPaletteAxis; A TPaletteAxisobject is used to display the color palette when drawing 2D histograms. The object is automatically created when drawing a 2D histogram when the option “z” is specified. It is added to the histogram list of functions. It can",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:99581,access,access,99581,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['access'],['access']
Security,"ented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or used by another class. The arrow is labelled with the variable(s) through which the pointed class or struct is accessible. . A yellow dashed arrow denotes a relation between a template instance and the template class it was instantiated from. The arrow is labelled with the template parameters of the instance. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph_legend.html:2109,access,accessible,2109,doc/master/graph_legend.html,https://root.cern,https://root.cern/doc/master/graph_legend.html,1,['access'],['accessible']
Security,"entifier; Int_tTBranch::fNleaves! Number of leaves; Int_tTBranch::fOffsetOffset of this branch; TBranch*TBranch::fParent! Pointer to parent branch.; Int_tTBranch::fReadBasket! Current basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; Bool_tTBranch::fSkipZip!After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. private:. UInt_tfClCheckSumClass checksum; TStringfClassNameName of the parent class, if we're the data member; Int_tfClassVersionVersion number of the class; TVirtualCollectionProxy*fCollProxy! Collection proxy; TStringfContNameClass name of referenced object; Int_tfIDElement serial number in the streamer info; TIndArrayfInd! Indices; TClass*fIndArrayCl! Class of the ind array; TStreamerInfo*fInfo! The streamer info; char*fObject! Pointer to object at address or the; TBranch*fParent! Parent of this branch. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchSTL(); Default constructor. TBranchSTL(TTree* tree, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel); Normal constructor, called from TTree. TBranchSTL(TBranch* parent, const char* name, TVirtualCollectionProxy* collProxy, Int_t buffsize, Int_t splitlevel, TStreamerInfo* info, Int_t id); Normal constructor, called from another branch. ~TBranchSTL(); destructor. void Browse(TBrowser* b); browse a STL branch. Int_t Fill(). Cleanup after revious fill. Int_t GetEntry(Long64_t entry = 0, Int_t getall = 0). Check if we should be doing this at all. TStreamerInfo* GetInfo() const. Check if we don't have the stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchSTL.html:12003,checksum,checksum,12003,root/html526/TBranchSTL.html,https://root.cern,https://root.cern/root/html526/TBranchSTL.html,1,['checksum'],['checksum']
