quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability," ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; --------; >>> ket(""10"") # doctest: +SKIP; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue"") # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/states.html:17603,down,down,17603,docs/4.6/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html,4,['down'],['down']
Availability," ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; --------; >>> ket(""10""); Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue""); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; if isinstance(dim, int):; dim = [dim] * len(seq); return tensor([b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/states.html:14786,down,down,14786,docs/4.2/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/states.html,6,['down'],['down']
Availability," 'scipy'}. return def_args. def _mkl_steadystate_args():; def_args = {'max_iter_refine': 10,; 'scaling_vectors': True,; 'weighted_matching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'mkl',; 'use_rcm': False,; 'use_wbm': False, 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None,; 'maxiter': 1000}. return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, 'scipy', 'mkl'}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:5199,avail,availability,5199,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,2,['avail'],['availability']
Availability," (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propagator (by Nathan Shammah).; Fixed dimensional incongruence in propagator (by Nathan Shammah); Fixed bug by rewriting clebsch function based on long integer fraction (by Eric Giguère).; Fixed bugs in QobjEvo’s args depending on state and added solver tests using them (by Eric Giguère).; Fixed bug in sesolve calculation of average states when summing the timeslot states (by Alex Pitchford).; Fixed bug in steadystate solver by removing separate arguments for MKL and Scipy (by Tarun Raheja).; Fixed Bloch.add_ponts by setting edgecolor = None in plot_points (by Nathan Shammah).; Fixed error checking for null matrix in essolve solver affecting also ode2es (by Peter Kirton).; Removed unnecessary shebangs in .pyx and .pxd files (by Samesh Lakhotia).; Fixed sesolve and import of os in codegen (by Alex Pitchford).; Updated plot_fock_distribution by removing the offset value 0.4 in the plot (by Rajiv-B). Version 4.4.1 (Au",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:3284,error,error,3284,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,3,['error'],['error']
Availability," (float) Minimum normalised gradient after which optimisation will terminate. max_iterations; (integer) Maximum iterations of the optimisation algorithm. max_fid_func_calls; (integer) Maximum number of calls to the fidelity function during the optimisation algorithm. accuracy_factor; (float) Determines the accuracy of the result. Typical values for accuracy_factor are: 1e12 for low accuracy; 1e7 for moderate accuracy; 10.0 for extremely high accuracy scipy.optimize.fmin_l_bfgs_b factr argument. Only set for specific methods (fmin_l_bfgs_b) that uses this Otherwise the same thing is passed as method_option ftol (although the scale is different) Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt; Attributes. termination_reason; (string) Description of the reason for terminating the optimisation. fidelity; (float) final (normalised) fidelity that was achieved. initial_fid_err; (float) fidelity error before optimisation starting. fid_err; (float) final fidelity error that was achieved. goal_achieved; (boolean) True is the fidely error achieved was below the target. grad_norm_final; (float) Final value of the sum of the squares of the (normalised) fidelity error gradients. grad_norm_min_reached; (float) True if the optimisation terminated due to the minimum value of the gradient being reached. num_iter; (integer) Number of iterations of the optimisation algorithm completed. max_iter_exceeded; (boolean) True if the iteration limit was reached. max_fid_func_exceeded; (boolean) True if the fidelity function call limit was reached. wall_time; (float) time elapsed during the optimisation. wall_time_limit_exceeded; (boolean) True if the wall time limit was reached. time; (array[num_tslots+1] of float) Time are the start of each timeslot with the final value being the total evolution time. initial_amps; (array[num_tslots, n_ctrls]) The amplitudes at the start of the optimisation. fin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:71023,error,error,71023,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['error'],['error']
Availability," - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control ampli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:226063,error,error,226063,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability," -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:44964,error,error,44964,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['error'],['error']
Availability," / N_substeps; nt = sso.ntraj. data = Result(); data.solver = ""smepdpsolve""; data.times = sso.times; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # Liouvillian for the deterministic part.; # needs to be modified for TD systems; L = liouvillian(sso.H, sso.c_ops). progress_bar.start(sso.ntraj). for n in range(sso.ntraj):; progress_bar.update(n); rho_t = mat2vec(sso.rho0.full()).ravel(). states_list, jump_times, jump_op_idx = \; _smepdpsolve_single_trajectory(data, L, dt, sso.times,; N_store, N_substeps,; rho_t, sso.rho0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / sso.ntraj. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. return data. def _smepdpsolve_single_trajectory(data, L, dt, times, N_store, N_substeps,; rho_t, dims, c_ops, e_ops):; """"""; Internal function. See smepdpsolve.; """"""; states_list = []. rho_t = np.copy(rho_t); sigma_t = np.copy(rho_t). prng = RandomState() # todo: seed it; r_jump, r_op = prng.rand(2). jump_times = []; jump_op_idx = []. for t_idx, t in enumerate(times):. if e_ops:; for e_idx, e in enumerate(e_ops):; data.expect[e_idx, t_idx] += expect_rho_vec(e, rho_t); else:; states_list.append(Qobj(vec2mat(rho_t), dims=dims)). for j in range(N_substeps):. if sigma_t.norm() < r_jump:; # jump occurs; p = np.array([expect(c.dag() * c, rho_t) for c in c_ops]); p = np.cumsum(p / np.sum(p)); n = np.where(p >= r_op)[0][0]. # apply jump; rho_t = c_ops[n] * rho_t * c_ops[n].dag(); rho_t /= expect(c_ops[n].dag() * c_ops[n], rho_t); sigma_t = np.copy(rho_t). # store info about jump; jump_times.appe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:34985,error,error,34985,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['error'],['error']
Availability," 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. Expectation Values¶. expect(oper, state)¶; Calculates the expectation value for operator(s) and state(s). Parameters:oper : qobj/array-like. A single or a list or operators for expectation value. state : qobj/array-like. A single or a list of quantum states or density matrices. Returns:expt : float/complex/array-like. Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:25343,mask,mask,25343,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,4,['mask'],['mask']
Availability," : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:4866,error,errors,4866,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['error'],['errors']
Availability," : list; An ordered list of times at which to return the value of the state. e_ops : Qobj / callable / list / dict / None, optional; A list or dictionary of operators as `Qobj` and/or callable; functions (they can be mixed) or a single operator or callable; function. For an operator ``op``, the result will be computed; using ``(state * op).tr()`` and the state at each time ``t``. For; callable functions, ``f``, the result is computed using; ``f(t, ado_state)``. The values are stored in ``expect`` on; (see the return section below). ado_init: bool, default False; Indicates if initial condition is just the system state, or a; numpy array including all ADOs. ado_return: bool, default True; Whether to also return as output the full state of all ADOs. Returns; -------; :class:`qutip.solver.Result`; The results of the simulation run, with the following attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if ``ado_return`` was set to ``True``). Each element is an; instance of :class:`HierarchyADOsState`. .; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`.extract`. * ``expect``: the value of each ``e_ops`` at time ``t`` (only; available if ``e_ops`` were given). If ``e_ops`` was passed; as a dictionary, then ``expect`` will be a dictionary with; the same keys as ``e_ops`` and values giving the list of; outcomes for the corresponding key.; """"""; e_ops, expected = self._convert_e_ops(e_ops); e_ops_callables = any(; not isinstance(op, Qobj) for op in e_ops.values(); ). n = self._sys_shape; rho_shape = (n, n); rho_dims = self._sys_dims; hierarchy_shape = (self._n_ados, n, n). output = Result(); output.solver = ""HEOMSolver""; output.times = tlist; if e_ops:; output.expect = expected; if not e_ops or sel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:25443,avail,available,25443,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,2,['avail'],['available']
Availability," : str. Directory for output images. Defaults to current working directory. Returns:File containing plot of Bloch sphere. :. show()¶; Display the Bloch sphere and corresponding data sets. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False)¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers.; Attributes. atol; float {1e-8}; Absolute tolerance. rtol; float {1e-6}; Relative tolerance. method; str {‘adams’,’bdf’}; Integration method. order; int {12}; Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; int {2500}; Max. number of internal steps/call. first_step; float {0}; Size of initial step (0 = automatic). min_step; float {0}; Minimum step size (0 = automatic). max_step; float {0}; Maximum step size (0 = automatic). tidy; bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus; int; Number of cpus used by mcsolver (default = # of cpus). norm_tol; float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps; int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states; bool {False}; Average states values over trajectories in stochastic solvers. average_expect; bool {True}; Avgerage expectation values over trajectories for stochastic solvers. ntraj; int {500}; Number of trajectories in stochastic solvers. rhs_reuse; bool {False,True}; Reuse Hamiltonian ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/classes.html:23988,toler,tolerance,23988,docs/3.0.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/classes.html,1,['toler'],['tolerance']
Availability," : str. Directory for output images. Defaults to current working directory. Returns:File containing plot of Bloch sphere. :. show()¶; Display the Bloch sphere and corresponding data sets. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False)¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers.; Attributes. atol; float {1e-8}; Absolute tolerance. rtol; float {1e-6}; Relative tolerance. method; str {‘adams’,’bdf’}; Integration method. order; int {12}; Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; int {2500}; Max. number of internal steps/call. first_step; float {0}; Size of initial step (0 = automatic). min_step; float {0}; Minimum step size (0 = automatic). max_step; float {0}; Maximum step size (0 = automatic). tidy; bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus; int; Number of cpus used by mcsolver (default = # of cpus). norm_tol; float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps; int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states; bool {True, False}; Avg. expectation values in mcsolver. ntraj; int {500}; Number of trajectories in stochastic solvers. rhs_reuse; bool {False,True}; Reuse Hamiltonian data. rhs_with_state; bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback sign",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:23926,toler,tolerance,23926,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,1,['toler'],['tolerance']
Availability," = 'operator-ket'; else:; new_dims = [self.dims[0], [1] * len(self.dims[0])]; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket in ekets]); if phase_fix is None:; phase = np.array([1] * len(ekets)); else:; phase = np.array([np.abs(ket[phase_fix, 0]) / ket[phase_fix, 0]; if ket[phase_fix, 0] else 1; for ket in ekets]); return evals, ekets / norms * phase. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:44979,toler,tolerance,44979,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,4,['toler'],['tolerance']
Availability," = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_ev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:20871,error,error,20871,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['error'],['error']
Availability," = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qey",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:9969,down,down,9969,docs/4.6/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html,4,['down'],['down']
Availability," = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]. Now we see the difference! The qutip.operators.sigmap operator acting on the spin state returns the zero vector. Why is this? To see what happened, let us use the qutip.operators.sigmaz operator:; In [51]: sigmaz(); Out[51]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [52]: sigmaz() * spin; Out[52]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [53]: spin2 = basis(2, 1). In [54]: spin2; Out[54]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. In [55]: sigmaz() * spin2; Out[55]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [56]: sigmaz() * spin; Out[56]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-states.html:14511,down,downarrow,14511,docs/3.1.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html,1,['down'],['downarrow']
Availability," = []; exponents.extend(; BathExponent(""R"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_real, vk_real); ); exponents.extend(; BathExponent(""I"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_imag, vk_imag); ). if combine:; exponents = self.combine(exponents). super().__init__(exponents). [docs] @classmethod; def combine(cls, exponents, rtol=1e-5, atol=1e-7):; """"""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""; groups = []; remaining = exponents[:]. while remaining:; e1 = remaining.pop(0); group = [e1]; for e2 in remaining[:]:; if (; np.isclose(e1.vk, e2.vk, rtol=rtol, atol=atol) and; np.allclose(e1.Q, e2.Q, rtol=rtol, atol=atol); ):; group.append(e2); remaining.remove(e2); groups.append(group). new_exponents = []; for combine in groups:; exp1 = combine[0]; if (exp1.type != exp1.types.RI) and all(; exp2.type == exp1.type for exp2 in combine; ):; # the group is either type I or R; ck = sum(exp.ck for exp in combine); new_exponents.append(BathExponent(; exp1.type, None, exp1.Q, ck, exp1.vk, tag=exp1.tag,; )); else:; # the group includes both type I and R exponents; ck_R = (; sum(exp.ck for exp in combine if exp.type == exp.types.R) +; sum(exp.ck for exp in combine if exp.type == exp.types.RI); ); ck_I = (; sum(exp.ck for exp in combine if exp.type == exp.type",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:7852,toler,tolerance,7852,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['toler'],['tolerance']
Availability," = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type). # Create the FideliyComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; if fid_type == 'DEF' or fid_type is None or fid_type == '':; # None given, use the default for the Dynamics; pass; elif fid_type == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type). if isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:28968,error,errors,28968,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['error'],['errors']
Availability," A list or dictionary of operators as `Qobj` and/or callable; functions (they can be mixed) or a single operator or callable; function. For an operator ``op``, the result will be computed; using ``(state * op).tr()`` and the state at each time ``t``. For; callable functions, ``f``, the result is computed using; ``f(t, ado_state)``. The values are stored in ``expect`` on; (see the return section below). ado_init: bool, default False; Indicates if initial condition is just the system state, or a; numpy array including all ADOs. ado_return: bool, default True; Whether to also return as output the full state of all ADOs. Returns; -------; :class:`qutip.solver.Result`; The results of the simulation run, with the following attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if ``ado_return`` was set to ``True``). Each element is an; instance of :class:`HierarchyADOsState`. .; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`.extract`. * ``expect``: the value of each ``e_ops`` at time ``t`` (only; available if ``e_ops`` were given). If ``e_ops`` was passed; as a dictionary, then ``expect`` will be a dictionary with; the same keys as ``e_ops`` and values giving the list of; outcomes for the corresponding key.; """"""; e_ops, expected = self._convert_e_ops(e_ops); e_ops_callables = any(; not isinstance(op, Qobj) for op in e_ops.values(); ). n = self._sys_shape; rho_shape = (n, n); rho_dims = self._sys_dims; hierarchy_shape = (self._n_ados, n, n). output = Result(); output.solver = ""HEOMSolver""; output.times = tlist; if e_ops:; output.expect = expected; if not e_ops or self.options.store_states:; output.states = []. if ado_init:; if isinstance(rho0, HierarchyADOsState):; rho0_he = rho0._ado_state; else",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:25600,avail,available,25600,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,2,['avail'],['available']
Availability," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/stats.html:2324,redundant,redundant,2324,docs/4.1/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/stats.html,8,['redundant'],['redundant']
Availability," Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-fee",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:17718,down,download,17718,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['down'],['download']
Availability," Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-fee",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:11931,down,download,11931,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['down'],['download']
Availability," Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-measurement.html:1979,down,down,1979,docs/4.6/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html,2,['down'],['down']
Availability," Emiliano Fortes); MAJOR Imported BoFiN HEOM (https://github.com/tehruhn/bofin/) into QuTiP and replaced the HEOM solver with a compatibility wrapper around BoFiN bosonic solver. (#1601, #1726, and #1724 by Simon Cross, Tarun Raheja and Neill Lambert); MAJOR Added support for plotting lines and arcs on the Bloch sphere. (#1690 by Gaurav Saxena, Asier Galicia and Simon Cross); Added transparency parameter to the add_point, add_vector and add_states methods in the Bloch and Bloch3d classes. (#1837 by Xavier Spronken); Support Path objects in qutip.fileio. (#1813 by Adrià Labay); Improved the weighting in steadystate solver, so that the default weight matches the documented behaviour and the dense solver applies the weights in the same manner as the sparse solver. (#1275 and #1802 by NS2 Group at LPS and Simon Cross); Added a color_style option to the hinton plotting function. (#1595 by Cassandra Granade); Improved the scaling of floquet_master_equation_rates and floquet_master_equation_tensor and fixed transposition and basis change errors in floquet_master_equation_tensor and floquet_markov_mesolve. (#1248 by Camille Le Calonnec, Jake Lishman and Eric Giguère); Removed linspace_with and view_methods from qutip.utilities. For the former it is far better to use numpy.linspace and for the later Python’s in-built help function or other tools. (#1680 by Eric Giguère); Added support for passing callable functions as e_ops to mesolve and sesolve. (#1655 by Marek Narożniak); Added the function steadystate_floquet, which returns the “effective” steadystate of a periodic driven system. (#1660 by Alberto Mercurio); Improved mcsolve memory efficiency by not storing final states when they are not needed. (#1669 by Eric Giguère); Improved the default colors and styling of matrix_histogram and provided additional styling options. (#1573 and #1628 by Mahdi Aslani); Sped up state_number_enumerate, state_number_index, state_index_number, and added some error checking. enr_state_diction",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:9313,error,errors,9313,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['error'],['errors']
Availability," False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a therm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-steady.html:8672,Toler,Tolerance,8672,docs/4.6/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-steady.html,2,['Toler'],['Tolerance']
Availability," False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:7878,error,errors,7878,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['error'],['errors']
Availability," Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can also carry out measurements on individual qubit (both in the middle and at the end of the circuit).; Each measurement is saved as a class object Measurement with parameters such as targets,; the target qubit on which the measurement will be carried out, and classical_store,; the index of the classical register which stores the result of the measurement. A circuit with the various gates and registers available is demonstrated below:; from qutip.qip.circuit import QubitCircuit, Gate; from qutip import tensor, basis. qc = QubitCircuit(N=2, num_cbits=1); swap_gate = Gate(name=""SWAP"", targets=[0, 1]). qc.add_gate(swap_gate); qc.a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-basics.html:1984,avail,available,1984,docs/4.7/guide/qip/qip-basics.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html,2,['avail'],['available']
Availability," However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C-code:; 'abs', 'arccos', 'arccosh', 'arg', 'arcsin', 'arcsinh', 'arctan', 'arctan2', 'arctanh', 'conj',; 'cos', 'cosh','exp', 'imag', 'log', 'pow', 'proj, 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp',; 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',; 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'tau', 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficien",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html:4042,avail,available,4042,docs/4.1/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-time.html,1,['avail'],['available']
Availability," However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C-code:; 'abs', 'arccos', 'arccosh', 'arg', 'arcsin', 'arcsinh', 'arctan', 'arctan2', 'arctanh', 'conj',; 'cos', 'cosh','exp', 'imag', 'log', 'pow', 'proj, 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp',; 'expm1', 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum',; 'gamma', 'gcd', 'hypot', 'inf', 'isclose', 'isfinite', 'isinf',; 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p', 'log2', 'modf',; 'nan', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh',; 'trunc'], ; dtype='<U9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html:3943,avail,available,3943,docs/4.0.2/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-time.html,1,['avail'],['available']
Availability," LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:3945,avail,available,3945,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['avail'],['available']
Availability," M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'],; atol=ss_args['matol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:23160,error,error,23160,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,8,"['error', 'toler']","['error', 'tolerance']"
Availability," Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, ...) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:13058,error,errors,13058,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,1,['error'],['errors']
Availability," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:2316,error,error,2316,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['error'],['error']
Availability," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/fidcomp.html:2325,error,error,2325,docs/4.5/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/fidcomp.html,2,['error'],['error']
Availability," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:2345,error,error,2345,docs/4.6/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html,4,['error'],['error']
Availability," None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It wil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:198413,error,error,198413,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability," Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:175189,error,error,175189,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability," Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used.; method_params (dict) – Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option (string) – determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:183759,error,error,183759,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability," Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:5084,down,download,5084,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['down'],['download']
Availability," QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are describ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-settings.html:1764,toler,tolerance,1764,docs/4.0.2/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html,1,['toler'],['tolerance']
Availability," Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.3. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-overview.html:1651,avail,available,1651,docs/4.3/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-overview.html,1,['avail'],['available']
Availability," Released. Release Notes; PyPI; Conda-forge. April 11, 2022; QuTiP 2021 Annual Report. QuTiP 2021 Annual Report. June 7, 2021; 2021 Google Summer of Code Project Updates. Felipe's blog posts; Purva's blog posts; Asier's blog posts. March 18, 2021; Technical Staff Position for QuTiP Available at RIKEN. See QuTiP Jobs. March 15, 2021; QuTiP applies to Google Summer of Code 2021 under the NumFOCUS organization. NumFOCUS GSoC 2021; QuTiP Proposal Ideas; Application Period: March 29- April 13, 2021. June 22, 2020; 2020 Google Summer of Code Project Updates. Jake's Blog posts; Sidhant's Blog posts; Asad's Blog posts. April 6, 2020; Unitary Fund supports QuTiP development through remote mentorships. Website; Blog post. March 16, 2020; Student applications open for Google Summer of Code 2020. Project Ideas. December 12, 2019; Krotov is a new quantum optimal control library built on top of QuTiP. Github repository; SciPost paper. November 31, 2019; QuTiP is listed as an available project in Kharagpur Winter of Code for Indian Institute of Technology students. KWoC 2019. September 11, 2019; QuTiP features for quantum information science are presented in a talk at IQIS 2019 in Milan, Italy. IQIS 2019. September 3-4, 2019; QuTiP joins the European open-source community of scientist using Python at EuroScipy 2019 in Bilbao, Spain. Tutorial: Quantum measurement; Seminar: QuTiP as an ecosystem for quantum physics exploration. July 23, 2019; Two students working on QuTiP projects for Google Summer of Code. Boxi's Blog on noise in QIP; Saumya's Blog on lattice models. July 3, 2019; QuTiP 4.4.0 is released. Available with conda and pip. Changelog. June 25, 2019; An interactive course on QuTiP and open source for physicists is taught at ICTP Trieste, Italy. Slides and MyBinder Notebooks. March 19, 2019; QuTiP Poster Presented at the Coherent Network Computing Conference in Atsugi, Japan. Poster; CNC Website. March 1, 2019; QuTiP Participates to Google Summer of Code 2019 trough NumFOC",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/news.html:2430,avail,available,2430,news.html,https://qutip.org,https://qutip.org/news.html,1,['avail'],['available']
Availability," Returns:oper : qutip.qobj.Qobj. Squeezing operator. phase(N, phi0=0)¶; Single-mode Pegg-Barnett phase operator. Parameters:N : int. Number of basis states in Hilbert space. phi0 : float. Reference phase. Returns:oper : qobj. Phase operator with respect to reference phase. Notes; The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None)¶; Creates a random NxN density matrix. Parameters:N : int. Shape of output density matrix. density : float. Density between [0,1] of output density matrix. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_herm(N, density=0.75, dims=None)¶; Creates a random NxN sparse Hermitian quantum object.; Uses \(H=X+X^{+}\) where \(X\) is; a randomly generated quantum operator with a given density. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Hermitian operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Hermitian quantum operator. rand_ket(N, density=1, dims=None)¶; Creates a random Nx1 sparse ket vector. Parameters:N : int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)¶; Creates a random NxN sparse unitary quantum object.; Uses \(\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:18303,error,error,18303,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['error'],['error']
Availability," SciPost Phys. 2, 003 (2017). 220. Dory et al., ""Tuning the photon statistics of a strongly coupled nanophotonic system"", ; Phys. Rev. A 95, 023804 (2017). 219. Lachance-Quirion et al., ""Resolving quanta of collective spin excitations in a millimeter-sized ferromagnet"", ; Science Advances 3, (2017). 218. Doyeux et al., ""Excitation injector in an atomic chain: Long-range transport and efficiency amplification"", ; Phys. Rev. A 95, 012138 (2017). 217. Roulet et al., ""Autonomous Rotor Heat Engine"", ; Phys. Rev. E 95, 062131 (2017). 216. Nigg et al., ""Robust quantum optimizer with full connectivity"", ; Science Advances 3, 1602273 (2017). 215. Puri et al., ""Quantum annealing with all-to-all connected nonlinear oscillators"", ; Nat. Commun. 8, 15785 (2017).>. 214. Shi et al., ""Model reduction of cavity nonlinear optics for photonic logic: a quasi-principal components approach"", ; J. Phys. D: Appl. Phys. 49, 465501 (2016). 213. McNally et al., ""Performance of 1D quantum cellular automata in the presence of error"", ; AIP Advances 6, 095115 (2016). 212. Zhong et al., ""Towards quantum entanglement of micromirrors via a two-level atom and radiation pressure"", ; arXiv:1609.00590. 211. Roth et al., ""Synchronization of active atomic clocks via quantum and classical channels"", ; Phys. Rev. A 94, 043841 (2016). 210. Jarlov et al., ""Effect of Pure Dephasing and Phonon Scattering on the Coupling of Semiconductor Quantum Dots to Optical Cavities"", ; Phys. Rev. Lett. 117, 076801 (2016). 209. Mahajan et al., ""Entanglement structure of non-equilibrium steady states"", ; arXiv:1608.05074. 208. Zhu et al., ""Implementing phase-covariant cloning in circuit quantum electrodynamics"", ; Annals of Physics 373, 512 (2016). 207. Fischer et al., ""Dynamical modeling of pulsed two-photon interference"", ; New J. Phys. 18, 113053 (2016).; Notebook1; Notebook2. 206. Seifoory et al., ""The properties of squeezed optical states created in lossy cavities"", ; arXiv:1608.05005. 205. Qin et al., ""Heralded quantum",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:20857,error,error,20857,users.html,https://qutip.org,https://qutip.org/users.html,1,['error'],['error']
Availability," Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-basics.html:1910,avail,available,1910,docs/3.0.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html,1,['avail'],['available']
Availability," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html:2396,mask,mask,2396,docs/4.3/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html,10,['mask'],['mask']
Availability," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:2396,mask,mask,2396,docs/4.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html,8,['mask'],['mask']
Availability," THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Impleme",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html:2926,mask,mask,2926,docs/4.3/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html,10,['mask'],['mask']
Availability," THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:2926,mask,mask,2926,docs/4.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html,8,['mask'],['mask']
Availability," The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:14346,down,downarrow,14346,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,4,['down'],['downarrow']
Availability," The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. guess_pulse_typestringtype / shape of pulse(s) used modulate the control amplitudes.; Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. Default is None. guess_pulse_paramsdictParameters for the guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:187357,error,error,187357,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,['error'],['error']
Availability," True a TextProgressBar will be used. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str. Name of generated RHS. cleanup: bool. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. spin_q_function(rho, theta, phi)[source]¶; Husimi Q-function for spins. Parameters:state : qobj. A state vector or density matrix for a spin-j quantum system. theta : array_like. theta-coordinates at which to calculate the Q f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:109595,error,error,109595,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:217034,error,error,217034,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,4,['error'],['error']
Availability," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. RN",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:162715,error,error,162715,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,12,['error'],['error']
Availability," Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Setting Options for the Dynamics Solvers. « Performance (QuT... Solving for Stea... ». Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; >>> options = Options(). the properties and default values of this class can be view via the print function:; >>> print(options); Options properties:; ----------------------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 8; rhs_filename: None; rhs_reuse: False; gui: True; mc_avg: True. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-options.html:2353,toler,tolerance,2353,docs/3.0.0/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-options.html,2,['toler'],['tolerance']
Availability," WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; from copy import deepcopy. import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.operators import identity; from qutip.qip.operations.gates import expand_operator, globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.noise import (; Noise, RelaxationNoise, DecoherenceNoise,; ControlAmpNoise, RandomNoise, UserNoise, process_noise); from qutip.qip.pulse import Pulse, Drift, _merge_qobjevo, _fill_coeff. __all__ = ['Processor']. [docs]class Processor(object):; """"""; A simulator of a quantum device based on the QuTiP solver; :func:`qutip.mesolve`.; It is defined by the available driving Hamiltonian and; the decoherence time for each component systems.; The processor can simulate the evolution under the given; control pulses. Noisy evolution is supported by; :class:`qutip.qip.Noise` and can be added to the processor. Parameters; ----------; N: int; The number of component systems. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list, optional; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``. spline_kind: str, optional; Type of the coefficient interpolation. Default is ""step_func""; Note that they have different requirement for the length of `coeff'. -""step_func"":; The coefficient will be treated as a step function.; E.g. ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient; is 3 in t=[0,1)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html:2896,avail,available,2896,docs/4.5/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/processor.html,1,['avail'],['available']
Availability," [37]: b.show(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; In [39]: xp=[cos(th) for th in linspace(0,2*pi,20)]. In [40]: yp=[sin(th) for th in linspace(0,2*pi,20)]. In [41]: zp=zeros(20). In [42]: pnts=[xp,yp,zp]. In [43]: b.add_points(pnts,'m') # <-- add a 'm' string to signify 'multi' colored points. In [44]: b.show(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; In [45]: xz=zeros(20). In [46]: yz=[sin(th) for th in linspace(0,pi,20)]. In [47]: zz=[cos(th) for th in linspace(0,pi,20)]. In [48]: b.add_points([xz,yz,zz]) # no 'm'. In [49]: b.show(). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The Bloch class uses Matplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In this sense the Bloch3d class is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-bloch.html:7700,down,down,7700,docs/3.0.0/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html,2,['down'],['down']
Availability," _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:18021,error,error,18021,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,7,['error'],['error']
Availability," _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:18007,error,error,18007,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,3,['error'],['error']
Availability," a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way or another. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:5838,error,error,5838,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,1,['error'],['error']
Availability," a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum information processing. Some of them are:. Krotov; Krotov focuses on the python implementation of Krotov’s method for quantum optimal control. pyEPR; pyEPR interfaces classical distributed microwave analysis with that of quantum structures and hamiltonians by providing easy to use analysis function and automation for the design of quantum chips. scQubits; scQubits is a Python library which provides a convenient way to simulate superconducting qubits by providing an interface to QuTiP. SimulaQron; SimulaQron is a distributed simulation of the end nodes in a quantum internet with the specific goal to explore application development. QInfer; QInfer is a library for working with sequential Monte Carlo methods for parameter estimation in quantum information. QPtomographer; QPtomographer derive quantum error bars for quantum processes in terms of the diamond norm to a reference quantum channel. QuNetSim; QuNetSim is a quantum networking simulation framework to develop and test protocols for quantum networks. qupulse; qupulse is a toolkit to facilitate experiments involving pulse driven state manipulation of physical qubits. Pulser; Pulser is a framework for composing, simulating and executing pulse sequences for neutral-atom quantum devices. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems.; There are detailed instructions on how to contribute code and documentation in the developers’ section of this guide.; You can also help out our users by answering questions in the QuTiP discussion mailing list, or by raising issues in the main GitHub repository if you find any bugs.; Anyone who contributes code will be duly recognized.; Even small contributions are noted.; See Contributors for a list of people who have helped in one way",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/frontmatter.html:6093,error,error,6093,docs/4.7/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html,1,['error'],['error']
Availability," a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and lists,; returns a list of the same structure, but where one or; more scalars have been removed. Examples; --------. >>> deep_remove([[[[0, 1, 2]], [3, 4], [5], [6, 7]]], 0, 5) # doctest: +SKIP; [[[[1, 2]], [3, 4], [], [6, 7]]]. """"""; if isinstance(l, list):; # Make a shallow copy at this level.; l = l[:]; for to_remove in what:; if to_remove in l:; l.remove(to_remove); else:; l = list(map(lambda elem: deep_remove(elem, to_remove), l)); return l. [docs]def unflatten(l, idxs):; """"""Unflattens a list by a given structure. Given a list of scalars and a deep list of indices; as produced by `flatten`, returns an ""unflattened""; form of the list. T",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/dimensions.html:3383,down,down,3383,docs/4.6/modules/qutip/dimensions.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/dimensions.html,4,['down'],['down']
Availability," a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> print(flatten([[[0], 1], 2])); [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and lists,; returns a list of the same structure, but where one or; more scalars have been removed. Examples; --------. >>> print(deep_remove([[[[0, 1, 2]], [3, 4], [5], [6, 7]]], 0, 5)); [[[[1, 2]], [3, 4], [], [6, 7]]]. """"""; if isinstance(l, list):; # Make a shallow copy at this level.; l = l[:]; for to_remove in what:; if to_remove in l:; l.remove(to_remove); else:; l = list(map(lambda elem: deep_remove(elem, to_remove), l)); return l. [docs]def unflatten(l, idxs):; """"""Unflattens a list by a given structure. Given a list of scalars and a deep list of indices; as produced by `flatten`, returns an ""unflattened""; form of the list. This perfectly invert",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/dimensions.html:3363,down,down,3363,docs/4.5/modules/qutip/dimensions.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/dimensions.html,1,['down'],['down']
Availability," a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. tol : Float; Optional threshold parameter for eigenvalues/Kraus ops to be discarded.; The default is to=1e-9. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper), tol); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper, tol); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). [docs]def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html:18809,error,errors,18809,docs/4.5/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/superop_reps.html,1,['error'],['errors']
Availability," a quantum object. Parameters. inptqutip.QobjInput quantum object. Returns. shapelistA list of the quantum objects shape. Notes; This function is for legacy compatibility only. Using the Qobj.shape; attribute is recommended. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None, seed=None)[source]¶; Creates a random NxN density matrix. Parameters. Nint, ndarray, listIf int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix. densityfloatDensity between [0,1] of output density matrix. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. seedintSeed for the random number generator. Returns. operqobjNxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_dm_ginibre(N=2, rank=None, dims=None, seed=None)[source]¶; Returns a Ginibre random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. If rank is None, a full-rank; (Hilbert-Schmidt ensemble) random density operator will be; returned. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. rankint or NoneRank of the sampled density operator. If None, a full-rank; density operator is generated. Returns. rhoQobjAn N × N density operator sampled from the Ginibre; or Hilbert-Schmidt distribution. rand_dm_hs(N=2, dims=None, seed=None)[source]¶; Returns a Hilbert-Schmidt random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifyin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:37121,error,error,37121,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:5736,avail,available,5736,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['avail'],['available']
Availability," a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future appli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2402,error,error,2402,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,2,['error'],['error']
Availability," answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [56]: sigmaz() * spin; Out[56]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [57]: vac = basis(5, 0). In [58]: one = basis(5, 1). In [59]: c = create(5). In [60]: N = num(5). In [61]: expect(N, vac); Out[61]: 0.0. In [62]: expect(N, one); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:14697,down,downarrow,14697,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,1,['down'],['downarrow']
Availability," answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [58]: vac = basis(5, 0). In [59]: one = basis(5, 1). In [60]: c = create(5). In [61]: N = num(5). In [62]: expect(N, vac); Out[62]: 0.0. In [63]: expect(N, one); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-states.html:15025,down,downarrow,15025,docs/4.4/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-states.html,1,['down'],['downarrow']
Availability," answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [58]: vac = basis(5, 0). In [59]: one = basis(5, 1). In [60]: c = create(5). In [61]: N = num(5). In [62]: expect(N, vac); Out[62]: 0.0. In [63]: expect(N, one); Out[63]: 1.0. In [64]: coh = coherent_dm(5, 1.0j). In [65]: expect(N, coh); Out[65]: 0.9970555745806596. In [6",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-states.html:14685,down,downarrow,14685,docs/4.5/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-states.html,1,['down'],['downarrow']
Availability," any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; self._num_ctrls = len(self.ctrl_dyn_gen). if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:26891,error,errors,26891,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['error'],['errors']
Availability," applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:219406,ERROR,ERROR,219406,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['ERROR'],['ERROR']
Availability," applied as dg*phase; """"""; if hasattr(self.dyn_gen_phase, 'dot'):; phased_dg = dg.dot(self._dyn_gen_phase); else:; phased_dg = dg*self._dyn_gen_phase; return phased_dg; ; def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:30595,error,errors,30595,docs/4.3/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html,1,['error'],['errors']
Availability," applied; after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and ge",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:240043,ERROR,ERROR,240043,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['ERROR'],['ERROR']
Availability," applied; after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and ge",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:252161,ERROR,ERROR,252161,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['ERROR'],['ERROR']
Availability," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; >>> ntraj = [1, 10, 100, 1000]. Keep in mind that ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:8266,error,errors,8266,docs/3.0.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html,2,['error'],['errors']
Availability," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; In [14]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000); 10.0%. Run time: 1.17s. Est. time left: 00:00:00:10; 20.0%. Run time: 2.27s. Est. time left: 00:00:00:09; 30.0%. Run time: 3.37s. Est. time left: 00:00:00:07; 40.0%. Run time: 4.51s. Est. time left: 00:00:00:06; 50.0%. Run time: 5.65s. Est. time left: 00:00:00:05; 60.0%. Run time: 6.78s. Est. time left: 00:00:00:04; 70.0%. Run time: 7.93s. Est. time left: 00:00:00:03; 80.0%. Run time: 9.06s. Est. time left: 00:00:00:02; 90.0%. Run time: 10.19s. Est. time left: 00:00:00:01; 100.0%. Run time: 11.29s. Est. time left: 00:00:00:00; Total run time: 11.34s. where we have added t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html:13011,error,errors,13011,docs/4.1/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html,1,['error'],['errors']
Availability," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; In [14]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000); 10.0%. Run time: 1.45s. Est. time left: 00:00:00:13; 20.0%. Run time: 2.89s. Est. time left: 00:00:00:11; 30.0%. Run time: 4.34s. Est. time left: 00:00:00:10; 40.0%. Run time: 5.78s. Est. time left: 00:00:00:08; 50.0%. Run time: 7.21s. Est. time left: 00:00:00:07; 60.0%. Run time: 8.64s. Est. time left: 00:00:00:05; 70.0%. Run time: 10.17s. Est. time left: 00:00:00:04; 80.0%. Run time: 11.59s. Est. time left: 00:00:00:02; 90.0%. Run time: 13.06s. Est. time left: 00:00:00:01; 100.0%. Run time: 14.45s. Est. time left: 00:00:00:00; Total run time: 14.55s. where we have added",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html:13011,error,errors,13011,docs/4.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html,1,['error'],['errors']
Availability," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; In [14]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000); 10.0%. Run time: 10.72s. Est. time left: 00:00:01:36; 20.0%. Run time: 21.56s. Est. time left: 00:00:01:26; 30.0%. Run time: 31.59s. Est. time left: 00:00:01:13; 40.0%. Run time: 44.59s. Est. time left: 00:00:01:06; 50.0%. Run time: 54.94s. Est. time left: 00:00:00:54; 60.0%. Run time: 67.04s. Est. time left: 00:00:00:44; 70.0%. Run time: 77.24s. Est. time left: 00:00:00:33; 80.0%. Run time: 87.60s. Est. time left: 00:00:00:21; 90.0%. Run time: 97.74s. Est. time left: 00:00:00:10; 100.0%. Run time: 107.73s. Est. time left: 00:00:00:00; Total run time: 107.79s. where we ha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html:13021,error,errors,13021,docs/4.0.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html,1,['error'],['errors']
Availability," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; In [14]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000); 10.0%. Run time: 2.03s. Est. time left: 00:00:00:18; 20.0%. Run time: 3.56s. Est. time left: 00:00:00:14; 30.0%. Run time: 5.10s. Est. time left: 00:00:00:11; 40.0%. Run time: 6.92s. Est. time left: 00:00:00:10; 50.0%. Run time: 8.75s. Est. time left: 00:00:00:08; 60.0%. Run time: 10.56s. Est. time left: 00:00:00:07; 70.0%. Run time: 12.28s. Est. time left: 00:00:00:05; 80.0%. Run time: 14.25s. Est. time left: 00:00:00:03; 90.0%. Run time: 15.88s. Est. time left: 00:00:00:01; 100.0%. Run time: 17.40s. Est. time left: 00:00:00:00; Total run time: 17.42s. where we have adde",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html:12994,error,errors,12994,docs/4.4/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html,1,['error'],['errors']
Availability," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; In [14]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000); 10.0%. Run time: 2.40s. Est. time left: 00:00:00:21; 20.0%. Run time: 4.75s. Est. time left: 00:00:00:18; 30.0%. Run time: 7.16s. Est. time left: 00:00:00:16; 40.0%. Run time: 9.80s. Est. time left: 00:00:00:14; 50.0%. Run time: 12.44s. Est. time left: 00:00:00:12; 60.0%. Run time: 14.85s. Est. time left: 00:00:00:09; 70.0%. Run time: 17.32s. Est. time left: 00:00:00:07; 80.0%. Run time: 19.58s. Est. time left: 00:00:00:04; 90.0%. Run time: 22.80s. Est. time left: 00:00:00:02; 100.0%. Run time: 28.03s. Est. time left: 00:00:00:00; Total run time: 28.04s. where we have add",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html:8732,error,errors,8732,docs/4.5/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-monte.html,1,['error'],['errors']
Availability," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; In [14]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000); 10.0%. Run time: 2.57s. Est. time left: 00:00:00:23; 20.0%. Run time: 4.90s. Est. time left: 00:00:00:19; 30.0%. Run time: 7.20s. Est. time left: 00:00:00:16; 40.0%. Run time: 9.68s. Est. time left: 00:00:00:14; 50.0%. Run time: 11.98s. Est. time left: 00:00:00:11; 60.0%. Run time: 14.43s. Est. time left: 00:00:00:09; 70.0%. Run time: 16.91s. Est. time left: 00:00:00:07; 80.0%. Run time: 19.25s. Est. time left: 00:00:00:04; 90.0%. Run time: 21.87s. Est. time left: 00:00:00:02; 100.0%. Run time: 24.21s. Est. time left: 00:00:00:00; Total run time: 24.27s. where we have add",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html:9329,error,errors,9329,docs/3.1.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html,1,['error'],['errors']
Availability," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; In [14]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000); 10.0%. Run time: 2.78s. Est. time left: 00:00:00:25; 20.0%. Run time: 5.59s. Est. time left: 00:00:00:22; 30.0%. Run time: 8.32s. Est. time left: 00:00:00:19; 40.0%. Run time: 11.10s. Est. time left: 00:00:00:16; 50.0%. Run time: 13.85s. Est. time left: 00:00:00:13; 60.0%. Run time: 16.62s. Est. time left: 00:00:00:11; 70.0%. Run time: 19.38s. Est. time left: 00:00:00:08; 80.0%. Run time: 22.11s. Est. time left: 00:00:00:05; 90.0%. Run time: 24.81s. Est. time left: 00:00:00:02; 100.0%. Run time: 27.67s. Est. time left: 00:00:00:00; Total run time: 27.72s. where we have ad",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:12871,error,errors,12871,docs/4.3/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html,1,['error'],['errors']
Availability," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; ntraj = [1, 10, 100, 1000]. Keep in mind that the input ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:7958,error,errors,7958,docs/4.6/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html,4,['error'],['errors']
Availability," arrays of state vectors or density matrices for the second input:; In [67]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [68]: expect(N, states); Out[68]: array([0., 1., 2., 3., 4.]). In [69]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [70]: expect(c, cat_list); Out[70]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [71]: up = basis(2, 0). In [72]: down = basis(2, 1). In [73]: expect(sigmaz(), up); Out[73]: 1.0. In [74]: expect(sigmaz(), down); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:16896,down,down,16896,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,1,['down'],['down']
Availability," assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:187144,error,error,187144,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability," assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:162339,error,error,162339,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability," assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:179058,error,error,179058,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability," assumed to be attribute name value pairs; They applied after the object is created; log_level (integer) – level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; out_file_ext (string or None) – files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files; gen_stats (boolean) – if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt – Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Return type:OptimResult. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:154144,error,error,154144,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability," be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes. ; Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None; ; guess_pulse_params : di",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:35164,error,error,35164,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,12,['error'],['error']
Availability," be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:19979,avail,available,19979,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['avail'],['available']
Availability," bool.'). [docs] def ptrace(self, sel):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q. [docs] def permute(self, order):; """"""Permutes a composite quantum object. Parameters; ----------; order : list/array; List specifying new tensor order. Returns; -------; P : :class:`qutip.Qobj`; Permuted quantum object. """"""; q = Qobj(); q.data, q.dims = _permute(self, order); return q.tidyup() if settings.auto_tidyup else q. [docs] def tidyup(self, atol=settings.auto_tidyup_atol):; """"""Removes small elements from the quantum object. Parameters; ----------; atol : float; Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object with small elements removed. """"""; if self.data.nnz:; #This does the tidyup and returns True if; #The sparse data needs to be shortened; if use_openmp() and self.data.nnz > 500:; if omp_tidyup(self.data.data,atol,self.data.nnz,; settings.num_cpus):; self.data.eliminate_zeros(); else:; if cy_tidyup(self.data.data,atol,self.data.nnz):; self.data.eliminate_zeros(); return self; else:; return self. [docs] def transform(self, inpt, inverse=False, sparse=True):; """"""Basis transform defined by input array. Input array can be a ``matrix`` defining the transformation,; or a ``list`` of kets that defines the new basis. Parameters; ----------; inpt : array_like; A ``matrix`` or ``list`` of kets defining the transformation.; inverse : bool; Whether to return inverse transformation.; sparse : bool; Use sparse matrices when possible. Can be slower. Ret",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:33875,toler,tolerance,33875,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['toler'],['tolerance']
Availability," branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deploymen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:12473,avail,available,12473,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['avail'],['available']
Availability," branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deploymen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:7725,avail,available,7725,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['avail'],['available']
Availability," build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:12829,error,errors,12829,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,2,['error'],['errors']
Availability," but have shapes {xvec.shape} and {yvec.shape}.""; ); return xvec, yvec. class _QFuncCoherentGrid:; """"""; Internal function to compute coherent state operators corresponding to a; grid of complex values in phase space. For efficiency reasons, this class; produces the adjoint of the coherent states, to save allocations when; calculating inner products later. Examples; --------; Initialise the grid calculator. >>> xvec = yvec = np.linspace(-1, 1, 21); >>> g = np.sqrt(0.5); >>> max_ns = 10; >>> grid = _QFuncCoherentGrid(xvec, yvec, g). The naive construction of the grid is. >>> xs, ys = np.meshgrid(xvec, yvec); >>> all_alphas = 0.5 * g * (xs + 1j*ys); >>> naive = np.array([; ... [; ... qutip.coherent(max_ns, alpha, method='analytic'); ... .dag().full().ravel(); ... for alpha in x_alphas; ... ]; ... for y_alphas in all_alphas; ... ]). The naive approach is typically several of orders of magnitude slower than; this class, which uses much simpler vectorised operations. The outputs are; within close tolerance, however:. >>> np.allclose(naive, grid(max_ns)); True; >>> np.allclose(naive[:, :, 4:7], grid(4, 7)); True; """"""; def __init__(self, xvec, yvec, g: float):; self.xvec, self.yvec = _qfunc_check_coordinates(xvec, yvec); x, y = np.meshgrid(0.5 * g * self.xvec, 0.5 * g * self.yvec); self.grid = np.empty(x.shape, dtype=np.complex128); self.grid.real = x; # We produce the adjoint of the coherent states to save an operation; # later when computing dot products, hence the negative imaginary part.; self.grid.imag = -y; self.prefactor = np.exp(-0.5 * (x * x + y * y)).astype(np.complex128). def _start(self, first: int):; """"""; Get the coherent state matrix corresponding to the first needed Fock; state.; """"""; if first == 0:; return self.prefactor.copy(); out = np.power(self.grid, first); out *= self.prefactor; return out. def __call__(self, first: int, last: int = None):; """"""; Get a 3D array of shape ``(yvec.size, xvec.size, last - first)`` of the; coherent-state vectors for all the F",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/wigner.html:18884,toler,tolerance,18884,docs/4.6/modules/qutip/wigner.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/wigner.html,4,['toler'],['tolerance']
Availability," calculating the propagator; gradient; """""". if self.oper_dtype == Qobj:; H = self._dyn_gen[k]; # Returns eigenvalues as array (row); # and eigenvectors as rows of an array; eig_val, eig_vec = sp_eigs(H.data, H.isherm,; sparse=self.sparse_eigen_decomp); eig_vec = eig_vec.T; if self.sparse_eigen_decomp:; # when sparse=True, sp_eigs returns an ndarray where each; # element is a sparse matrix so we convert it into a sparse; # matrix we can later pass to Qobj(...); eig_vec = sp.hstack(eig_vec). elif self.oper_dtype == np.ndarray:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = eigh(H). else:; assert False, f""Unknown oper_dtype {self.oper_dtype!r}"". # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:48478,down,down,48478,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,4,['down'],['down']
Availability," calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:95765,error,error,95765,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability," callback function that returns the; superoperator at a given time. rho0 : qutip.Qobj. Initial density matrix or state vector (ket). times : array_like. list of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_ops : list of qutip.Qobj / callback function. single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like. list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like. optional list of precomputed tensors \(T_k\). kwargs : dictionary. Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output: qutip.solver.Result. An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:141815,error,error,141815,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability," callback function. thres : float; Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options : qutip.solver.Options; Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes:; atol : float {1e-8}; Absolute tolerance. rtol : float {1e-6}; Relative tolerance. method : str {‘adams’,’bdf’}; Integration method. order : int {12}; Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps : int {2500}; Max. number of internal steps/call. first_step : float {0}; Size of initial step (0 = automatic). min_step : float {0}; Minimum step size (0 = automatic). max_step : float {0}; Maximum step size (0 = automatic). tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus : int; Number of cpus used by mcsolver (default = # of cpus). norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states : bool {False}; Average states values over trajectories in stochastic solvers. average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers. mc_corr_eps : float {1e-10}; Arbitrarily small value ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:33808,toler,tolerance,33808,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['toler'],['tolerance']
Availability," callback function. thres¶; float – Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. options¶; qutip.solver.Options – Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. atol¶; float {1e-8} – Absolute tolerance. rtol¶; float {1e-6} – Relative tolerance. method¶; str {‘adams’,’bdf’} – Integration method. order¶; int {12} – Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps¶; int {2500} – Max. number of internal steps/call. first_step¶; float {0} – Size of initial step (0 = automatic). min_step¶; float {0} – Minimum step size (0 = automatic). max_step¶; float {0} – Maximum step size (0 = automatic). tidy¶; bool {True,False} – Tidyup Hamiltonian and initial state by removing small terms. num_cpus¶; int – Number of cpus used by mcsolver (default = # of cpus). norm_tol¶; float – Tolerance used when finding wavefunction norm in mcsolve. norm_steps¶; int – Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states¶; bool {False} – Average states values over trajectories in stochastic solvers. average_expect¶; bool {True} – Average expectation values over trajectories for stochastic solvers. mc_corr_eps¶; float {1e-10} – Arbitrarily small value for eliminating any divide-by-zero",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:36235,toler,tolerance,36235,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['toler'],['tolerance']
Availability," called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; Thi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:62047,error,error,62047,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,4,['error'],['error']
Availability," can be installed using:; sudo apt-get install texlive-latex-extra # recommended for plotting; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install liblapack-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.8+)¶. Setup Using Homebrew¶; The latest version of QuTiP can be quickly installed on OS X using Homebrew and the automated installation shell scripts. Python 2.7 installation script; Python 3.4 installation script. Having downloaded the script corresponding to the version of Python you want to use, the installation script can be run from the terminal using (replacing X with 2 or 3); sh install_qutip_pyX.sh. The script will then install Homebrew and the required QuTiP dependencies before installing QuTiP itself and running the built in test suite. Any errors in the homebrew configuration will be displayed at the end. Using Python 2.7 or 3.4, the python commend-line and IPython interpreter can be run by calling python and ipython or python3 and ipython3, respectively.; If you have installed other packages in the /usr/local/ directory, or have changed the permissions of any of its sub-directories, then this script may fail to install all the necessary tools automatically. Setup Using Macports¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’.; On the Mac OS, you can install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via (Replace ‘34’ with ‘27’ if you want Python 2.7); sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo port install py34-cython; sudo port install py34-ipython +notebook+parallel; sudo port install py34-pip. Now",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:7145,error,errors,7145,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['error'],['errors']
Availability," can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be us",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:226980,error,error,226980,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability," class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:3815,avail,available,3815,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,"['avail', 'down']","['available', 'download']"
Availability," coherence function:. .. math::. g^{(1)}(\\tau) = \lim_{t \to \infty}; \\frac{\\langle a^\\dagger(t+\\tau)a(t)\\rangle}; {\\langle a^\\dagger(t)a(t)\\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Note: g1 is only defined for stationary; statistics (uses steady state). Parameters; ----------. H : :class:`qutip.qobj.Qobj`; system Hamiltonian. taulist : *list* / *array*; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list of :class:`qutip.qobj.Qobj`; list of collapse operators. a_op : :class:`qutip.qobj.Qobj`; The annihilation operator of the mode. solver : str; choice of solver (`me` for master-equation and; `es` for exponential series). options : :class:`qutip.solver.Options`; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. g1: *array*; The normalized first-order coherence function. """""". # first calculate the steady state photon number; rho0 = steadystate(H, c_ops); n = np.array([expect(rho0, a_op.dag() * a_op)]). # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, None, taulist, c_ops, a_op.dag(), a_op,; args=args, solver=solver, options=options); g1 = G1 / n. return g1. [docs]def coherence_function_g2(H, taulist, c_ops, a_op, solver=""me"", args=None,; options=Options(ntraj=[20, 100])):; """"""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\\tau) = \lim_{t \to \infty}; \\frac{\\langle a^\\dagger(t)a^\\dagger(t+\\tau); a(t+\\tau)a(t)\\rangle}; {\\langle a^\\dagger(t)a(t)\\rangle^2}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Note: g2 is only defined for stationary; statistics (uses steady state ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:14631,error,errors,14631,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['error'],['errors']
Availability," config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:24922,toler,tolerance,24922,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['toler'],['tolerance']
Availability," controls. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. class QubitCircuit(*args, **kwargs)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. input_stateslistA list of string such as 0,’+’, “A”, “Y”. Only used for latex. dimslistA list of integer for the dimension of each composite system.; e.g [2,2,2,2,2] for 5 qubits system. If None, qubits system; will be the default option. Examples; >>> def user_gate():; ... mat = np.array([[1., 0],; ... [0., 1.j]]); ... return Qobj(mat, dims=[[2], [2]]); >>> qc.QubitCircuit(2, user_gates={""T"":user_gate}); >>> qc.add_gate(""T"", targets=[0]). class Processor(N, t1=None, t2=None, dims=None, spline_kind='step_func')[source]¶; A simulator of a quantum device based on the QuTiP solver; qutip.mesolve.; It is defined by the available driving Hamiltonian and; the decoherence time for each component systems.; The processor can simulate the evolution under the given; control pulses. Noisy evolution is supported by; qutip.qip.Noise and can be added to the processor. Parameters. N: intThe number of component systems. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of float, optionalCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: list, optionalThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. spline_kind: str, optionalType of the coefficient interpolation. Default is “step_func”; Note that they have different requirement for the length of `coeff’.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:73110,avail,available,73110,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['avail'],['available']
Availability," created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:8115,error,error,8115,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,18,['error'],"['error', 'errors']"
Availability," data.solver = ""sepdpsolve""; data.times = sso.tlist; data.expect = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.ss = np.zeros((len(sso.e_ops), N_store), dtype=complex); data.jump_times = []; data.jump_op_idx = []. # effective hamiltonian for deterministic part; Heff = sso.H; for c in sso.c_ops:; Heff += -0.5j * c.dag() * c. progress_bar.start(sso.ntraj); for n in range(sso.ntraj):; progress_bar.update(n); psi_t = sso.state0.full().ravel(). states_list, jump_times, jump_op_idx = \; _ssepdpsolve_single_trajectory(data, Heff, dt, sso.times,; N_store, N_substeps,; psi_t, sso.state0.dims,; sso.c_ops, sso.e_ops). data.states.append(states_list); data.jump_times.append(jump_times); data.jump_op_idx.append(jump_op_idx). progress_bar.finished(). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[m][n] for m in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _ssepdpsolve_single_trajectory(data, Heff, dt, times, N_store, N_substeps,; psi_t, dims, c_ops, e_ops):; """"""; Internal function. See ssepdpsolve.; """"""; states_list = []. phi_t = np.copy(psi_t). prng = RandomState() # todo: seed it; r_jump, r_op = prng.rand(2). jump_times = []; jump_op_idx = []. for t_idx, t in enumerate(times):. if e_ops:; for e_idx, e in enumerate(e_ops):; s = cy_expect_psi_csr(; e.data.data, e.data.indices, e.data.indptr, psi_t, 0); data.expect[e_idx, t_idx] += s; data.ss[e_idx, t_idx] += s ** 2; else:; states_list.append(Qobj(psi_t, dims=dims)). for j in range(N_substeps):. if norm(phi_t) ** 2 < r_jump:; # jump occurs; p = np.array([norm(c.data * psi_t) ** 2 for c in c_ops]); p = np.cumsum(p / ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:31773,error,error,31773,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['error'],['error']
Availability," deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:9759,mask,masking,9759,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['mask'],['masking']
Availability," dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:6681,error,errors,6681,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,2,['error'],['errors']
Availability," dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """""";",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html:6681,error,errors,6681,docs/4.2/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/propcomp.html,8,['error'],['errors']
Availability," dynamics. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float. Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algori",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:177821,error,error,177821,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['error'],['error']
Availability," dynamics. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.mini",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:153072,error,error,153072,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['error'],['error']
Availability," dynamics. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string. Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer. The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float. Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:138875,error,error,138875,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['error'],['error']
Availability," eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(self, states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:7002,toler,tolerance,7002,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['toler'],['tolerance']
Availability," else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:33527,error,errors,33527,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['error'],['errors']
Availability," else:; results = np.zeros([n_expt_op, n_tsteps], dtype=complex). for n, e in enumerate(e_ops):; results[n, :] = expect(e, esval(es, tlist)). data = Result(); data.solver = ""essolve""; data.times = tlist; data.expect = [np.real(results[n, :]) if e.isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """""". if issuper(L):. # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/essolve.html:4907,error,error,4907,docs/4.5/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/essolve.html,1,['error'],['error']
Availability," else:; results = np.zeros([n_expt_op, n_tsteps], dtype=complex). for n, e in enumerate(e_ops):; results[n, :] = expect(e, esval(es, tlist)). data = Result(); data.solver = ""essolve""; data.times = tlist; data.expect = [np.real(results[n, :]) if e.isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """""". if issuper(L):. # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/essolve.html:4898,error,error,4898,docs/4.2/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/essolve.html,5,['error'],['error']
Availability," environment, use:; sudo apt-get install python3-dev cython3 python3-setuptools python3-nose; sudo apt-get install python3-numpy python3-scipy python3-matplotlib. and then do the installation from source using python3 instead of python.; Optional, but recommended, dependencies can be installed using:; sudo apt-get install texlive-latex-extra # recommended for plotting; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install liblapack-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.8+)¶. Setup Using Homebrew¶; The latest version of QuTiP can be quickly installed on OS X using Homebrew and the automated installation shell scripts. Python 2.7 installation script; Python 3.4 installation script. Having downloaded the script corresponding to the version of Python you want to use, the installation script can be run from the terminal using (replacing X with 2 or 3); sh install_qutip_pyX.sh. The script will then install Homebrew and the required QuTiP dependencies before installing QuTiP itself and running the built in test suite. Any errors in the homebrew configuration will be displayed at the end. Using Python 2.7 or 3.4, the python commend-line and IPython interpreter can be run by calling python and ipython or python3 and ipython3, respectively.; If you have installed other packages in the /usr/local/ directory, or have changed the permissions of any of its sub-directories, then this script may fail to install all the necessary tools automatically. Setup Using Macports¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’.; On the Mac OS, you can install the required libraries via MacPorts. After installation, the necess",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:6810,down,downloaded,6810,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['down'],['downloaded']
Availability," error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]¶; clear any temporarily held status data. compute_fid_grad(self)[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]¶; Check configuration and initialise the normalisation. init_normalization(self)[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:109752,error,error,109752,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability," error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]¶; clear any temporarily held status data. flag_system_changed(self)[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]¶; initialises the computer based on the configuration of the Dynamics. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]¶; clear any temporarily held ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:108400,error,error,108400,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability," et al., ""Interactively Applying the Variational Method to the Dihydrogen Molecule: Exploring Bonding and Antibonding"", ; Journal of Chemical Education (2016). 203. Pleinert et al., ""Quantum signatures of collective behavior of a coherently driven two atom system coupled to a single-mode of the electromagnetic field"", ; arXiv:1608.00137. 202. Wang et al., ""Multiple-output microwave single-photon source using superconducting circuits with longitudinal and transverse couplings"", ; Phys. Rev. A 94, 053858 (2016). 201. Marshall et al., ""Continuous-variable quantum computing on encrypted data"", ; Nat. Comm. 7, 13795 (2016). 200. Dajka et al., ""Leggett–Garg inequalities for a quantum top affected by classical noise"", ; J. Quantum Inf. Process. (2016). 199. Rouxinol et al., ""Measurements of nanoresonator-qubit interactions in a hybrid quantum electromechanical system"", ; Nanotechnology 27, 364003 (2016). 198. Hocker et al., ""PEET: a Matlab tool for estimating physical gate errors in quantum information processing systems"", ; Quantum Information Processing (2016). 197. Daskin, ""Quantum eigenvalue estimation for irreducible non-negative matrices"", ; Int. J. Quantum Inform. 14, 1650005 (2016). 196. Dlaska et al., ""Robust quantum state transfer via topologically protected edge channels in dipolar arrays"", ; Quantum Sci. Technol. 2, 015001 (2017). 195. Juliusson et al., ""Manipulating Fock states of a harmonic oscillator while preserving its linearity"", ; Phys. Rev. A 94, 063861 (2016). 194. Banchi et al., ""Quantum gate learning in qubit networks: Toffoli gate without time-dependent control"", ; njp Quantum Information 2, 16019 (2016). 193. Hofer et al., ""Autonomous quantum refrigerator in a circuit QED architecture based on a Josephson junction"", ; Phys. Rev. B 94, 235420 (2016). 192. Sampaio et al., ""Calorimetric measurement of work for a driven harmonic oscillator"", ; Phys. Rev. E 94, 062122 (2016). 191. Molony et al., ""Production of ultracold 87Rb133Cs in the absolute ground s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/users.html:22962,error,errors,22962,users.html,https://qutip.org,https://qutip.org/users.html,1,['error'],['errors']
Availability," explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:23375,error,errors,23375,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['errors']
Availability," factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/changelog.html:13404,toler,tolerance,13404,docs/3.0.1/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html,1,['toler'],['tolerance']
Availability," factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:15304,toler,tolerance,15304,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,1,['toler'],['tolerance']
Availability," factorial was moved to scipy.misc module.; Added tidyup function to tensor function output.; Removed openmp flags from setup.py as new Mac Xcode compiler does not recognize them.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:12739,toler,tolerance,12739,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,1,['toler'],['tolerance']
Availability," fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). In [72]: ax.view_init(azim=-55, elev=45). In [73]: plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; In [74]: rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). In [75]: hinton(rho_ss); Out[75]: ; (<Figure size 800x600 with 2 Axes>,; <matplotlib.axes._subplots.AxesSubplot at 0x1a25a249b0>). In [76]: plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-visualization.html:11478,error,errors,11478,docs/4.5/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-visualization.html,1,['error'],['errors']
Availability," file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:221109,error,error,221109,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability," file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]¶; clear any temporarily held status data. flag_system_changed(self)[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]¶;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:107509,error,error,107509,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability," find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will become very inefficient.; In the following we describe the predefined subclasses for Processor:",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:4831,avail,available,4831,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,4,['avail'],['available']
Availability," for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/history.html:2590,avail,available,2590,docs/4.7/guide/heom/history.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html,2,['avail'],['available']
Availability," for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time depen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:225084,error,error,225084,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['error'],['error']
Availability," for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time depen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:237199,error,error,237199,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['error'],['error']
Availability," for the summary file.; default is a space. data_sep¶; str – delimiter for the data files (arrays saved to file).; default is a space. summary_file¶; str – File path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. level¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. dump_summary¶; bool – When True summary items are appended to the iter_summary. iter_summary¶; list of optimizer.OptimIterSummary – Summary at each iteration. dump_fid_err¶; bool – When True values are appended to the fid_err_log. fid_err_log¶; list of float – Fidelity error at each call of the fid_err_func. dump_grad_norm¶; bool – When True values are appended to the fid_err_log. grad_norm_log¶; list of float – Gradient norm at each call of the grad_norm_log. dump_grad¶; bool – When True values are appended to the grad_log. grad_log¶; list of ndarray – Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters:f (filename or filehandle) – If specified then all summary and object data will go in one file.; If None is specified then type specific files will be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:116796,error,error,116796,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability," for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like. optional list of precomputed tensors \(T_k\). kwargs : dictionary. Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output: qutip.solver.Result. An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:142280,error,error,142280,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability," for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:210482,error,error,210482,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['error'],['error']
Availability," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See TimeslotComputer; classes for details). tslot_paramsdictParameters for the Tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:220942,error,error,220942,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['error'],['error']
Availability," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works.; (See TimeslotComputer classes for; details). tslot_paramsdictParameters for the Ti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:233055,error,error,233055,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['error'],['error']
Availability," from the qutip.solver.Result object returned by mcsolve. In the above example using:; In [16]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]); 10.0%. Run time: 1.83s. Est. time left: 00:00:00:16; 20.0%. Run time: 3.83s. Est. time left: 00:00:00:15; 30.0%. Run time: 5.66s. Est. time left: 00:00:00:13; 40.0%. Run time: 7.31s. Est. time left: 00:00:00:10; 50.0%. Run time: 8.95s. Est. time left: 00:00:00:08; 60.0%. Run time: 10.76s. Est. time left: 00:00:00:07; 70.0%. Run time: 12.59s. Est. time left: 00:00:00:05; 80.0%. Run time: 14.30s. Est. time left: 00:00:00:03; 90.0%. Run time: 15.92s. Est. time left: 00:00:00:01; 100.0%. Run time: 17.62s. Est. time left: 00:00:00:00; Total run time: 17.63s. we can extract the relevant expectation values using:; In [17]: expt1 = data.expect[0]. In [18]: expt10 = data.expect[1]. In [19]: expt100 = data.expect[2]. In [20]: expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [21]: options = Option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html:15817,avail,available,15817,docs/4.4/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html,1,['avail'],['available']
Availability," g^{(2)}(\\tau) = \lim_{t \to \infty}; \\frac{\\langle a^\\dagger(t)a^\\dagger(t+\\tau); a(t+\\tau)a(t)\\rangle}; {\\langle a^\\dagger(t)a(t)\\rangle^2}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Note: g2 is only defined for stationary; statistics (uses steady state rho0). Parameters; ----------. H : :class:`qutip.qobj.Qobj`; system Hamiltonian. taulist : *list* / *array*; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list of :class:`qutip.qobj.Qobj`; list of collapse operators. a_op : :class:`qutip.qobj.Qobj`; The annihilation operator of the mode. solver : str; choice of solver (`me` for master-equation and; `es` for exponential series). options : :class:`qutip.solver.Options`; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. g2: *array*; The normalized second-order coherence function. """""". # first calculate the the steady state photon number; rho0 = steadystate(H, c_ops); n = np.array([expect(rho0, a_op.dag() * a_op)]). # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, None, taulist, c_ops,; a_op.dag(), a_op.dag() * a_op, a_op,; solver=solver, args=args, options=options); g2 = G2 / n**2. return g2. # spectrum. [docs]def spectrum(H, wlist, c_ops, a_op, b_op, solver=""es"", use_pinv=False):; """"""; Calculate the spectrum of the correlation function; :math:`\lim_{t \to \infty} \left<A(t+\\tau)B(t)\\right>`,; i.e., the Fourier transform of the correlation function:. .. math::. S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\\tau)B(t)\\right>; e^{-i\omega\\tau} d\\tau. using the solver indicated by the `solver` parameter. Note: this spectrum; is only defined for stationary st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:16307,error,errors,16307,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['error'],['errors']
Availability," global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:112567,error,error,112567,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability," handling of time-dependent Hamiltonian with a custom tlist and c_ops. (#1561). Developer Changes¶. Read documentation version and release from the VERSION file. Version 4.6.1 (May 4, 2021)¶; This minor release fixes bugs in QIP gate definitions, fixes building from; the source tarball when git is not installed and works around an MKL; bug in versions of SciPy <= 1.4.; It also adds the [full] pip install target so that pip install qutip[full]; installs qutip and all of its optional and developer dependencies. Improvements¶. Add the [full] pip install target (by Jake Lishman). Bug Fixes¶. Work around pointer MKL eigh bug in SciPy <= 1.4 (by Felipe Bivort Haiek); Fix berkeley, swapalpha and cz gate operations (by Boxi Li); Expose the CPHASE control gate (by Boxi Li); Fix building from the sdist when git is not installed (by Jake Lishman). Developer Changes¶. Move the qutip-doc documentation into the qutip repository (by Jake Lishman); Fix warnings in documentation build (by Jake Lishman); Fix warnings in pytest runs and make pytest treat warnings as errors (by Jake Lishman); Add Simon Cross as author (by Simon Cross). Version 4.6.0 (April 11, 2021)¶; This release brings improvements for qubit circuits, including a pulse scheduler, measurement statistics, reading/writing OpenQASM and optimisations in the circuit simulations.; This is the first release to have full binary wheel releases on pip; you can now do pip install qutip on almost any machine to get a correct version of the package without needing any compilers set up.; The support for Numpy 1.20 that was first added in QuTiP 4.5.3 is present in this version as well, and the same build considerations mentioned there apply here too.; If building using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:11162,error,errors,11162,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['error'],['errors']
Availability," high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; --",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:42936,toler,tolerance,42936,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,2,['toler'],['tolerance']
Availability," high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : :class:`qutip.Qobj`; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; tol = 1e-15 if tol == 0 else tol; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Ret",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:45770,toler,tolerance,45770,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,4,['toler'],['tolerance']
Availability," high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print(""WARNING: Ground state may be degenerate. ""; ""Use Q.eigenstates()""); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:39737,toler,tolerance,39737,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['toler'],['tolerance']
Availability," high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (default=True); Check for degenerate ground state. Returns; -------; eigval : float; Eigenvalue for the ground state of quantum operator.; eigvec : qobj; Eigenket for the ground state of quantum operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if safe:; evals = 2; else:; evals = 1; grndval, grndvec = sp_eigs(self.data, self.isherm, sparse=sparse,; eigvals=evals, tol=tol, maxiter=maxiter); if safe:; if tol == 0: tol = 1e-15; if (grndval[1]-grndval[0]) <= 10*tol:; print('WARNING: Ground state may be degenerate. Use Q.eigenstates()'); new_dims = [self.dims[0], [1] * len(self.dims[0])]; grndvec = Qobj(grndvec[0], dims=new_dims); grndvec = grndvec / grndvec.norm(); return grndval[0], grndvec. [docs] def trans(self):; """"""Transposed operator. Returns; -------; oper : qobj;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:39531,toler,tolerance,39531,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['toler'],['tolerance']
Availability," implemented for CP maps.""); J = sr.to_choi(self); tensor_idxs = enumerate_flat(J.dims); J_dual = tensor.tensor_swap(J, *(; list(zip(tensor_idxs[0][1], tensor_idxs[0][0])) +; list(zip(tensor_idxs[1][1], tensor_idxs[1][0])); )).trans(); J_dual.superrep = 'choi'; return J_dual. [docs] def conj(self):; """"""Conjugate operator of quantum object.; """"""; out = Qobj(); out.data = self.data.conj(); out.dims = [self.dims[0], self.dims[1]]; return out. [docs] def norm(self, norm=None, sparse=False, tol=0, maxiter=100000):; """"""Norm of a quantum object. Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the `norm` and; argument. Parameters; ----------; norm : str; Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',; or for operators: trace 'tr', Frobius 'fro', one 'one', or max; 'max'. sparse : bool; Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float; Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns; -------; norm : float; The requested norm of the operator or state quantum object. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.type in ['oper', 'super']:; if norm is None or norm == 'tr':; _op = self.data * zcsr_adjoint(self.data); vals = sp_eigs(_op, True, vecs=False,; sparse=sparse, tol=tol, maxiter=maxiter); return np.sum(np.sqrt(np.abs(vals))); elif norm == 'fro':; return sp_fro_norm(self.data); elif norm == 'one':; return sp_one_norm(self.data); elif norm == 'max':; return sp_max_norm(self.data); else:; raise ValueError(; ""For matrices, norm must be 'tr', 'fro', 'one', or 'max'.""); else:; if norm is None or norm == 'l2':; return sp_L2_norm(self.data); elif norm == 'max':; return s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:27248,Toler,Tolerance,27248,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['Toler'],['Tolerance']
Availability," import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, eigh; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls_ = np.empty((len(ctrls), len(ctrls[0])), dtype=object); for i, ctrl in enumerate(ctrls):; ctrls_[i, :] = ctrl; ctrls = ctrls_; except:; pass. if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj""); else:; raise TypeError(""Controls list or array not set correctly""). return ctrls. def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:4035,error,error,4035,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,4,['error'],['error']
Availability," in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:16133,error,error,16133,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,9,['error'],['error']
Availability," in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:16132,error,error,16132,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['error'],['error']
Availability," in parallel.; In the case of gates schedule,; the result will be the gates cycle list. Parameters; ----------; priority: bool; If use distance to the start and end nodes; as a priority measure for the schedule problem.; apply_constraint: function; A Python function that determines; if to instruction can be executed in parallel.; E.g. if two gates apply to the same qubit, the function; returns False. Returns; -------; cycles_list: list; A list of cycles, where each cycle is a list of instructions; that can be executed in parallel.; constraint_dependency: set; A set of instruction pairs that are found conflicted; due to the hardware constraints.; Because of this, they are executed in different cycles.; This set is used to add this dependency to the graph; in another method.; """"""; # The method will destruct the graph, therefore we make a copy.; graph = deepcopy(self.nodes); cycles_list = []; available_nodes = list(self.start) # a list of available instructions; # pairs of instructions that are limited by hardware constraint; constraint_dependency = set(). while available_nodes:; if random:; shuffle(available_nodes); if priority:; available_nodes.sort(key=cmp_to_key(self._compare_priority)); current_cycle = []; if apply_constraint is None: # if no constraits; current_cycle = deepcopy(available_nodes); else: # check if constraits allow the parallelization; for node1 in available_nodes:; approval = True; for node2 in current_cycle:; if not apply_constraint(node1, node2, graph):; approval = False; # save the conflicted pairs of instructions; constraint_dependency.add((node2, node1)); if approval:; current_cycle.append(node1); # add this cycle to cycles_list; cycles_list.append(current_cycle). # update the list of available nodes; # remove the executed nodes from available_node; for node in current_cycle:; available_nodes.remove(node); # add new nodes to available_nodes; # if they have no other predecessors; for node in current_cycle:; for successor_ind in graph[node].succ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:8349,avail,available,8349,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['avail'],['available']
Availability," in state_inds only. Parameters:states_inds : list of integer. The states that should be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. .. note:: :. Experimental. full(squeeze=False)¶; Dense array from quantum object. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000)¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError :. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Paramet",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:9212,toler,tolerance,9212,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['toler'],['tolerance']
Availability," indices of target pulse in the list of pulses.; **kwargs:; Key word arguments for the random number generator. Attributes; ----------; dt: float, optional; The time interval between two random amplitude. The coefficients; of the noise are the same within this time range.; rand_gen: numpy.random, optional; A random generator in numpy.random, it has to take a ``size``; parameter.; indices: list of int; The indices of target pulse in the list of pulses.; **kwargs:; Key word arguments for the random number generator. Examples; --------; >>> gaussnoise = RandomNoise( \; dt=0.1, rand_gen=np.random.normal, loc=mean, scale=std) \; # doctest: +SKIP; """"""; def __init__(; self, dt, rand_gen, indices=None, **kwargs):; super(RandomNoise, self).__init__(coeff=None, tlist=None); self.rand_gen = rand_gen; self.kwargs = kwargs; if ""size"" in kwargs:; raise ValueError(""size is preditermined inside the noise object.""); self.dt = dt; self.indices = indices. [docs] def get_noisy_dynamics(; self, dims=None, pulses=None, systematic_noise=None):; if pulses is None:; pulses = []; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; t_max = -np.inf; t_min = np.inf; for pulse in pulses:; t_max = max(max(pulse.tlist), t_max); t_min = min(min(pulse.tlist), t_min); # create new tlist and random coeff; num_rand = int(np.floor((t_max - t_min) / self.dt)) + 1; tlist = (np.arange(0, self.dt*num_rand, self.dt)[:num_rand] + t_min); # [:num_rand] for round of error like 0.2*6=1.2000000000002. for i in indices:; pulse = pulses[i]; coeff = self.rand_gen(**self.kwargs, size=num_rand); pulses[i].add_coherent_noise(; pulse.qobj, pulse.targets, tlist, coeff); return pulses, systematic_noise. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html:11813,error,error,11813,docs/4.6/modules/qutip/qip/noise.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html,2,['error'],['error']
Availability," invoked automatically when using the iterative 'GMRES' and 'LGMRES' solvers that uses a combination of symmetric and antisymmetric matrix permutations that attempts to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; True, False; Attempt to generate a preconditioner when using the 'iter",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-steady.html:7564,avail,available,7564,docs/3.0.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html,2,['avail'],['available']
Availability," is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object,; e.g. optimizer.dynamics.fid_computer The optimisation can be run; through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:57581,ERROR,ERROR,57581,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['ERROR'],['ERROR']
Availability," is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(self, other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|ot",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:11789,toler,tolerance,11789,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['toler'],['tolerance']
Availability," is overridden by alg_params; (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. Note that where there is an attribute; of the :obj:`~Optimizer` object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_type : string; Propagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:34419,error,error,34419,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability," it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters:norm : str. Which norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparse : bool. Use sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tol : float. Tolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used); for trace norm. Returns:norm : float. The requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(state)[source]¶; Overlap between two state vectors.; Gives the overlap (scalar product) for the quantum object and state; state vector. Parameters:state : qobj. Quantum object for a state vector of type ‘ket’ or ‘bra’. Returns:overlap : complex. Complex valued overlap. Raises:TypeError. Can only calculate overlap between a bra and ket quantum objects. permute(order)[source]¶; Permutes a composite quantum object. Parameters:order : list/array. List specifying new tensor order. Returns:P : qobj. Permuted quantum object. ptrace(sel)[source]¶; Partial trace of the quantum object. Parameters:sel : int/list. An int or list of components to keep after part",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:11783,toler,tolerance,11783,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['toler'],['tolerance']
Availability," logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimize",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:24711,error,errors,24711,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['errors']
Availability," m=1)[source]¶; Tunneling operator with elements of the form; \(\sum |N><N+m| + |N+m><N|\). Parameters. NintNumber of basis states in Hilbert space. mint (default = 1)Number of excitations in tunneling event. Returns. TQobjTunneling operator. Notes. New in version 3.2. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None, seed=None)[source]¶; Creates a random NxN density matrix. Parameters. Nint, ndarray, listIf int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix. densityfloatDensity between [0,1] of output density matrix. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_dm_ginibre(N=2, rank=None, dims=None, seed=None)[source]¶; Returns a Ginibre random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. If rank is None, a full-rank; (Hilbert-Schmidt ensemble) random density operator will be; returned. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. rankint or NoneRank of the sampled density operator. If None, a full-rank; density operator is generated. Returns. rhoQobjAn N × N density operator sampled from the Ginibre; or Hilbert-Schmidt distribution. rand_dm_hs(N=2, dims=None, seed=None)[source]¶; Returns a Hilbert-Schmidt random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifyin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:29703,error,error,29703,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['error'],['error']
Availability," match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to build documentation to 1.22.0. (#1940); Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new solvers – qutip.krylovsolve based on the Krylov subspace approximation and qutip.nonmarkov.heom that reimplements the BoFiN HEOM solver.; Bloch sphere rendering gained support for drawing arcs and lines on the sphere, and for setting the transparency of rendered points and vectors, Hinton plots gained support for specifying a coloring style, and matrix histograms gained better default colors and more flexible styling options.; Other significant improvements include better scaling of the Floquet solver, support for pass",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:6329,error,error,6329,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['error'],['error']
Availability," matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dumping¶. The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:61669,error,error,61669,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,4,['error'],['error']
Availability," meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by taulist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solver",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:88561,error,errors,88561,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['errors']
Availability," measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random. Returns. result: CircuitResultReturn a CircuitResult object containing; output state and probability. run_statistics(state, cbits=None)[source]¶; Calculate all the possible outputs of a circuit; (varied by measurement gates). Parameters. stateketstate to be observed on specified by density matrix. cbitsList of ints, optionalinitialization of the classical bits. Returns. result: CircuitResultReturn a CircuitResult object containing; output states and and their probabilities. step()[source]¶; Return state after one step of circuit evolution; (gate or measurement). Returns. stateket or operstate after one evolution step. class Processor(N, t1=None, t2=None, dims=None, spline_kind='step_func')[source]¶; A simulator of a quantum device based on the QuTiP solver; qutip.mesolve. It is defined by the available driving Hamiltonian; and the decoherence time for each component systems. The processor can; simulate the evolution under the given control pulses. Noisy evolution is; supported by Noise and can be added to the processor. Parameters. N: intThe number of component systems. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of float, optionalCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: list, optionalThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. spline_kind: str, optionalType of the coefficient interpolation. Default is “step_func”; Note that they have different requirement for the length of coeff. “step_func”:; The coefficient will be treated as a step function. E.g.; tlist=[0,1,2] and coeff=[3,2], means that the coefficient is; 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:88002,avail,available,88002,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['avail'],['available']
Availability," might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:9653,down,down,9653,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['down'],['down']
Availability," n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:80258,error,error,80258,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability," name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:48698,error,error,48698,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability," not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is ``1 - fidelity``. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length ``num_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:19737,error,error,19737,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability," not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:19491,error,error,19491,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['error'],['error']
Availability," now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization.; This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list with Python functions as time-dependence.; Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Ver",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:26712,error,error,26712,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['error'],['error']
Availability," np.real(norm) / self.dimensional_norm. [docs] def normalize_gradient_SU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This SU version respects global phase; """"""; grad_normalized = np.real(grad) / self.dimensional_norm. return grad_normalized. [docs] def normalize_PSU(self, A):; """""". """"""; try:; if A.shape[0] == A.shape[1]:; # input is an operator (Qobj, array, sparse etc), so; norm = _trace(A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:13749,error,error,13749,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['error'],['error']
Availability," numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, _dense_eigs; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls = np.array(ctrls, dtype=object); except:; pass. if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj""); else:; raise TypeError(""Controls list or array not set correctly""). return ctrls. def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always',",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/dynamics.html:4033,error,error,4033,docs/4.5/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/dynamics.html,1,['error'],['error']
Availability," objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:58367,mask,mask,58367,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['mask'],['mask']
Availability," objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:58602,mask,mask,58602,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['mask'],['mask']
Availability," ode_args:; r.set_f_params(*ode_args); r.set_initial_value(initial_vector, tlist[0]). e_ops_data = []; output.expect = []; if callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; cdata = get_curr_state_data(r). if opt.store_states:; if issuper(rho0):; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims, fast=""mc-dm"")). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). for m in range(n_expt_op):; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/mesolve.html:15895,error,error,15895,docs/4.4/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/mesolve.html,2,['error'],['error']
Availability," of Feynman Diagrams (both classify terms by increasing number; of interactions).; The result is a standard QuTiP results object with the attributes:. times: the times at which the state was evaluated (i.e. tlist); states: the system states at each time; expect: the values of each e_ops at each time; ado_states: see below (an instance of; HierarchyADOsState). If ado_return=True is passed to .run(...) the full set of auxilliary; density operators (ADOs) that make up the hierarchy at each time will be; returned as .ado_states. We will describe how to use these to determine; other properties, such as system-bath currents, later in the fermionic guide; (see Determining currents).; If one has a full set of ADOs from a previous call of .run(...) you may; supply it as the initial state of the solver by calling; .run(result.ado_states[-1], tlist, ado_init=True).; As with other QuTiP solvers, if expectation operators or functions are supplied; using .run(..., e_ops=[...]) the expectation values are available in; result.expect.; Below we run the solver again, but use e_ops to store the expectation; values of the population of the system states and the coherence:; # Define the operators that measure the populations of the two; # system states:; P11p = basis(2,0) * basis(2,0).dag(); P22p = basis(2,1) * basis(2,1).dag(). # Define the operator that measures the 0, 1 element of density matrix; # (corresonding to coherence):; P12p = basis(2,0) * basis(2,1).dag(). # Run the solver:; tlist = np.linspace(0, 20, 101); result = solver.run(rho0, tlist, e_ops={""11"": P11p, ""22"": P22p, ""12"": P12p}). # Plot the results:; fig, axes = plt.subplots(1, 1, sharex=True, figsize=(8,8)); axes.plot(result.times, result.expect[""11""], 'b', linewidth=2, label=""P11""); axes.plot(result.times, result.expect[""12""], 'r', linewidth=2, label=""P12""); axes.set_xlabel(r't', fontsize=28); axes.legend(loc=0, fontsize=12). Steady-state¶; Using the same solver, we can also determine the steady state of the; combined s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/heom/bosonic.html:5481,avail,available,5481,docs/4.7/guide/heom/bosonic.html,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html,2,['avail'],['available']
Availability," of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:74296,error,error,74296,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability," of output image. Default is ‘png’. dirc : str. Directory for output images. Defaults to current working directory. Returns:File containing plot of Bloch sphere. :. show()¶; Display the Bloch sphere and corresponding data sets. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False)¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers.; Attributes. atol; float {1e-8}; Absolute tolerance. rtol; float {1e-6}; Relative tolerance. method; str {‘adams’,’bdf’}; Integration method. order; int {12}; Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; int {2500}; Max. number of internal steps/call. first_step; float {0}; Size of initial step (0 = automatic). min_step; float {0}; Minimum step size (0 = automatic). max_step; float {0}; Maximum step size (0 = automatic). tidy; bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus; int; Number of cpus used by mcsolver (default = # of cpus). norm_tol; float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps; int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states; bool {False}; Average states values over trajectories in stochastic solvers. average_expect; bool {True}; Avgerage expectation values over trajectories for stochastic solvers. ntraj; int {500}; Number of trajectories in stochastic solvers. rhs_reus",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/classes.html:23948,toler,tolerance,23948,docs/3.0.1/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/classes.html,1,['toler'],['tolerance']
Availability," of output image. Default is ‘png’. dirc : str. Directory for output images. Defaults to current working directory. Returns:File containing plot of Bloch sphere. :. show()¶; Display the Bloch sphere and corresponding data sets. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False)¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers.; Attributes. atol; float {1e-8}; Absolute tolerance. rtol; float {1e-6}; Relative tolerance. method; str {‘adams’,’bdf’}; Integration method. order; int {12}; Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; int {2500}; Max. number of internal steps/call. first_step; float {0}; Size of initial step (0 = automatic). min_step; float {0}; Minimum step size (0 = automatic). max_step; float {0}; Maximum step size (0 = automatic). tidy; bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms. num_cpus; int; Number of cpus used by mcsolver (default = # of cpus). norm_tol; float; Tolerance used when finding wavefunction norm in mcsolve. norm_steps; int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_states; bool {True, False}; Avg. expectation values in mcsolver. ntraj; int {500}; Number of trajectories in stochastic solvers. rhs_reuse; bool {False,True}; Reuse Hamiltonian data. rhs_with_state; bool {False,True}; Whether or not to include the state in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:23886,toler,tolerance,23886,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,1,['toler'],['tolerance']
Availability," of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:3355,error,error,3355,docs/4.6/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html,3,"['Error', 'error']","['Error', 'error']"
Availability," only. Using the `Qobj.isoperbra`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isoperbra else False. def isoper(Q):; """"""Determines if given quantum object is a operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isoper : bool; True if Qobj is operator, False otherwise. Examples; --------; >>> a = destroy(5); >>> isoper(a); True. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isoper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isoper else False. def issuper(Q):; """"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:52801,toler,tolerance,52801,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,3,['toler'],['tolerance']
Availability," op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; if e.dims[1] != psi0.dims[0]:; raise TypeError(f""e_ops dims ({e.dims}) are not compatible""; f"" with the state's ({psi0.dims})""); else:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; output.expe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/sesolve.html:11200,error,error,11200,docs/4.6/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/sesolve.html,2,['error'],['error']
Availability," operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:pairs : tuple. One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:cqobj : Qobj. The original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:rho : qobj. Density matrix of composite ob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:43244,mask,mask,43244,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['mask'],['mask']
Availability," optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:30699,error,error,30699,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,6,['error'],['error']
Availability," optionalArguments for qutip.QobjEvo. noisy: bool, optionalIf noise are included. Default is False. Returns. qobjevo: qutip.QobjEvoThe qutip.QobjEvo representation of the unitary evolution. c_ops: list of qutip.QobjEvoA list of lindblad operators is also returned. if noisy==Flase,; it is always an empty list. load_circuit(self, qc, min_fid_err=inf, merge_gates=True, setting_args=None, verbose=False, **kwargs)[source]¶; Find the pulses realizing a given qutip.qip.Circuit using; qutip.control.optimize_pulse_unitary. Further parameter for; for qutip.control.optimize_pulse_unitary needs to be given as; keyword arguments. By default, it first merge all the gates; into one unitary and then find the control pulses for it.; It can be turned off and one can set different parameters; for different gates. See examples for details. Parameters. qc: :class:`qutip.QubitCircuit` or list of QobjThe quantum circuit to be translated. min_fid_err: float, optionalThe minimal fidelity tolerance, if the fidelity error of any; gate decomposition is higher, a warning will be given.; Default is infinite. merge_gates: boolean, optimalIf True, merge all gate/Qobj into one Qobj and then; find the optimal pulses for this unitary matrix. If False,; find the optimal pulses for each gate/Qobj. setting_args: dict, optionalOnly considered if merge_gates is False.; It is a dictionary containing keyword arguments; for different gates.; E.g:; setting_args = {“SNOT”: {“num_tslots”: 10, “evo_time”: 1},. “SWAP”: {“num_tslots”: 30, “evo_time”: 3},; “CNOT”: {“num_tslots”: 30, “evo_time”: 3}}. verbose: boolean, optionalIf true, the information for each decomposed gate; will be shown. Default is False. **kwargskeyword arguments for qutip.control.optimize_pulse_unitary. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Hamiltonian. Notes; len(tlist",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:87018,toler,tolerance,87018,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,2,"['error', 'toler']","['error', 'tolerance']"
Availability," options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solvers.; openmp_threads : int; Number of OPENMP threads to use. Default is number of cpu cores.; rhs_reuse : bool {False,True}; Reuse Hamiltonian data.; rhs_with_state : bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature.; rhs_filename : str; Name for compiled Cython file.; seeds : ndarray; Array containing random number seeds for mcsolver.; store_final_state : bool {False, True}; Whether or not to store ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/solver.html:5834,Toler,Tolerance,5834,docs/4.6/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html,2,['Toler'],['Tolerance']
Availability," or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect.; use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. Default; None means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_t_tol=1e-6, norm_steps=5,; rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False,; rhs_with_state=False, store_final_state=False,; store_states=False, steady_state_average=False,; seeds=None,; normalize_output=True, use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:7543,toler,tolerance,7543,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,6,['toler'],['tolerance']
Availability," order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = ntraj; # Holds seeds for rand num gen; self.seeds = seeds; # tidyup Hamiltonian before calculation (default = True); self.tidy = tidy; # include the state in the function callback signature; self.rhs_with_state = rhs_with_state; # Use preexisting RHS function for time-dependent solvers; self.rhs_reuse = rhs_reuse; # Use filename for preexisting RHS function (will default to last; # compiled function if None & rhs_exists=True); self.rhs_filename = rhs_filename; # small value in mc solver for computing correlations; self.mc_corr_eps = 1e-10; # Number of processors to use (mcsolve only); if num_cpus:; self.num_cpus = num_cpus; else:; self.num_cpus = qset.num_cpus; # Tolerance for wavefunction norm (mcsolve only); self.norm_tol = norm_tol; # Tolerance for collapse time precision (mcsolve only); self.norm_t_tol = norm_t_tol; # Max. number of steps taken to find wavefunction norm to within; # norm_tol (mcsolve only); self.norm_steps = norm_steps; # Number of threads for openmp; if openmp_threads is None:; self.openmp_threads = qset.num_cpus; else:; self.openmp_threads = openmp_threads; # store final state?; self.store_final_state = store_final_state; # store states even if expectation operators are given?; self.store_states = store_states; # average mcsolver density matricies assuming steady state evolution; self.steady_state_average = steady_state_average; # Normalize output of solvers; # (turned off for batch unitary propagator mode); self.normalize_output = normalize_output; # Use OPENMP for sparse matrix vector multiplication; self.use_openmp = use_openmp. def __str__(self):; if self.seeds is None:; seed_length = 0; else:; seed_length = len(self.seeds); s = """"; s += ""Options:\n""; s += ""-----------\n""; s += ""atol: "" + str(self.atol) + ""\n""",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/solver.html:9308,Toler,Tolerance,9308,docs/4.6/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/solver.html,2,['Toler'],['Tolerance']
Availability," over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:42301,mask,mask,42301,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,['mask'],['mask']
Availability," pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:240782,error,error,240782,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['error'],['error']
Availability," pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:252901,error,error,252901,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['error'],['error']
Availability," parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation; Attributes. iter_num; (int) Iteration number of the pulse optimisation. fid_func_call_num; (int) Fidelity function call number of the pulse optimisation. grad_func_call_num; (int) Gradient function call number of the pulse optimisation. fid_err; (float) Fidelity error. grad_norm; (float) fidelity gradient (wrt the control parameters) vector norm that is the magnitude of the gradient. wall_time; (float) Time spent computing the pulse optimisation so far (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used; Attributes. fid_err_targ; (float) Target fidelity error. fid_goal; (float) goal fidelity, e.g. 1 - self.fid_err_targ It its typical to set this for unitary systems. max_wall_time; (float) # maximum time for optimisation (seconds). min_gradient_norm; (float) Minimum normalised gradient after which optimisation will terminate. max_iterations; (integer) Maximum iterations of the optimisation algorithm. max_fid_func_calls; (integer) Maximum number of calls to the fidelity function during the optimisation algorithm. accuracy_factor; (float) Determines the accuracy of the result. Typical values for accuracy_factor are: 1e12 for low accuracy; 1e7 for moderate accuracy; 10.0 for extremely high accuracy scipy.optimize.fmin_l_bfgs_b factr argument. Only set for specific methods (fmin_l_bfgs_b) that uses this Otherwise the same thing is passed as method_option ftol (although the scale is different) Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimis",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:69824,error,error,69824,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['error'],['error']
Availability," parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object at 0x1a2041a320>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:107683,error,errors,107683,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['error'],['errors']
Availability," parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eaa20>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:89722,error,errors,89722,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['error'],['errors']
Availability," parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:121901,error,errors,121901,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['errors']
Availability," passed as grad; This SU version respects global phase. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control ampl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:98067,error,error,98067,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability," permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; Internal use module for manipulating dims specifications.; """""". __all__ = [] # Everything should be explicitly imported, not made available; # by default. import numpy as np; from operator import getitem; from functools import partial. [docs]def is_scalar(dims):; """"""; Returns True if a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/dimensions.html:2205,avail,available,2205,docs/4.5/modules/qutip/dimensions.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/dimensions.html,3,['avail'],['available']
Availability," range(n_ts):; fwd_evo = dyn._fwd_evo[k]; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; G",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:17914,error,error,17914,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['error'],['error']
Availability," regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. args : dict; Dictionary of arguments to be passed to solver. solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : st",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:100902,error,errors,100902,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['errors']
Availability," representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. sinm(self)[source]¶; Sine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix sine of operator. Raises. TypeErrorQuantum object is not square. Notes; Uses the Q.expm() method. sqrtm(self, sparse=False, tol=0, maxiter=100000)[source]¶; Sqrt of a quantum operator.; Operator must be square. Parameters. sparseboolUse sparse eigenvalue/vector solver. tolfloatTolerance used by sparse solver (0 = machine precision). maxiterintMaximum number of iterations used by sparse solver. Returns. operqutip.QobjMatrix square root of operator. Raises. TypeErrorQuantum object is not square. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. tidyup(self, atol=1e-12)[source]¶; Removes small elements from the quantum object. Parameters. atolfloatAbsolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns. operqutip.QobjQuantum object with small elements removed. tr(self)[source]¶; Trace of a quantum object. Returns. tracefloatReturns real if operator is Hermitian, returns complex; otherwise. trans(self)[source]¶; Transposed operator. Returns. operqutip.QobjTranspose of input operator. transform(self, inpt, inverse=False, sparse=True)[source]¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters. inptarray_likeA matrix or list of kets defining the transformation. inverseboolWhether to return inverse transformation. sparseboolUse sparse matrices when possible. Can be slower. Returns. operqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(self, method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eige",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:14337,toler,tolerance,14337,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['toler'],['tolerance']
Availability," result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14460,error,error,14460,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,2,['error'],['error']
Availability," result; res.states.append(states_list); noise.append(dW); res.measurement.append(m); res.expect += expect; res.ss += expect * expect; res.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); res.runs_expect = np.stack(paths_expect). # average density matrices (vectorized maybe); # ajgpitch 2019-10-25: np.any(res.states) seems to error; # I guess there may be a potential exception if there are no states?; # store individual trajectory states; res.traj_states = res.states; res.avg_states = None; if options.average_states and options.store_states:; avg_states_list = []; for n in range(len(res.times)):; tslot_states = [res.states[mm][n].data for mm in range(nt)]; if len(tslot_states) > 0:; state = Qobj(np.sum(tslot_states),; dims=res.states[0][n].dims).unit(); avg_states_list.append(state); # store average states; res.states = res.avg_states = avg_states_list. # average; res.expect = res.expect / nt. # standard error; if nt > 1:; res.se = (res.ss - nt * (res.expect ** 2)) / (nt * (nt - 1)); else:; res.se = None. # convert complex data to real if hermitian; res.expect = [np.real(res.expect[n, :]); if e.isherm else res.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return res. def _single_trajectory(i, sso):; # Only one step?; ssolver = sso.solver_obj(); #ssolver.set_data(sso); ssolver.set_solver(sso); result = ssolver.cy_sesolve_single_trajectory(i)#, sso); return result. # The code for ssepdpsolve have been moved to the file pdpsolve.; # The call is still in stochastic for consistance.; [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:41932,error,error,41932,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['error'],['error']
Availability," result; res.states.append(states_list); noise.append(dW); res.measurement.append(m); res.expect += expect; res.ss += expect * expect; res.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); res.runs_expect = np.stack(paths_expect). # average density matrices (vectorized maybe); # ajgpitch 2019-10-25: np.any(res.states) seems to error; # I guess there may be a potential exception if there are no states?; # store individual trajectory states; res.traj_states = res.states; res.avg_states = None; if options.average_states and options.store_states:; avg_states_list = []; for n in range(len(res.times)):; tslot_states = [res.states[mm][n].data for mm in range(nt)]; if len(tslot_states) > 0:; state = Qobj(np.sum(tslot_states),; dims=res.states[0][n].dims).unit(); avg_states_list.append(state); # store average states; res.states = res.avg_states = avg_states_list. # average; res.expect = res.expect / nt. # standard error; if nt > 1:; res.se = (res.ss - nt * (res.expect ** 2)) / (nt * (nt - 1)); else:; res.se = None. # convert complex data to real if hermitian; res.expect = [np.real(res.expect[n, :]); if e.isherm else res.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return res. def _single_trajectory(i, sso):; # Only one step?; ssolver = sso.solver_obj(); ssolver.set_solver(sso); result = ssolver.cy_sesolve_single_trajectory(i); return result. # The code for ssepdpsolve have been moved to the file pdpsolve.; # The call is still in stochastic for consistance.; [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly space",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:42358,error,error,42358,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,2,['error'],['error']
Availability," results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]@_deprecate(""direct eigenstate and -value calculation""); def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. .. deprecated:: 4.6.0; :obj:`~ode2es` will be removed in QuTiP 5. Please use; :obj:`qutip.Qobj.eigenstates` to get the eigenstates and -values,; and use :obj:`~qutip.QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/essolve.html:4131,error,error,4131,docs/4.7/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html,2,['error'],['error']
Availability," rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / np.sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; In [26]: q * x; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-26-c5138e004127> in <module>(); ----> 1 q * x. /opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/qutip/qobj.py in __mul__(self, other); 433 ; 434 else:; --> 435 raise TypeError(""Incompatible Qobj shapes""); 436 ; 437 elif isinstance(other, (list, np.ndarray)):. TypeError: Incompatible Qobj shapes. In addition, the logic operators is equal == and is not equal != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Eigenenergies; Q.eigenenergies()",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-basics.html:9845,error,error,9845,docs/3.1.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html,1,['error'],['error']
Availability," self.apply_params(). [docs] def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:11088,error,errors,11088,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,6,['error'],['errors']
Availability," self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:27760,error,errors,27760,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,1,['error'],['errors']
Availability," self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)). def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; self._num_ctrls = len(self.ctrl_dyn_gen). if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:25994,error,errors,25994,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['error'],['errors']
Availability," self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None. self.apply_params(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots. if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]. self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None. if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). def _apply_bounds_and_offset(self, pulse):; """"""; Ensure that the randomly generated pulse fits within the bounds; (after apply",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:8514,error,errors,8514,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,4,['error'],['errors']
Availability," solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlation_2op_2t()"",; FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:22458,error,errors,22458,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['error'],['errors']
Availability," spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-measurement.html:2930,down,down,2930,docs/4.6/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html,2,['down'],['down']
Availability," state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). # spectrum. [docs]def spectrum_ss(H, wlist, c_ops, a_op, b_op):; """"""; Calculate the spectrum of the correlation function; :math:`\lim_{t \\to \\infty} \left<A(t+\\tau)B(t)\\right>`,; i.e., the Fourier transform of the correlati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:26741,error,errors,26741,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,6,['error'],['errors']
Availability," states in state_inds only. Parameters:states_inds : list of integer. The states that should be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Note; Experimental. full(squeeze=False)¶; Dense array from quantum object. Returns:data : array. Array of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000)¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigval : float. Eigenvalue for the ground state of quantum operator. eigvec : qobj. Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:bra : qobj. Quantum object of type ‘bra’. ket : qobj. Quantum object of type ‘ket’. Returns:elem : complex. Complex valued matrix element. Raises:TypeError. Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameter",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:10322,toler,tolerance,10322,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['toler'],['tolerance']
Availability," summary file.; default is a space. data_sep : str; delimiter for the data files (arrays saved to file).; default is a space. summary_file : str; File path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. level¶. The level of data dumping that will occur. SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes:; dump_summary : bool; When True summary items are appended to the iter_summary. iter_summary : list of optimizer.OptimIterSummary; Summary at each iteration. dump_fid_err : bool; When True values are appended to the fid_err_log. fid_err_log : list of float; Fidelity error at each call of the fid_err_func. dump_grad_norm : bool; When True values are appended to the fid_err_log. grad_norm_log : list of float; Gradient norm at each call of the grad_norm_log. dump_grad : bool; When True values are appended to the grad_log. grad_log : list of ndarray; Gradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. dump_all¶; True if everything (ignoring the summary) is to be dumped. dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters:; f : filename or filehandle; If specified then all summary and object data will go in one file.; If None is specified then type specific files will be ge",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:125650,error,error,125650,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability," t2 = self.t2[qu_ind]; if t1 is not None:; op = 1/np.sqrt(t1) * destroy(2); lindblad_noise.add_lindblad_noise(op, qu_ind, coeff=True); if t2 is not None:; # Keep the total dephasing ~ exp(-t/t2); if t1 is not None:; if 2*t1 < t2:; raise ValueError(; ""t1={}, t2={} does not fulfill ""; ""2*t1>t2"".format(t1, t2)); T2_eff = 1./(1./t2-1./2./t1); else:; T2_eff = t2; op = 1/np.sqrt(2*T2_eff) * sigmaz(); lindblad_noise.add_lindblad_noise(op, qu_ind, coeff=True); return lindblad_noise. [docs]class ControlAmpNoise(Noise):; """"""; The noise in the amplitude of the control pulse. Parameters; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like, optional; A NumPy array specifies the time of each coefficient.; indices: list of int, optional; The indices of target pulse in the list of pulses.; Attributes; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like; A NumPy array specifies the time of each coefficient.; indices: list of int; The indices of target pulse in the list of pulses. """"""; def __init__(self, coeff, tlist=None, indices=None):; self.coeff = coeff; self.tlist = tlist; self.indices = indices. [docs] def get_noisy_dynamics(self, pulses):; """"""; Return a list of pulses containing the input pulse with additional; coherent noise. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The input `Pulse` object with additional coherent noise.; """"""; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; for i in indices:; pulse = pulses[i]; if isinstance(self.coeff, (int, float)):; coeff = pulse.coeff * self.coeff; else:; coeff = self.coeff; if self.tlist is None:; tlist = pulse.tlist; else:; tlist = self.tlist; pulses[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html:10543,avail,available,10543,docs/4.5/modules/qutip/qip/noise.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html,1,['avail'],['available']
Availability," term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:29531,error,error,29531,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['error']
Availability," terminate. max_iterations¶; integer – Maximum iterations of the optimisation algorithm. max_fid_func_calls¶; integer – Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor¶; float – Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. termination_reason¶; string – Description of the reason for terminating the optimisation. fidelity¶; float – final (normalised) fidelity that was achieved. initial_fid_err¶; float – fidelity error before optimisation starting. fid_err¶; float – final fidelity error that was achieved. goal_achieved¶; boolean – True is the fidely error achieved was below the target. grad_norm_final¶; float – Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached¶; float – True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter¶; integer – Number of iterations of the optimisation algorithm completed. max_iter_exceeded¶; boolean – True if the iteration limit was reached. max_fid_func_exceeded¶; boolean – True if the fidelity function call limit was reached. wall_time¶; float – time elapsed during the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the optimisation. final_amps¶; array[num_tslots, n_ctrls] – The amplitu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:74077,error,error,74077,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability," terms for the imaginary; part of the correlation function. The corresponding ceofficients are; passed as ck_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:53908,toler,tolerance,53908,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['toler'],['tolerance']
Availability," the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:90076,Toler,Tolerance,90076,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['Toler'],['Tolerance']
Availability," the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, rho0, tlist, e_ops, options=None, floquet_basis=True, f_modes_0=None, f_modes_table_t=None, f_energies=None, T=None)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; It is important to understand in which frame and basis the results; are return",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:97235,Toler,Tolerance,97235,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['Toler'],['Tolerance']
Availability," the fidelity error gradients wrt the control in the timeslot. grad_norm; (float) Last computed value for the norm of the fidelity error gradients (sqrt of the sum of the squares). fid_err_grad_current; (boolean) flag to specify whether the fidelity / fid_err are based on the current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header); Attributes. phase_option; (string) determines how global phase is treated in fidelity calculations: PSU - global phase ignored SU - global phase included. fidelity_prenorm; (complex) Last computed value of the fidelity before it is normalised It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current; (boolean) flag to specify whether fidelity_prenorm are based on the current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:90019,error,error,90019,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['error'],['error']
Availability," the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:97976,error,error,97976,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability," the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k). def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX';",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/propcomp.html:6229,error,errors,6229,docs/4.4/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/propcomp.html,1,['error'],['errors']
Availability," the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict; Dictionary of parameters for time dependent systems. tol : float; Tolerance of the solver for implicit methods. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in `times`. dW_factors : array; Array of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:; order 1/2 algorithms: 'euler-maruyama', 'pc-euler', 'pc-euler-imp'; order 1 algorithms: 'milstein', 'platen', 'milstein-imp', 'rouchon'; order 3/2 algorithms: 'taylor1.5', 'taylor1.5-imp', 'explicit1.5'; order 2 algorithms: 'taylor2.0'; call help of :func:`qutip.stochastic.stochastic_solvers`; for a description of the solvers.; Implicit methods can adjust tolerance via the kw 'tol'; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne'); The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expect : bool (default False); Whether or not to store the e_ops expect values for all paths. store_measurement : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.Result` instance returned by the solver. noise : int, array[int, 1d], array[double, 4d]; int : seed of the noise; array[int, 1d], length = ntraj, seeds for each trajectories; array[double, 4d] (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]); vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. The correspond to results.noise. noiseDepth : int; Number of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalize : bool; (default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:9789,toler,tolerance,9789,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,2,['toler'],['tolerance']
Availability," the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fpri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:25844,error,error,25844,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['error']
Availability," the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(self, method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(self, states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran order",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:8968,avail,available,8968,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['avail'],['available']
Availability," then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if isinstance(times, string_types):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). if not self.tslot_computer.compare_amps(new_amps):; if self.config.test_out_amps:; fname = ""amps_{}_{}_{}_call{}{}"".format(; self.id_text,; self.prop_computer.id_text,; self.fid_computer.id_text,; self.stats.num_ctrl_amp_updates,; self.config.test_out_f_ext). fpath = os.path.join(self.config.test_out_dir, fname); self.save_amps(fpath, verbose=True). [docs] def flag_system_changed(self):; """"""; Flag eveolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:17681,error,error,17681,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,2,['error'],['error']
Availability," this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; c_op (Qobj) – operator C.; d_op (Qobj) – operator D.; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by taulist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:92242,error,errors,92242,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['errors']
Availability," this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Returns instance of OptimResult, which has attributes giving the. reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=10000000.0, dyn_type='GEN_MAT', prop_type='DEF', fid_type='DEF', phase_option=None, fid_err_scale_factor=None, amp_update_mode='ALL', init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters:drift : Qobj. the underlying dynamics generator of the sy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:141848,error,error,141848,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['error'],['error']
Availability," this value will be added; to any initial pulses generated. log_level : integer. level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None. files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:Returns instance of OptimResult, which has attributes giving the. reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=10000000.0, phase_option='PSU', amp_update_mode='ALL', init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, out_file_ext='.txt', gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise am",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:136302,error,error,136302,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['error'],['error']
Availability," times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. :math:`t \rightarrow \infty`; here tlist is; automatically set, ignoring user input. taulist : *list* / *array*; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list of :class:`qutip.qobj.Qobj`; list of collapse operators. (does not accept time dependence). a_op : :class:`qutip.qobj.Qobj`; operator A. b_op : :class:`qutip.qobj.Qobj`; operator B. c_op : :class:`qutip.qobj.Qobj`; operator C. d_op : :class:`qutip.qobj.Qobj`; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : :class:`qutip.solver.Options`; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat: *array*; An 2-dimensional *array* (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional *array* of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). # spectrum. [docs]def spectrum_ss(H, wlist, c_ops, a_op, b_op):; """"""; Calculate the spectrum of the correlation function; :math:`\lim_{t \to \infty} \left<A(t+\\tau)B(t)\\right>`,; i.e., the Fourier transform of the correl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:27586,error,errors,27586,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['error'],['errors']
Availability," times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]); 10.0%. Run time: 1.51s. Est. time left: 00:00:00:13; 20.0%. Run time: 2.97s. Est. time left: 00:00:00:11; 30.0%. Run time: 4.43s. Est. time left: 00:00:00:10; 40.0%. Run time: 5.93s. Est. time left: 00:00:00:08; 50.0%. Run time: 7.39s. Est. time left: 00:00:00:07; 60.0%. Run time: 8.85s. Est. time left: 00:00:00:05; 70.0%. Run time: 10.33s. Est. time left: 00:00:00:04; 80.0%. Run time: 11.77s. Est. time left: 00:00:00:02; 90.0%. Run time: 13.22s. Est. time left: 00:00:00:01; 100.0%. Run time: 14.66s. Est. time left: 00:00:00:00; Total run time: 14.75s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html:15952,avail,available,15952,docs/4.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html,1,['avail'],['available']
Availability," to compute \(\rho(t_n)\).; Must be uniformily spaced. e_ops : list of qutip.Qobj / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like; optional list of precomputed tensors \(T_k\). kwargs : dictionary; Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:156770,error,error,156770,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['error']
Availability," to_super does nothing to things; # that are already type=super, while it will; # promote unitaries to superunitaries.; return super_tensor(*map(qutip.superop_reps.to_super, args)). else:; # Everything's just an oper, so ordinary tensor products work.; return tensor(*args). elif all(map(_isketlike, args)):; # Ket-likes.; if any(arg.isoperket for arg in args):; # We have a vectorized operator, we we may need to promote; # something.; return super_tensor(*(; arg if arg.isoperket; else operator_to_vector(qutip.states.ket2dm(arg)); for arg in args; )). else:; # Everything's ordinary, so we can use the tensor product here.; return tensor(*args). elif all(map(_isbralike, args)):; # Turn into ket-likes and recurse.; return composite(*(arg.dag() for arg in args)).dag(). else:; raise TypeError(""Unsupported Qobj types [{}]."".format(; "", "".join(arg.type for arg in args); )). def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> print(flatten([[[0], 1], 2])); [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). def _enumerate_flat(l, idx=0):; if not isinstance(l, list):; # Found a scalar, so return and increment.; return idx, idx + 1; else:; # Found a list, so append all the scalars; # from it and recurse to keep the increment; # correct.; acc = []; for elem in l:; labels, idx = _enumerate_flat(elem, idx); acc.append(labels); return acc, idx. def enumerate_flat(l):; """"""Labels the indices at which scalars occur in a flattened list. Given a list containing a mix of scalars and lists,; returns a list of the same structure, where each scalar; has been replaced by an index into the flattened list. Examples; --------. >>> print(enumerate_flat([[[10], [20, 30]], 40])); [[[0], [1, 2]], 3]. """"""; return _enumerate_flat(l)[0]. def deep_remove(l, *what):; """"""Removes scalars from all levels of a n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html:9067,down,down,9067,docs/3.1.0/modules/qutip/tensor.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/tensor.html,1,['down'],['down']
Availability," tolerance. rtol; (float {1e-6}) Relative tolerance. method; (str {‘adams’,’bdf’}) Integration method. order; (int {12}) Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; (int {2500}) Max. number of internal steps/call. first_step; (float {0}) Size of initial step (0 = automatic). min_step; (float {0}) Minimum step size (0 = automatic). max_step; (float {0}) Maximum step size (0 = automatic). tidy; (bool {True,False}) Tidyup Hamiltonian and initial state by removing small terms. num_cpus; (int) Number of cpus used by mcsolver (default = # of cpus). norm_tol; (float) Tolerance used when finding wavefunction norm in mcsolve. norm_steps; (int) Max. number of steps used to find wavefunction norm to within norm_tol in mcsolve. average_states; (bool {False}) Average states values over trajectories in stochastic solvers. average_expect; (bool {True}) Average expectation values over trajectories for stochastic solvers. mc_corr_eps; (float {1e-10}) Arbitrarily small value for eliminating any divide-by-zero errors in correlation calculations when using mcsolve. ntraj; (int {500}) Number of trajectories in stochastic solvers. openmp_threads; (int) Number of OPENMP threads to use. Default is number of cpu cores. rhs_reuse; (bool {False,True}) Reuse Hamiltonian data. rhs_with_state; (bool {False,True}) Whether or not to include the state in the Hamiltonian function callback signature. rhs_filename; (str) Name for compiled Cython file. seeds; (ndarray) Array containing random number seeds for mcsolver. store_final_state; (bool {False, True}) Whether or not to store the final state of the evolution in the result class. store_states; (bool {False, True}) Whether or not to store the state vectors or density matrices in the result class, even if expectation values operators are given. If no expectation are provided, then states are stored by default and this option has no effect. use_openmp; (bool {True, False}) Use OPENMP for sparse matrix vector multiplication. Default None mea",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:34019,error,errors,34019,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['error'],['errors']
Availability," tolerance. rtol; (float {1e-6}) Relative tolerance. method; (str {‘adams’,’bdf’}) Integration method. order; (int {12}) Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; (int {2500}) Max. number of internal steps/call. first_step; (float {0}) Size of initial step (0 = automatic). min_step; (float {0}) Minimum step size (0 = automatic). max_step; (float {0}) Maximum step size (0 = automatic). tidy; (bool {True,False}) Tidyup Hamiltonian and initial state by removing small terms. num_cpus; (int) Number of cpus used by mcsolver (default = # of cpus). norm_tol; (float) Tolerance used when finding wavefunction norm in mcsolve. norm_steps; (int) Max. number of steps used to find wavefunction norm to within norm_tol in mcsolve. average_states; (bool {False}) Average states values over trajectories in stochastic solvers. average_expect; (bool {True}) Average expectation values over trajectories for stochastic solvers. mc_corr_eps; (float {1e-10}) Arbitrarily small value for eliminating any divide-by-zero errors in correlation calculations when using mcsolve. ntraj; (int {500}) Number of trajectories in stochastic solvers. rhs_reuse; (bool {False,True}) Reuse Hamiltonian data. rhs_with_state; (bool {False,True}) Whether or not to include the state in the Hamiltonian function callback signature. rhs_filename; (str) Name for compiled Cython file. seeds; (ndarray) Array containing random number seeds for mcsolver. store_final_state; (bool {False, True}) Whether or not to store the final state of the evolution in the result class. store_states; (bool {False, True}) Whether or not to store the state vectors or density matrices in the result class, even if expectation values operators are given. If no expectation are provided, then states are stored by default and this option has no effect. class Result[source]¶; Class for storing simulation results from any of the dynamics solvers.; Attributes. solver; (str) Which solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, ...",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:26514,error,errors,26514,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['error'],['errors']
Availability," trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; Th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:112766,error,error,112766,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability," trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are retu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:106994,error,error,106994,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability," used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options); else:; return _correlation_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:11475,error,errors,11475,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['error'],['errors']
Availability," used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodic : boolean; True if the pulse generator produces periodic pulses. random : boolean; True if the pulse generator produces random pulses. """"""; def __init__(self, dyn=None):; self.parent = dyn; self.reset(). [docs] def reset(self):; """"""; reset attributes to default values; """"""; if isinstance(self.parent, dynamics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = -np.Inf; self.ubound = np.Inf. [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; self._pulse_initialised = True. if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). def _apply_bounds_and_offset(self, pulse):; """"""; Ensure that the randomly generated pulse fits within the bounds; (after applying the offset); Assumes that pulses passed are centered around zero (on average); """"""; if np.isinf(self.lbound) and np.isinf(self.ubound):; return pulse + self.offset. max_amp = max(pulse); min_amp = min(pulse); if (max_amp + self.offset <= self.ubound and; min_amp + self.offset >= self.lbound):; return pulse + self.offset. # Some shifting / scaling is require",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:7911,error,errors,7911,docs/3.1.0/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html,1,['error'],['errors']
Availability," used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object at 0xd1fd3bdd8>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters. waveguide_emission_indiceslist or tupleList of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:129581,error,error,129581,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['error'],['error']
Availability," using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); print(""Number of iterations {}"".format(result.num_iter)). tlist = np.hstack([[0.]] + time_record); for i in range(len(self.pulses)):; self.pulses[i].tlist = tlist; coeffs = np.vstack([np.hstack(coeff_record)]); self.coeffs = coeffs. return tlist, coeffs. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:8187,error,error,8187,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,2,['error'],['error']
Availability," version 0.21+"" % Cython.__version__). # If only time-dependence is in Objects, then prefer string based format; if (len(h_func) + len(c_func) + len(h_str) + len(c_str)) == 0:; h_str += h_obj #Does nothing if not objects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:10075,Error,Error,10075,docs/4.6/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html,2,['Error'],['Error']
Availability, x / np.sqrt(2); ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-basics.html:12486,error,error,12486,docs/4.3/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-basics.html,1,['error'],['error']
Availability," {0.type} ""; ""and superrep = {0.superrep} to supermatrix not ""; ""supported."".format(q_oper); ). [docs]def to_kraus(q_oper):; """"""; Converts a Qobj representing a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to Kraus representation. If; ``q_oper`` is ``type=""oper""``, then it is taken to act by conjugation,; such that ``to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]``. Returns; -------; kraus_ops : list of Qobj; A list of quantum objects, each representing a Kraus operator in the; decomposition of ``q_oper``. Raises; ------; TypeError: if the given quantum object is not a map, or cannot be; decomposed into Kraus operators.; """"""; if q_oper.type == 'super':; if q_oper.superrep in (""super"", ""chi""):; return to_kraus(to_choi(q_oper)); elif q_oper.superrep == 'choi':; return choi_to_kraus(q_oper); elif q_oper.type == 'oper': # Assume unitary; return [q_oper]; else:; raise TypeError(; ""Conversion of Qobj with type = {0.type} ""; ""and superrep = {0.superrep} to Kraus decomposition not ""; ""supported."".format(q_oper); ). def to_stinespring(q_oper):; r""""""; Converts a Qobj representing a quantum map $\Lambda$ to a pair of partial isometries; $A$ and $B$ such that $\Lambda(X) = \Tr_2(A X B^\dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$. For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters; ----------; q_oper : Qobj; Superoperator to be converted to a Stinespring pair. Returns; -------; A, B : Qobj; Quantum objects representing each of the Stinespring matrices for the input Qobj.; """"""; return choi_to_stinespring(to_choi(q_oper)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/superop_reps.html:18339,error,errors,18339,docs/4.3/modules/qutip/superop_reps.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/superop_reps.html,1,['error'],['errors']
Availability," {‘tol’:1e-6}. methodstring (‘homodyne’, ‘heterodyne’)The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expectbool (default False)Whether or not to store the e_ops expect values for all paths. store_measurementbool (default False)Whether or not to store the measurement results in the; qutip.solver.Result instance returned by the solver. noiseint, array[int, 1d], array[double, 4d]int : seed of the noise; array[int, 1d], length = ntraj, seeds for each trajectories; array[double, 4d] (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]). vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. The correspond to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. optionsqutip.solver.OptionsGeneric solver options. Only options.average_states and; options.store_states are used. map_func: functionA map function or managing the calls to single-trajactory solvers. map_kwargs: dictionaryOptional keyword arguments to the map_func function function. progress_barqutip.ui.BaseProgressBarOptional progress bar class instance. *; time-dependent Qobj can be used for H, c_ops and sc_ops.; The format for time-dependent system hamiltonian is:; H = [Qobj0,[Qobj1,coeff1],[Qobj2,coeff2],…]= Qobj0 + Qobj1 * coeff1(t) + Qobj2 * coeff2(t). coeff function can be:function: coeff(t, args) -> complex; str: “sin(1j*w*t)”; np.array[complex, 1d] of length equal to the times array. The argument args for the function coeff is the args keyword argument ofthe stochastic solver. Likewisem in str cases, the parameters (‘w’ in this case) are taken fromthe args keywords argument. *While mixing coeff type does not results in errors, it is not recommende",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:50119,error,errors,50119,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['errors']
Availability, — QuTiP 4.7 Documentation; Classes — QuTiP 4.7 Documentation; Functions — QuTiP 4.7 Documentation. Bibliography — QuTiP 4.7 Documentation; Change Log — QuTiP 4.7 Documentation; Developers — QuTiP 4.7 Documentation; Copyright and Licensing — QuTiP 4.7 Documentation; Copyright and Licensing — QuTiP 4.7 Documentation. /development; . /ideas; ; GPU implementation of the Hierarchical Equations of Motion — QuTiP 4.7 Documentation; Pulse level description of quantum circuits — QuTiP 4.7 Documentation; Quantum Error Mitigation — QuTiP 4.7 Documentation; QuTiP Interactive — QuTiP 4.7 Documentation; TensorFlow Data Backend — QuTiP 4.7 Documentation. Contributing to QuTiP Development — QuTiP 4.7 Documentation; Development Documentation — QuTiP 4.7 Documentation; Working with the QuTiP Documentation — QuTiP 4.7 Documentation; Ideas for future QuTiP development — QuTiP 4.7 Documentation; Release and Distribution — QuTiP 4.7 Documentation; QuTiP Development Roadmap — QuTiP 4.7 Documentation. /downloads; . /12a86e4dcaaba8c4a8de323bd441ab96; ; plot_qip_relaxation.py. /1b50abbe88595fe251e07102f532b361; ; plot_qip_amplitude_noise.ipynb. /3f58cb72e9b73bcbfbeb9e0f6960b60b; ; plot_qip_relaxation.ipynb. /5bc733f4cdb3729576a991efbdd8c026; ; plot_qip_intro_processor.ipynb. /7aaebc4b1d6f7b38aa6c893905ac98ef; ; plot_qip_intro_processor.py. /aacc19a817412ec042804206e9c23202; ; plot_qip_amplitude_noise.py. /e1a1bbebf99cf434ac461d7e6da91f40; ; qutip_tree.pdf. Frontmatter — QuTiP 4.7 Documentation. /gallery; . /build; . /qip; ; Control Amplitude Noise — QuTiP 4.7 Documentation; Basic use of Processor — QuTiP 4.7 Documentation; T2 Relaxation — QuTiP 4.7 Documentation. Gallery — QuTiP 4.7 Documentation. Index — QuTiP 4.7 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 4.7 Documentation; Dynamics Simulation Results — QuTiP 4.7 Documentation; Floquet Formalism — QuTiP 4.7 Documentation; Introduction — QuTiP 4.7 Documentation; Krylov Solver — QuTiP 4.7 Documentation; Lin,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:58661,down,downloads,58661,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['down'],['downloads']
Availability,"""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; self.dimensional_norm = 1.0; self.dimensional_norm = \; self.fid_norm_func(dyn.target.dag()*dyn.target). [do",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:11409,error,errors,11409,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,9,['error'],['errors']
Availability,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:2640,error,error,2640,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['error'],['error']
Availability,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2669,error,error,2669,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimresult.html:2805,error,error,2805,docs/4.1/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimresult.html,8,['error'],['error']
Availability,"'PSU'); self.apply_params(). def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:11074,error,errors,11074,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,3,['error'],['errors']
Availability,"'heterodyne':; sso.d2_len = 1; sso.sc_ops = []; for sc in iter(sc_ops):; sso.sc_ops += [sc / np.sqrt(2), -1.0j * sc / np.sqrt(2)]; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast. elif sso.solver == 'taylor15':; sso.generate_A_ops = _generate_A_ops_simple; sso.generate_noise = _generate_noise_Taylor_15; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'taylor15-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:17424,avail,available,17424,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['avail'],['available']
Availability,"(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=-inf, amp_ubound=inf, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=10000000.0, phase_option='PSU', amp_update_mode='ALL', init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, out_file_ext='.txt', gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:H_d : Qobj. Drift (aka system) the underlying Hamiltonian of the system. H_c : Qobj. a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:137502,error,error,137502,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['error'],['error']
Availability,"(October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. Version 4.6.3 (February ?, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:2788,fault,faults,2788,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,1,['fault'],['faults']
Availability,"(Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Not",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:181999,error,error,181999,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability,"(Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; mim_grad (float) – Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg (string) – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:157080,error,error,157080,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability,"(and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_0=\ket{\psi_0}\) and the target \(\newcommand{\ket}[1]{\left|{#1}\right\rangle} X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[\newcommand{\tr}[0]{\operatorname{tr}} f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:6254,error,error,6254,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,6,['error'],['error']
Availability,"(op). self.op_index += 1; return self.state. def _evolve_state(self, U):; '''; Applies unitary to state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. if self.mode == ""state_vector_simulator"":; self._evolve_ket(U); elif self.mode == ""density_matrix_simulator"":; self._evolve_dm(U); else:; raise NotImplementedError(; ""mode {} is not available."".format(self.mode)). def _evolve_ket(self, U):; '''; Applies unitary to ket state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. self.state = U * self.state. def _evolve_dm(self, U):; '''; Applies unitary to density matrix state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. self.state = U * self.state * U.dag(). def _apply_measurement(self, operation):; '''; Applies measurement gate specified by operation to current state. Parameters; ----------; operation: :class:`.Measurement`; Measurement gate in a circuit object.; '''. states, probabilities = operation.measurement_comp_basis(self.state). if self.mode == ""state_vector_simulator"":; if self.measure_results:; i = int(self.measure_results[self.measure_ind]); self.measure_ind += 1; else:; probabilities = [p/sum(probabilities) for p in probabilities]; i = np.random.choice([0, 1], p=probabilities); self.probability *= probabilities[i]; self.state = states[i]; if operation.classical_store is not None:; self.cbits[operation.classical_store] = i. elif self.mode == ""density_matrix_simulator"":; states = list(filter(lambda x: x is not None, states)); probabilities = list(filter(lambda x: x != 0, probabilities)); self.state = sum(p * s for s, p in zip(states, probabilities)); else:; raise NotImplementedError(; ""mode {} is not available."".format(self.mode)). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:65292,avail,available,65292,docs/4.6/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html,2,['avail'],['available']
Availability,"(sso.e_ops), len(sso.times)), dtype=complex); res.ss = np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); res.measurement = []; res.solver = sso.solver_name; res.ntraj = sso.ntraj; res.num_expect = len(sso.e_ops). nt = sso.ntraj; task = _single_trajectory; map_kwargs = {'progress_bar': sso.progress_bar}; map_kwargs.update(sso.map_kwargs); task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs); noise = []; for result in results:; states_list, dW, m, expect = result; res.states.append(states_list); noise.append(dW); res.measurement.append(m); res.expect += expect; res.ss += expect * expect; res.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); res.runs_expect = np.stack(paths_expect). # average density matrices (vectorized maybe); # ajgpitch 2019-10-25: np.any(res.states) seems to error; # I guess there may be a potential exception if there are no states?; # store individual trajectory states; res.traj_states = res.states; res.avg_states = None; if options.average_states and options.store_states:; avg_states_list = []; for n in range(len(res.times)):; tslot_states = [res.states[mm][n].data for mm in range(nt)]; if len(tslot_states) > 0:; state = Qobj(np.sum(tslot_states),; dims=res.states[0][n].dims).unit(); avg_states_list.append(state); # store average states; res.states = res.avg_states = avg_states_list. # average; res.expect = res.expect / nt. # standard error; if nt > 1:; res.se = (res.ss - nt * (res.expect ** 2)) / (nt * (nt - 1)); else:; res.se = None. # convert complex data to real if hermitian; res.expect = [np.real(res.expect[n, :]); if e.isherm else res.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return res. def _single_trajectory(i, sso):; # Only one step?; ssolver = sso.solver_obj(); #ssolver.set_data(sso); ssolver.set_solver(sso); result = ssolver.cy_sesolve_single_trajectory(i)#, sso); retur",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:41342,error,error,41342,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['error'],['error']
Availability,"(sso.e_ops), len(sso.times)), dtype=complex); res.ss = np.zeros((len(sso.e_ops), len(sso.times)), dtype=complex); res.measurement = []; res.solver = sso.solver_name; res.ntraj = sso.ntraj; res.num_expect = len(sso.e_ops). nt = sso.ntraj; task = _single_trajectory; map_kwargs = {'progress_bar': sso.progress_bar}; map_kwargs.update(sso.map_kwargs); task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs); noise = []; for result in results:; states_list, dW, m, expect = result; res.states.append(states_list); noise.append(dW); res.measurement.append(m); res.expect += expect; res.ss += expect * expect; res.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); res.runs_expect = np.stack(paths_expect). # average density matrices (vectorized maybe); # ajgpitch 2019-10-25: np.any(res.states) seems to error; # I guess there may be a potential exception if there are no states?; # store individual trajectory states; res.traj_states = res.states; res.avg_states = None; if options.average_states and options.store_states:; avg_states_list = []; for n in range(len(res.times)):; tslot_states = [res.states[mm][n].data for mm in range(nt)]; if len(tslot_states) > 0:; state = Qobj(np.sum(tslot_states),; dims=res.states[0][n].dims).unit(); avg_states_list.append(state); # store average states; res.states = res.avg_states = avg_states_list. # average; res.expect = res.expect / nt. # standard error; if nt > 1:; res.se = (res.ss - nt * (res.expect ** 2)) / (nt * (nt - 1)); else:; res.se = None. # convert complex data to real if hermitian; res.expect = [np.real(res.expect[n, :]); if e.isherm else res.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return res. def _single_trajectory(i, sso):; # Only one step?; ssolver = sso.solver_obj(); ssolver.set_solver(sso); result = ssolver.cy_sesolve_single_trajectory(i); return result. # The code for ssepdp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:41768,error,error,41768,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,2,['error'],['error']
Availability,"(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). (png, hires.png, pdf). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). (png, hires.png, pdf). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The Bloch class uses Matplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In this sense the Bloch3d class is much more advanced, as objects are rendered in 3D leadi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-bloch.html:5982,down,down,5982,docs/4.6/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html,2,['down'],['down']
Availability,") that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for symmetric (or Hermitian), positive-definite matrices. Since the Liouvillian has none of these properties, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to be good. QuTiP makes use of an incomplete LU preconditioner is invoked automatically when using the iterative 'GMRES' and 'LGMRES' solvers that uses a combination of symmetric and antisymmetric matrix permutations that attempts to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-steady.html:6968,error,error,6968,docs/3.0.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html,2,['error'],['error']
Availability,")); >>> processor.add_control(sigmax()); >>> # num_tslots and evo_time are two keyword arguments; ... tlist, coeffs = processor.load_circuit(; ... qc, num_tslots=num_tslots, evo_time=evo_time); >>>; >>> # Different parameters for different gates; ... qc = QubitCircuit(N=2); >>> qc.add_gate(""SNOT"", 0); >>> qc.add_gate(""SWAP"", targets=[0, 1]); >>> qc.add_gate('CNOT', controls=1, targets=[0]); >>>; >>> processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); >>> processor.add_control(sigmax(), cyclic_permutation=True); >>> processor.add_control(sigmay(), cyclic_permutation=True); >>> processor.add_control(tensor([sigmay(), sigmay()])); >>> setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ... ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ... ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}; >>> tlist, coeffs = processor.load_circuit(; ... qc, setting_args=setting_args, merge_gates=False). Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors. The typical approaches are either applying bit/sign flipping gate probabilistically or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous time evolution. Instead, the error is added to the driving Hamiltonian list (coherent control error) or the collapse operators (decoherent error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qub",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-qip.html:13442,error,errors,13442,docs/4.5/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-qip.html,1,['error'],['errors']
Availability,"):; """"""Creates a tensor product for a set of qubits in either; the 'up' :math:`|0>` or 'down' :math:`|1>` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu'); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; ----",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/states.html:14100,down,down,14100,docs/4.2/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/states.html,6,['down'],['down']
Availability,"):; """"""Creates a tensor product for a set of qubits in either; the 'up' :math:`|0>` or 'down' :math:`|1>` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu'); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; --------; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/states.html:15140,down,down,15140,docs/3.1.0/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/states.html,1,['down'],['down']
Availability,"):; cfg.reset_test_out_files(); else:; if self.stats is None:; logger.warn(""Cannot output test files when stats""; "" attribute is not set.""); self.config.test_out_amps = False; self.config.test_out_prop = False; self.config.test_out_prop_grad = False; self.config.test_out_evo = False. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib; self.get_num_ctrls(). if init_tslots:; self.init_time_slots(); self._init_lists(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If N",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:15516,error,errors,15516,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['error'],['errors']
Availability,"); Improved the scaling of floquet_master_equation_rates and floquet_master_equation_tensor and fixed transposition and basis change errors in floquet_master_equation_tensor and floquet_markov_mesolve. (#1248 by Camille Le Calonnec, Jake Lishman and Eric Giguère); Removed linspace_with and view_methods from qutip.utilities. For the former it is far better to use numpy.linspace and for the later Python’s in-built help function or other tools. (#1680 by Eric Giguère); Added support for passing callable functions as e_ops to mesolve and sesolve. (#1655 by Marek Narożniak); Added the function steadystate_floquet, which returns the “effective” steadystate of a periodic driven system. (#1660 by Alberto Mercurio); Improved mcsolve memory efficiency by not storing final states when they are not needed. (#1669 by Eric Giguère); Improved the default colors and styling of matrix_histogram and provided additional styling options. (#1573 and #1628 by Mahdi Aslani); Sped up state_number_enumerate, state_number_index, state_index_number, and added some error checking. enr_state_dictionaries now returns a list for idx2state. (#1604 by Johannes Feist); Added new Husimi Q algorithms, improving the speed for density matrices, and giving a near order-of-magnitude improvement when calculating the Q function for many different states, using the new qutip.QFunc class, instead of the qutip.qfunc function. (#934 and #1583 by Daniel Weigand and Jake Lishman); Updated licence holders with regards to new governance model, and remove extraneous licensing information from source files. (#1579 by Jake Lishman); Removed the vendored copy of LaTeX’s qcircuit package which is GPL licensed. We now rely on the package being installed by user. It is installed by default with TexLive. (#1580 by Jake Lishman); The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (#1509 by Purva Thakre). Bug Fixes¶. Fix ci",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:10234,error,error,10234,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['error'],['error']
Availability,"); elif (n-self.N) == measurement.classical_store:; store_tag = n - measurement.targets[0]; col.append(r"" \qw \cwx[%d] "" % store_tag); else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states_quantum = [r""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states[:self.N]]; input_states_classical = [r""\lstick{"" + x + ""}"" if x is not None; else """" for x in self.input_states[self.N:]]; input_states = input_states_quantum + input_states_classical. code = """"; n_iter = (reversed(range(self.N+self.num_cbits)) if self.reverse_states; else range(self.N+self.num_cbits)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(ops)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. # This slightly convoluted dance with the conversion formats is because; # image conversion has optional dependencies. We always want the `png` and; # `svg` methods to be available so that they are discoverable by the user,; # however if one is called without the required dependency, then they'll; # get a `RuntimeError` explaining the problem. We only want the IPython; # magic methods `_repr_xxx_` to be defined if we know that the image; # conversion is available, so the user doesn't get exceptions on display; # because IPython tried to do something behind their back. def _raw_png(self):; return _latex.image_from_latex(self.latex_code(), ""png""). if 'png' in _latex.CONVERTERS:; _repr_png_ = _raw_png. @property; def png(self):; return DisplayImage(self._raw_png(), embed=True). def _raw_svg(self):; return _latex.image_from_latex(self.latex_code(), ""svg""). if 'svg' in _latex.CONVERTERS:; _repr_svg_ = _raw_svg. @property; def svg(self):; return DisplaySVG(self._raw_svg()). def _to_qasm(self, qasm_out):; """"""; Pipe output of circuit object to QasmOutput object. Parameters; ----------; qasm_out: QasmOutput; object to store QASM output.; """""". qasm_out.output(""qreg q[{}];"".format(self.N)); if self.num_cbits:; qasm_out.outp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:52511,avail,available,52511,docs/4.6/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html,2,['avail'],['available']
Availability,"); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(); ; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(); ; if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html:17007,error,error,17007,docs/4.3/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/bloch_redfield.html,4,['error'],['error']
Availability,")\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. solver : str. choice of solver (me for master-equation and; es for exponential series). options : Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2, G2 : tuple. The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:99870,error,errors,99870,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['errors']
Availability,")¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resides not only in its ability to capture complex time evolutions from very large Hilbert spaces with very small dimenions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the function qutip.krylovsolve. Arguments are nearly the same as qutip.mesolve; function for master-equation evolution, except that the initial state must be a k",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:3221,error,error,3221,docs/4.7/guide/dynamics/dynamics-krylov.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html,2,['error'],['error']
Availability,"**k * vac).unit() for k in range(5)] # must normalize. In [68]: expect(N, states); Out[68]: array([0., 1., 2., 3., 4.]). In [69]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [70]: expect(c, cat_list); Out[70]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [71]: up = basis(2, 0). In [72]: down = basis(2, 1). In [73]: expect(sigmaz(), up); Out[73]: 1.0. In [74]: expect(sigmaz(), down); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:16987,down,down,16987,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,1,['down'],['down']
Availability,"*4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup: out.tidyup(); if (settings.auto_tidyup_dims ; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1 for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching dims; # are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype=='object':; return np.array([self * item for item in other],; dtype=object); else:; return self.data * other. elif isinstance(other, list):; # if other is a list, do element-wise multiplication; return np.array([self * item for item in other],;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:15408,mask,mask,15408,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,2,['mask'],['mask']
Availability,"*4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup: out.tidyup(); if (settings.auto_tidyup_dims; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1 for l, r in zip_longest(dims[0],; dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching; # dims are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. elif self.shape[1] == 1 and other.shape[0] == 1:; out = Qobj(); out.data = self.data * other.data; out.dims = [self.dims[0], other.dims[1]]; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype == 'object':; return np.array([self * item for it",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:15668,mask,mask,15668,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,2,['mask'],['mask']
Availability,"*k * vac).unit() for k in range(5)] # must normalize. In [68]: expect(N, states); Out[68]: array([ 0., 1., 2., 3., 4.]). In [69]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [70]: expect(c, cat_list); Out[70]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [71]: up = basis(2, 0). In [72]: down = basis(2, 1). In [73]: expect(sigmaz(), up); Out[73]: 1.0. In [74]: expect(sigmaz(), down); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-states.html:17132,down,down,17132,docs/4.2/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-states.html,3,['down'],['down']
Availability,"+0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-basics.html:9484,down,download,9484,docs/4.6/guide/qip/qip-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html,4,['down'],['download']
Availability,"+; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; --------; >>> ket(""10""); Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue""); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; if isinstance(dim, int):; dim = [dim] * len(seq); return tensor([b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/states.html:15820,down,down,15820,docs/3.1.0/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/states.html,1,['down'],['down']
Availability,", *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:24511,error,errors,24511,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['errors']
Availability,", 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:16454,down,down,16454,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,2,['down'],['down']
Availability,", 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-states.html:16512,down,down,16512,docs/4.7/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html,2,['down'],['down']
Availability,", Iterable):; props = qc; gates = None # using list of Qobj, no gates name; else:; raise ValueError(; ""qc should be a ""; ""QubitCircuit or a list of Qobj""); if merge_gates: # merge all gates/Qobj into one Qobj; props = [gate_sequence_product(props)]; gates = None. time_record = [] # a list for all the gates; coeff_record = []; last_time = 0. # used in concatenation of tlist; for prop_ind, U_targ in enumerate(props):; U_0 = identity(U_targ.dims[0]). # If qc is a QubitCircuit and setting_args is not empty,; # we update the kwargs for each gate.; # keyword arguments in setting_arg have priority; if gates is not None and setting_args:; kwargs.update(setting_args[gates[prop_ind]]). full_drift_ham = self.drift.get_ideal_qobjevo(self.dims).cte; full_ctrls_hams = [pulse.get_ideal_qobj(self.dims); for pulse in self.pulses]; result = cpo.optimize_pulse_unitary(; full_drift_ham, full_ctrls_hams, U_0, U_targ, **kwargs). if result.fid_err > min_fid_err:; warnings.warn(; ""The fidelity error of gate {} is higher ""; ""than required limit. Use verbose=True to see""; ""the more detailed information."".format(prop_ind)). time_record.append(result.time[1:] + last_time); last_time += result.time[-1]; coeff_record.append(result.final_amps.T). if verbose:; print(""********** Gate {} **********"".format(prop_ind)); print(""Final fidelity error {}"".format(result.fid_err)); print(""Final gradient normal {}"".format(; result.grad_norm_final)); print(""Terminated due to {}"".format(result.termination_reason)); print(""Number of iterations {}"".format(result.num_iter)). tlist = np.hstack([[0.]] + time_record); for i in range(len(self.pulses)):; self.pulses[i].tlist = tlist; coeffs = np.vstack([np.hstack(coeff_record)]); self.coeffs = coeffs. return tlist, coeffs. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:7844,error,error,7844,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,2,['error'],['error']
Availability,", PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import os; import warnings; from qutip import __version__. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/solver.html:3887,toler,tolerance,3887,docs/3.1.0/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html,1,['toler'],['tolerance']
Availability,", \(\beta\) doesn’t matter). See eq.; (2.18) of chapter 12.2 of [1]. Order strong 1.5; Code: 'taylor1.5-imp' or 'taylor15-imp'. explicit1.5Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than taylor15 but usable by; general_stochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:111302,Avail,Available,111302,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['Avail'],['Available']
Availability,", ``f``, the result is computed using; ``f(t, ado_state)``. The values are stored in ``expect`` on; (see the return section below). ado_init: bool, default False; Indicates if initial condition is just the system state, or a; numpy array including all ADOs. ado_return: bool, default True; Whether to also return as output the full state of all ADOs. Returns; -------; :class:`qutip.solver.Result`; The results of the simulation run, with the following attributes:. * ``times``: the times ``t`` (i.e. the ``tlist``). * ``states``: the system state at each time ``t`` (only available; if ``e_ops`` was ``None`` or if the solver option; ``store_states`` was set to ``True``). * ``ado_states``: the full ADO state at each time (only available; if ``ado_return`` was set to ``True``). Each element is an; instance of :class:`HierarchyADOsState`. .; The state of a particular ADO may be extracted from; ``result.ado_states[i]`` by calling :meth:`.extract`. * ``expect``: the value of each ``e_ops`` at time ``t`` (only; available if ``e_ops`` were given). If ``e_ops`` was passed; as a dictionary, then ``expect`` will be a dictionary with; the same keys as ``e_ops`` and values giving the list of; outcomes for the corresponding key.; """"""; e_ops, expected = self._convert_e_ops(e_ops); e_ops_callables = any(; not isinstance(op, Qobj) for op in e_ops.values(); ). n = self._sys_shape; rho_shape = (n, n); rho_dims = self._sys_dims; hierarchy_shape = (self._n_ados, n, n). output = Result(); output.solver = ""HEOMSolver""; output.times = tlist; if e_ops:; output.expect = expected; if not e_ops or self.options.store_states:; output.states = []. if ado_init:; if isinstance(rho0, HierarchyADOsState):; rho0_he = rho0._ado_state; else:; rho0_he = rho0; if rho0_he.shape != hierarchy_shape:; raise ValueError(; f""ADOs passed with ado_init have shape {rho0_he.shape}""; f""but the solver hierarchy shape is {hierarchy_shape}""; ); rho0_he = rho0_he.reshape(n ** 2 * self._n_ados); else:; rho0_he = np.zeros([n ** ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:25885,avail,available,25885,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,2,['avail'],['available']
Availability,", g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively ; ; Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to ; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict ; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms.; ; sec_cutoff : float {0.1}; Cutoff for secular approximation.; ; tol : float {qutip.setttings.atol}; Tolerance used for removing small values after ; basis transformation.; ; spectra_cb : list; DEPRECIATED. Do not use.; ; options : :class:`qutip.solver.Options`; Options for the solver.; ; progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H); ; if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None; ; if not (spectra_cb is None):; warnings.warn(""The",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html:5742,Toler,Tolerance,5742,docs/4.6/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/bloch_redfield.html,1,['Toler'],['Tolerance']
Availability,", k]); / (1 - np.abs(dot)**2)**0.5). subspace = vecs.conj().T @ ops[i].data @ vecs; eigvals, eigvecs = la.eig(subspace). perm = np.argsort(eigvals); eigvals = eigvals[perm]. vecs_new = vecs @ eigvecs[:, perm]; for k in range(len(eigvals)):; vecs_new[:, k] = vecs_new[:, k] / la.norm(vecs_new[:, k]). k = 0; while k < len(eigvals):; ttol = max(tol, tol * abs(eigvals[k])); inds, = np.where(abs(eigvals - eigvals[k]) < ttol); if len(inds) > 1: # if at least 2 eigvals are degenerate; vecs_new[:, inds] = _degen(tol, vecs_new[:, inds], ops, i+1); k = inds[-1] + 1; return vecs_new. [docs]def simdiag(ops, evals: bool = True, *,; tol: float = 1e-14, safe_mode: bool = True):; """"""Simultaneous diagonalization of commuting Hermitian matrices. Parameters; ----------; ops : list/array; ``list`` or ``array`` of qobjs representing commuting Hermitian; operators. evals : bool [True]; Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tol : float [1e-14]; Tolerance for detecting degenerate eigenstates. safe_mode : bool [True]; Whether to check that all ops are Hermitian and commuting. If set to; ``False`` and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns; --------; eigs : tuple; Tuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. """"""; if not ops:; raise ValueError(""No input matrices.""); N = ops[0].shape[0]; num_ops = len(ops) if safe_mode else 0; for jj in range(num_ops):; A = ops[jj]; shape = A.shape; if shape[0] != shape[1]:; raise TypeError('Matricies must be square.'); if shape[0] != N:; raise TypeError('All matrices. must be the same shape'); if not A.isherm:; raise TypeError('Matricies must be Hermitian'); for kk in range(jj):; B = ops[kk]; if (A * B - B * A).norm() / (A * B).norm() > tol:; raise TypeError('Matricies must commute.'). eigvals, eigvecs = la.eigh(ops[0].full()); p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/simdiag.html:3527,Toler,Tolerance,3527,docs/4.6/modules/qutip/simdiag.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/simdiag.html,2,['Toler'],['Tolerance']
Availability,", optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for ex",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:220031,ERROR,ERROR,220031,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['ERROR'],['ERROR']
Availability,", see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:108338,Avail,Available,108338,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['Avail'],['Available']
Availability,",; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats¶; Stats – Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer¶; TimeslotComputer (subclass instance) – Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer¶; PropagatorComputer (subclass instance) – Used to compute the propagators and their gradients. fid_computer¶; FidelityComputer (subclass instance) – Used to computer the fidelity error and the fidelity error; gradient. memory_optimization¶; int – Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype¶; type – Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform bette",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:77274,error,error,77274,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,2,['error'],['error']
Availability,",; init_pulse_type=init_pulse_type,; init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats). [docs]def opt_pulse_crab(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0,; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:29331,error,error,29331,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,",; otherwise complex values are returned. dnorm(B=None)[source]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters:B : Qobj or None. If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns:d : float. Either the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:6058,toler,tolerance,6058,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['toler'],['tolerance']
Availability,",; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type,; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats). [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0,; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonia",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:41145,error,error,41145,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,",; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type,; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type,; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats). [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0,; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU',; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:40645,error,error,40645,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['error'],['error']
Availability,"- global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; Attributes. scale_factor; (float) The fidelity error calculated is of some arbitary scale. This factor can be used to scale the fidelity error such that it may represent some physical measure If None is given then it is caculated as 1/2N, where N is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients; Attributes. epsilon; (float) control amplitude offset to use when approximating the gradient wrt a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each times",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:93966,error,error,93966,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['error'],['error']
Availability,"---------------------------------; # Load user configuration if present: override defaults.; #; try:; if os.name == ""nt"":; qutip_rc_file = os.path.join(; os.getenv('APPDATA'), 'qutip', ""qutiprc""; ); else:; qutip_rc_file = os.path.join(; # This should possibly be changed to ~/.config/qutiprc,; # to follow XDG specs. Also, OS X uses a different naming; # convention as well.; os.environ['HOME'], "".qutiprc""; ); qutip.settings.load_rc_file(qutip_rc_file). except Exception as e:; try:; qutip.settings._logger.warning(""Error loading RC file."", exc_info=1); except:; pass. # -----------------------------------------------------------------------------; # cpu/process configuration; #; import multiprocessing. # Check if environ flag for qutip processes is set; if 'QUTIP_NUM_PROCESSES' in os.environ:; qutip.settings.num_cpus = int(os.environ['QUTIP_NUM_PROCESSES']); else:; os.environ['QUTIP_NUM_PROCESSES'] = str(qutip.settings.num_cpus). if qutip.settings.num_cpus == 0:; # if num_cpu is 0 set it to the available number of cores; from qutip.hardware_info import hardware_info; info = hardware_info(); if 'cpus' in info:; qutip.settings.num_cpus = info['cpus']; else:; qutip.settings.num_cpus = multiprocessing.cpu_count(). # -----------------------------------------------------------------------------; # Load configuration from environment variables: override defaults and; # configuration file.; #. # check for fortran mcsolver files; try:; from qutip.fortran import mcsolve_f90; except:; qutip.settings.fortran = False; else:; qutip.settings.fortran = True. # check for scikits.umfpack; try:; import scikits.umfpack as umfpack; except:; qutip.settings.umfpack = False; else:; qutip.settings.umfpack = True; del umfpack; # -----------------------------------------------------------------------------; # Check that import modules are compatible with requested configuration; #. # Check for Matplotlib; try:; import matplotlib; except:; warnings.warn(""matplotlib not found: Graphics will not work",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:7256,avail,available,7256,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['avail'],['available']
Availability,"----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. .. note:: Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_1t(H, state0, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). [docs]def correlation_4op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op, c_op, d_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t+\\tau)D(t)\\right>`; along two time axes using the quantum regression theorem and",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/correlation.html:24664,error,errors,24664,docs/4.5/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/correlation.html,1,['error'],['errors']
Availability,"----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2.; ; .. note:: Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_1t(H, state0, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). [docs]def correlation_4op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op, c_op, d_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t+\\tau)D(t)\\right>`; along two time axes using the quantum regression theorem ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:24289,error,errors,24289,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['error'],['errors']
Availability,"-----; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:5478,error,error,5478,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['error'],['error']
Availability,"----. H : :class:`qutip.Qobj`; System Hamiltonian. state0 : :class:`qutip.Qobj`; Initial state vector (ket) or density matrix. times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; List of deterministic collapse operators. sc_ops : list of :class:`qutip.Qobj`; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. m_ops : list of :class:`qutip.Qobj`; List of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict / list; List of dictionary of additional problem-specific parameters.; Implicit methods can adjust tolerance via args = {'tol':value}. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in `times`. d1 : function; Function for calculating the operator-valued coefficient to the; deterministic increment dt. d2 : function; Function for calculating the operator-valued coefficient to the; stochastic increment(s) dW_n, where n is in [0, d2_len[. d2_len : int (default 1); The number of stochastic increments in the process. dW_factors : array; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:5193,toler,tolerance,5193,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,4,['toler'],['tolerance']
Availability,"----; N : int; Dimension of the state vector to be returned. dims : list of ints, or None; Left-dimensions of the resultant quantum object.; If None, [N] is used. Returns; -------; psi : Qobj; A random state vector drawn from the Haar measure.; """"""; if dims:; _check_ket_dims(dims, N); else:; dims = [[N],[1]]; psi = rand_unitary_haar(N, seed=seed) * basis(N, 0); psi.dims = dims; return psi. [docs]def rand_dm(N, density=0.75, pure=False, dims=None, seed=None):; """"""Creates a random NxN density matrix. Parameters; ----------; N : int, ndarray, list; If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix.; density : float; Density between [0,1] of output density matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns; -------; oper : qobj; NxN density matrix quantum operator. Notes; -----; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that :math:`Tr(\\rho)=1`. """"""; if isinstance(N,(np.ndarray,list)):; if np.abs(np.sum(N)-1.0) > 1e-15:; raise ValueError('Eigenvalues of a density matrix must sum to one.'); H = sp.diags(N,0, dtype=complex, format='csr'); N = len(N); if dims:; _check_dims(dims, N, N); nvals = N**2*density; H = rand_jacobi_rotation(H, seed=seed); while H.nnz < 0.95*nvals:; H = rand_jacobi_rotation(H); H.sort_indices(); elif isinstance(N, (int, np.int32, np.int64)):; if dims:; _check_dims(dims, N, N); if pure:; dm_density = sqrt(density); psi = rand_ket(N, dm_density); H = psi * psi.dag(); H.data.sort_indices(); else:; non_zero = 0; tries = 0; while non_zero == 0 and tries < 10:; H = rand_herm(N, density, seed=seed); H = H.dag() * H; non_zero = H.tr(); tries += 1; if tries >= 10:; raise ValueError(; ""Requested density is too low to generate density matrix.""); H = H / H.tr(); H.data.sort_indices(); else:; raise TypeError('Input N must be an integer or array_like.'); if d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/random_objects.html:10472,error,error,10472,docs/4.4/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/random_objects.html,1,['error'],['error']
Availability,"----; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. op : :class:`.Qobj`; The measurement operator. targets : list of ints, optional; Specifies a list of target ""qubit"" indices on which to apply the; measurement using :func:`qutip.qip.operations.gates.expand_operator`; to expand op into full dimension. Returns; -------; measured_value : float; The result of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/measurement.html:7936,down,down,7936,docs/4.7/modules/qutip/measurement.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/measurement.html,2,['down'],['down']
Availability,"-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-overview.html:2404,avail,available,2404,docs/3.0.1/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-overview.html,1,['avail'],['available']
Availability,"-dependent (TD) function stuff; config.tdfunc = None # Placeholder for TD RHS function.; config.colspmv = None # Placeholder for TD col-spmv function.; config.colexpect = None # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code). [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html:3670,error,error,3670,docs/4.2/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/rhs_generate.html,4,['error'],['error']
Availability,"-env python qutip. This will automatically install all the necessary packages, and none of the optional packages.; You activate the new environment by running; conda activate qutip-env. You can also install any more optional packages you want with conda install, for example matplotlib, ipython or jupyter. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages, and the latest source code is available in our GitHub repository.; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the GitHub repository.; You can install from source by using the Python-recommended PEP 517 procedure, or if you want more control or to have a development version, you can use the low-level build procedure with setuptools. PEP 517 Source Builds¶; The easiest way to build QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:5340,avail,available,5340,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['avail'],['available']
Availability,". . Basic use of Processor — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Gallery »; Basic use of Processor. Note; Click here to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 640x480 with 1 Axes>, <matplotlib.axes._subplots.AxesSubplot object at 0x1a15c5cef0>). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 3.107 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/gallery/qutip_examples/qip/plot_qip_intro_processor.html:400,down,download,400,docs/4.5/gallery/qutip_examples/qip/plot_qip_intro_processor.html,https://qutip.org,https://qutip.org/docs/4.5/gallery/qutip_examples/qip/plot_qip_intro_processor.html,1,['down'],['download']
Availability,". . Control Amplitude Noise — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Gallery »; Control Amplitude Noise. Note; Click here to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x1a15c5a0b8>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2.step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.131 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/gallery/qutip_examples/qip/plot_qip_amplitude_noise.html:402,down,download,402,docs/4.5/gallery/qutip_examples/qip/plot_qip_amplitude_noise.html,https://qutip.org,https://qutip.org/docs/4.5/gallery/qutip_examples/qip/plot_qip_amplitude_noise.html,1,['down'],['download']
Availability,". . Frontmatter — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:Alexander Pitchford. Author:Chris Grenade. Author:Arne Grimsmo. Author:P.D. Nation. Author:J.R. Johansson. version:4.0. status:Released (XX YY, 2017). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/frontmatter.html:498,avail,available,498,docs/4.0.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html,1,['avail'],['available']
Availability,". . Frontmatter — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Author:Alexander Pitchford. Author:Arne Grimsmo. Author:J.R. Johansson. Author:Chris Grenade. version:4.1. status:Released (March 10, 2017). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/frontmatter.html:498,avail,available,498,docs/4.1/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.1/frontmatter.html,1,['avail'],['available']
Availability,". . Frontmatter — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Author:Alexander Pitchford. Author:Arne Grimsmo. Author:J.R. Johansson. Author:Chris Grenade. version:4.2. status:Released (July 28, 2017). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. Earlier development of QuTiP was partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of int",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/frontmatter.html:498,avail,available,498,docs/4.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html,1,['avail'],['available']
Availability,". . Frontmatter — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Author:Alexander Pitchford. Author:Arne Grimsmo. Author:J.R. Johansson. Author:Chris Grenade. version:4.3. status:Released (July 18, 2018). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/frontmatter.html:498,avail,available,498,docs/4.3/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.3/frontmatter.html,1,['avail'],['available']
Availability,". . Frontmatter — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; J.R. Johansson. Author; Chris Grenade. Author; P.D. Nation. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. version; 4.4. status; Released (July 18, 2018). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/frontmatter.html:494,avail,available,494,docs/4.4/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html,1,['avail'],['available']
Availability,". . Frontmatter — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. version; 4.5. status; Released (January 30, 2020). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/frontmatter.html:507,avail,available,507,docs/4.5/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.5/frontmatter.html,1,['avail'],['available']
Availability,". . Overview: module code — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.random_objects; qutip.rhs_generate; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/index.html:292,avail,available,292,docs/4.0.2/modules/index.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/index.html,1,['avail'],['available']
Availability,". . Overview: module code — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.random_objects; qutip.rhs_generate; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/index.html:292,avail,available,292,docs/4.1/modules/index.html,https://qutip.org,https://qutip.org/docs/4.1/modules/index.html,1,['avail'],['available']
Availability,". . Overview: module code — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.random_objects; qutip.rhs_generate; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/index.html:292,avail,available,292,docs/4.2/modules/index.html,https://qutip.org,https://qutip.org/docs/4.2/modules/index.html,1,['avail'],['available']
Availability,". . Overview: module code — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/index.html:292,avail,available,292,docs/4.3/modules/index.html,https://qutip.org,https://qutip.org/docs/4.3/modules/index.html,1,['avail'],['available']
Availability,". . Overview: module code — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models.circuitprocessor; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/index.html:288,avail,available,288,docs/4.4/modules/index.html,https://qutip.org,https://qutip.org/docs/4.4/modules/index.html,1,['avail'],['available']
Availability,". . Overview: module code — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.lattice; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/index.html:301,avail,available,301,docs/4.5/modules/index.html,https://qutip.org,https://qutip.org/docs/4.5/modules/index.html,1,['avail'],['available']
Availability,". . T2 Relaxation — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Gallery »; T2 Relaxation. Note; Click here to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = True; processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(). Total running time of the script: ( 0 minutes 0.119 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/gallery/qutip_examples/qip/plot_qip_relaxation.html:382,down,download,382,docs/4.5/gallery/qutip_examples/qip/plot_qip_relaxation.html,https://qutip.org,https://qutip.org/docs/4.5/gallery/qutip_examples/qip/plot_qip_relaxation.html,1,['down'],['download']
Availability,". 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 1.187 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html:1630,Down,Download,1630,docs/4.6/gallery/build/qip/plot_qip_intro_processor.html,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html,2,['Down'],['Download']
Availability,". Basic use of Processor — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 1.187 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on F",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html:421,down,download,421,docs/4.6/gallery/build/qip/plot_qip_intro_processor.html,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_intro_processor.html,2,['down'],['download']
Availability,". Basic use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Doc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:446,down,download,446,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,2,['down'],['download']
Availability,". Control Amplitude Noise — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f24ea6622b0>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.094 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html:423,down,download,423,docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html,2,['down'],['download']
Availability,". Control Amplitude Noise — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Bui",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:448,down,download,448,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,2,['down'],['download']
Availability,". Copyright and Licensing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing; License Terms for Documentation Text; License Terms for Source Code of QuTiP and Code Samples. QuTiP: Quantum Toolbox in Python. »; Copyright and Licensing. Copyright and Licensing¶; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; Unless specifically indicated otherwise, all code samples, the source code of QuTiP, and its reproductions in this documentation, are licensed under the terms of the 3-clause BSD license, reproduced below. License Terms for Documentation Text¶; The canonical form of this license is available at https://creativecommons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived fro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:829,avail,available,829,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['avail'],['available']
Availability,". Frontmatter — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.6.3. copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement perfo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:565,avail,available,565,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,1,['avail'],['available']
Availability,". Gallery — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/gallery/build/index.html:560,Down,Download,560,docs/4.6/gallery/build/index.html,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/index.html,2,['Down'],['Download']
Availability,". Gallery — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/gallery/build/index.html:585,Down,Download,585,docs/4.7/gallery/build/index.html,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/index.html,2,['Down'],['Download']
Availability,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas.html:425,Error,Error,425,docs/4.6/development/ideas.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html,2,['Error'],['Error']
Availability,". Ideas for future QuTiP development — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; Ideas for significant new features are listed here. For the general roadmap,; see QuTiP Development Roadmap. QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Google Summer of Code¶; Many possible extensions and improvements to QuTiP have been documented as; part of Google Summer of Code:. GSoC 2021; GSoC 2022. Completed Projects¶; These projects have been completed:. TensorFlow Data Backend. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas.html:400,Error,Error,400,docs/4.7/development/ideas.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas.html,2,['Error'],['Error']
Availability,". It can be used to set tlist if; all pulses are controlled by the same time sequence. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See qutip.qip.Pulse for detailed information`. set_up_ops(self, N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(self, sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. t2: list of float, optionalCharacterize the decoherence of dephasing for; each qubit. add_control(self, qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a new; qutip.qip.Pulse; object for the device that is turned off; (tlist = None, coeff = None). To activate the pulse, one; can set i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:121700,avail,available,121700,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['avail'],['available']
Availability,". News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP is open-source software for simulating the dynamics of open quantum systems. The QuTiP library depends on the excellent Numpy, Scipy, and Cython numerical packages. In addition, graphical output is provided by Matplotlib. QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of Hamiltonians, including those with arbitrary time-dependence, commonly found in a wide range of physics applications such as quantum optics, trapped ions, superconducting circuits, and quantum nanomechanical resonators. QuTiP is freely available for use and/or modification on all major platforms such as Linux, Mac OSX, and Windows*. Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics and dynamics in the classroom. *QuTiP is developed on Unix platforms only, and some features may not be available under Windows. From the classroom to the corporate office, QuTiP is used around the world to advance research in quantum optics, quantum information, quantum open systems, optomechanics, and many related fields. QuTiP is in use at nearly every single research university around the globe, government-funded research labs, and is relied upon by every major corporation focused on developing a quantum computer. QuTiP is already being used at a variety of institutions around the globe, and has been downloaded more than a million times since its initial release. Need; help in simulating a tricky problem? Our large community of users are gracious enough to take a moment of their time and help in tackling even the most esoteric of issues. Distribution of the 39,420 Unique Visitors in 2020. Supporting Organizations; Developers from Nori's lab and Blais' lab have been actively contributing QuTiP. QuTiP is currently supported by these organizations:. QuTiP is pro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index.html:1121,avail,available,1121,index.html,https://qutip.org,https://qutip.org/index.html,1,['avail'],['available']
Availability,". Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The qutip.operators.sigmap operator acting on the spin state returns the zero vector. Why is this? To see what happened, let us use the qutip.operators.sigmaz operator:; print(sigmaz()). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. spin2 = basis(2, 1). print(spin2). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. print(sigmaz() * spin2). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) sta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:13653,down,downarrow,13653,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,4,['down'],['downarrow']
Availability,. Overview: module code — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.heom; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyr,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/index.html:321,avail,available,321,docs/4.6/modules/index.html,https://qutip.org,https://qutip.org/docs/4.6/modules/index.html,2,['avail'],['available']
Availability,. Overview: module code — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qut,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/index.html:346,avail,available,346,docs/4.7/modules/index.html,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html,2,['avail'],['available']
Availability,". Parameters. dimslistDimensions specification for a Qobj. Returns. permlistA list such that data[flatten(dims)[idx]] gives the; index of the tensor data corresponding to the idx``th; dimension of ``dims. dims_to_tensor_shape(dims)[source]¶; Given the dims of a Qobj instance, returns the shape of the; corresponding tensor. This helps, for instance, resolve the; column-stacking convention for superoperators. Parameters. dimslistDimensions specification for a Qobj. Returns. tensor_shapetupleNumPy shape of the corresponding tensor. enumerate_flat(l)[source]¶; Labels the indices at which scalars occur in a flattened list.; Given a list containing a mix of scalars and lists,; returns a list of the same structure, where each scalar; has been replaced by an index into the flattened list.; Examples; >>> print(enumerate_flat([[[10], [20, 30]], 40])) ; [[[0], [1, 2]], 3]. flatten(l)[source]¶; Flattens a list of lists to the first level.; Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list.; Examples; >>> flatten([[[0], 1], 2]) ; [0, 1, 2]. is_scalar(dims)[source]¶; Returns True if a dims specification is effectively; a scalar (has dimension 1). unflatten(l, idxs)[source]¶; Unflattens a list by a given structure.; Given a list of scalars and a deep list of indices; as produced by flatten, returns an “unflattened”; form of the list. This perfectly inverts flatten.; Examples; >>> l = [[[10, 20, 30], [40, 50, 60]], [[70, 80, 90], [100, 110, 120]]] ; >>> idxs = enumerate_flat(l) ; >>> unflatten(flatten(l), idxs) == l ; True. Functions acting on states and operators¶. Expectation Values¶. expect(oper, state)[source]¶; Calculates the expectation value for operator(s) and state(s). Parameters. operqobj/array-likeA single or a list or operators for expectation value. stateqobj/array-likeA single or a list of quantum states or density matrices. Returns. exptfloat/complex/array-likeExpectation value. real if oper is Hermi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:54809,down,down,54809,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['down'],['down']
Availability,". Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (12.04 and later) is to use the QuTiP PPA; sudo add-apt-",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:3681,down,download,3681,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['down'],['download']
Availability,". Raises; ------; TypeError; Can only calculate overlap between a bra and ket quantum objects. """""". if isinstance(state, Qobj):. if self.isbra:; if state.isket:; return (self.data * state.data)[0, 0]; elif state.isbra:; return (self.data * state.data.H)[0, 0]. elif self.isket:; if state.isbra:; return (self.data.H * state.data.H)[0, 0]; elif state.isket:; return (self.data.H * state.data)[0, 0]. raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Para",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:37640,toler,tolerance,37640,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,2,['toler'],['tolerance']
Availability,". T2 Relaxation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.147 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_relaxation.html:403,down,download,403,docs/4.6/gallery/build/qip/plot_qip_relaxation.html,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_relaxation.html,2,['down'],['download']
Availability,". T2 Relaxation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:428,down,download,428,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html,2,['down'],['download']
Availability,". log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils` in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~qutip.control.optimresult.OptimResult`,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc.; """""". # parameters are checked in create pulse optimiser. # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The 'accuracy_factor' parameter is dep",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:26197,error,error,26197,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,". operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(self, bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(self, other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|ot",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:12096,toler,tolerance,12096,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['toler'],['tolerance']
Availability,". property dumping¶. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]¶; Check the elapsed wall time",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:78992,error,error,78992,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability,". qutip.control.fidcomp — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.fidcomp. Source code for qutip.control.fidcomp; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling wi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html:626,error,error,626,docs/4.7/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/fidcomp.html,4,['error'],['error']
Availability,". qutip.control.optimizer — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the H",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html:953,error,error,953,docs/4.7/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html,2,['error'],['error']
Availability,". qutip.control.pulsegen — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulsegen. Source code for qutip.control.pulsegen; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. """""". if pulse_type",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulsegen.html:982,error,errors,982,docs/4.7/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulsegen.html,4,['error'],['errors']
Availability,". qutip.control.pulseoptim — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulseoptim. Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:782,error,error,782,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,". qutip.control.stats — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.stats. Source code for qutip.control.stats; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/stats.html:634,redundant,redundant,634,docs/4.7/modules/qutip/control/stats.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/stats.html,2,['redundant'],['redundant']
Availability,". qutip.dimensions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.dimensions. Source code for qutip.dimensions; """"""; Internal use module for manipulating dims specifications.; """""". __all__ = [] # Everything should be explicitly imported, not made available; # by default. import numpy as np; from operator import getitem; from functools import partial. [docs]def is_scalar(dims):; """"""; Returns True if a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and li",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/dimensions.html:490,avail,available,490,docs/4.7/modules/qutip/dimensions.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/dimensions.html,2,['avail'],['available']
Availability,". qutip.partial_transpose — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.partial_transpose. Source code for qutip.partial_transpose; __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.da",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:610,mask,mask,610,docs/4.7/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html,8,['mask'],['mask']
Availability,". qutip.qip.device.modelprocessor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.modelprocessor. Source code for qutip.qip.device.modelprocessor; from collections.abc import Iterable; import numbers. import numpy as np. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.operations.gates import globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor. __all__ = ['ModelProcessor']. [docs]class ModelProcessor(Processor):; """"""; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.Processor`). Parameters; ----------; N: int; The number of component systems. correct_global_phase: boolean, optional; If true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. Attributes; ----------; params: dict; A Python dictionary contains the name and the value of the parameters; in the physical realization, such as laser frequency, detuning etc. correct_global_phase: float; Save the global phase, the analytical solution; will track th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/modelprocessor.html:928,avail,available,928,docs/4.7/modules/qutip/qip/device/modelprocessor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/modelprocessor.html,2,['avail'],['available']
Availability,". qutip.qip.device.optpulseprocessor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.optpulseprocessor. Source code for qutip.qip.device.optpulseprocessor; from collections.abc import Iterable; import warnings; import numbers. import numpy as np. from qutip.qobj import Qobj; import qutip.control.pulseoptim as cpo; from qutip.operators import identity; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.operations.gates import gate_sequence_product. __all__ = ['OptPulseProcessor']. [docs]class OptPulseProcessor(Processor):; """"""; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; `qutip.control.optimize_pulse_unitary` function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using :func:`qutip.mesolve`.; (For attributes documentation, please; refer to the parent class :class:`.Processor`). Parameters; ----------; N: int; The number of component systems. drift: `:class:`qutip.Qobj`; The drift Hamiltonian. The size must match the whole quantum system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``; """"""; def __init__(self, N, drift=None, t1=None, t2=None, dims=None):; super(OptPulseProcessor, self).__init__(; N, t1=t1, t2=t2, dims=dims); if drift is not None:;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/optpulseprocessor.html:953,avail,available,953,docs/4.7/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/optpulseprocessor.html,2,['avail'],['available']
Availability,". qutip.qip.device.spinchain — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.spinchain. Source code for qutip.qip.device.spinchain; from copy import deepcopy. import numpy as np. from qutip.operators import sigmax, sigmay, sigmaz; from qutip.tensor import tensor; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.modelprocessor import ModelProcessor; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.spinchaincompiler import SpinChainCompiler. __all__ = ['SpinChain', 'LinearSpinChain', 'CircularSpinChain']. [docs]class SpinChain(ModelProcessor):; """"""; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses :class:`qutip.qip.device.LinearSpinChain` and; :class:`qutip.qip.device.CircularSpinChain`.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/spinchain.html:922,avail,available,922,docs/4.7/modules/qutip/qip/device/spinchain.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/spinchain.html,2,['avail'],['available']
Availability,". time left: 00:00:00:13; 40.0%. Run time: 7.31s. Est. time left: 00:00:00:10; 50.0%. Run time: 8.95s. Est. time left: 00:00:00:08; 60.0%. Run time: 10.76s. Est. time left: 00:00:00:07; 70.0%. Run time: 12.59s. Est. time left: 00:00:00:05; 80.0%. Run time: 14.30s. Est. time left: 00:00:00:03; 90.0%. Run time: 15.92s. Est. time left: 00:00:00:01; 100.0%. Run time: 17.62s. Est. time left: 00:00:00:00; Total run time: 17.63s. we can extract the relevant expectation values using:; In [17]: expt1 = data.expect[0]. In [18]: expt10 = data.expect[1]. In [19]: expt100 = data.expect[2]. In [20]: expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [21]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [22]: times = np.linspace(0.0, 10.0, 200). In [23]: psi0 = tensor(fock(2, 0), f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html:16188,down,down,16188,docs/4.4/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-monte.html,1,['down'],['down']
Availability,".0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.0.1 (Aug 5, 2014):¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occured when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsing; the version number of the Cython package. Version 3.0.0 (July 17, 2014):¶. New Features¶. New module qutip.stochastic with stochastic master equation and stochastic; Schrödinger equation solvers.; Expanded steady state solvers. The function steady has been deprecated in; favor of steadystate. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state.; New module qutip.qip with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures.; New module qutip.distributions with unified API for working with; distribution functions.; New format for defining time-dependent Hamiltonians and collapse operators,; using a pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/changelog.html:2596,failure,failure,2596,docs/3.0.1/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html,1,['failure'],['failure']
Availability,".0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are describ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-settings.html:2564,toler,tolerance,2564,docs/3.1.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html,1,['toler'],['tolerance']
Availability,".0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are describ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-settings.html:2462,toler,tolerance,2462,docs/3.0.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html,2,['toler'],['tolerance']
Availability,".1.0 or later then, add the conda-forge channel with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Github repository. http://github.com/qutip. In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type envir",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/installation.html:4785,down,download,4785,docs/4.4/installation.html,https://qutip.org,https://qutip.org/docs/4.4/installation.html,2,['down'],['download']
Availability,".1.0 or later then, add the conda-forge channel with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type envir",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:4689,down,download,4689,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,3,['down'],['download']
Availability,".7’ compiler will not work with QuTiP. You will have to use the g++ compiler in mingw32. If you need to create a Python 2.7 conda environment see building-conda-environment, including adding-conda-forge; Then run:; conda install mingwpy. To specify the use of the mingw compiler you will need to create the following file:; <path to my Python env>/Lib/distutils/distutils.cfg. with the following contents:; [build]; compiler=mingw32; [build_ext]; compiler=mingw32. <path to my Python env> will be something like C:\Ananconda2\ or C:\Ananconda2\envs\qutip-env\ depending on where you installed Anaconda or Miniconda, and whether you created a specific environment.; You can then install QuTiP using either the install-via_pip or install-get-it method. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the pytest testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that you have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; In [1]: from qutip import *. In [2]: about(). Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/installation.html:8613,error,errors,8613,docs/4.5/installation.html,https://qutip.org,https://qutip.org/docs/4.5/installation.html,1,['error'],['errors']
Availability,".; rhs_with_state : bool {False,True}; Whether or not to include the state in the Hamiltonian function; callback signature.; rhs_filename : str; Name for compiled Cython file.; seeds : ndarray; Array containing random number seeds for mcsolver.; store_final_state : bool {False, True}; Whether or not to store the final state of the evolution in the; result class.; store_states : bool {False, True}; Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect.; use_openmp : bool {True, False}; Use OPENMP for sparse matrix vector multiplication. Default; None means auto check. """""". def __init__(self, atol=1e-8, rtol=1e-6, method='adams', order=12,; nsteps=1000, first_step=0, max_step=0, min_step=0,; average_expect=True, average_states=False, tidy=True,; num_cpus=0, norm_tol=1e-3, norm_steps=5, rhs_reuse=False,; rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False,; store_final_state=False, store_states=False, seeds=None,; steady_state_average=False, normalize_output=True,; use_openmp=None, openmp_threads=None):; # Absolute tolerance (default = 1e-8); self.atol = atol; # Relative tolerance (default = 1e-6); self.rtol = rtol; # Integration method (default = 'adams', for stiff 'bdf'); self.method = method; # Max. number of internal steps/call; self.nsteps = nsteps; # Size of initial step (0 = determined by solver); self.first_step = first_step; # Minimal step size (0 = determined by solver); self.min_step = min_step; # Max step size (0 = determined by solver); self.max_step = max_step; # Maximum order used by integrator (<=12 for 'adams', <=5 for 'bdf'); self.order = order; # Average expectation values over trajectories (default = True); self.average_states = average_states; # average expectation values; self.average_expect = average_expect; # Number of trajectories (default = 500); self.ntraj = nt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:5316,toler,tolerance,5316,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,3,['toler'],['tolerance']
Availability,".]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; if isinstance(dim, int):; dim = [dim] * len(seq); return tensor([basis(dim[i], _character_to_qudit(x)); for i, x in enumerate(seq)]). [docs]def bra(seq, dim=2):; """"""; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:. - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization). Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; bra : qobj. Examples; --------; >>> bra(""10"") # doctest: +SKIP; Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue"") # doctest: +SKIP; Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3) # doctest: +SKIP; Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]) # doctest: +SKIP; Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]; """"""; return ket(seq, dim=dim).dag(). #; # quantum state number helper functions; #; [docs]def state_number_enumerate(dim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/states.html:19167,down,down,19167,docs/4.6/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html,4,['down'],['down']
Availability,".ctrls[2*self.N: 3*self.N-1]. @property; def sxsy_u(self):; return self.coeffs[2*self.N: 3*self.N-1]. [docs] def load_circuit(; self, qc, schedule_mode=""ASAP"", compiler=None):; return super(LinearSpinChain, self).load_circuit(; qc, ""linear"", schedule_mode=schedule_mode, compiler=compiler). [docs] def get_operators_labels(self):; """"""; Get the labels for each Hamiltonian.; It is used in the method``plot_pulses``.; It is a 2-d nested list, in the plot,; a different color will be used for each sublist.; """"""; return ([[r""$\sigma_x^%d$"" % n for n in range(self.N)],; [r""$\sigma_z^%d$"" % n for n in range(self.N)],; [r""$\sigma_x^%d\sigma_x^{%d} + \sigma_y^%d\sigma_y^{%d}$""; % (n, n + 1, n, n + 1) for n in range(self.N - 1)],; ]). [docs] def adjacent_gates(self, qc):; return super(LinearSpinChain, self).adjacent_gates(qc, ""linear""). [docs]class CircularSpinChain(SpinChain):; """"""; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit.; """"""; def __init__(self, N, correct_global_phase=True,; sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None):; if N <= 1:; raise ValueError(; ""Circuit spin chain must have at least 2 qubits. ""; ""The number of qubits is increased to 2.""); super(Circ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:16221,avail,available,16221,docs/4.6/modules/qutip/qip/device/spinchain.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html,4,['avail'],['available']
Availability,".drift_dyn_gen, np.ndarray):; raise TypeError(""Cannot get drift dimension, ""; ""as drift not set (correctly).""); return self.drift_dyn_gen.shape[0]. [docs] def get_num_ctrls(self):; """"""; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently; """"""; self.num_ctrls = len(self.ctrl_dyn_gen); return self.num_ctrls. [docs] def get_owd_evo_target(self):; """"""; Get the inverse of the target.; Used for calculating the 'backward' evolution; """"""; return la.inv(self.target). [docs] def combine_dyn_gen(self, k):; """"""; Computes the dynamics generator for a given timeslot; The is the combined Hamiltion for unitary systems; """"""; dg = np.asarray(self.drift_dyn_gen); for j in range(self.get_num_ctrls()):; dg = dg + self.ctrl_amps[k, j]*np.asarray(self.ctrl_dyn_gen[j]); return dg. [docs] def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:19945,error,errors,19945,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['error'],['errors']
Availability,".e_ops_qoevo[ii](t, state). def finish(self):; if self.isfunc:; result = self.raw_out; else:; result = []; for ii in range(self.e_num):; if self.e_ops_isherm[ii]:; result.append(np.real(self.raw_out[ii, :])); else:; result.append(self.raw_out[ii, :]); if self.e_ops_dict:; result = {e: result[n]; for n, e in enumerate(self.e_ops_dict.keys())}; return result. def __eq__(self, other):; if isinstance(other, ExpectOps):; other = other.raw_e_ops; return self.raw_e_ops == other. def __ne__(self, other):; return not (self == other). def __bool__(self):; return bool(self.e_num). [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/solver.html:3971,toler,tolerance,3971,docs/4.7/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/solver.html,2,['toler'],['tolerance']
Availability,".first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you inp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:3461,Toler,Tolerance,3461,docs/4.6/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html,2,['Toler'],['Tolerance']
Availability,".isherm else results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]@_deprecate(""direct eigenstate and -value calculation""); def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. .. deprecated:: 4.6.0; :obj:`~ode2es` will be removed in QuTiP 5. Please use; :obj:`Qobj.eigenstates` to get the eigenstates and -values, and use; :obj:`~QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 =",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/essolve.html:5842,error,error,5842,docs/4.6/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/essolve.html,2,['error'],['error']
Availability,".num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:24069,error,errors,24069,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['errors']
Availability,".scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). def _apply_bounds_and_offset(self, pulse):; """"""; Ensure that the randomly generated pulse fits within the bounds",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:8515,error,errors,8515,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,5,['error'],['errors']
Availability,".t1) != N or len(self.t2) != N:; raise ValueError(; ""Length of t1 or t2 does not match N, ""; ""len(t1)={}, len(t2)={}"".format(; len(self.t1), len(self.t2))); lindblad_noise = Pulse(None, None). if self.targets is None:; targets = range(N); else:; targets = self.targets; for qu_ind in targets:; t1 = self.t1[qu_ind]; t2 = self.t2[qu_ind]; if t1 is not None:; op = 1/np.sqrt(t1) * destroy(2); lindblad_noise.add_lindblad_noise(op, qu_ind, coeff=True); if t2 is not None:; # Keep the total dephasing ~ exp(-t/t2); if t1 is not None:; if 2*t1 < t2:; raise ValueError(; ""t1={}, t2={} does not fulfill ""; ""2*t1>t2"".format(t1, t2)); T2_eff = 1./(1./t2-1./2./t1); else:; T2_eff = t2; op = 1/np.sqrt(2*T2_eff) * sigmaz(); lindblad_noise.add_lindblad_noise(op, qu_ind, coeff=True); return lindblad_noise. [docs]class ControlAmpNoise(Noise):; """"""; The noise in the amplitude of the control pulse. Parameters; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like, optional; A NumPy array specifies the time of each coefficient.; indices: list of int, optional; The indices of target pulse in the list of pulses.; Attributes; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like; A NumPy array specifies the time of each coefficient.; indices: list of int; The indices of target pulse in the list of pulses. """"""; def __init__(self, coeff, tlist=None, indices=None):; self.coeff = coeff; self.tlist = tlist; self.indices = indices. [docs] def get_noisy_dynamics(self, pulses):; """"""; Return a list of pulses containing the input pulse with additional; coherent noise. Parameters; ----------; pulses: list of :class:`qutip.qip.Pulse`; The input pulses, on which the noise object will be applied. Returns; -------; noisy_pulses: list of :class:`qutip.qip.Pulse`; The input `Pulse` object with additional coherent noise",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html:10228,avail,available,10228,docs/4.5/modules/qutip/qip/noise.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/noise.html,1,['avail'],['available']
Availability,"/array-like. A single or a list of quantum states or density matrices. Returns:expt : float/complex/array-like. Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:25660,mask,mask,25660,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['mask'],['mask']
Availability,"/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32. [build_ext]; compiler = mingw32. The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above. Obtain the QuTiP source code and installed it following the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, then head on over to the QuTiP Discussion Board and post a message detailing your particular issue. Checking Version Information using the About Function¶; QuTiP includes an “about” function for viewing information about QuTiP and the important dependencies installed on your system. To view this information:; >>> from qutip import *; >>> about(). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:10302,error,errors,10302,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['error'],['errors']
Availability,"0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat[t_idx, :] += \; 1/(4*options.ntraj[0]) * (c_tau[0] - c_tau[2] -; 1j*c_tau[1] + 1j*c_tau[3]); if t_idx == 1:; options.rhs_reuse = True. return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full();",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:36626,error,errors,36626,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['error'],['errors']
Availability,"0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]); 10.0%. Run time: 1.16s. Est. time left: 00:00:00:10; 20.0%. Run time: 2.28s. Est. time left: 00:00:00:09; 30.0%. Run time: 3.39s. Est. time left: 00:00:00:07; 40.0%. Run time: 4.48s. Est. time left: 00:00:00:06; 50.0%. Run time: 5.62s. Est. time left: 00:00:00:05; 60.0%. Run time: 6.73s. Est. time left: 00:00:00:04; 70.0%. Run time: 8.04s. Est. time left: 00:00:00:03; 80.0%. Run time: 9.34s. Est. time left: 00:00:00:02; 90.0%. Run time: 11.02s. Est. time left: 00:00:00:01; 100.0%. Run time: 12.62s. Est. time left: 00:00:00:00; Total run time: 12.70s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html:15948,avail,available,15948,docs/4.1/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html,1,['avail'],['available']
Availability,"0,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is gi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:6703,error,error,6703,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:58626,mask,masklist,58626,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['mask'],"['mask', 'masklist']"
Availability,"0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional ent",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:58861,mask,masklist,58861,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,4,['mask'],"['mask', 'masklist']"
Availability,"00:00:00:07; 60.0%. Run time: 8.85s. Est. time left: 00:00:00:05; 70.0%. Run time: 10.33s. Est. time left: 00:00:00:04; 80.0%. Run time: 11.77s. Est. time left: 00:00:00:02; 90.0%. Run time: 13.22s. Est. time left: 00:00:00:01; 100.0%. Run time: 14.66s. Est. time left: 00:00:00:00; Total run time: 14.75s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), dest",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html:16323,down,down,16323,docs/4.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-monte.html,1,['down'],['down']
Availability,"00:00:52; 60.0%. Run time: 63.03s. Est. time left: 00:00:00:42; 70.0%. Run time: 72.90s. Est. time left: 00:00:00:31; 80.0%. Run time: 83.01s. Est. time left: 00:00:00:20; 90.0%. Run time: 93.36s. Est. time left: 00:00:00:10; 100.0%. Run time: 104.57s. Est. time left: 00:00:00:00; Total run time: 104.58s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), dest",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html:16349,down,down,16349,docs/4.0.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html,1,['down'],['down']
Availability,"08160606+0.47629143j 0. +0.j ]; [ 0. +0.j 0. +0.j 0. +0.j; -0.1919832 -0.22178051j 0.28831061-0.27313483j]; [-0.07903194-0.04842048j 0. +0.j 0. +0.j; 0.42183113+0.00672673j 0.81327946-0.46667892j]; [-0.08160606-0.47629143j -0.1919832 +0.22178051j 0.42183113-0.00672673j; 0. +0.j 0.32721563-0.41352091j]; [ 0. +0.j 0.28831061+0.27313483j 0.81327946+0.46667892j; 0.32721563+0.41352091j 0.8523009 +0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); rand_ket, rand_ket_haar; \(N \times 1\). Hermitian operator (oper); rand_herm; \(N \times 1\). Density operator (oper); rand_dm, rand_dm_hs, rand_dm_ginibre; \(N \times N\). Unitary operator (oper); rand_unitary, rand_unitary_haar; \(N \times N\). CPTP channel (super); rand_super, rand_super_bcsz; \((N \times N) \times (N \times N)\). In all cases, these functions can be called with a single parameter \(N\) that dimension of the relevant Hilbert space. The optional; dims keyword argument allows for the dimensions of a random state, unitary or channel to be broken down into subsystems.; In [2]: print rand_super_bcsz(7).dims; File ""<ipython-input-2-ab0324dc4f28>"", line 1; print rand_super_bcsz(7).dims; ^; SyntaxError: invalid syntax. In [3]: print rand_super_bcsz(6, dims=[[[2, 3], [2, 3]], [[2, 3], [2, 3]]]).dims; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-random.html:2577,down,down,2577,docs/4.3/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-random.html,1,['down'],['down']
Availability,"0:00:00:11; 60.0%. Run time: 14.18s. Est. time left: 00:00:00:09; 70.0%. Run time: 16.65s. Est. time left: 00:00:00:07; 80.0%. Run time: 18.97s. Est. time left: 00:00:00:04; 90.0%. Run time: 21.36s. Est. time left: 00:00:00:02; 100.0%. Run time: 23.81s. Est. time left: 00:00:00:00; Total run time: 23.88s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), dest",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html:12645,down,down,12645,docs/3.1.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html,1,['down'],['down']
Availability,"0:00:00:14; 60.0%. Run time: 17.20s. Est. time left: 00:00:00:11; 70.0%. Run time: 20.03s. Est. time left: 00:00:00:08; 80.0%. Run time: 22.99s. Est. time left: 00:00:00:05; 90.0%. Run time: 26.27s. Est. time left: 00:00:00:02; 100.0%. Run time: 29.58s. Est. time left: 00:00:00:00; Total run time: 29.68s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), dest",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html:16189,down,down,16189,docs/4.3/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.3/guide/dynamics/dynamics-monte.html,1,['down'],['down']
Availability,"0Qobjstarting point for the evolution.; Typically the identity matrix. U_targQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:193356,error,error,193356,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['error'],['error']
Availability,"0Qobjstarting point for the evolution.; Typically the identity matrix. U_targQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:168852,error,error,168852,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['error'],['error']
Availability,"1) != N or len(self.t2) != N:; raise ValueError(; ""Length of t1 or t2 does not match N, ""; ""len(t1)={}, len(t2)={}"".format(; len(self.t1), len(self.t2))). if self.targets is None:; targets = range(N); else:; targets = self.targets; for qu_ind in targets:; t1 = self.t1[qu_ind]; t2 = self.t2[qu_ind]; if t1 is not None:; op = 1/np.sqrt(t1) * destroy(dims[qu_ind]); systematic_noise.add_lindblad_noise(op, qu_ind, coeff=True); if t2 is not None:; # Keep the total dephasing ~ exp(-t/t2); if t1 is not None:; if 2*t1 < t2:; raise ValueError(; ""t1={}, t2={} does not fulfill ""; ""2*t1>t2"".format(t1, t2)); T2_eff = 1./(1./t2-1./2./t1); else:; T2_eff = t2; op = 1/np.sqrt(2*T2_eff) * 2 * num(dims[qu_ind]); systematic_noise.add_lindblad_noise(op, qu_ind, coeff=True); return pulses, systematic_noise. [docs]class ControlAmpNoise(Noise):; """"""; The noise in the amplitude of the control pulse. Parameters; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like, optional; A NumPy array specifies the time of each coefficient.; indices: list of int, optional; The indices of target pulse in the list of pulses.; Attributes; ----------; coeff: list; A list of the coefficients for the control Hamiltonians.; For available choices, see :class:`qutip.QobjEvo`.; tlist: array_like; A NumPy array specifies the time of each coefficient.; indices: list of int; The indices of target pulse in the list of pulses. """"""; def __init__(self, coeff, tlist=None, indices=None):; self.coeff = coeff; self.tlist = tlist; self.indices = indices. [docs] def get_noisy_dynamics(; self, dims=None, pulses=None, systematic_noise=None):; if pulses is None:; pulses = []; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; for i in indices:; pulse = pulses[i]; if isinstance(self.coeff, (int, float)):; coeff = pulse.coeff * self.coeff; else:; coeff = self.coeff; if self.tlist is None:; tlist = pul",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html:8638,avail,available,8638,docs/4.6/modules/qutip/qip/noise.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html,4,['avail'],['available']
Availability,"1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspace",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-measurement.html:4479,down,down,4479,docs/4.6/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html,4,['down'],['down']
Availability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string. Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:173576,error,error,173576,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string. Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict. Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string. Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:182207,error,error,182207,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:188377,error,error,188377,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['error']
Availability,"1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_method : string; Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:197012,error,error,197012,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['error']
Availability,"1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:4034,avail,available,4034,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['avail'],['available']
Availability,"10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be gi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:6701,error,error,6701,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,8,['error'],['error']
Availability,"100, 'diag_pivot_thresh': 0.1, 'maxiter': 1000,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2',; 'restart': 20,; 'max_iter_refine': 10,; 'scaling_vectors': True,; 'weighted_matching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:5759,avail,availability,5759,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['avail'],['availability']
Availability,"11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, al",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:11760,down,down,11760,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['down'],['down']
Availability,"1]) % N]); else:; qc_t.add_gate(gate.name,; [(end + gate.targets[0]) % N,; (end + gate.targets[1]) % N]); j = j + 1. else:; qc_t.add_gate(gate.name, gate.targets, gate.controls,; gate.arg_value, gate.arg_label). return qc_t. [docs] def eliminate_auxillary_modes(self, U):; return U. [docs] def optimize_circuit(self, qc):; """"""; Take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters; ----------; qc: :class:`qutip.QubitCircuit`; Takes the quantum circuit to be implemented. Returns; -------; qc: :class:`qutip.QubitCircuit`; The circuit representation with elementary gates; that can be implemented in this model.; """"""; self.qc0 = qc; self.qc1 = self.adjacent_gates(self.qc0); self.qc2 = self.qc1.resolve_gates(; basis=[""SQRTISWAP"", ""ISWAP"", ""RX"", ""RZ""]); return self.qc2. [docs]class LinearSpinChain(SpinChain):; """"""; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit.; """"""; def __init__(self, N, correct_global_phase=True,; sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None):. super(LinearSpinChain, self).__init__(; N, correct_global_phase=correct_global_phase,; sx=sx, sz=sz, sxsy=sxsy, t1=t1, t2=t2); self.set_u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html:13383,avail,available,13383,docs/4.5/modules/qutip/qip/device/spinchain.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html,1,['avail'],['available']
Availability,"2 * (_kB / _h); return w_GHz. def _version2int(version_string):; str_list = version_string.split(; ""-dev"")[0].split(""rc"")[0].split(""a"")[0].split(""b"")[0].split(; ""post"")[0].split('.'); return sum([int(d if len(d) > 0 else 0) * (100 ** (3 - n)); for n, d in enumerate(str_list[:3])]). def _blas_info():; config = np.__config__; if hasattr(config, 'blas_ilp64_opt_info'):; blas_info = config.blas_ilp64_opt_info; elif hasattr(config, 'blas_opt_info'):; blas_info = config.blas_opt_info; else:; blas_info = {}; _has_lib_key = 'libraries' in blas_info.keys(); blas = None; if hasattr(config,'mkl_info') or \; (_has_lib_key and any('mkl' in lib for lib in blas_info['libraries'])):; blas = 'INTEL MKL'; elif hasattr(config,'openblas_info') or \; (_has_lib_key and any('openblas' in lib for lib in blas_info['libraries'])):; blas = 'OPENBLAS'; elif 'extra_link_args' in blas_info.keys() and ('-Wl,Accelerate' in blas_info['extra_link_args']):; blas = 'Accelerate'; else:; blas = 'Generic'; return blas. def available_cpu_count():; """"""; Get the number of cpus.; It tries to only get the number available to qutip.; """"""; import os; import multiprocessing; try:; import psutil; except ImportError:; psutil = None; num_cpu = 0. if 'QUTIP_NUM_PROCESSES' in os.environ:; # We consider QUTIP_NUM_PROCESSES=0 as unset.; num_cpu = int(os.environ['QUTIP_NUM_PROCESSES']). if num_cpu == 0 and 'SLURM_CPUS_PER_TASK' in os.environ:; num_cpu = int(os.environ['SLURM_CPUS_PER_TASK']). if num_cpu == 0 and hasattr(os, 'sched_getaffinity'):; num_cpu = len(os.sched_getaffinity(0)). if (; num_cpu == 0; and psutil is not None; and hasattr(psutil.Process(), ""cpu_affinity""); ):; num_cpu = len(psutil.Process().cpu_affinity()). if num_cpu == 0:; try:; num_cpu = multiprocessing.cpu_count(); except NotImplementedError:; pass. return num_cpu or 1. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/utilities.html:7665,avail,available,7665,docs/4.7/modules/qutip/utilities.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/utilities.html,2,['avail'],['available']
Availability,"2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-settings.html:2176,toler,tolerance,2176,docs/3.1.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html,1,['toler'],['tolerance']
Availability,"4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup:; out.tidyup(); if (settings.auto_tidyup_dims; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1; for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching; # dims are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. elif self.shape[1] == 1 and other.shape[0] == 1:; out = Qobj(); out.data = self.data * other.data; out.dims = [self.dims[0], other.dims[1]]; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype == 'object':; out = np.empty(other.shape, dtype=o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:16332,mask,mask,16332,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,8,['mask'],['mask']
Availability,"473610+0.26899532j 0.00000000+0.j 0.21699323-0.14122294j; -0.12734561+0.05322338j 0.00000000+0.j ]; [ 0.00000000+0.j 0.21699323+0.14122294j 0.00000000+0.j; -0.11379132+0.23186375j 0.00000000+0.j ]; [ 0.00000000+0.j -0.12734561-0.05322338j -0.11379132-0.23186375j; 0.00000000+0.j -0.21668267-0.1563881j ]; [ 0.19439792+0.46184373j 0.00000000+0.j 0.00000000+0.j; -0.21668267+0.1563881j 0.49328238+0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); rand_ket, rand_ket_haar; \(N \times 1\). Hermitian operator (oper); rand_herm; \(N \times 1\). Density operator (oper); rand_dm, rand_dm_hs, rand_dm_ginibre; \(N \times N\). Unitary operator (oper); rand_unitary, rand_unitary_haar; \(N \times N\). CPTP channel (super); rand_super, rand_super_bcsz; \((N \times N) \times (N \times N)\). In all cases, these functions can be called with a single parameter \(N\) that dimension of the relevant Hilbert space. The optional; dims keyword argument allows for the dimensions of a random state, unitary or channel to be broken down into subsystems.; In [2]: print rand_super_bcsz(7).dims; File ""<ipython-input-2-aef77a269b21>"", line 1; print rand_super_bcsz(7).dims; ^; SyntaxError: invalid syntax. In [3]: print rand_super_bcsz(6, dims=[[[2, 3], [2, 3]], [[2, 3], [2, 3]]]).dims; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-random.html:2633,down,down,2633,docs/4.0.2/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-random.html,1,['down'],['down']
Availability,"565611j 0.00000000+0.j -0.58658376+0.47851684j; 0.00000000+0.j 0.29087032-0.04403322j]; [ 0.00000000+0.j -0.58658376-0.47851684j -1.48253672+0.j; 0.14821531-0.00900551j 0.21133530-0.4525358j ]; [-0.07695716-0.33797916j 0.00000000+0.j 0.14821531+0.00900551j; 0.00000000+0.j 0.08601466-0.31579196j]; [ 0.00000000+0.j 0.29087032+0.04403322j 0.21133530+0.4525358j; 0.08601466+0.31579196j 0.00000000+0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); rand_ket, rand_ket_haar; \(N \times 1\). Hermitian operator (oper); rand_herm; \(N \times 1\). Density operator (oper); rand_dm, rand_dm_hs, rand_dm_ginibre; \(N \times N\). Unitary operator (oper); rand_unitary, rand_unitary_haar; \(N \times N\). CPTP channel (super); rand_super, rand_super_bcsz; \((N \times N) \times (N \times N)\). In all cases, these functions can be called with a single parameter \(N\) that dimension of the relevant Hilbert space. The optional; dims keyword argument allows for the dimensions of a random state, unitary or channel to be broken down into subsystems.; In [2]: print rand_super_bcsz(7).dims; File ""<ipython-input-2-aef77a269b21>"", line 1; print rand_super_bcsz(7).dims; ^; SyntaxError: invalid syntax. In [3]: print rand_super_bcsz(6, dims=[[[2, 3], [2, 3]], [[2, 3], [2, 3]]]).dims; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-random.html:2645,down,down,2645,docs/4.2/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-random.html,1,['down'],['down']
Availability,"584-0.47165765j 0. +0.j; -0.15248215-0.48974871j 0. +0.j ]; [-0.46056584+0.47165765j 0.18241967+0.j 0. +0.j; -0.20212601+0.15804465j 0.01329707-0.42871682j]; [ 0. +0.j 0. +0.j 0. +0.j; 0. +0.j -0.0608447 +0.38781155j]; [-0.15248215+0.48974871j -0.20212601-0.15804465j 0. +0.j; 0. +0.j 0.02299724+0.33505856j]; [ 0. +0.j 0.01329707+0.42871682j -0.0608447 -0.38781155j; 0.02299724-0.33505856j 0. +0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); rand_ket, rand_ket_haar; \(N \times 1\). Hermitian operator (oper); rand_herm; \(N \times 1\). Density operator (oper); rand_dm, rand_dm_hs, rand_dm_ginibre; \(N \times N\). Unitary operator (oper); rand_unitary, rand_unitary_haar; \(N \times N\). CPTP channel (super); rand_super, rand_super_bcsz; \((N \times N) \times (N \times N)\). In all cases, these functions can be called with a single parameter \(N\) that dimension of the relevant Hilbert space. The optional; dims keyword argument allows for the dimensions of a random state, unitary or channel to be broken down into subsystems.; In [2]: print(rand_super_bcsz(7).dims); [[[7], [7]], [[7], [7]]]. In [3]: print(rand_super_bcsz(6, dims=[[[2, 3], [2, 3]], [[2, 3], [2, 3]]]).dims); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-random.html:2552,down,down,2552,docs/4.4/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-random.html,1,['down'],['down']
Availability,"59639e0>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[g^{(2)}(\tau) = \lim_{t o \infty}; \frac{\langle a^\dagger(t)a^\dagger(t+\tau); a(t+\tau)a(t)\rangle}; {\langle a^\dagger(t)a(t)\rangle^2}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Note: g2 is only defined for stationary; statistics (uses steady state rho0). Parameters:H : qutip.qobj.Qobj. system Hamiltonian. taulist : list / array. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list of qutip.qobj.Qobj. list of collapse operators. a_op : qutip.qobj.Qobj. The annihilation operator of the mode. solver : str. choice of solver (me for master-equation and; es for exponential series). options : qutip.solver.Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g2: array. The normalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:A : qobj. A Hamiltonian or Liouvillian operator. c_op_list : list. A list of collapse operators. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:88373,error,errors,88373,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['error'],['errors']
Availability,"6 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); rand_ket, rand_ket_haar; \(N \times 1\). Hermitian operator (oper); rand_herm; \(N \times 1\). Density operator (oper); rand_dm, rand_dm_hs, rand_dm_ginibre; \(N \times N\). Unitary operator (oper); rand_unitary, rand_unitary_haar; \(N \times N\). CPTP channel (super); rand_super, rand_super_bcsz; \((N \times N) \times (N \times N)\). In all cases, these functions can be called with a single parameter \(N\) that specifies the dimension of the relevant Hilbert space. The optional; dims keyword argument allows for the dimensions of a random state, unitary or channel to be broken down into subsystems.; >>> rand_super_bcsz(7).dims; [[[7], [7]], [[7], [7]]]; >>> rand_super_bcsz(6, dims=[[[2, 3], [2, 3]], [[2, 3], [2, 3]]]).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. Several of the distributions supported by QuTiP support additional parameters as well, namely density and rank. In particular,; the rand_herm and rand_dm functions return quantum objects such that a fraction of the elements are identically equal to zero.; The ratio of nonzero elements is passed as the density keyword argument. By contrast, the rand_dm_ginibre and; rand_super_bcsz take as an argument the rank of the generated object, such that passing rank=1 returns a random; pure state or unitary channel, respectively. Passing rank=None specifies that the generated object should be; full-rank for the given dimension.; For example,; >>> rand_dm(5, density=0.5); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-random.html:2694,down,down,2694,docs/4.6/guide/guide-random.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-random.html,4,['down'],['down']
Availability,"7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:3904,avail,available,3904,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,2,"['avail', 'down']","['available', 'download']"
Availability,": 00:00:00:05; 60.0%. Run time: 6.73s. Est. time left: 00:00:00:04; 70.0%. Run time: 8.04s. Est. time left: 00:00:00:03; 80.0%. Run time: 9.34s. Est. time left: 00:00:00:02; 90.0%. Run time: 11.02s. Est. time left: 00:00:00:01; 100.0%. Run time: 12.62s. Est. time left: 00:00:00:00; Total run time: 12.70s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), dest",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html:16319,down,down,16319,docs/4.1/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.1/guide/dynamics/dynamics-monte.html,1,['down'],['down']
Availability,": ``'taylor1.5-imp'`` or ``'taylor15-imp'``. explicit1.5; Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than ``taylor15`` but usable by; :func:`~general_stochastic`. See eq. (2.13) of chapter 11.2 of; [1]_. - Order strong 1.5; - Code: ``'explicit1.5'``, ``'explicit15'`` or ``'platen15'``. taylor2.0; Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]_. - Order strong 2.0; - Code: ``'taylor2.0'``, ``'taylor20'`` or ``2.0``. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; :func:`~general_stochastic` only accepts the derivative-free; solvers: ``'euler'``, ``'platen'`` and ``'explicit1.5'``. Available solvers for :obj:`~photocurrent_sesolve` and \; :obj:`~photocurrent_mesolve`; Photocurrent use ordinary differential equations between; stochastic ""jump/collapse"". euler; Euler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]_. - Order 1.0; - Code: ``'euler'``. predictor–corrector; predictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. - Order 2.0; - Code: ``'pred-corr'``. References; ----------; .. [1] Peter E. Kloeden and Exkhard Platen, *Numerical Solution of; Stochastic Differential Equations*.; .. [2] H.-P. Breuer and F. Petruccione, *The Theory of Open Quantum; Systems*.; .. [3] Pierre Rouchon and Jason F. Ralpha, *Efficient Quantum Filtering for; Quantum Feedback Control*, `arXiv:1410.5345 [quant-ph]; <https://arxiv.org/abs/1410.5345>`_, Phys. Rev. A 91, 012118,; (2015).; .. [4] Howard M. Wiseman, Gerard J. Milburn, *Quantum measurement and; control*.; """"",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:6633,Avail,Available,6633,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,2,['Avail'],['Available']
Availability,": dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]; [0.]; [0.]; [0.]]. bell_state(state='00')[source]¶; Returns the selected Bell state:. \[\begin{split}\begin{aligned}; \lvert B_{00}\rangle &=; \frac1{\sqrt2}(\lvert00\rangle+\lvert11\rangle)\\; \lvert B_{01}\rangle &=; \frac1{\sqrt2}(\lvert00\rangle-\lvert11\rangle)\\; \lvert B_{10}\rangle &=; \frac1{\sqrt2}(\lvert01\rangle+\lvert10\rangle)\\; \lvert B_{11}\rangle &=; \frac1{\sqrt2}(\lvert01\rangle-\lvert10\rangle)\\; \end{aligned}\end{split}\]. Returns. Bell_stateqobjBell state. bra(seq, dim=2)[source]¶; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:. ‘g’/’e’ (ground and excited state); ‘u’/’d’ (spin up and down); ‘H’/’V’ (horizontal and vertical polarization). Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. braqobj. Examples; >>> bra(""10"") ; Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue"") ; Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3) ; Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]) ; Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method='operator')[source]¶; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters. NintNumber of Fock states in Hilbert",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:3840,down,down,3840,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['down'],['down']
Availability,": dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]; [0.]; [0.]; [0.]]. bell_state(state='00')[source]¶; Returns the selected Bell state:. \[\begin{split}\begin{aligned}; \lvert B_{00}\rangle &=; \frac1{\sqrt2}(\lvert00\rangle+\lvert11\rangle)\\; \lvert B_{01}\rangle &=; \frac1{\sqrt2}(\lvert00\rangle-\lvert11\rangle)\\; \lvert B_{10}\rangle &=; \frac1{\sqrt2}(\lvert01\rangle+\lvert10\rangle)\\; \lvert B_{11}\rangle &=; \frac1{\sqrt2}(\lvert01\rangle-\lvert10\rangle)\\; \end{aligned}\end{split}\]. Returns. Bell_stateqobjBell state. bra(seq, dim=2)[source]¶; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:. ‘g’/’e’ (ground and excited state); ‘u’/’d’ (spin up and down); ‘H’/’V’ (horizontal and vertical polarization). Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. braqobj. Examples; >>> bra(""10"") ; Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue"") ; Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3) ; Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]) ; Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method=None)[source]¶; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters. NintNumber of Fock states in Hilbert space",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:3889,down,down,3889,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['down'],['down']
Availability,": dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The qutip.operators.sigmap operator acting on the spin state returns the zero vector. Why is this? To see what happened, let us use the qutip.operators.sigmaz operator:; In [52]: sigmaz(); Out[52]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [53]: sigmaz() * spin; Out[53]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. In [54]: spin2 = basis(2, 1). In [55]: spin2; Out[55]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. In [56]: sigmaz() * spin2; Out[56]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-states.html:13988,down,downarrow,13988,docs/4.5/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-states.html,1,['down'],['downarrow']
Availability,: x / np.sqrt(2); ,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-basics.html:12992,error,error,12992,docs/4.4/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-basics.html,1,['error'],['error']
Availability,":. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string. Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict. Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string. Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict. Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. guess_pulse_type : string. type / shape of pulse(s) used modulate the control amplitudes.; Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. Default is None. guess_pulse_params : dict. Parameters for the guess pulse generator object; The key value pairs are assumed to be attribute name v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:174406,error,error,174406,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,4,['error'],['error']
Availability,":; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", c_ops[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""collapse operator"" +; ""time-dependence, "" +; ""args must be a dictionary""); c_ops_shifted.append([c_ops[i][0], fn]); else:; c_ops_shifted.append(c_ops[i]). return H_shifted, c_ops_shifted, _args. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/correlation.html:41366,error,errors,41366,docs/4.4/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/correlation.html,1,['error'],['errors']
Availability,":; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:104140,error,error,104140,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability,":; return -0.5j * ((1j * self).expm() - (-1j * self).expm()); else:; raise TypeError('Invalid operand for matrix square root'). [docs] def inv(self, sparse=False):; """"""Matrix inverse of a quantum operator. Operator must be square. Returns; -------; oper : :class:`qutip.Qobj`; Matrix inverse of operator. Raises; ------; TypeError; Quantum object is not square.; """"""; if self.shape[0] != self.shape[1]:; raise TypeError('Invalid operand for matrix inverse'); if sparse:; inv_mat = sp.linalg.inv(sp.csc_matrix(self.data)); else:; inv_mat = np.linalg.inv(self.full()); return Qobj(inv_mat, dims=self.dims[::-1]). [docs] def unit(self, inplace=False,; norm=None, sparse=False,; tol=0, maxiter=100000):; """"""Operator or state normalized to unity. Uses norm from Qobj.norm(). Parameters; ----------; inplace : bool; Do an in-place normalization; norm : str; Requested norm for states / operators.; sparse : bool; Use sparse eigensolver for trace norm. Does not affect other norms.; tol : float; Tolerance used by sparse eigensolver.; maxiter : int; Number of maximum iterations performed by sparse eigensolver. Returns; -------; oper : :class:`qutip.Qobj`; Normalized quantum object if not in-place,; else None. """"""; if inplace:; nrm = self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter). self.data /= nrm; elif not inplace:; out = self / self.norm(norm=norm, sparse=sparse,; tol=tol, maxiter=maxiter); if settings.auto_tidyup:; return out.tidyup(); else:; return out; else:; raise Exception('inplace kwarg must be bool.'). [docs] def ptrace(self, sel, sparse=None):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace.; The order is unimportant; no transposition will be done and the; spaces will remain in the same order in the output. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identic",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:34336,Toler,Tolerance,34336,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['Toler'],['Tolerance']
Availability,":`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:9349,error,errors,9349,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['error'],['errors']
Availability,"; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:27961,error,errors,27961,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,8,['error'],['errors']
Availability,"; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; self._num_ctrls = len(self.ctrl_dyn_gen). if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:26195,error,errors,26195,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,2,['error'],['errors']
Availability,"; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rh",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html:2729,mask,mask,2729,docs/4.3/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html,5,['mask'],['mask']
Availability,"; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:2729,mask,mask,2729,docs/4.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html,4,['mask'],['mask']
Availability,"; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:3399,error,error,3399,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,3,"['Error', 'error']","['Error', 'error']"
Availability,"; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Author:Alexander Pitchford. Author:Arne Grimsmo. Author:J.R. Johansson. Author:Chris Grenade. version:4.1. status:Released (March 10, 2017). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/frontmatter.html:1259,down,download,1259,docs/4.1/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.1/frontmatter.html,1,['down'],['download']
Availability,"; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/guide-settings.html:2819,toler,tolerance,2819,docs/4.0.2/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/guide-settings.html,1,['toler'],['tolerance']
Availability,"; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.propcomp. Source code for qutip.control.propcomp; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/propcomp.html:1141,error,errors,1141,docs/4.7/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/propcomp.html,2,['error'],['errors']
Availability,"; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.147 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_relaxation.html:1678,Down,Download,1678,docs/4.6/gallery/build/qip/plot_qip_relaxation.html,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_relaxation.html,2,['Down'],['Download']
Availability,"; If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]. [docs] def refresh_drift_att",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:33048,error,error,33048,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,12,['error'],['error']
Availability,"; If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:28547,error,error,28547,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,8,['error'],['error']
Availability,"; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `tlist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state den",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:4793,error,errors,4793,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,6,['error'],['errors']
Availability,"; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment. You may wish to install Miniconda instead if you need to be economical with disk space. However, if you are not familiar with conda environments and only plan to use if for QuTiP, then you should probably work with a default Anaconda / Miniconda environment.; To create a Conda env for QuTiP called qutip-env:; conda create -n qutip-env python=3. Note the python=3 can be ommited if you want the default Python ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:2084,avail,available,2084,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,1,['avail'],['available']
Availability,"; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:3900,down,download,3900,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,1,['down'],['download']
Availability,"; Use Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:7941,Toler,Tolerance,7941,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,2,['Toler'],['Tolerance']
Availability,"; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See :obj:`~TimeslotComp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:45248,error,error,45248,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"; basis(N, 1) = ground state. Examples; >>> basis(5,2); Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]; >>> basis([2,2,2], [0,1,0]); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]; [0.]; [0.]; [0.]]. bell_state(state='00')[source]¶; Returns the Bell state:. |B00> = 1 / sqrt(2)*[|0>|0>+|1>|1>]; |B01> = 1 / sqrt(2)*[|0>|0>-|1>|1>]; |B10> = 1 / sqrt(2)*[|0>|1>+|1>|0>]; |B11> = 1 / sqrt(2)*[|0>|1>-|1>|0>]. Returns. Bell_stateqobjBell state. bra(seq, dim=2)[source]¶; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:; - ‘g’/’e’ (ground and excited state); - ‘u’/’d’ (spin up and down); - ‘H’/’V’ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. braqobj. Examples; >>> bra(""10""); Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue""); Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3); Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]); Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method='operator')[source]¶; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters. NintNumber of Fock states in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:3559,down,down,3559,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['down'],['down']
Availability,"; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:116724,error,errors,116724,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['errors']
Availability,"; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x1a2041a3c8>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:101203,error,errors,101203,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['error'],['errors']
Availability,"; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x2b22624eaac8>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, ca",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:83234,error,errors,83234,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['error'],['errors']
Availability,"; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True. # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:63094,error,errors,63094,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,5,['error'],['errors']
Availability,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:4410,mask,mask,4410,docs/4.6/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html,2,['mask'],['mask']
Availability,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Fe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/partial_transpose.html:4390,mask,mask,4390,docs/4.5/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/partial_transpose.html,1,['mask'],['mask']
Availability,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Ju",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/partial_transpose.html:4377,mask,mask,4377,docs/4.4/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/partial_transpose.html,1,['mask'],['mask']
Availability,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html:4350,mask,mask,4350,docs/4.0.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/partial_transpose.html,1,['mask'],['mask']
Availability,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:4350,mask,mask,4350,docs/4.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html,1,['mask'],['mask']
Availability,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/partial_transpose.html:4350,mask,mask,4350,docs/4.1/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/partial_transpose.html,1,['mask'],['mask']
Availability,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html:4381,mask,mask,4381,docs/4.3/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html,1,['mask'],['mask']
Availability,"; else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:2595,mask,mask,2595,docs/4.7/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html,2,['mask'],['mask']
Availability,"; for the me and es solvers.; tlist (array_like) – list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool {False, True}) – If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\).; solver (str) – choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat – An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. Return type:ndarray. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; rho0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:86795,error,errors,86795,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['errors']
Availability,"; if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_condition",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:17044,error,error,17044,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['error']
Availability,"; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:32516,error,errors,32516,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['error'],['errors']
Availability,"; only, and is set to ``True`` by default when finding a preconditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int, default 10; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, default 1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, default 1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method. If None; given then ``max(0.1*tol, 1e-15)`` is used. matol : float, default 1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' (default); and 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool, default False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, default 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/steadystate.html:8080,toler,tolerance,8080,docs/4.6/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/steadystate.html,4,['toler'],['tolerance']
Availability,"; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:31079,error,error,31079,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,8,['error'],['error']
Availability,"; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:30651,error,error,30651,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. V",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:25849,mask,mask,25849,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['mask'],['mask']
Availability,"; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; phase_option='PSU',; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------. H_d : Qobj; Drift (aka system) the underlying Hamiltonian of the system. H_c : Qobj; a list of control Hamiltonians. These are sca",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:13505,error,error,13505,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['error'],['error']
Availability,"; result.ado_states[i] by calling extract.; expect: the value of each e_ops at time t (only; available if e_ops were given). If e_ops was passed; as a dictionary, then expect will be a dictionary with; the same keys as e_ops and values giving the list of; outcomes for the corresponding key. steady_state(use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False)[source]¶; Compute the steady state of the system. Parameters. use_mklbool, default=FalseWhether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refineintSpecifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs.; For a complete description, see iparm(8) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. mkl_weighted_matchingboolMKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods.; For a complete description, see iparm(13) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. Returns. steady_stateQobjThe steady state density matrix of the system. steady_adosHierarchyADOsStateThe steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling extract. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, bnd_cut_approx=False, options=None, progress_bar=None, combine=True)[source]¶; A helper class for creating an HEOMSolver that is backwards; compatible with the HSolverDL provided in qutip.nonmarkov.heom; in QuTiP 4.6 and below.; See HEOMSolver and DrudeLorentzBath for more; descriptions of the underlying solver and bath construction.; An exact copy of the QuTiP 4.6 HSolverDL is provided in; qutip.nonmarkov.dlheom_solver for cases where the functionality of; the older solver is required. The older solver will be",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:46399,reliab,reliability,46399,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['reliab'],['reliability']
Availability,"; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Comput",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:8291,error,error,8291,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['error'],['error']
Availability,"; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Optional Installation Options¶. UMFPACK Linear Solver¶; As of SciPy 0.14+, the umfpack linear solver routines for solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:10790,avail,available,10790,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,['avail'],['available']
Availability,"; the opposite sign (i.e. ""-"" or ""+""). dim : int or None; The dimension (i.e. maximum number of excitations for this exponent).; Usually ``2`` for fermionic exponents or ``None`` (i.e. unlimited) for; bosonic exponents. Q : Qobj; The coupling operator for this excitation mode. vk : complex; The frequency of the exponent of the excitation term. ck : complex; The coefficient of the excitation term. ck2 : optional, complex; For exponents of type ""RI"" this is the coefficient of the term in the; imaginary expansion (and ``ck`` is the coefficient in the real; expansion). sigma_bar_k_offset : optional, int; For exponents of type ""+"" this gives the offset (within the list of; exponents within the bath) of the corresponding ""-"" bath exponent.; For exponents of type ""-"" it gives the offset of the corresponding; ""+"" exponent. tag : optional, str, tuple or any other object; A label for the exponent (often the name of the bath). It; defaults to None. Attributes; ----------. All of the parameters are available as attributes.; """"""; types = enum.Enum(""ExponentType"", [""R"", ""I"", ""RI"", ""+"", ""-""]). def _check_ck2(self, type, ck2):; if type == self.types[""RI""]:; if ck2 is None:; raise ValueError(""RI bath exponents require ck2""); else:; if ck2 is not None:; raise ValueError(; ""Second co-efficient (ck2) should only be specified for RI""; "" bath exponents""; ). def _check_sigma_bar_k_offset(self, type, offset):; if type in (self.types[""+""], self.types[""-""]):; if offset is None:; raise ValueError(; ""+ and - bath exponents require sigma_bar_k_offset""; ); else:; if offset is not None:; raise ValueError(; ""Offset of sigma bar (sigma_bar_k_offset) should only be""; "" specified for + and - bath exponents""; ). def __init__(; self, type, dim, Q, ck, vk, ck2=None, sigma_bar_k_offset=None,; tag=None,; ):; if not isinstance(type, self.types):; type = self.types[type]; self._check_ck2(type, ck2); self._check_sigma_bar_k_offset(type, sigma_bar_k_offset); self.type = type; self.dim = dim; self.Q = Q; self.c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:2854,avail,available,2854,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['avail'],['available']
Availability,"; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP sett",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:3624,error,errors,3624,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,10,['error'],['errors']
Availability,"= None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'taylor15-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operato",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:18238,avail,available,18238,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['avail'],['available']
Availability,"= [(c**k * vac).unit() for k in range(5)] # must normalize. In [68]: expect(N, states); Out[68]: array([ 0., 1., 2., 3., 4.]). In [69]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [70]: expect(c, cat_list); Out[70]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [71]: up = basis(2, 0). In [72]: down = basis(2, 1). In [73]: expect(sigmaz(), up); Out[73]: 1.0. In [74]: expect(sigmaz(), down); Out[74]: -1.0. as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; In [75]: spin1 = basis(2, 0). In [76]: spin2 = basis(2, 1). In [77]: two_spins = tensor(spin1, spin2). In [78]: sz1 = tensor(sigmaz(), qeye(2)). In [79]: sz2 = tensor(qeye(2), sigmaz()). In [80]: expect(sz1, two_spins); Out[80]: 1.0. In [81]: expect(sz2, two_spins); Out[81]: -1.0. Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-states.html:17488,down,down,17488,docs/3.1.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html,1,['down'],['down']
Availability,"= [(c**k * vac).unit() for k in range(5)] # must normalize. In [69]: expect(N, states); Out[69]: array([ 0., 1., 2., 3., 4.]). In [70]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [71]: expect(c, cat_list); Out[71]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [72]: up = basis(2, 0). In [73]: down = basis(2, 1). In [74]: expect(sigmaz(), up); Out[74]: 1.0. In [75]: expect(sigmaz(), down); Out[75]: -1.0. as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; In [76]: spin1 = basis(2, 0). In [77]: spin2 = basis(2, 1). In [78]: two_spins = tensor(spin1, spin2). In [79]: sz1 = tensor(sigmaz(), qeye(2)). In [80]: sz2 = tensor(qeye(2), sigmaz()). In [81]: expect(sz1, two_spins); Out[81]: 1.0. In [82]: expect(sz2, two_spins); Out[82]: -1.0. Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-states.html:17329,down,down,17329,docs/3.0.1/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html,1,['down'],['down']
Availability,"= [(c**k * vac).unit() for k in range(5)] # must normalize. In [69]: expect(N, states); Out[69]: array([ 0., 1., 2., 3., 4.]). In [70]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [71]: expect(c, cat_list); Out[71]: array([ 0.+0.j, 0.-1.j, -1.+0.j, 0.+1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [72]: up = basis(2, 0). In [73]: down = basis(2, 1). In [74]: expect(sigmaz(), up); Out[74]: 1.0. In [75]: expect(sigmaz(), down); Out[75]: -1.0. as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; In [76]: spin1 = basis(2, 0). In [77]: spin2 = basis(2, 1). In [78]: two_spins = tensor(spin1, spin2). In [79]: sz1 = tensor(sigmaz(), qeye(2)). In [80]: sz2 = tensor(qeye(2), sigmaz()). In [81]: expect(sz1, two_spins); Out[81]: 1.0. In [82]: expect(sz2, two_spins); Out[82]: -1.0. Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-states.html:17268,down,down,17268,docs/3.0.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html,1,['down'],['down']
Availability,"= \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ah",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html:40285,error,error,40285,docs/4.4/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html,4,['error'],['error']
Availability,"= \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:40221,error,error,40221,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,3,['error'],['error']
Availability,"= \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:40285,error,error,40285,docs/4.3/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html,1,['error'],['error']
Availability,"= \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html:39555,error,error,39555,docs/4.7/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimizer.html,2,['error'],['error']
Availability,"= np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. # auxiliary. def _transform_H_t_shift(H, args=None):; """"""; Time shift the Hamiltonian with private time-shift variable _t0; """""". if isinstance(H, Qobj):; # constant hamiltonian; return H, args. if isinstance(H, types.FunctionType):; # function-callback based time-dependence; if isinstance(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""); return H_shifted, _args. if isinstance(H, list):; # string/function-list based time-dependence; H_shifted = []; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. for i in range(len(H)):; if isinstance(H[i], list):; # modify hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t+args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Note: other functions already raise errors for mixed; # td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t+args_i[""_t0""], args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, args"" +; ""must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). return H_shifted, _args. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:39420,error,errors,39420,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['error'],['errors']
Availability,"= {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\end{split}\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the intial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\begin{split}\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\end{split}\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is show in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation or; qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_ss or; qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_4op_1t; \(\left<A(0)B(\tau)C(\tau)D(0)\right>\). qutip.correlation.correlation_4op_2t; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function sovlers return a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-correlation.html:3356,avail,available,3356,docs/3.0.0/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html,3,['avail'],['available']
Availability,"='RND', pulse_scaling=1.0, pulse_offset=0.0,; log_level=logging.NOTSET, out_file_ext='.txt', gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------. H_d : Qobj; Drift (aka system) the underlying Hamiltonian of the system. H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:14342,error,error,14342,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['error'],['error']
Availability,"=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:155780,error,error,155780,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability,"=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:H_d : Qobj or list of Qobj. Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : Qobj. a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control ampli",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:151784,error,error,151784,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['error'],['error']
Availability,"=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters:; H : Qobj; system Hamiltonian. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool; If True, calculate; \(\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:83692,error,errors,83692,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['errors']
Availability,"=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:225494,error,error,225494,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"=True); >>> processor.add_control(tensor([sigmay(), sigmay()])); >>> setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ... ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ... ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}; >>> tlist, coeffs = processor.load_circuit(; ... qc, setting_args=setting_args, merge_gates=False). Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors. The typical approaches are either applying bit/sign flipping gate probabilistically or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous time evolution. Instead, the error is added to the driving Hamiltonian list (coherent control error) or the collapse operators (decoherent error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-qip.html:13976,error,error,13976,docs/4.5/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-qip.html,1,['error'],['error']
Availability,">. Return type:qobj. Examples; >>> basis(5,2); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qotoolbox:; basis(N, 1) = ground state. bell_state(state='00')[source]¶; Returns the Bell state:. |B00> = 1 / sqrt(2)*[|0>|0>+|1>|1>]; |B01> = 1 / sqrt(2)*[|0>|0>-|1>|1>]; |B10> = 1 / sqrt(2)*[|0>|1>+|1>|0>]; |B11> = 1 / sqrt(2)*[|0>|1>-|1>|0>]. Returns:Bell_state – Bell state. Return type:qobj. bra(seq, dim=2)[source]¶; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters:seq (str / list of ints or characters) – Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:; - ‘g’/’e’ (ground and excited state); - ‘u’/’d’ (spin up and down); - ‘H’/’V’ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim; : int (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns:bra. Return type:qobj. Examples; >>> bra(""10""); Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue""); Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3); Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]); Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method='operator')[source]¶; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters:; N (int) – ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:2826,down,down,2826,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['down'],['down']
Availability,">> ket2dm(x); Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j]]. """"""; if Q.type == 'ket':; out = Q * Q.dag(); elif Q.type == 'bra':; out = Q.dag() * Q; else:; raise TypeError(""Input is not a ket or bra vector.""); return Qobj(out). #; # projection operator; #; [docs]def projection(N, n, m, offset=0):; """"""The projection operator that projects state :math:`|m>` on state :math:`|n>`. Parameters; ----------; N : int; Number of basis states in Hilbert space. n, m : float; The number states in the projection. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the projector. Returns; -------; oper : qobj; Requested projection operator. """"""; ket1 = basis(N, n, offset=offset); ket2 = basis(N, m, offset=offset). return ket1 * ket2.dag(). #; # composite qubit states; #; def qstate(string):; """"""Creates a tensor product for a set of qubits in either; the 'up' :math:`|0>` or 'down' :math:`|1>` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu'); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/states.html:13152,down,down,13152,docs/4.2/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/states.html,3,['down'],['down']
Availability,"ABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/solver.html:2777,toler,tolerance,2777,docs/4.0.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html,1,['toler'],['tolerance']
Availability,"AL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; import numbers. import numpy as np. from qutip.qobj import Qobj; import qutip.control.pulseoptim as cpo; from qutip.operators import identity; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.operations.gates import gate_sequence_product. __all__ = ['OptPulseProcessor']. [docs]class OptPulseProcessor(Processor):; """"""; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; `qutip.control.optimize_pulse_unitary` function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using :func:`qutip.mesolve`.; (For attributes documentation, please; refer to the parent class :class:`.Processor`). Parameters; ----------; N: int; The number of component systems. drift: `:class:`qutip.Qobj`; The drift Hamiltonian. The size must match the whole quantum system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``; """"""; def __init__(self, N, drift=None, t1=None, t2=None, dims=None):; super(OptPulseProcessor, s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:2688,avail,available,2688,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,2,['avail'],['available']
Availability,"AL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; import numbers. import numpy as np. from qutip.qobj import Qobj; import qutip.control.pulseoptim as cpo; from qutip.operators import identity; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.operations.gates import gate_sequence_product. __all__ = ['OptPulseProcessor']. [docs]class OptPulseProcessor(Processor):; """"""; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; `qutip.control.optimize_pulse_unitary` function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using :func:`qutip.mesolve`.; (For attributes documentation, please; refer to the parent class :class:`qutip.qip.device.Processor`). Parameters; ----------; N: int; The number of component systems. drift: `:class:`qutip.Qobj`; The drift Hamiltonian. The size must match the whole quantum system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``; """"""; def __init__(self, N, drift=None, t1=None, t2=None, dims=None):; super(OptP",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html:2668,avail,available,2668,docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/optpulseprocessor.html,1,['avail'],['available']
Availability,"A_ops_Euler. elif sso.solver == 'fast-milstein':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_single_fast; elif len(sc_ops) == 2:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast. elif sso.method == 'heterodyne':; sso.d2_len = 1; sso.sc_ops = []; for sc in iter(sc_ops):; sso.sc_ops += [sc / np.sqrt(2), -1.0j * sc / np.sqrt(2)]; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast; ; elif sso.solver == 'taylor15':; sso.generate_A_ops = _generate_A_ops_simple; sso.generate_noise = _generate_noise_Taylor_15; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:17024,avail,available,17024,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,3,['avail'],['available']
Availability,"CE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:2933,error,error,2933,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['error'],['error']
Availability,"CE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:2904,error,error,2904,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['error'],['error']
Availability,"CES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import os; import warnings; from qutip import __version__. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/solver.html:3929,toler,tolerance,3929,docs/3.1.0/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html,1,['toler'],['tolerance']
Availability,"Changing Settings; Persistent Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possib",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-settings.html:1818,toler,tolerance,1818,docs/4.2/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-settings.html,4,['toler'],['tolerance']
Availability,"Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html:11456,avail,available,11456,docs/3.1.0/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html,1,['avail'],['available']
Availability,"Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; writer=""avconv"", codec=""libx264"", verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html:10862,avail,available,10862,docs/4.2/modules/qutip/ipynbtools.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/ipynbtools.html,10,['avail'],['available']
Availability,"Diff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:65317,error,errors,65317,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['error'],['errors']
Availability,"Diff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:64923,error,errors,64923,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['error'],['errors']
Availability,"DiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type). if isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot dur",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:29650,error,errors,29650,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['error'],['errors']
Availability,"Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:108270,avail,available,108270,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['avail'],['available']
Availability,"Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimresult. Source code for qutip.control.optimresult; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator fro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimresult.html:1245,error,error,1245,docs/4.7/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimresult.html,2,['error'],['error']
Availability,"E',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:41910,error,error,41910,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"EGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import warnings; from copy import deepcopy. import numpy as np. from qutip.operators import tensor, identity, destroy, sigmax, sigmaz; from qutip.states import basis; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.device.processor import Processor; from qutip.qip.device.modelprocessor import ModelProcessor; from qutip.qip.operations import expand_operator; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.gatecompiler import GateCompiler; from qutip.qip.compiler import CavityQEDCompiler. __all__ = ['DispersiveCavityQED']. [docs]class DispersiveCavityQED(ModelProcessor):; """"""; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float, optional; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optional; The number of energy levels in the resonator. deltamax: int or list, optional; The coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optional; The coefficients of sigma-z for each of the qubits in the system. w0: int, optional; The base frequency of the resonator. eps: int or list, optional; The epsilon for each of the qubits in the system. delta: int or list, optional; The epsilon for each of the qubit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html:2886,avail,available,2886,docs/4.6/modules/qutip/qip/device/cavityqed.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/cavityqed.html,2,['avail'],['available']
Availability,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:2937,error,error,2937,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['error'],['error']
Availability,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:2966,error,error,2966,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"False):; """"""Dense array from quantum object. Parameters; ----------; order : str {'C', 'F'}; Return array in C (default) or Fortran ordering.; squeeze : bool {False, True}; Squeeze output array.; ; Returns; -------; data : array; Array of complex data from quantum objects `data` attribute.; """"""; if squeeze:; return self.data.toarray(order=order).squeeze(); else:; return self.data.toarray(order=order). [docs] def diag(self):; """"""Diagonal elements of quantum object. Returns; -------; diags : array; Returns array of ``real`` values if operators is Hermitian,; otherwise ``complex`` values are returned. """"""; out = self.data.diagonal(); if np.any(np.imag(out) > settings.atol) or not self.isherm:; return out; else:; return np.real(out). [docs] def expm(self, method='dense'):; """"""Matrix exponential of quantum operator. Input operator must be square. Parameters; ----------; method : str {'dense', 'sparse'}; Use set method to use to calculate the matrix exponentiation. The; available choices includes 'dense' and 'sparse'. Since the; exponential of a matrix is nearly always dense, method='dense'; is set as default.s. Returns; -------; oper : qobj; Exponentiated quantum operator. Raises; ------; TypeError; Quantum operator is not square. """"""; if self.dims[0][0] != self.dims[1][0]:; raise TypeError('Invalid operand for matrix exponential'). if method == 'dense':; F = sp_expm(self.data, sparse=False). elif method == 'sparse':; F = sp_expm(self.data, sparse=True). else:; raise ValueError(""method must be 'dense' or 'sparse'.""). out = Qobj(F, dims=self.dims); return out.tidyup() if settings.auto_tidyup else out. [docs] def check_herm(self):; """"""Check if the quantum object is hermitian. Returns; -------; isherm : bool; Returns the new value of isherm property.; """"""; self._isherm = None; return self.isherm. [docs] def sqrtm(self, sparse=False, tol=0, maxiter=100000):; """"""Sqrt of a quantum operator. Operator must be square. Parameters; ----------; sparse : bool; Use sparse eigenvalue/v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:27666,avail,available,27666,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,1,['avail'],['available']
Availability,"False, args={}, options=<qutip.solver.Options object at 0x2b22624eaac8>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate; \(\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x2b22624ea978>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:84648,error,errors,84648,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['error'],['errors']
Availability,"FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:95661,error,error,95661,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"Fock state. Examples; >>> fock_dm(3,1); Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]]. ghz_state(N=3)[source]¶; Returns the N-qubit GHZ-state. Parameters:; N : int (default=3); Number of qubits in state. Returns:; G : qobj; N-qubit GHZ-state. maximally_mixed_dm(N)[source]¶; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters:; N : int; Number of basis states in Hilbert space. Returns:; dm : qobj; Thermal state density matrix. ket(seq, dim=2)[source]¶; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters:; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:; - ‘g’/’e’ (ground and excited state); - ‘u’/’d’ (spin up and down); - ‘H’/’V’ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns:; ket : qobj. Examples; >>> ket(""10""); Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue""); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. ket2dm(Q)[source]¶; Takes input ket or bra vector and returns density matrix; formed by o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:10857,down,down,10857,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['down'],['down']
Availability,"H : :class:`qutip.qobj.Qobj`; system Hamiltonian. rho0 : :class:`qutip.qobj.Qobj`; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. taulist : *list* / *array*; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list of :class:`qutip.qobj.Qobj`; list of collapse operators. a_op : :class:`qutip.qobj.Qobj`; operator A. b_op : :class:`qutip.qobj.Qobj`; operator B. c_op : :class:`qutip.qobj.Qobj`; operator C. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : :class:`qutip.solver.Options`; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec: *array*; An *array* of correlation values for the times specified by `taulist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args=None,; options=Options(ntraj=[20, 100])):; """"""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math: `\\tau<0`. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; system Hamiltonian, or a callback function for time-dependent; Hamilt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:10479,error,errors,10479,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['error'],['errors']
Availability,"IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:2826,error,errors,2826,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,5,['error'],['errors']
Availability,"In [68]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [69]: expect(N, states); Out[69]: array([0., 1., 2., 3., 4.]). In [70]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. In [71]: expect(c, cat_list); Out[71]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [72]: up = basis(2, 0). In [73]: down = basis(2, 1). In [74]: expect(sigmaz(), up); Out[74]: 1.0. In [75]: expect(sigmaz(), down); Out[75]: -1.0. as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; In [76]: spin1 = basis(2, 0). In [77]: spin2 = basis(2, 1). In [78]: two_spins = tensor(spin1, spin2). In [79]: sz1 = tensor(sigmaz(), qeye(2)). In [80]: sz2 = tensor(qeye(2), sigmaz()). In [81]: expect(sz1, two_spins); Out[81]: 1.0. In [82]: expect(sz2, two_spins); Out[82]: -1.0. Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-states.html:16947,down,down,16947,docs/4.5/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-states.html,1,['down'],['down']
Availability,"Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:drift : Qobj or list of Qobj. the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj. a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:167396,error,error,167396,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['error'],['error']
Availability,"Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:182876,error,error,182876,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,['error'],['error']
Availability,"Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:184610,error,error,184610,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['error']
Availability,"Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:drift : Qobj or list of Qobj. the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]. a list of control dynamics generators. These are scaled by; th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:169811,error,error,169811,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['error'],['error']
Availability,"Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-basics.html:2010,avail,available,2010,docs/3.1.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html,1,['avail'],['available']
Availability,"Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this us",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:1257,avail,available,1257,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,2,['avail'],['available']
Availability,"It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidelity function call number of the pulse optimisation. grad_func_call_numintGradient function call number of the pulse optimisation. fid_errfloatFidelity error. grad_normfloatfidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_timefloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attribut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:86604,error,error,86604,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,5,['error'],['error']
Availability,"LIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; import qutip.settings as qset; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:2850,toler,tolerance,2850,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,3,['toler'],['tolerance']
Availability,"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from copy import deepcopy. import numpy as np. from qutip.operators import sigmax, sigmay, sigmaz; from qutip.tensor import tensor; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.modelprocessor import ModelProcessor; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.spinchaincompiler import SpinChainCompiler. __all__ = ['SpinChain', 'LinearSpinChain', 'CircularSpinChain']. [docs]class SpinChain(ModelProcessor):; """"""; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses :class:`qutip.qip.device.LinearSpinChain` and; :class:`qutip.qip.device.CircularSpinChain`.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:2657,avail,available,2657,docs/4.6/modules/qutip/qip/device/spinchain.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html,2,['avail'],['available']
Availability,"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import division, print_function, absolute_import; import os; # Fix the multiprocessing issue with NumPy compiled against OPENBLAS; if 'OPENBLAS_MAIN_FREE' not in os.environ:; os.environ['OPENBLAS_MAIN_FREE'] = '1'; # automatically set number of threads used by MKL and openblas to 1; # prevents errors when running things in parallel. Should be set; # by user directly in a script or notebook if >1 is needed.; # Must be set BEFORE importing NumPy; if 'MKL_NUM_THREADS' not in os.environ:; os.environ['MKL_NUM_THREADS'] = '1'. if 'OPENBLAS_NUM_THREADS' not in os.environ:; os.environ['OPENBLAS_NUM_THREADS'] = '1'. import sys; import warnings. import qutip.settings; import qutip.version; from qutip.version import version as __version__; from qutip.utilities import _version2int. # -----------------------------------------------------------------------------; # Check if we're in IPython.; try:; __IPYTHON__; qutip.settings.ipython = True; except:; qutip.settings.ipython = False. # -----------------------------------------------------------------------------; # Check for minimum requirements of dependencies, give the user a warning; # if the requirements aren't fulfilled; #. numpy_requirement = ""1.6.0""; try:; import numpy; if _version2int(numpy.__v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip.html:3604,error,errors,3604,docs/3.1.0/modules/qutip.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html,1,['error'],['errors']
Availability,"LITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/solver.html:2819,toler,tolerance,2819,docs/4.0.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html,1,['toler'],['tolerance']
Availability,"Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for symmetric (or Hermitian), positive-definite matrices. Since the Liouvillian has none of these properties, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to be good. QuTiP makes use of an incomplete LU preconditioner is invoked automatically when using the iterative 'GMRES' and 'LGMRES' solvers that uses a combination of symmetric and antisymmetric matrix permutations that attempts to improve the preconditioning process. These featu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-steady.html:5650,down,downside,5650,docs/3.0.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html,2,['down'],['downside']
Availability,"Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes:; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting. fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached. max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:81927,error,error,81927,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability,"NTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np; import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; These are the other non-periodic options:; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; These are the periodic options; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over.; """""". if pulse_type == 'RND",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html:3850,error,errors,3850,docs/3.1.0/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulsegen.html,2,['error'],['errors']
Availability,"NTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html:2840,error,errors,2840,docs/4.5/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/propcomp.html,3,['error'],['errors']
Availability,"Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (14.04 and later) is to use the QuTiP PPA; sudo add-apt-",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/installation.html:3989,down,download,3989,docs/3.1.0/installation.html,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html,1,['down'],['download']
Availability,"New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:2701,avail,available,2701,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,1,['avail'],['available']
Availability,"None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times for :math:`t`. Must be uniformly spaced. c_ops : list of :class:`qutip.Qobj`; Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_ops : list of :class:`qutip.Qobj` / callback function single; single operator or list of operato",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:18252,avail,available,18252,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,3,['avail'],['available']
Availability,"OCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html:2630,mask,mask,2630,docs/4.3/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html,5,['mask'],['mask']
Availability,"OCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:2630,mask,mask,2630,docs/4.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html,4,['mask'],['mask']
Availability,"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import warnings; from copy import deepcopy. import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.operators import identity; from qutip.qip.operations.gates import expand_operator, globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.noise import (; Noise, RelaxationNoise, DecoherenceNoise,; ControlAmpNoise, RandomNoise, process_noise); from qutip.qip.pulse import Pulse, Drift, _merge_qobjevo, _fill_coeff. __all__ = ['Processor']. [docs]class Processor(object):; """"""; A simulator of a quantum device based on the QuTiP solver; :func:`qutip.mesolve`. It is defined by the available driving Hamiltonian; and the decoherence time for each component systems. The processor can; simulate the evolution under the given control pulses. Noisy evolution is; supported by :class:`.Noise` and can be added to the processor. Parameters; ----------; N: int; The number of component systems. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list, optional; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``. spline_kind: str, optional; Type of the coefficient interpolation. Default is ""step_func""; Note that they have different requirement for the length of ``coeff``. - ""step_func"":; The coefficient will be treated as a step function. E.g.; ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient is; 3 in t=[0,1) and 2 i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html:2939,avail,available,2939,docs/4.6/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/processor.html,2,['avail'],['available']
Availability,"ON) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(se",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/termcond.html:2789,error,error,2789,docs/4.1/modules/qutip/control/termcond.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/termcond.html,8,['error'],['error']
Availability,"OODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimresult.html:2666,error,error,2666,docs/4.1/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimresult.html,16,['error'],['error']
Availability,"OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numpy as np; from qutip.operators import sigmax, sigmay, sigmaz, identity; from qutip.tensor import tensor; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor; from qutip.qip.device.modelprocessor import ModelProcessor; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.gatecompiler import GateCompiler; from qutip.qip.compiler.spinchaincompiler import SpinChainCompiler. __all__ = ['SpinChain', 'LinearSpinChain', 'CircularSpinChain']. [docs]class SpinChain(ModelProcessor):; """"""; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses :class:`qutip.qip.LinearSpinChain` and; :class:`qutip.qip.CircularSpinChain`.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`qutip.qip.device.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for al",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html:2728,avail,available,2728,docs/4.5/modules/qutip/qip/device/spinchain.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/spinchain.html,1,['avail'],['available']
Availability,"OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFG",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:2672,error,error,2672,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['error'],['error']
Availability,"OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: Optimize",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:2643,error,error,2643,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['error'],['error']
Availability,"Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-settings.html:1877,toler,tolerance,1877,docs/4.6/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-settings.html,2,['toler'],['tolerance']
Availability,"Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters:; H (Qobj) – system Hamiltonian.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators.; a_op (Qobj) – operator A.; b_op (Qobj) – operator B.; reverse (bool) – If True, calculate; \(\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\).; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec – An array of correlation values for the times specified by tlist. Return type:array. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:83297,error,errors,83297,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['errors']
Availability,"Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:42626,mask,mask,42626,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['mask'],['mask']
Availability,"P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.7.5. copyright; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the Copyright and Licensing page of this documentation. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/frontmatter.html:1708,down,downloaded,1708,docs/4.7/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html,1,['down'],['downloaded']
Availability,"Qobj data =; [[ 1. 0.]; [ 0. -1.]]. """"""; return 2.0 * jmat(1.0 / 2, 'z'). #; # DESTROY returns annihilation operator for N dimensional Hilbert space; # out = destroy(N), N is integer value & N>0; #; [docs]def destroy(N, offset=0):; '''Destruction (lowering) operator. Parameters; ----------; N : int; Dimension of Hilbert space. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Returns; -------; oper : qobj; Qobj for lowering operator. Examples; --------; >>> destroy(4); Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); data = np.sqrt(np.arange(offset+1, N+offset, dtype=complex)); ind = np.arange(1,N, dtype=np.int32); ptr = np.arange(N+1, dtype=np.int32); ptr[-1] = N-1; return Qobj(fast_csr_matrix((data,ind,ptr),shape=(N,N)), isherm=False). #; # create returns creation operator for N dimensional Hilbert space; # out = create(N), N is integer value & N>0; #; [docs]def create(N, offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4); Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/operators.html:8483,error,error,8483,docs/4.2/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/operators.html,6,['error'],['error']
Availability,"QobjInitial density matrix or state vector (ket). analytical: boolIf True, calculate the evolution with matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)[source]¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a ne",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:97371,avail,available,97371,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['avail'],['available']
Availability,"QuTiP is the original quantum framework written in Python; the most widely ; used programming language in the quantum sciences. Python's straightforward syntax allows for constructing, manipulating, and evolving quantum objects using QuTiP with just a few lines of code. Easy to learn, and 100% open-source, QuTiP is the ideal toolbox for research or the classroom. Did you know that you can determine if an operator is Hermitian without performing the conjugate transpose? QuTiP does. In fact, it is just one of many custom algorithms that QuTiP uses to maximize performance. Focusing on sparse matrices, and the means by which to efficiently manipulate these data structures, allows QuTiP to tackle even the largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming language, and the performance of compiled code, all for free. What can be better than that?; . Can't express your time-dependence analytically, or need to construct a function from a data set? No problem. QuTiP allows for passing interpolating functions as time-dependent arguments to the evol",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/features.html:1279,avail,available,1279,features.html,https://qutip.org,https://qutip.org/features.html,1,['avail'],['available']
Availability,"QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.processor. Source code for qutip.qip.device.processor; from collections.abc import Iterable; import warnings; from copy import deepcopy. import numpy as np; from scipy.interpolate import CubicSpline. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.operators import identity; from qutip.qip.operations.gates import expand_operator, globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip import Options; from qutip.qip.circuit import QubitCircuit; from qutip.qip.noise import (; Noise, RelaxationNoise, DecoherenceNoise,; ControlAmpNoise, RandomNoise, process_noise); from qutip.qip.pulse import Pulse, Drift, _merge_qobjevo, _fill_coeff. __all__ = ['Processor']. [docs]class Processor(object):; """"""; A simulator of a quantum device based on the QuTiP solver; :func:`qutip.mesolve`. It is defined by the available driving Hamiltonian; and the decoherence time for each component systems. The processor can; simulate the evolution under the given control pulses. Noisy evolution is; supported by :class:`.Noise` and can be added to the processor. Parameters; ----------; N: int; The number of component systems. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. dims: list, optional; The dimension of each component system.; Default value is a; qubit system of ``dim=[2,2,2,...,2]``. spline_kind: str, optional; Type of the coefficient interpolation. Default is ""step_func""; Note that they have different requirement for the length of ``coeff``. - ""step_func"":; The coefficient will be treated as a step function. E.g.; ``tlist=[0,1,2]`` and ``coeff=[3,2]``, means that the coefficient is; 3 in t=[0,1) and 2 i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/processor.html:1231,avail,available,1231,docs/4.7/modules/qutip/qip/device/processor.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/processor.html,2,['avail'],['available']
Availability,"Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f24ea6622b0>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.094 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html:1689,Down,Download,1689,docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html,https://qutip.org,https://qutip.org/docs/4.6/gallery/build/qip/plot_qip_amplitude_noise.html,2,['Down'],['Download']
Availability,"Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():; As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; In [3]: options = Options(). In [4]: options.num_cpus = 3. In [5]: options.atol = 1e-10. or one can use an inline method,; In [6]: options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [7]: print(options); Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last exa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/dynamics/dynamics-options.html:2225,toler,tolerance,2225,docs/4.5/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.5/guide/dynamics/dynamics-options.html,1,['toler'],['tolerance']
Availability,"Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():; As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; In [3]: options = Options(). In [4]: options.num_cpus = 3. In [5]: options.atol = 1e-10. or one can use an inline method,; In [6]: options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [7]: print(options); Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last exa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-options.html:2200,toler,tolerance,2200,docs/4.4/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-options.html,1,['toler'],['tolerance']
Availability,"R OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator fro",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html:2935,error,error,2935,docs/4.3/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html,5,['error'],['error']
Availability,"R OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. stats : Stats; Object contaning the stats for the r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimresult.html:2935,error,error,2935,docs/4.1/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimresult.html,3,['error'],['error']
Availability,"T NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import numbers. import numpy as np. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.operations.gates import globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor. __all__ = ['ModelProcessor']. [docs]class ModelProcessor(Processor):; """"""; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.Processor`). Parameters; ----------; N: int; The number of component systems. correct_global_phase: boolean, optional; If true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. Attributes; ----------; params: dict; A Python dictionary contains the name and the value of the parameters; in the physical realization, such as laser frequency, detuning etc. correct_global_phase: float; Save the g",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/modelprocessor.html:2663,avail,available,2663,docs/4.6/modules/qutip/qip/device/modelprocessor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/modelprocessor.html,2,['avail'],['available']
Availability,"T NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from collections.abc import Iterable; import numbers. import numpy as np. from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.operations.gates import globalphase; from qutip.tensor import tensor; from qutip.mesolve import mesolve; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device.processor import Processor. __all__ = ['ModelProcessor']. [docs]class ModelProcessor(Processor):; """"""; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`qutip.qip.device.Processor`). Parameters; ----------; N: int; The number of component systems. correct_global_phase: boolean, optional; If true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or float; Characterize the decoherence of amplitude damping for; each qubit. A list of size `N` or a float for all qubits. t2: list of float; Characterize the decoherence of dephasing for; each qubit. A list of size `N` or a float for all qubits. Attributes; ----------; params: dict; A Python dictionary contains the name and the value of the parameters; in the physical realization, such as laser frequency, detuning etc. correct_global_phase: f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qip/device/modelprocessor.html:2643,avail,available,2643,docs/4.5/modules/qutip/qip/device/modelprocessor.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qip/device/modelprocessor.html,1,['avail'],['available']
Availability,"T':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:63586,error,errors,63586,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['error'],['errors']
Availability,"TMSolverOptions. Returns:output: qutip.solver.Result. An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:142527,error,error,142527,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:2472,error,error,2472,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,8,['error'],['error']
Availability,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:3718,error,error,3718,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['error'],['error']
Availability,"TRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import sys; import datetime; from collections import OrderedDict; import os; import warnings; from qutip import __version__; from qutip.qobj import Qobj; import qutip.settings as qset; from types import FunctionType, BuiltinFunctionType. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:2808,toler,tolerance,2808,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,3,['toler'],['tolerance']
Availability,"TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:156191,error,error,156191,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,6,['error'],['error']
Availability,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. """""". if ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html:2701,error,errors,2701,docs/4.6/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulsegen.html,4,['error'],['errors']
Availability,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied ov",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html:2672,error,errors,2672,docs/4.1/modules/qutip/control/pulsegen.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulsegen.html,12,['error'],['errors']
Availability,"TextProgressBar will be used. Returns:; a : qobj; Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:; U : qobj; Operator representing the propagator. Returns:; a : qobj; Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H : qobj; System Hamiltonian. c_ops : list; list of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:; Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters:; waveguide_emission_indices : list or tuple; List of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:111362,error,error,111362,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['error']
Availability,"Ti and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A). if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely positiv",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/metrics.html:11936,error,error,11936,docs/4.4/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/metrics.html,5,['error'],['error']
Availability,"Ti and SchattenNorms.jl. (By contrast,; # QETLAB uses the dual problem.). # Check if A and B are both unitaries. If so, then we can without; # loss of generality choose B to be the identity by using the; # unitary invariance of the diamond norm,; # || A - B ||_♢ = || A B⁺ - I ||_♢.; # Then, using the technique mentioned by each of Johnston and; # da Silva,; # || A B⁺ - I ||_♢ = max_{i, j} | \lambda_i(A B⁺) - \lambda_j(A B⁺) |,; # where \lambda_i(U) is the ith eigenvalue of U. if (; # There's a lot of conditions to check for this path.; not force_solve and B is not None and; # Only check if they aren't superoperators.; A.type == ""oper"" and B.type == ""oper"" and; # The difference of unitaries optimization is currently; # only implemented for d == 2. Much of the code below is more general,; # though, in anticipation of generalizing the optimization.; A.shape[0] == 2; ):; # Make an identity the same size as A and B to; # compare against.; I = qeye(A.dims[0]); # Compare to B first, so that an error is raised; # as soon as possible.; Bd = B.dag(); if (; (B * Bd - I).norm() < 1e-6 and; (A * A.dag() - I).norm() < 1e-6; ):; # Now we are on the fast path, so let's compute the; # eigenvalues, then find the diameter of the smallest circle; # containing all of them.; #; # For now, this is only implemented for dim = 2, such that; # generalizing here will allow for generalizing the optimization.; # A reasonable approach would probably be to use Welzl's algorithm; # (https://en.wikipedia.org/wiki/Smallest-circle_problem).; U = A * B.dag(); eigs = U.eigenenergies(); eig_distances = np.abs(eigs[:, None] - eigs[None, :]); return np.max(eig_distances). # Force the input superoperator to be a Choi matrix.; J = to_choi(A); ; if B is not None:; J -= to_choi(B). # Watrous 2012 also points out that the diamond norm of Lambda; # is the same as the completely-bounded operator-norm (∞-norm); # of the dual map of Lambda. We can evaluate that norm much more; # easily if Lambda is completely posit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/metrics.html:10396,error,error,10396,docs/4.2/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/metrics.html,5,['error'],['error']
Availability,"TraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:64415,error,errors,64415,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['error'],['errors']
Availability,"U'); self.apply_params(). [docs] def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option). @property; def phase_option(self):; return self._phase_option. @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)). [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; Th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:11075,error,errors,11075,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['error'],['errors']
Availability,"UTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; """"""; import numpy as np; # QuTiP; from qutip import Qobj; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=-np.Inf, amp_ubound=np.Inf,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; optim_alg='LBFGSB', max_metric_corr=10, accuracy_factor=1e7,; dyn_type='GEN_MAT', prop_type='DEF',; fid_type='DEF', phase_option=None, fid_err_scale_factor=None,; amp_update_mode='ALL',; init_pulse_type='RND', pulse_scaling=1.0, pulse_offset=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:3886,error,error,3886,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['error'],['error']
Availability,"U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; ``alg_params`` (if given there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the per",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:43459,error,error,43459,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A `",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:22026,error,error,22026,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequenci",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:219296,error,error,219296,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:235737,error,error,235737,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"[3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j]]. """"""; if Q.type == 'ket':; out = Q * Q.dag(); elif Q.type == 'bra':; out = Q.dag() * Q; else:; raise TypeError(""Input is not a ket or bra vector.""); return Qobj(out). #; # projection operator; #; [docs]def projection(N, n, m, offset=None):; r""""""; The projection operator that projects state :math:`\lvert m\rangle` on; state :math:`\lvert n\rangle`. Parameters; ----------; N : int; Number of basis states in Hilbert space. n, m : float; The number states in the projection. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the projector. Returns; -------; oper : qobj; Requested projection operator.; """"""; ket1 = basis(N, n, offset=offset); ket2 = basis(N, m, offset=offset). return ket1 * ket2.dag(). #; # composite qubit states; #; def qstate(string):; r""""""Creates a tensor product for a set of qubits in either; the 'up' :math:`\lvert0\rangle` or 'down' :math:`\lvert1\rangle` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu') # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; '",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/states.html:15941,down,down,15941,docs/4.6/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html,4,['down'],['down']
Availability,"[8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; if isinstance(dim, int):; dim = [dim] * len(seq); return tensor([basis(dim[i], _character_to_qudit(x)); for i, x in enumerate(seq)]). [docs]def bra(seq, dim=2):; """"""; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; bra : qobj. Examples; --------; >>> bra(""10""); Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue""); Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3); Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]); Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]; """"""; return ket(seq, dim=dim).dag(). #; # quantum state number helper functions; #; [docs]def state_number_enumerate(dims, excitations=None, state=None, idx=0):; """"""; An iterator ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/states.html:16282,down,down,16282,docs/4.2/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/states.html,6,['down'],['down']
Availability,"[[ 1. 0.]; [ 0. -1.]]. """"""; return 2 * jmat(1 / 2, 'z'). #; # DESTROY returns annihilation operator for N dimensional Hilbert space; # out = destroy(N), N is integer value & N>0; #; [docs]def destroy(N, offset=0):; '''Destruction (lowering) operator. Parameters; ----------; N : int; Dimension of Hilbert space. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Returns; -------; oper : qobj; Qobj for lowering operator. Examples; --------; >>> destroy(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); data = np.sqrt(np.arange(offset+1, N+offset, dtype=complex)); ind = np.arange(1,N, dtype=np.int32); ptr = np.arange(N+1, dtype=np.int32); ptr[-1] = N-1; return Qobj(fast_csr_matrix((data,ind,ptr),shape=(N,N)), isherm=False). #; # create returns creation operator for N dimensional Hilbert space; # out = create(N), N is integer value & N>0; #; [docs]def create(N, offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4) # doctest: +SKIP; Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/operators.html:8655,error,error,8655,docs/4.6/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/operators.html,4,['error'],['error']
Availability,"[[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]. Now we see the difference! The qutip.operators.sigmap operator acting on the spin state returns the zero vector. Why is this? To see what happened, let us use the qutip.operators.sigmaz operator:; In [52]: sigmaz(); Out[52]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [53]: sigmaz() * spin; Out[53]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [54]: spin2 = basis(2, 1). In [55]: spin2; Out[55]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. In [56]: sigmaz() * spin2; Out[56]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\mathrm{up}\right>\) state of a two-level spin system while spin2 gives the \(\left|\mathrm{down}\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\mathrm{up}\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\mathrm{down}\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\mathr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-states.html:14282,down,down,14282,docs/3.0.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html,2,['down'],['down']
Availability,"[docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:3369,mask,mask,3369,docs/4.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html,8,['mask'],['mask']
Availability,"[np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]); 10.0%. Run time: 11.71s. Est. time left: 00:00:01:45; 20.0%. Run time: 21.91s. Est. time left: 00:00:01:27; 30.0%. Run time: 32.13s. Est. time left: 00:00:01:14; 40.0%. Run time: 42.52s. Est. time left: 00:00:01:03; 50.0%. Run time: 52.77s. Est. time left: 00:00:00:52; 60.0%. Run time: 63.03s. Est. time left: 00:00:00:42; 70.0%. Run time: 72.90s. Est. time left: 00:00:00:31; 80.0%. Run time: 83.01s. Est. time left: 00:00:00:20; 90.0%. Run time: 93.36s. Est. time left: 00:00:00:10; 100.0%. Run time: 104.57s. Est. time left: 00:00:00:00; Total run time: 104.58s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html:15978,avail,available,15978,docs/4.0.2/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.0.2/guide/dynamics/dynamics-monte.html,1,['avail'],['available']
Availability,"\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_ops : list of qutip.Qobj / callback function. single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like. list of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensors : array_like. optional list of precomputed tensors \(T_k\). kwargs : dictionary. Optional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns:output: qutip.solver.Result. An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:141983,error,error,141983,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability,"\left|\mathrm{up}\right>\) state of a two-level spin system while spin2 gives the \(\left|\mathrm{down}\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\mathrm{up}\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\mathrm{down}\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\mathrm{up}\right>\) state is label as \(\left|0\right>\), and the \(\left|\mathrm{down}\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [58]: vac = basis(5, 0). In [59]: one = basis(5, 1). In [60]: c = create(5). In [61]: N = num(5). In [62]: expect(N, vac); Out[62]: 0.0. In [63]: expect(N, one); Out[63]: 1.0. In [64]: coh = coherent_dm(5, 1.0j). In [65]: expect(N, coh); Out[65]: 0.9970555745806599. In [66]: cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). In [67]: expect(c, cat); Out[67]: -0.9999999999999998j. The qutip.expect function also accepts lists or arra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-states.html:15259,down,down,15259,docs/3.0.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html,1,['down'],['down']
Availability,"\left|\mathrm{up}\right>\) state of a two-level spin system while spin2 gives the \(\left|\mathrm{down}\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\mathrm{up}\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\mathrm{down}\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\mathrm{up}\right>\) state is label as \(\left|0\right>\), and the \(\left|\mathrm{down}\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [58]: vac = basis(5, 0). In [59]: one = basis(5, 1). In [60]: c = create(5). In [61]: N = num(5). In [62]: expect(N, vac); Out[62]: 0.0. In [63]: expect(N, one); Out[63]: 1.0. In [64]: coh = coherent_dm(5, 1.0j). In [65]: expect(N, coh); Out[65]: 0.9970555745806599. In [66]: cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). In [67]: expect(c, cat); Out[67]: 0.9999999999999998j. The qutip.expect function also accepts lists or array",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-states.html:15321,down,down,15321,docs/3.0.1/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html,1,['down'],['down']
Availability,"\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. solver : str. choice of solver (me for master-equation and; es for exponential series). options : Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g1, G1 : tuple. The normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like. list of times for \(\tau\). taulist must be positive and c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:98426,error,errors,98426,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['errors']
Availability,"]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [69]: expect(N, states); Out[69]: array([0., 1., 2., 3., 4.]). In [70]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. In [71]: expect(c, cat_list); Out[71]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [72]: up = basis(2, 0). In [73]: down = basis(2, 1). In [74]: expect(sigmaz(), up); Out[74]: 1.0. In [75]: expect(sigmaz(), down); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-states.html:17298,down,down,17298,docs/4.4/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-states.html,1,['down'],['down']
Availability,"]; ....: for k in range(len(lbls_list))])); ....: . In [71]: fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). In [72]: ax.view_init(azim=-55, elev=45). In [73]: plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; In [74]: rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). In [75]: fig, ax = hinton(rho_ss) # xlabels=xlabels, ylabels=xlabels). In [76]: plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-visualization.html:12213,error,errors,12213,docs/3.1.0/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-visualization.html,1,['error'],['errors']
Availability,"]; ....: for k in range(len(lbls_list))])); ....: . In [71]: fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). In [72]: ax.view_init(azim=-55, elev=45). In [73]: plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; In [74]: rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). In [75]: fig, ax = hinton(rho_ss) # xlabels=xlabels, ylabels=xlabels). In [76]: plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-visualization.html:11370,error,errors,11370,docs/4.2/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-visualization.html,4,['error'],['errors']
Availability,"_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : Qobj; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : arra",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:20083,error,error,20083,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"_basis=krylov_basis,; t0=tlist[0],; tf=tlist[-1],; target_tolerance=options.atol,; ). # To avoid the singularity at t0, we add a small epsilon value; t_min = (tlist[-1] - tlist[0]) / options.nsteps + tlist[0]; bracket = [t_min, tlist[-1]]. if (np.sign(f(bracket[0])) == -1) and (np.sign(f(bracket[-1])) == -1):; delta_t = tlist[-1] - tlist[0]; return delta_t. elif (np.sign(f(bracket[0])) == 1) and (np.sign(f(bracket[-1])) == 1):; raise ValueError(; ""No solution exists with the given combination of parameters 'krylov_dim', ""; ""tolerance = 'options.atol', maximum number allowed of krylov internal ""; ""partitions = 'options.nsteps' and 'tlist'. Try reducing the tolerance, or ""; ""increasing 'krylov_dim'. If nothing works, then a deeper analysis of the ""; ""problem is recommended.""; ). else:; sol = root_scalar(f=f, bracket=bracket, method=""brentq"", xtol=options.atol); if sol.converged:; delta_t = sol.root; return delta_t; else:; raise Exception(; ""Method did not converge, try increasing 'krylov_dim', ""; ""taking a lesser final time 'tlist[-1]' or decreasing the ""; ""tolerance via Options().atol. ""; ""If nothing works, this problem might not be suitable for ""; ""Krylov or a deeper analysis might be required.""; ). def _lanczos_error_equation_to_optimize_delta_t(; T, krylov_basis, t0, tf, target_tolerance; ):; """"""; Function to optimize in order to obtain the optimal number of; Lanczos algorithm iterations, governed by the optimal timestep size between; Lanczos iteractions.; """"""; eigenvalues1, eigenvectors1 = eigh(T[0:, 0:]); U1 = np.matmul(krylov_basis[0:, 0:].T, eigenvectors1); e01 = eigenvectors1.conj().T[:, 0]. eigenvalues2, eigenvectors2 = eigh(T[0:-1, 0: T.shape[1] - 1]); U2 = np.matmul(krylov_basis[0:-1, :].T, eigenvectors2); e02 = eigenvectors2.conj().T[:, 0]. def f(t):; delta_t = -1j * (t - t0). aux1 = np.multiply(np.exp(delta_t * eigenvalues1), e01); psi1 = np.matmul(U1, aux1). aux2 = np.multiply(np.exp(delta_t * eigenvalues2), e02); psi2 = np.matmul(U2, aux2). error = np.l",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:15425,toler,tolerance,15425,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,2,['toler'],['tolerance']
Availability,"_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/partial_transpose.html:4600,mask,mask,4600,docs/4.4/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/partial_transpose.html,3,['mask'],['mask']
Availability,"_evo = True; oper_n = dims[0][0]; norm_dim_factor = np.sqrt(oper_n); else:; oper_evo = False; norm_dim_factor = 1.0. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). def get_curr_state_data():; if oper_evo:; return vec2mat(r.y); else:; return r.y. #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). # get the current state / oper data if needed; cdata = None; if opt.store_states or opt.normalize_output or n_expt_op > 0:; cdata = get_curr_state_data(). if opt.normalize_output:; # cdata *= _get_norm_factor(cdata, oper_evo); cdata *= norm_dim_factor / la_norm(cdata); if oper_evo:; r.set_initial_value(cdata.ravel('F'), r.t); else:; r.set_initial_value(cdata, r.t). if opt.store_states:; output.states.append(Qobj(cdata, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(cdata, dims=dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; cdata, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; cdata = get_curr_state_data(); if opt.normalize_output:; cdata *= norm_dim_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/sesolve.html:23419,error,error,23419,docs/4.3/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/sesolve.html,1,['error'],['error']
Availability,"_expt_op == 0:; # fall back on storing states; opt.store_states = True; need_qobj_state = True; else:; for op in e_ops:; if not isinstance(op, Qobj) and callable(op):; output.expect.append(np.zeros(n_tsteps, dtype=complex)); need_qobj_state = True; e_ops_data.append(None); continue; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if need_qobj_state:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; if not isinstance(e_ops[m], Qobj) and callable(e_ops[m]):; output.expect[m][t_idx] = e_ops[m](t, rho_t); else:; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 to 2021 inclusive, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/mesolve.html:16328,error,error,16328,docs/4.7/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/mesolve.html,2,['error'],['error']
Availability,"_factor': 100, 'diag_pivot_thresh': None, 'maxiter': 1000,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2',; 'restart': 20,; 'max_iter_refine': 10,; 'scaling_vectors': True,; 'weighted_matching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, 'scipy', 'mkl'}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {'direct', 'eigen', 'iterative-gmres',; 'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',; 'power-gmres', 'power-lgmres', 'power-bicgstab'}; Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen',; iterative GMRES method 'iterative-gmres', iterative LGMRES method; 'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',; SVD 'svd' (dense), or inverse-power method 'power'. The iterative; power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for 'smaller' systems.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/steadystate.html:4945,avail,availability,4945,docs/4.5/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/steadystate.html,1,['avail'],['availability']
Availability,"_imag. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. classmethod combine(exponents, rtol=1e-05, atol=1e-07)[source]¶; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present.; Exponents with the same frequency are only combined if they share the; same coupling operator .Q.; Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters. exponentslist of BathExponentThe list of exponents to combine. rtolfloat, default 1e-5The relative tolerance to use to when comparing frequencies and; coupling operators. atolfloat, default 1e-7The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns. list of BathExponentThe new reduced list of exponents. class DrudeLorentzBath(Q, lam, gamma, T, Nk, combine=True, tag=None)[source]¶; A helper class for constructing a Drude-Lorentz bosonic bath from the; bath parameters (see parameters below). Parameters. QQobjOperator describing the coupling between system and bath. lamfloatCoupling strength. gammafloatBath spectral density cutoff frequency. TfloatBath temperature. NkintNumber of exponential terms used to approximate the bath correlation; functions. combinebool, default TrueWhether to combine exponents with the same frequency (and coupling; operator). See BosonicBath.combine for details. tagoptional, str, tuple or any other objectA label for the bath exponents (for example, the name of the; bath). It defaults to None but can be set to help identify which; bath an exponent is from. terminator()[source]¶; Return the Matsubara terminator for the bath and the calculated; app",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:54016,toler,tolerance,54016,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['toler'],['tolerance']
Availability,"_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:101818,error,error,101818,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability,"_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:5912,error,error,5912,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['error'],['error']
Availability,"_offset) should only be""; "" specified for + and - bath exponents""; ). def __init__(; self, type, dim, Q, ck, vk, ck2=None, sigma_bar_k_offset=None,; tag=None,; ):; if not isinstance(type, self.types):; type = self.types[type]; self._check_ck2(type, ck2); self._check_sigma_bar_k_offset(type, sigma_bar_k_offset); self.type = type; self.dim = dim; self.Q = Q; self.ck = ck; self.vk = vk; self.ck2 = ck2; self.sigma_bar_k_offset = sigma_bar_k_offset; self.tag = tag. def __repr__(self):; dims = getattr(self.Q, ""dims"", None); return (; f""<{self.__class__.__name__} type={self.type.name}""; f"" dim={self.dim!r}""; f"" Q.dims={dims!r}""; f"" ck={self.ck!r} vk={self.vk!r} ck2={self.ck2!r}""; f"" sigma_bar_k_offset={self.sigma_bar_k_offset!r}""; f"" tag={self.tag!r}>""; ). [docs]class Bath:; """"""; Represents a list of bath expansion exponents. Parameters; ----------; exponents : list of BathExponent; The exponents of the correlation function describing the bath. Attributes; ----------. All of the parameters are available as attributes.; """"""; def __init__(self, exponents):; self.exponents = exponents. [docs]class BosonicBath(Bath):; """"""; A helper class for constructing a bosonic bath from the expansion; coefficients and frequencies for the real and imaginary parts of; the bath correlation function. If the correlation functions ``C(t)`` is split into real and imaginary; parts::. C(t) = C_real(t) + i * C_imag(t). then::. C_real(t) = sum(ck_real * exp(- vk_real * t)); C_imag(t) = sum(ck_imag * exp(- vk_imag * t)). Defines the coefficients ``ck`` and the frequencies ``vk``. Note that the ``ck`` and ``vk`` may be complex, even through ``C_real(t)``; and ``C_imag(t)`` (i.e. the sum) is real. Parameters; ----------; Q : Qobj; The coupling operator for the bath. ck_real : list of complex; The coefficients of the expansion terms for the real part of the; correlation function. The corresponding frequencies are passed as; vk_real. vk_real : list of complex; The frequencies (exponents) of the expansion t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:4490,avail,available,4490,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['avail'],['available']
Availability,"_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_ts",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:155613,error,error,155613,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability,"_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:H_d : Qobj or list of Qobj. Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : Qobj. a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:151617,error,error,151617,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['error'],['error']
Availability,"_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; ``H_d + ctrl_amp[j]*H_c[j]`` The control pulse is an ``[n_ts, n_ctrls]``; array of piecewise amplitudes. The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0 : Qobj; Starting point for the evolution. Typically the identity matrix. U_targ : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:41890,error,error,41890,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"_pulse_type='RND', pulse_scaling=1.0, pulse_offset=0.0, log_level=0, out_file_ext='.txt', gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:H_d : Qobj. Drift (aka system) the underlying Hamiltonian of the system. H_c : Qobj. a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:137669,error,error,137669,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['error'],['error']
Availability,"_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """""";",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:27764,error,errors,27764,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['errors']
Availability,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1. ; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html:6351,error,error,6351,docs/4.1/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dynamics.html,8,['error'],['error']
Availability,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:7528,error,error,7528,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,4,['error'],['error']
Availability,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:7642,error,error,7642,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,8,['error'],['error']
Availability,"_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computer : TimeslotComputer (subclass instance); Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computer : PropagatorComputer (subclass instance); Used to compute the propagators and their gradients. fid_computer : FidelityComputer (subclass instance); Used to computer the fidelity error and the fidelity error; gradient. memory_optimization : int; Level of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtype : type; Data type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:85275,error,error,85275,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,2,['error'],['error']
Availability,"_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython file",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:7055,avail,available,7055,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['avail'],['available']
Availability,"a Options().atol. ""; ""If nothing works, this problem might not be suitable for ""; ""Krylov or a deeper analysis might be required.""; ). def _lanczos_error_equation_to_optimize_delta_t(; T, krylov_basis, t0, tf, target_tolerance; ):; """"""; Function to optimize in order to obtain the optimal number of; Lanczos algorithm iterations, governed by the optimal timestep size between; Lanczos iteractions.; """"""; eigenvalues1, eigenvectors1 = eigh(T[0:, 0:]); U1 = np.matmul(krylov_basis[0:, 0:].T, eigenvectors1); e01 = eigenvectors1.conj().T[:, 0]. eigenvalues2, eigenvectors2 = eigh(T[0:-1, 0: T.shape[1] - 1]); U2 = np.matmul(krylov_basis[0:-1, :].T, eigenvectors2); e02 = eigenvectors2.conj().T[:, 0]. def f(t):; delta_t = -1j * (t - t0). aux1 = np.multiply(np.exp(delta_t * eigenvalues1), e01); psi1 = np.matmul(U1, aux1). aux2 = np.multiply(np.exp(delta_t * eigenvalues2), e02); psi2 = np.matmul(U2, aux2). error = np.linalg.norm(psi1 - psi2). steps = max(1, (tf - t0) // (t - t0)); return np.log10(error) + np.log10(steps) - np.log10(target_tolerance). return f. def _make_partitions(tlist, n_timesteps):; """"""Generates an internal 'partitions' list of np.arrays to iterate Lanczos; algorithms on each of them, based on 'tlist' and the optimized number of; iterations 'n_timesteps'.; """""". _tlist = np.copy(tlist). if n_timesteps == 1:; _tlist = np.insert(_tlist, 0, tlist[0]); _tlist = np.append(_tlist, tlist[-1]); partitions = [_tlist]; return partitions. n_timesteps += 1; krylov_tlist = np.linspace(tlist[0], tlist[-1], n_timesteps); krylov_partitions = [; np.array(krylov_tlist[i: i + 2]) for i in range(n_timesteps - 1); ]; partitions = []; for krylov_partition in krylov_partitions:; start = krylov_partition[0]; end = krylov_partition[-1]; condition = _tlist <= end; partitions.append([start] + _tlist[condition].tolist() + [end]); _tlist = _tlist[~condition]. return partitions. def _e_ops_outputs(krylov_results, e_ops, n_tlist_steps, opt):; krylov_results.expect = []; if callable(e_ops):; n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html:16434,error,error,16434,docs/4.7/modules/qutip/krylovsolve.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/krylovsolve.html,2,['error'],['error']
Availability,"a ``size``; parameter as the size of random numbers in the output array.; indices: list of int, optional; The indices of target pulse in the list of pulses.; **kwargs:; Key word arguments for the random number generator. Attributes; ----------; dt: float, optional; The time interval between two random amplitude. The coefficients; of the noise are the same within this time range.; rand_gen: numpy.random, optional; A random generator in numpy.random, it has to take a ``size``; parameter.; indices: list of int; The indices of target pulse in the list of pulses.; **kwargs:; Key word arguments for the random number generator. Examples; --------; >>> gaussnoise = RandomNoise( \; dt=0.1, rand_gen=np.random.normal, loc=mean, scale=std) \; # doctest: +SKIP; """"""; def __init__(; self, dt, rand_gen, indices=None, **kwargs):; super(RandomNoise, self).__init__(coeff=None, tlist=None); self.rand_gen = rand_gen; self.kwargs = kwargs; if ""size"" in kwargs:; raise ValueError(""size is preditermined inside the noise object.""); self.dt = dt; self.indices = indices. [docs] def get_noisy_dynamics(; self, dims=None, pulses=None, systematic_noise=None):; if pulses is None:; pulses = []; if self.indices is None:; indices = range(len(pulses)); else:; indices = self.indices; t_max = -np.inf; t_min = np.inf; for pulse in pulses:; t_max = max(max(pulse.tlist), t_max); t_min = min(min(pulse.tlist), t_min); # create new tlist and random coeff; num_rand = int(np.floor((t_max - t_min) / self.dt)) + 1; tlist = (np.arange(0, self.dt*num_rand, self.dt)[:num_rand] + t_min); # [:num_rand] for round of error like 0.2*6=1.2000000000002. for i in indices:; pulse = pulses[i]; coeff = self.rand_gen(**self.kwargs, size=num_rand); pulses[i].add_coherent_noise(; pulse.qobj, pulse.targets, tlist, coeff); return pulses, systematic_noise. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/noise.html:11838,error,error,11838,docs/4.7/modules/qutip/qip/noise.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/noise.html,2,['error'],['error']
Availability,"a basis transformation defined by inpt matrix. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool :. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array :. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array :. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:4854,toler,tolerance,4854,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['toler'],['tolerance']
Availability,"a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. log_level¶; i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:98619,error,error,98619,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integrat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-control.html:11997,avail,available,11997,docs/4.3/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-control.html,5,['avail'],['available']
Availability,"a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = ‘smilu_2’Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ system",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:135405,avail,availability,135405,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['avail'],['availability']
Availability,"ab(L, b, tol=ss_args['tol'],; M=ss_args['M'], x0=ss_args['x0'],; maxiter=ss_args['maxiter'],; callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; retur",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:23781,error,error,23781,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,6,['error'],['error']
Availability,"able(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fall back on storing states; opt.store_states = True; else:; for op in e_ops:; if op.dims != rho0.dims:; raise TypeError(f""e_ops dims ({op.dims}) are not ""; f""compatible with the state's ""; f""({rho0.dims})""); e_ops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. def get_curr_state_data(r):; return vec2mat(r.y). #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; cdata = get_curr_state_data(r); fdata = dense2D_to_fastcsr_fmode(cdata, size, size). # Try to guess if there is a fast path for rho_t; if issuper(rho0) or not rho0.isherm:; rho_t = Qobj(fdata, dims=dims); else:; rho_t = Qobj(fdata, dims=dims, fast=""mc-dm""). if opt.store_states:; output.states.append(rho_t). if expt_callback:; # use callback method; output.expect.append(e_ops(t, rho_t)). for m in range(n_expt_op):; output.expect[m][t_idx] = expect_rho_vec(e_ops_data[m], r.y,; e_ops[m].isherm; and rho0.isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if opt.store_final_state:; cdata = get_curr_state_data(r); output.final_state = Qobj(cdata, dims=dims,; isherm=rho0.isherm or None). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lamb",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mesolve.html:17486,error,error,17486,docs/4.6/modules/qutip/mesolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mesolve.html,2,['error'],['error']
Availability,"aceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params). # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params). # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:64822,error,errors,64822,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['error'],['errors']
Availability,"aces (m << dim(H)).; The output is either the state vector or the expectation values of; supplied operators (“e_ops”) at arbitrary points at (“tlist”).; Additional options; Additional options to krylovsolve can be set with the following:. “store_states”: stores states even though expectation values are; requested via the “e_ops” argument.; “store_final_state”: store final state even though expectation values are; requested via the “e_ops” argument. Parameters. Hqutip.QobjSystem Hamiltonian. psi0:class: qutip.QobjInitial state vector (ket). tlistNone / list / arrayList of times on which to evolve the initial state. If None, nothing; happens but the code won’t break. krylov_dim: intDimension of Krylov approximation subspaces used for the time; evolution approximation. e_opsNone / list of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. optionsOptions; Instance of ODE solver options, as well as krylov parameters.; atol: controls (approximately) the error desired for the finalsolution. (Defaults to 1e-8). nsteps: maximum number of krylov’s internal number of Lanczositerations. (Defaults to 10000). progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. sparsebool (default False)Use np.array to represent system Hamiltonians. If True, scipy sparse; arrays are used instead. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array result.expect of expectation values for the times; tlist, or an array result.states of state vectors corresponding; to the times tlist [if e_ops is an empty list]. Bloch-Redfield Master Equation¶. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfiel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:92409,error,error,92409,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['error'],['error']
Availability,"adient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:106455,error,error,106455,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability,"ady-state’ is only implemented; for the me and es solvers. tlist : array_like. list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. reverse : bool. If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat : array. An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters:H : Qobj. system Hamiltonian. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators. a_op : Qobj. operator A. b_op : Qobj. operator B. reverse : bo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:81463,error,errors,81463,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['errors']
Availability,"ady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters:; H : Qobj; system Hamiltonian. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:82249,error,errors,82249,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['errors']
Availability,"age. Default is ‘png’. dirc : str. Directory for output images. Defaults to current working directory. Returns:File containing plot of Bloch sphere. show()[source]¶; Display the Bloch sphere and corresponding data sets. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers.; Attributes. atol; (float {1e-8}) Absolute tolerance. rtol; (float {1e-6}) Relative tolerance. method; (str {‘adams’,’bdf’}) Integration method. order; (int {12}) Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; (int {2500}) Max. number of internal steps/call. first_step; (float {0}) Size of initial step (0 = automatic). min_step; (float {0}) Minimum step size (0 = automatic). max_step; (float {0}) Maximum step size (0 = automatic). tidy; (bool {True,False}) Tidyup Hamiltonian and initial state by removing small terms. num_cpus; (int) Number of cpus used by mcsolver (default = # of cpus). norm_tol; (float) Tolerance used when finding wavefunction norm in mcsolve. norm_steps; (int) Max. number of steps used to find wavefunction norm to within norm_tol in mcsolve. average_states; (bool {False}) Average states values over trajectories in stochastic solvers. average_expect; (bool {True}) Average expectation values over trajectories for stochastic solvers. mc_corr_eps; (float {1e-10}) Arbitrarily small value for elim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:25497,toler,tolerance,25497,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"agger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, ‘scipy’, ‘mkl’}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {‘direct’, ‘eigen’, ‘it",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:101441,error,errors,101441,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['error'],['errors']
Availability,"agger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:115011,error,errors,115011,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['errors']
Availability,"ains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.6.3. copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the sy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/frontmatter.html:1455,down,downloaded,1455,docs/4.6/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html,1,['down'],['downloaded']
Availability,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:224231,error,error,224231,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['error'],['error']
Availability,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:232709,error,error,232709,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['error'],['error']
Availability,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:236347,error,error,236347,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['error'],['error']
Availability,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:244828,error,error,244828,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['error'],['error']
Availability,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:216259,error,error,216259,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"aised exceptions in simple cases. (#1819, #1697 and #1702 by Simon Cross and Saumya Biswas); Fixed the displaying of the title for hinton and matrix_histogram plots when a title is given. Previously the supplied title was not displayed. (#1707 by Vladimir Vargas-Calderón); Removed an incorrect check on the initial state dimensions in the QubitCircuit constructor. This allows, for example, the construction of qutrit circuits. (#1807 by Boxi Li); Fixed the checking of method and offset parameters in coherent and coherent_dm. (#1469 and #1741 by Joseph Fox-Rabinovitz and Simon Cross); Removed the Hamiltonian saved in the sesolve solver results. (#1689 by Eric Giguère); Fixed a bug in rand_herm with pos_def=True and density>0.5 where the diagonal was incorrectly filled. (#1562 by Eric Giguère). Documentation Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor grammar errors in the dynamics guide. (#1822 by Victor Omole); Fixed many small documentation typos. (#1569 by Ashish Panigrahi); Added Pulser to the list of libraries that use QuTiP. (#1570 by Ashish Panigrahi); Corrected typo in the states and operators guide. (#1567 by Laurent Ajdnik); Converted http links to https. (#1555 by Jake Lishamn). Developer Changes¶. Add GitHub actions test run on windows-latest. (#1853 and #1855 by Simon Cross); Bumped the version of pillow used to build documentation from 9.0.0 to 9.0.1. (#1835 by dependabot); Migrated the qutip.superop_reps tests to pytest. (#1825 by Felipe Bivort Haiek); Migrated the qutip.steadystates tests to pytest. (#1679 by Eric Giguère); Changed the README.md CI badge to the GitHub Actions badge. (#1581 by Jake Lishman); Updated CodeClimate configuration to treat our Python source files as Python 3. (#1577 by Jake Lishman); Reduced cyclomatic complexity in qutip._mkl. (#1576 by Jake Lishman); Fixed PEP8 warnings in qutip.control",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:12958,error,errors,12958,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['error'],['errors']
Availability,"aises; ------; TypeError; Can only calculate overlap between a bra and ket quantum objects.; ; """""". if isinstance(state, Qobj):. if self.isbra:; if state.isket:; return (self.data * state.data)[0, 0]; elif state.isbra:; return (self.data * state.data.H)[0, 0]. elif self.isket:; if state.isbra:; return (self.data.H * state.data.H)[0, 0]; elif state.isket:; return (self.data.H * state.data)[0, 0]. raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Para",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:37434,toler,tolerance,37434,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['toler'],['tolerance']
Availability,"al : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are dervived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_method : string; a scip",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:53311,error,error,53311,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"al equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops¶; function – Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise¶; function – Function for generate an array of pre-computed noise signal. homogeneous¶; bool (True) – Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver¶; string – Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: ‘euler-maruyama’, ‘fast-euler-maruyama’,; ‘pc-euler’ is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: ‘milstein’, ‘fast-milstein’, ‘platen’,; ‘milstein-imp’ is semi-implicit Milstein method,; 3/2 order algorithms: ‘taylor15’,; ‘taylor15-imp’ is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {‘tol’:value},; default is {‘tol’:1e-6}. method¶; string (‘homodyne’, ‘heterodyne’, ‘photocurrent’) – The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution¶; string (‘normal’, ‘poission’) – The name of the distribution used for the stochastic increments. store_measurements¶; bool (default False) – Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise¶; array – Vector specifying the noise. normalize¶; bool (default True) – Whether or not to normalize the wave function during the evolution. options¶; qutip.solver.Options – Generic solver options. map_func¶; function – A map function or managing the calls to single-trajactory solvers. map_kwargs¶; dictionary – Optional keyword arguments to the map_func fun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:47088,toler,tolerance,47088,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"al folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the conda procedure described above.; If you want to build from source or use runtime compilation with Cython, you will need to have a working C++ compiler.; You can download the Visual Studio IDE from Microsoft, which has a free Community edition containing a sufficient C++ compiler.; This is the recommended compiler toolchain on Windows.; When installing, be sure to select the following components:. Windows “X” SDK (where “X” stands for your version: 7/8/8.1/10); Visual Studio C++ build tools. You can then follow the installation from source section as normal. Important; In order to prevent issues with the PATH environment variable not containing the compiler and associated libraries, it is recommended to use the developer command prompt in the Visual Studio installation folder instead of the built-in command prompt. The Community edition of Visual Studio takes around 10GB of disk space.; If this is prohibitive for you, it is also possible to install only the build tools and necessary SDKs instead, which should save about 2GB of space. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful.; To run the suite of tests scripts you",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:8614,down,download,8614,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['down'],['download']
Availability,"al maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:155479,error,error,155479,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,['error'],['error']
Availability,"alQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:202408,error,error,202408,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"al_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_met",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13608,error,errors,13608,docs/4.3/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html,7,['error'],['errors']
Availability,"alls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:88019,error,error,88019,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,5,['error'],['error']
Availability,"alseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:137408,Toler,Tolerance,137408,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['Toler'],['Tolerance']
Availability,"aluate(qobj_list, t, args)¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:qobj_list : list. A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float. The time for which to evaluate the time-dependent Qobj instance. args : dictionary. A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output : Qobj. A Qobj instance that represents the value of qobj_list at time t. expm(method=None)¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method : str {‘dense’, ‘sparse’, ‘scipy-dense’, ‘scipy-sparse’}. Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’ for using QuTiP’s; implementation of expm using dense and sparse matrices,; respectively, and ‘scipy-dense’ and ‘scipy-sparse’ for using the; scipy.linalg.expm (dense) and scipy.sparse.linalg.expm (sparse).; If no method is explicitly given a heuristic will be used to try; and automatically select the most appropriate solver. Returns:oper : qobj. Exponentiated quantum operator. Raises:TypeError :. Quantum operator is not square. extract_states(states_inds, normalize=False)¶; Qobj with states in state_inds only. Parameters:states_inds : list of integer. The states that should be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. .. note:: :. Experi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:7658,avail,available,7658,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['avail'],['available']
Availability,"aluate(qobj_list, t, args)¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:qobj_list : list. A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float. The time for which to evaluate the time-dependent Qobj instance. args : dictionary. A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output : Qobj. A Qobj instance that represents the value of qobj_list at time t. expm(method=None)¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method : str {‘dense’, ‘sparse’, ‘scipy-dense’, ‘scipy-sparse’}. Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’ for using QuTiP’s; implementation of expm using dense and sparse matrices,; respectively, and ‘scipy-dense’ and ‘scipy-sparse’ for using the; scipy.linalg.expm (dense) and scipy.sparse.linalg.expm (sparse).; If no method is explicitly given a heuristic will be used to try; and automatically select the most appropriate solver. Returns:oper : qobj. Exponentiated quantum operator. Raises:TypeError. Quantum operator is not square. extract_states(states_inds, normalize=False)¶; Qobj with states in state_inds only. Parameters:states_inds : list of integer. The states that should be kept. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Note; Experimental. f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:8777,avail,available,8777,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['avail'],['available']
Availability,"alue pairs.; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse. It's intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The param",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:13638,ERROR,ERROR,13638,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['ERROR'],['ERROR']
Availability,"alue pairs.; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse. It's intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~qutip.control.optimresult.OptimResult`,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:12153,ERROR,ERROR,12153,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,1,['ERROR'],['ERROR']
Availability,"alue. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:25826,mask,mask,25826,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,2,['mask'],['mask']
Availability,"ame value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils` in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """""". # parameters are checked in create pulse optimiser. # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The '",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:27466,error,error,27466,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"ame value pairs. They applied after the; object is created. log_level : integer; level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to ``None`` will suppress the output; of files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs': num_coeffs,; 'init_coeff_scaling': init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; gue",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:38360,error,error,38360,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"ameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes.; Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. Default is None. guess_pulse_params : dict; Parameters for the guess pulse generator object; The key value pairs are assumed to be attribu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:189207,error,error,189207,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,2,['error'],['error']
Availability,"ameter is deprecated. ""; ""Use 'scale_factor' in fid_params instead""). # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""). # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True. # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:61456,error,errors,61456,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,5,['error'],['errors']
Availability,"ameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """""". if issuper(L):. # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full().sum()) < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.matrix(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/essolve.html:5563,error,error,5563,docs/4.4/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/essolve.html,1,['error'],['error']
Availability,"amics. initial : Qobj. starting point for the evolution.; Typically the identity matrix. target : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float. Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algori",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:169304,error,error,169304,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['error'],['error']
Availability,"amics. initial : Qobj. starting point for the evolution.; Typically the identity matrix. target : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.mini",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:144302,error,error,144302,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,2,['error'],['error']
Availability,"amics. initial : Qobj. starting point for the evolution.; Typically the identity matrix. target : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. optim_alg : string. Multi-variable optimisation algorithm; options are BFGS, LBFGSB; (see Optimizer classes for details). max_metric_corr : integer. The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float. Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:132334,error,error,132334,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,2,['error'],['error']
Availability,"ams=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; H_d (Qobj or list of Qobj) – Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; H_c (Qobj) – a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; U_0 (Qobj) – starting point for the evolution.; Typically the identity matrix; U_targ (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:180572,error,error,180572,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,2,['error'],['error']
Availability,"ams=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:H_d : Qobj or list of Qobj. Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : Qobj. a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:176406,error,error,176406,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,2,['error'],['error']
Availability,"an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:192316,error,error,192316,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability,"ance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:226362,error,error,226362,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability,"and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: float, optionalSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optionalThe number of energy levels in the resonator. deltamax: int or list, optionalThe coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optionalThe coefficients of sigma-z for each of the qubits in the system. w0: int, optionalThe base frequency of the resonator. eps: int or list, optionalThe epsilon for each of the qubits in the system. delta: int or list, optionalThe epsilon for each of the qubits in the system. g: int or list, optio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:149547,avail,available,149547,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['avail'],['available']
Availability,"and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/changelog.html:5640,avail,available,5640,docs/3.0.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html,2,['avail'],['available']
Availability,"and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/changelog.html:8203,avail,available,8203,docs/3.1.0/changelog.html,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html,7,['avail'],['available']
Availability,"and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013)¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:39959,avail,available,39959,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['avail'],['available']
Availability,"and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.decomp_curr[k]:; self.spectral_decomp(k). [docs] def spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Limbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'. def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; This base class method simply returns dyn_gen[k]; other subclass methods will include some factor; """"""; return self.dyn_gen[k]. def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; This base class method simply returns ctrl_dyn_gen[j]; other subclass methods will include some factor; """"""; return self.ctrl_dyn_gen[j]. [docs]clas",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:21545,error,errors,21545,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['error'],['errors']
Availability,"and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude dam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13922,error,errors,13922,docs/4.7/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html,2,['error'],['errors']
Availability,"ange Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.qip.device.cavityqed. Source code for qutip.qip.device.cavityqed; import warnings; from copy import deepcopy. import numpy as np. from qutip.operators import tensor, identity, destroy, sigmax, sigmaz; from qutip.states import basis; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.device.processor import Processor; from qutip.qip.device.modelprocessor import ModelProcessor; from qutip.qip.operations import expand_operator; from qutip.qobj import Qobj; from qutip.qobjevo import QobjEvo; from qutip.qip.pulse import Pulse; from qutip.qip.compiler.gatecompiler import GateCompiler; from qutip.qip.compiler import CavityQEDCompiler. __all__ = ['DispersiveCavityQED']. [docs]class DispersiveCavityQED(ModelProcessor):; """"""; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class :class:`.ModelProcessor`). Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float, optional; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optional; The number of energy levels in the resonator. deltamax: int or list, optional; The coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optional; The coefficients of sigma-z for each of the qubits in the system. w0: int, optional; The base frequency of the resonator. eps: int or list, optional; The epsilon for each of the qubits in the system. delta: int or list, optional; The epsilon for each of the qubit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/device/cavityqed.html:1151,avail,available,1151,docs/4.7/modules/qutip/qip/device/cavityqed.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/device/cavityqed.html,2,['avail'],['available']
Availability,"ange Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states wit",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-measurement.html:1945,down,down,1945,docs/4.7/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html,2,['down'],['down']
Availability,"angle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. solver : str; choice of solver (me for master-equation and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:99393,error,errors,99393,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['errors']
Availability,"annel with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:4734,avail,available,4734,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,3,['avail'],['available']
Availability,"antum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-overview.html:1693,avail,available,1693,docs/4.6/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-overview.html,2,['avail'],['available']
Availability,"ape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; if isinstance(dim, int):; dim = [dim] * len(seq); return tensor([basis(dim[i], _character_to_qudit(x)); for i, x in enumerate(seq)]). def bra(seq, dim=2):; """"""; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; bra : qobj. Examples; --------; >>> bra(""10""); Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue""); Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3); Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]); Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]; """"""; return ket(seq, dim=dim).dag(). #; # quantum state number helper functions; #; [docs]def state_number_enumerate(dims, excitations=None, state=None, idx=0):; """"""; An iterator ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/states.html:17310,down,down,17310,docs/3.1.0/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/states.html,1,['down'],['down']
Availability,"ar from SciPy.optimize; The two methods implemented are:. BFGS - Broyden–Fletcher–Goldfarb–Shanno algorithm. This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS. This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4231,error,error,4231,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['error'],['error']
Availability,"arameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlatio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:118425,error,errors,118425,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['errors']
Availability,"arameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x1a2041a2b0>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-ste",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:104177,error,errors,104177,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['error'],['errors']
Availability,"arameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x2b22624ea9b0>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:86212,error,errors,86212,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['error'],['errors']
Availability,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-control.html:12901,error,errors,12901,docs/4.7/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html,2,['error'],['errors']
Availability,"are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:8106,error,error,8106,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,2,['error'],"['error', 'errors']"
Availability,"arg=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:; drift (Qobj or list of Qobj) – the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift; ctrls (List of Qobj) – a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; initial (Qobj) – starting point for the evolution.; Typically the identity matrix; target (Qobj) – target transformation, e.g. gate or state, for the time evolution; num_tslots (integer or None) – number of timeslots.; None implies that timeslots will be given in the tau array; evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:146810,error,error,146810,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,2,['error'],['error']
Availability,"arg=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:drift : Qobj or list of Qobj. the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj. a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj. starting point for the evolution.; Typically the identity matrix. target : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:142876,error,error,142876,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,2,['error'],['error']
Availability,"arget : Qobj; Quantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns; -------; fid : float; Fidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary.; """"""; kraus_form = to_kraus(oper); d = kraus_form[0].shape[0]. if kraus_form[0].shape[1] != d:; return TypeError(""Average gate fidelity only implemented for square ""; ""superoperators.""). if target is None:; return (d + np.sum([np.abs(A_k.tr())**2; for A_k in kraus_form])) / (d**2 + d); else:; return (d + np.sum([np.abs((A_k * target.dag()).tr())**2; for A_k in kraus_form])) / (d**2 + d). [docs]def tracedist(A, B, sparse=False, tol=0):; """"""; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, ""Quantum Computation and Quantum Information"". Parameters; ----------!=; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; tracedist : float; Trace distance between A and B. Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971); """"""; if A.isket or A.isbra:; A = ket2dm(A); if B.isket or B.isbra:; B = ket2dm(B). if A.dims != B.dims:; raise TypeError(""A and B do not have same dimensions.""). diff = A - B; diff = diff.dag() * diff; vals = sp_eigs(diff.data, diff.isherm, vecs=False, sparse=sparse, tol=tol); return float(np.real(0.5 * np.sum(np.sqrt(np.abs(vals))))). [docs]def hilbert_dist(A, B):; """"""; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; dist : float; Hilbert-Schmidt distance between density matrices. Notes; -----; See V. Vedral ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/metrics.html:5973,Toler,Tolerance,5973,docs/4.6/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/metrics.html,2,['Toler'],['Tolerance']
Availability,"args; ss.type = ""QobjEvo"". except Exception:; ss.h_func = H; ss.Hc_td = -0.5 * sum(ss.td_n_ops); ss.Hc_td.compile(); ss.with_state = options.rhs_with_state; ss.makefunc = _func_set; ss.set_args = _func_args; ss.type = ""callback"". solver_safe[""mcsolve""] = ss; self.ss = ss; self.reset(). def set_e_ops(self, e_ops=[]):; if e_ops:; self.e_ops = ExpectOps(e_ops); else:; self.e_ops = ExpectOps([]). self.e_ops.check_dims(self.ss.td_c_ops[0].cte.dims). ss = self.ss; if ss is not None and ss.type == ""Diagonal"" and not self.e_ops.isfunc:; e_ops = [; Qobj(ss.Ud @ e.full() @ ss.U, dims=e.dims); for e in self.e_ops.e_ops; ]; self.e_ops = ExpectOps(e_ops). if not self.e_ops:; self.options.store_states = True. def run_test(self):; try:; for c_op in self.ss.td_c_ops:; c_op.mul_vec(0, self.psi0); except Exception as e:; raise Exception(""c_ops are not consistant with psi0"") from e. if self.ss.type == ""QobjEvo"":; try:; self.ss.H_td.mul_vec(0., self.psi0); except Exception as e:; raise Exception(""Error calculating H"") from e; else:; try:; rhs, ode_args = self.ss.makefunc(self.ss); rhs(0, self.psi0.full().ravel(), ode_args); except Exception as e:; raise Exception(""Error calculating H"") from e. def run(self, num_traj=0, psi0=None, tlist=None,; args={}, e_ops=None, options=None,; progress_bar=True,; map_func=parallel_map, map_kwargs={}):; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # 4 situation for run:; # - first run; # - change parameters; # - add trajectories; # (self.add_traj) Not Implemented; # - continue from the last time and states; # (self.continue_runs) Not Implemented; # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; options = options if options is not None else self.options. if self.ran and tlist[0] == self.t:; # psi0 is ignored since we restart from a; # different states for each trajectories; self.continue_runs(num_traj, tlist, args, e_ops, options,; progress_bar, map_func, map_kwargs); return. if args and args != self.s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html:10231,Error,Error,10231,docs/4.6/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/mcsolve.html,2,['Error'],['Error']
Availability,"arrays of state vectors or density matrices for the second input:; In [67]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [68]: expect(N, states); Out[68]: array([ 0., 1., 2., 3., 4.]). In [69]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [70]: expect(c, cat_list); Out[70]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [71]: up = basis(2, 0). In [72]: down = basis(2, 1). In [73]: expect(sigmaz(), up); Out[73]: 1.0. In [74]: expect(sigmaz(), down); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-states.html:17041,down,down,17041,docs/4.2/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-states.html,3,['down'],['down']
Availability,"arrays of state vectors or density matrices for the second input:; In [67]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [68]: expect(N, states); Out[68]: array([ 0., 1., 2., 3., 4.]). In [69]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [70]: expect(c, cat_list); Out[70]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [71]: up = basis(2, 0). In [72]: down = basis(2, 1). In [73]: expect(sigmaz(), up); Out[73]: 1.0. In [74]: expect(sigmaz(), down); Out[74]: -1.0. as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; In [75]: spin1 = basis(2, 0). In [76]: spin2 = basis(2, 1). In [77]: two_spins = tensor(spin1, spin2). In [78]: sz1 = tensor(sigmaz(), qeye(2)). In [79]: sz2 = tensor(qeye(2), sigmaz()). In [80]: expect(sz1, two_spins); Out[80]: 1.0. In [81]: expect(sz2, two_spins); Out[81]: -1.0. Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-states.html:17397,down,down,17397,docs/3.1.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html,1,['down'],['down']
Availability,"arrays of state vectors or density matrices for the second input:; In [68]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [69]: expect(N, states); Out[69]: array([ 0., 1., 2., 3., 4.]). In [70]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [71]: expect(c, cat_list); Out[71]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [72]: up = basis(2, 0). In [73]: down = basis(2, 1). In [74]: expect(sigmaz(), up); Out[74]: 1.0. In [75]: expect(sigmaz(), down); Out[75]: -1.0. as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; In [76]: spin1 = basis(2, 0). In [77]: spin2 = basis(2, 1). In [78]: two_spins = tensor(spin1, spin2). In [79]: sz1 = tensor(sigmaz(), qeye(2)). In [80]: sz2 = tensor(qeye(2), sigmaz()). In [81]: expect(sz1, two_spins); Out[81]: 1.0. In [82]: expect(sz2, two_spins); Out[82]: -1.0. Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-states.html:17238,down,down,17238,docs/3.0.1/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html,1,['down'],['down']
Availability,"arrays of state vectors or density matrices for the second input:; In [68]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [69]: expect(N, states); Out[69]: array([ 0., 1., 2., 3., 4.]). In [70]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit(); ....: for x in [0, 1.0j, -1.0, -1.0j]]; ....: . In [71]: expect(c, cat_list); Out[71]: array([ 0.+0.j, 0.-1.j, -1.+0.j, 0.+1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [72]: up = basis(2, 0). In [73]: down = basis(2, 1). In [74]: expect(sigmaz(), up); Out[74]: 1.0. In [75]: expect(sigmaz(), down); Out[75]: -1.0. as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; In [76]: spin1 = basis(2, 0). In [77]: spin2 = basis(2, 1). In [78]: two_spins = tensor(spin1, spin2). In [79]: sz1 = tensor(sigmaz(), qeye(2)). In [80]: sz2 = tensor(qeye(2), sigmaz()). In [81]: expect(sz1, two_spins); Out[81]: 1.0. In [82]: expect(sz2, two_spins); Out[82]: -1.0. Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-states.html:17177,down,down,17177,docs/3.0.0/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html,1,['down'],['down']
Availability,"artial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built w",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html:4485,mask,mask,4485,docs/4.6/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/partial_transpose.html,2,['mask'],['mask']
Availability,"artial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/partial_transpose.html:4465,mask,mask,4465,docs/4.5/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/partial_transpose.html,1,['mask'],['mask']
Availability,"artial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/partial_transpose.html:4452,mask,mask,4452,docs/4.4/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/partial_transpose.html,1,['mask'],['mask']
Availability,"as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:226258,error,error,226258,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability,"as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= loggi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:21648,error,errors,21648,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['errors']
Availability,"ase of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation; Attributes. iter_num; (int) Iteration number of the pulse optimisation. fid_func_call_num; (int) Fidelity function call number of the pulse optimisation. grad_func_call_num; (int) Gradient function call number of the pulse optimisation. fid_err; (float) Fidelity error. grad_norm; (float) fidelity gradient (wrt the control parameters) vector norm that is the magnitude of the gradient. wall_time; (float) Time spent computing the pulse optimisation so far (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used; Attributes. fid_err_targ; (float) Target fidelity error. fid_goal; (float) goal fidelity, e.g. 1 - self.fid_err_targ It its typical to set this for unitary systems. max_wall_time; (float) # maximum time for optimisation (seconds). min_gradient_norm; (float) Minimum normalised gradient after which optimisation will terminate. max_iterations; (integer) Maximum iterations of the optimisation algorithm. max_fid_func_calls; (integer) Maximum number of calls to the fidelity function during the optimisation algorithm. accuracy_factor; (flo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:69322,error,error,69322,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['error'],['error']
Availability,"ask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, ps",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html:3400,mask,mask,3400,docs/4.3/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html,14,['mask'],['mask']
Availability,"asses that define the dynamics of the (quantum) system and target evolution; to be optimised.; The contols are also defined here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import os; import numpy as np; import scipy.linalg as la; from six import string_types; # QuTiP logging; import qutip.logging as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl. [docs]class Dynamics:; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before any of the methods; can be used. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; Note value should be set using set_log_level. stats : Stats; Attributes of which give performance stats for the optimisation; set to None to reduce overhead of c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:4498,error,errors,4498,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,2,['error'],['errors']
Availability,"assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC UPDATE_ALL is the; only one that currently works. (See TimeslotComputer classes; for details). tslot_paramsdictParameters for the TimeslotComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. guess_pulse_typestring, default NoneType / shape of pulse(s) used modulate the control amplitudes.; Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. guess_pulse_paramsdictParameters for the guess pulse generator object.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:213292,error,error,213292,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"ate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:6835,error,error,6835,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,11,['error'],['error']
Availability,"ates or density matrices. Returns:expt – Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Return type:float/complex/array-like. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:; oper (qobj) – Operator for expectation value.; state (qobj/list) – A single or list of quantum states or density matrices.. Returns:var – Variance of operator ‘oper’ for given state. Return type:float. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:; rho (qutip.qobj) – A density matrix.; mask (list / array) – A mask that selects which subsystems should be transposed.; method (str) – choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr – A density matrix with the selected subsystems transposed. Return type:qutip.qobj. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state (qobj) – Ket, bra, or density matrix for a two-qubit state. Returns:concur – Concurrence. Return type:float. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:; rho (qo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:44775,mask,mask,44775,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['mask'],['mask']
Availability,"ath. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this us",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-basics.html:1316,avail,available,1316,docs/4.7/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-basics.html,2,['avail'],['available']
Availability,"ath:`t`. Must be uniformly spaced. c_ops : list of time_dependent_object; List of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_ops : list of time_dependent_object; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; ``c_ops``. e_ops : list of :class:`qutip.Qobj`; Single operator or list of operators for which to evaluate; expectation values. m_ops : list of :class:`qutip.Qobj`; List of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict; Dictionary of parameters for time dependent systems. tol : float; Tolerance of the solver for implicit methods. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in `times`. dW_factors : array; Array of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:. - order 1/2 algorithms: 'euler-maruyama', 'pc-euler', 'pc-euler-imp'; - order 1 algorithms: 'milstein', 'platen', 'milstein-imp', 'rouchon'; - order 3/2 algorithms: 'taylor1.5', 'taylor1.5-imp', 'explicit1.5'; - order 2 algorithms: 'taylor2.0'. See the documentation of :func:`~qutip.stochastic.stochastic_solvers`; for a description of the solvers. Implicit methods can adjust; tolerance via the kw 'tol'. Default is {'tol': 1e-6}. method : string ('homodyne', 'heterodyne'); The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expect : bool (default False); Whether or not to",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:10065,Toler,Tolerance,10065,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,2,['Toler'],['Tolerance']
Availability,"ation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option). @property; def phase_option(self):; return self._phase_option. @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)). [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; self.dimensional_norm = 1.0; self.dimensional_norm = \; self.fid_norm_func(dyn.target.dag()*dyn.target). [do",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:11408,error,errors,11408,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['error'],['errors']
Availability,"ations; sso.A_ops = sso.generate_A_ops(sso.sc_ops, sso.L.data, sso.dt). # use .data instead of Qobj ?; sso.s_e_ops = [spre(e) for e in sso.e_ops]. if sso.m_ops:; sso.s_m_ops = [[spre(m) if m else None for m in m_op]; for m_op in sso.m_ops]; else:; sso.s_m_ops = [[spre(c) for _ in range(sso.d2_len)]; for c in sso.sc_ops]. map_kwargs = {'progress_bar': progress_bar}; map_kwargs.update(sso.map_kwargs). task = _smesolve_single_trajectory; task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs). for result in results:; states_list, dW, m, expect, ss = result; data.states.append(states_list); data.noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += ss. # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[mm][n] for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _smesolve_single_trajectory(n, sso):; """"""; Internal function. See smesolve.; """"""; dt = sso.dt; times = sso.times; d1, d2 = sso.d1, sso.d2; d2_len = sso.d2_len; L_data = sso.L.data; N_substeps = sso.N_substeps; N_store = sso.N_store; A_ops = sso.A_ops. rho_t = mat2vec(sso.state0.full()).ravel(); dims = sso.state0.dims. expect = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex); ss = np.zeros((len(sso.e_ops), sso.N_store), dtype=complex). # reseed the random number generator so that forked; # processes do not get the same sequence of random numbers; np.random.seed((n+1) * np.random.randint(0, 4294967295 // (sso.ntraj+1))). if sso.noise is None:; if sso.generate_noise:; dW = sso.generate_noise(len(A_ops), N_stor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:27639,error,error,27639,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,5,['error'],['error']
Availability,"ation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. version; 4.5. status; Released (January 30, 2020). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the syst",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/frontmatter.html:1372,down,download,1372,docs/4.5/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.5/frontmatter.html,1,['down'],['download']
Availability,ato-regular.eot; lato-regular-1.eot. lato-regular-1.eot; lato-regular.ttf; lato-regular.woff; lato-regular.woff2. /RobotoSlab; . roboto-slab-v7-bold.eot. roboto-slab-v7-bold.eot; roboto-slab-v7-bold-1.eot. roboto-slab-v7-bold-1.eot; roboto-slab-v7-bold.ttf; roboto-slab-v7-bold.woff; roboto-slab-v7-bold.woff2; roboto-slab-v7-regular.eot; roboto-slab-v7-regular.ttf; roboto-slab-v7-regular.woff; roboto-slab-v7-regular.woff2. fontawesome-webfont-1.eot; fontawesome-webfont.eot; fontawesome-webfont.svg; fontawesome-webfont.ttf; fontawesome-webfont.woff; fontawesome-webfont.woff2. /js; ; modernizr.min.js; theme.js. doctools.js; documentation_options.js; favicon.ico; jquery.js; language_data.js; pygments.css; searchtools.js; underscore.js. /4.5; . /apidoc; ; API documentation — QuTiP 4.5 Documentation; Classes — QuTiP 4.5 Documentation; Functions — QuTiP 4.5 Documentation. Bibliography — QuTiP 4.5 Documentation; Change Log — QuTiP 4.5 Documentation; Developers — QuTiP 4.5 Documentation. /downloads; . /0a0d7dafe3f05d5f557344a23a835b36; ; plot_qip_amplitude_noise.py. /14df9cb9ce9929475a42b569fbb148fc; ; plot_qip_intro_processor.ipynb. /59247c9cb8a48d534ebd46ff105c141b; ; plot_qip_amplitude_noise.ipynb. /839a90675d1beebb9439ea0d47dac946; ; plot_qip_relaxation.py. /e1a1bbebf99cf434ac461d7e6da91f40; ; qutip_tree.pdf. /e57ad33a2917887dba8bce16c8b8588d; ; plot_qip_relaxation.ipynb. /f96e7cc4c3405f73eeeff70f35cf5f6f; ; plot_qip_intro_processor.py. Frontmatter — QuTiP 4.5 Documentation. /gallery; . /qutip_examples; . /qip; ; Control Amplitude Noise — QuTiP 4.5 Documentation; Basic use of Processor — QuTiP 4.5 Documentation; T2 Relaxation — QuTiP 4.5 Documentation. Gallery — QuTiP 4.5 Documentation. Index — QuTiP 4.5 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 4.5 Documentation; Dynamics Simulation Results — QuTiP 4.5 Documentation; Floquet Formalism — QuTiP 4.5 Documentation; Lindblad Master Equation Solver — QuTiP 4.5 Documentation; Monte Carlo Solv,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:40529,down,downloads,40529,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['down'],['downloads']
Availability,"ators. initial : Qobj. starting point for the evolution.; Typically the identity matrix. target : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float. Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algori",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:171825,error,error,171825,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['error'],['error']
Availability,"ators. initial : Qobj. starting point for the evolution.; Typically the identity matrix. target : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.mini",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:146494,error,error,146494,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability,"atrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators “is equal” == and “is not equal” != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Cosine; Q.cosm(); Cosine of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Diamond Norm; Q.dnorm(); Returns the diamond norm. Eige",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-basics.html:9570,error,error,9570,docs/4.6/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html,4,['error'],['error']
Availability,"atsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provid",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:233483,error,error,233483,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['error'],['error']
Availability,"atsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provid",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:245601,error,error,245601,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['error'],['error']
Availability,"atter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure-qutip_org. Tree-diagram of the 361 user accessible functions and classes in QuTiP 4.4. A vector image of the code tree is in qutip_tree.pdf. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-overview.html:1647,avail,available,1647,docs/4.4/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-overview.html,1,['avail'],['available']
Availability,"babilities.append(probability); cbits_results.append(self.cbits). return CircuitResult(states, probabilities, cbits_results). [docs] def step(self):; '''; Return state after one step of circuit evolution; (gate or measurement). Returns; -------; state : ket or oper; state after one evolution step.; '''. op = self.ops[self.op_index]; if isinstance(op, Measurement):; self._apply_measurement(op); elif isinstance(op, tuple):; operation, U = op; apply_gate = all([self.cbits[i] for i; in operation.classical_controls]); if apply_gate:; if self.precompute_unitary:; U = expand_operator(U, self.qc.N,; operation.get_inds(self.qc.N)); self._evolve_state(U); else:; self._evolve_state(op). self.op_index += 1; return self.state. def _evolve_state(self, U):; '''; Applies unitary to state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. if self.mode == ""state_vector_simulator"":; self._evolve_ket(U); elif self.mode == ""density_matrix_simulator"":; self._evolve_dm(U); else:; raise NotImplementedError(; ""mode {} is not available."".format(self.mode)). def _evolve_ket(self, U):; '''; Applies unitary to ket state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. self.state = U * self.state. def _evolve_dm(self, U):; '''; Applies unitary to density matrix state. Parameters; ----------; U: Qobj; unitary to be applied.; '''. self.state = U * self.state * U.dag(). def _apply_measurement(self, operation):; '''; Applies measurement gate specified by operation to current state. Parameters; ----------; operation: :class:`.Measurement`; Measurement gate in a circuit object.; '''. states, probabilities = operation.measurement_comp_basis(self.state). if self.mode == ""state_vector_simulator"":; if self.measure_results:; i = int(self.measure_results[self.measure_ind]); self.measure_ind += 1; else:; probabilities = [p/sum(probabilities) for p in probabilities]; i = np.random.choice([0, 1], p=probabilities); self.probability *= probabilities[i]; self.state = states[i]; if operat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html:63962,avail,available,63962,docs/4.6/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/circuit.html,4,['avail'],['available']
Availability,"back function. thres; (float) Threshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below treshold. options; (qutip.solver.Options) Generic solver options. Solver Options and Results¶. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, seeds=None, steady_state_average=False, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers.; Attributes. atol; (float {1e-8}) Absolute tolerance. rtol; (float {1e-6}) Relative tolerance. method; (str {‘adams’,’bdf’}) Integration method. order; (int {12}) Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nsteps; (int {2500}) Max. number of internal steps/call. first_step; (float {0}) Size of initial step (0 = automatic). min_step; (float {0}) Minimum step size (0 = automatic). max_step; (float {0}) Maximum step size (0 = automatic). tidy; (bool {True,False}) Tidyup Hamiltonian and initial state by removing small terms. num_cpus; (int) Number of cpus used by mcsolver (default = # of cpus). norm_tol; (float) Tolerance used when finding wavefunction norm in mcsolve. norm_steps; (int) Max. number of steps used to find wavefunction norm to within norm_tol in mcsolve. average_states; (bool {False}) Average states values over trajectories in stochastic solvers. average_expect; (bool {True}) Average expectation values over trajectories for stochastic solvers. mc_corr_eps; (float {1e-10}) Arbitrarily small value for elim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:33002,toler,tolerance,33002,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['toler'],['tolerance']
Availability,"bal phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:106799,error,error,106799,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability,"basis(3,2); >>> ket2dm(x); Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j]]. """"""; if Q.type == 'ket':; out = Q * Q.dag(); elif Q.type == 'bra':; out = Q.dag() * Q; else:; raise TypeError(""Input is not a ket or bra vector.""); return Qobj(out). #; # projection operator; #; def projection(N, n, m, offset=0):; """"""The projection operator that projects state |m> on state |n>: |n><m|. Parameters; ----------. N : int; Number of basis states in Hilbert space. n, m : float; The number states in the projection. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the projector. Returns; -------; oper : qobj; Requested projection operator.; """"""; ket1 = basis(N, n, offset=offset); ket2 = basis(N, m, offset=offset). return ket1 * ket2.dag(). #; # composite qubit states; #; def qstate(string):; """"""Creates a tensor product for a set of qubits in either; the 'up' :math:`|0>` or 'down' :math:`|1>` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu'); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/states.html:14192,down,down,14192,docs/3.1.0/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/states.html,1,['down'],['down']
Availability,"be applied as dg*phase; """"""; if hasattr(self.dyn_gen_phase, 'dot'):; phased_dg = dg.dot(self._dyn_gen_phase); else:; phased_dg = dg*self._dyn_gen_phase; return phased_dg. def _create_decomp_lists(self):; """"""; Create lists that will hold the eigen decomposition; used in calculating propagators and gradients; Note: used with PropCompDiag propagator calcs; """"""; n_ts = self.num_tslots; self._decomp_curr = [False for x in range(n_ts)]; self._prop_eigen = [object for x in range(n_ts)]; self._dyn_gen_eigenvectors = [object for x in range(n_ts)]; if self.cache_dyn_gen_eigenvectors_adj:; self._dyn_gen_eigenvectors_adj = [object for x in range(n_ts)]; self._dyn_gen_factormatrix = [object for x in range(n_ts)]. [docs] def initialize_controls(self, amps, init_tslots=True):; """"""; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:30537,error,errors,30537,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,6,['error'],['errors']
Availability,"be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # check parameters here, as names are different than in; # create_pulse_optimizer, so TypeErrors would be confusing. if not isinstance(H_d, Qobj):; if not isinstance(H_d, (list, tuple)):; raise TypeError(""H_d should be a Qobj or a list of Qobj""); else:; for H in H_d:; if not isinstance(H, Qobj):; raise TypeError(""H_d should be a Qobj or a list of Qobj""). if not isinstance(H_c, (list, tuple)):; raise TypeError(""H_c should be a list of Qobj""); else:; for ctrl in H_c:; if not isinstance(ctrl, Qobj):; raise TypeError(""H_c should be a list of Qobj""). if not isinstance(U_0, Qobj):; raise TypeError(""U_0 must be a Qobj""). if not isinstance(U_targ, Qobj):; raise TypeError(""U_targ must be a Qobj""); ; # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is depreca",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:26845,error,error,26845,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser. # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The 'accurac",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:27037,error,error,27037,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,1,['error'],['error']
Availability,"be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser; ; # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The 'a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:27066,error,error,27066,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['error'],['error']
Availability,"be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. reverse : bool {False, True}. If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str {‘me’, ‘mc’, ‘es’}. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options. Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec : ndarray. An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj. Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like. list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:84496,error,errors,84496,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['errors']
Availability,"be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : bool {False, True}; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str {‘me’, ‘mc’, ‘es’}; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; Solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : ndarray; An array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. state0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking stea",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:85290,error,errors,85290,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['errors']
Availability,"be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : list / array; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. :math:`t. ightarrow infty`; here tlist is. automatically set, ignoring user input. taulist : list / array; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list of qutip.qobj.Qobj; list of collapse operators. (does not accept time dependence). a_op : qutip.qobj.Qobj; operator A. b_op : qutip.qobj.Qobj; operator B. c_op : qutip.qobj.Qobj; operator C. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : qutip.solver.Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat: array. An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args=None, options=<qutip.solver.Options instance at 0x105963ab8>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:H : qutip.qobj.Qobj. system Hamiltonian. rho0 : qutip.qobj.Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:78803,error,errors,78803,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['error'],['errors']
Availability,"bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if ss_args['info']['precond_time'] is not None:; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); else:; ss_args['info']['solution_time'] = ss_args['info']['iter_time']; ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['solution_time'] = _svd_end-_svd_start; if ss_args['all_states']:; rhoss_list = []; for n in range(ns.shape[1]):; rhoss = Qobj(vec2mat(ns[:, n]), dims=L.dims[0]); rhoss_list.append(rhoss / rhoss.tr()); if ss_args['return_info']:; retur",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/steadystate.html:20976,error,error,20976,docs/4.2/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/steadystate.html,6,['error'],['error']
Availability,"bj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [21]: q = destroy(4). In [22]: x = sigmax(). In [23]: q + 5; Out[23]: ; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. In [24]: x * x; Out[24]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. In [25]: q ** 3; Out[25]: ; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. In [26]: x / np.sqrt(2); Out[26]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; In [27]: q * x; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-27-57f05cd0899f> in <module>; ----> 1 q * x. /miniconda3/envs/release/lib/python3.6/site-packages/qutip-4.5.0-py3.6-macosx-10.9-x86_64.egg/qutip/qobj.py in __mul__(self, other); 553 ; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556 ; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators is equal == and is not equal != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Cosine; Q.cosm(); Cosine of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-basics.html:9747,error,error,9747,docs/4.5/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-basics.html,1,['error'],['error']
Availability,"bj data =; [[ 1. 0.]; [ 0. -1.]]. """"""; return 2.0 * jmat(1.0 / 2, 'z'). #; # DESTROY returns annihilation operator for N dimensional Hilbert space; # out = destroy(N), N is integer value & N>0; #; [docs]def destroy(N, offset=0):; '''Destruction (lowering) operator. Parameters; ----------; N : int; Dimension of Hilbert space. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Returns; -------; oper : qobj; Qobj for lowering operator. Examples; --------; >>> destroy(4); Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); return Qobj(sp.spdiags(np.sqrt(range(offset, N+offset)),; 1, N, N, format='csr')). #; # create returns creation operator for N dimensional Hilbert space; # out = create(N), N is integer value & N>0; #; [docs]def create(N, offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4); Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # rais",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/operators.html:9214,error,error,9214,docs/3.1.0/modules/qutip/operators.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/operators.html,1,['error'],['error']
Availability,"bj, isket, isoper, issuper; from qutip.states import ket2dm; from qutip.solver import Result; from qutip.qobjevo import QobjEvo; from qutip.superoperator import spre, spost, mat2vec, liouvillian; from qutip.solver import Options; from qutip.parallel import serial_map; from qutip.ui.progressbar import TextProgressBar; from qutip.pdpsolve import main_ssepdpsolve, main_smepdpsolve. __all__ = ['ssesolve', 'photocurrent_sesolve', 'smepdpsolve',; 'smesolve', 'photocurrent_mesolve', 'ssepdpsolve',; 'stochastic_solvers', 'general_stochastic']. [docs]def stochastic_solvers():; # This docstring contains several literal backslash characters inside LaTeX; # blocks, but it cannot be declared as a raw string because we also need to; # use a line continuation. At one point we need a restructured text; # ""definition list"", where the heading _must_ be entirely on one line,; # however it will violate our line-length reporting if we do that.; """"""; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions. Notes; -----; Available solvers for :obj:`~ssesolve` and :obj:`~smesolve`; euler-maruyama; A simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting ``sc_ops``. *not tested*. - Order 0.5; - Code: ``'euler-maruyama'``, ``'euler'`` or ``0.5``. milstein; An order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]_. - Order strong 1.0; - Code: ``'milstein'`` or ``1.0``. milstein-imp; An order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. - Order strong 1.0; - Code: ``'milstein-imp'``. predictor-corrector; Generalization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:3285,avail,available,3285,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['avail'],['available']
Availability,"bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:19412,error,errors,19412,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['errors']
Availability,"bute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It use",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:82814,error,error,82814,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability,"bute name value pairs. They applied after the; object is created. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~OptimResult`, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc.; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""). if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""). if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:14410,error,error,14410,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-settings.html:3619,toler,tolerance,3619,docs/3.1.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html,1,['toler'],['tolerance']
Availability,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/guide/guide-settings.html:3579,toler,tolerance,3579,docs/3.0.1/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-settings.html,1,['toler'],['tolerance']
Availability,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-settings.html:3517,toler,tolerance,3517,docs/3.0.0/guide/guide-settings.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html,1,['toler'],['tolerance']
Availability,"c directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the n",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:6681,down,down,6681,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['down'],['down']
Availability,"c solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:40467,toler,tolerance,40467,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,4,['toler'],['tolerance']
Availability,"c use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:1655,Down,Download,1655,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,2,['Down'],['Download']
Availability,"c_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. Steady-state Solvers¶; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters:; A : qobj; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : str {None, ‘scipy’, ‘mkl’}; Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. method : str {‘direct’, ‘eigen’, ‘iterative-gmres’,. ‘iterative-lgmres’, ‘iterative-bicgstab’, ‘svd’, ‘power’,; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’}. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’,; iterative GMRES method ‘iterative-gmres’, iterative LGMRES method; ‘iterative-lgmres’, iterative BICGSTAB method ‘iterative-bicgstab’,; SVD ‘svd’ (dense), or inverse-power method ‘power’. The iterative; power methods ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use; the same solvers as their direct counterparts. return_info : bool, optional, default = False; Return a dictionary of solver-specific infomation about the; solution and how it was obtained. sparse : bool, optional, default = True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:101870,avail,availability,101870,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['avail'],['availability']
Availability,"calculated; """"""; self._check_test_out_files(). if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FideliyComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; # Note this call is made just to initialise the num_ctrls attrib; self.get_num_ctrls(). if init_tslots:; self.init_time_slots(); self._init_lists(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:16011,error,errors,16011,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['error'],['errors']
Availability,"callable(e_ops):; n_expt_op = 0; expt_callback = True; output.num_expect = 1; elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False; output.num_expect = n_expt_op; if n_expt_op == 0:; # fallback on storing states; opt.store_states = True; else:; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); if oper_evo:; for e in e_ops:; e_ops_data.append(e.dag().data); else:; for e in e_ops:; e_ops_data.append(e.data); else:; raise TypeError(""Expectation parameter must be a list or a function""). if opt.store_states:; output.states = []. if oper_evo:; def get_curr_state_data(r):; return vec2mat(r.y); else:; def get_curr_state_data(r):; return r.y. #; # start evolution; #; dt = np.diff(tlist); cdata = None; progress_bar.start(n_tsteps); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""); # get the current state / oper data if needed; if opt.store_states or opt.normalize_output or n_expt_op > 0 or expt_callback:; cdata = get_curr_state_data(r). if opt.normalize_output:; # normalize per column; if oper_evo:; cdata /= la_norm(cdata, axis=0); #cdata *= norm_dim_factor / la_norm(cdata); r.set_initial_value(cdata.ravel('F'), r.t); else:; #cdata /= la_norm(cdata); norm = normalize_inplace(cdata); if norm > 1e-12:; # only reset the solver if state changed; r.set_initial_value(cdata, r.t); else:; r._y = cdata. if opt.store_states:; if oper_evo:; fdata = dense2D_to_fastcsr_fmode(cdata, size, size); output.states.append(Qobj(fdata, dims=dims)); else:; fdata = dense1D_to_fastcsr_ket(cdata); output.states.append(Qobj(fdata, dims=dims, fast='mc')). if expt_callback:; # use callback method; output.expect.append(e_ops(t, Qobj(cdata, dims=dims))). if oper_evo:; for m in range(n_expt_op):; output.expe",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/sesolve.html:10878,error,error,10878,docs/4.4/modules/qutip/sesolve.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/sesolve.html,2,['error'],['error']
Availability,"can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:210773,error,error,210773,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:184841,error,error,184841,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['error'],['error']
Availability,"can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:160109,error,error,160109,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,4,['error'],['error']
Availability,"can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:202341,error,error,202341,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"cation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude value",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:4631,ERROR,ERROR,4631,docs/4.6/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html,2,['ERROR'],['ERROR']
Availability,"ccepts lists or arrays of state vectors or density matrices for the second input:; In [68]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [69]: expect(N, states); Out[69]: array([0., 1., 2., 3., 4.]). In [70]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. In [71]: expect(c, cat_list); Out[71]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [72]: up = basis(2, 0). In [73]: down = basis(2, 1). In [74]: expect(sigmaz(), up); Out[74]: 1.0. In [75]: expect(sigmaz(), down); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-states.html:17207,down,down,17207,docs/4.4/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-states.html,1,['down'],['down']
Availability,"ccepts lists or arrays of state vectors or density matrices for the second input:; In [68]: states = [(c**k * vac).unit() for k in range(5)] # must normalize. In [69]: expect(N, states); Out[69]: array([0., 1., 2., 3., 4.]). In [70]: cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. In [71]: expect(c, cat_list); Out[71]: array([ 0.+0.j, 0.+1.j, -1.+0.j, 0.-1.j]). Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; In [72]: up = basis(2, 0). In [73]: down = basis(2, 1). In [74]: expect(sigmaz(), up); Out[74]: 1.0. In [75]: expect(sigmaz(), down); Out[75]: -1.0. as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; In [76]: spin1 = basis(2, 0). In [77]: spin2 = basis(2, 1). In [78]: two_spins = tensor(spin1, spin2). In [79]: sz1 = tensor(sigmaz(), qeye(2)). In [80]: sz2 = tensor(qeye(2), sigmaz()). In [81]: expect(sz1, two_spins); Out[81]: 1.0. In [82]: expect(sz2, two_spins); Out[82]: -1.0. Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-states.html:16856,down,down,16856,docs/4.5/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-states.html,1,['down'],['down']
Availability,"ce of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means the individual, individuals, entity or entities that; offer(s) the Work under the terms of this License.; “Original Author” means, in the case of a literary or artistic work, the; individual, individuals, entity or entities who created the Work or if no; individual or entity can be identified, the publisher; and in addition; (i) in the case of a performance the actors, singers, musicians, dancers,; and other persons who act, sing, deliver, declaim, play in, interpret or; otherwise perform literary or artistic works or expressions of folklore;; (ii) in the case of a phonogram the producer being the person or legal; entity who first fixes the sounds of a performance or other sounds; and,; (iii) in the case of broadcasts, the organization that transmits the; broadcast.; “Work” means the literary and/or artistic work offered under the terms of; this License including without limitation any",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/copyright-1.html:3099,avail,available,3099,docs/4.7/copyright-1.html,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html,2,['avail'],['available']
Availability,"ce(args, dict) or args is None:; if args is None:; _args = {""_t0"": 0}; else:; _args = args.copy(); _args[""_t0""] = 0; H_shifted = lambda t, args_i: H(t+args_i[""_t0""], args_i); else:; raise TypeError(""If using function-callback based Hamiltonian"" +; ""time-dependence, args must be a dictionary""). if isinstance(H, list) or c_ops_is_td:; # string/function-list based time-dependence; if args is None:; _args = {""_t0"": 0}; elif isinstance(args, dict):; _args = args.copy(); _args[""_t0""] = 0; else:; _args = {""_user_args"": args, ""_t0"": 0}. if isinstance(H, list):; # hamiltonian is time-dependent; H_shifted = []. for i in range(len(H)):; if isinstance(H[i], list):; # modify Hamiltonian time dependence in accordance with the; # quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check already raises; # errors formixed td formatting; fn = sub(""(?<=[^0-9a-zA-Z_])t(?=[^0-9a-zA-Z_])"",; ""(t+_t0)"", H[i][1]); else:; if isinstance(H[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; H[i][1](t + args_i[""_t0""],; args_i[""_user_args""]); else:; raise TypeError(""If using string-list based"" +; ""Hamiltonian time-dependence, "" +; ""args must be a dictionary""); H_shifted.append([H[i][0], fn]); else:; H_shifted.append(H[i]). if c_ops_is_td:; # collapse operators are time-dependent; c_ops_shifted = []. for i in range(len(c_ops)):; if isinstance(c_ops[i], list):; # modify collapse operators time dependence in accordance; # with the quantum regression theorem; if isinstance(args, dict) or args is None:; if isinstance(c_ops[i][1], types.FunctionType):; # function-list based time-dependence; fn = lambda t, args_i: \; c_ops[i][1](t + args_i[""_t0""], args_i); else:; # string-list based time-dependence; # Again, note: _td_format_check",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:40060,error,errors,40060,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,5,['error'],['errors']
Availability,"ceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:64910,error,errors,64910,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,5,['error'],['errors']
Availability,"cept errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_call",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:20405,error,error,20405,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['error']
Availability,"ception('inplace kwarg must be bool.'). [docs] def ptrace(self, sel):; """"""Partial trace of the quantum object. Parameters; ----------; sel : int/list; An ``int`` or ``list`` of components to keep after partial trace. Returns; -------; oper : qobj; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q. [docs] def permute(self, order):; """"""Permutes a composite quantum object. Parameters; ----------; order : list/array; List specifying new tensor order. Returns; -------; P : qobj; Permuted quantum object. """"""; q = Qobj(); q.data, q.dims = _permute(self, order); return q.tidyup() if settings.auto_tidyup else q. [docs] def tidyup(self, atol=settings.auto_tidyup_atol):; """"""Removes small elements from the quantum object. Parameters; ----------; atol : float; Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns; -------; oper : qobj; Quantum object with small elements removed. """"""; if self.data.nnz:; #This does the tidyup and returns True if; #The sparse data needs to be shortened; if use_openmp() and self.data.nnz > 500:; if omp_tidyup(self.data.data,atol,self.data.nnz,; settings.num_cpus):; self.data.eliminate_zeros(); else:; if cy_tidyup(self.data.data,atol,self.data.nnz):; self.data.eliminate_zeros(); return self; else:; return self. [docs] def transform(self, inpt, inverse=False, sparse=True):; """"""Basis transform defined by input array. Input array can be a ``matrix`` defining the transformation,; or a ``list`` of kets that defines the new basis. Parameters; ----------; inpt : array_like; A ``matrix`` or ``list`` of kets defining the transformation.; inverse : bool; Whether to return inverse transformation.; sparse : bool; Use sparse matrices when possible. Can be slower. Returns; -------; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:33488,toler,tolerance,33488,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['toler'],['tolerance']
Availability,"cessor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); >>> processor.add_control(sigmax(), cyclic_permutation=True); >>> processor.add_control(sigmay(), cyclic_permutation=True); >>> processor.add_control(tensor([sigmay(), sigmay()])); >>> setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ... ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ... ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}; >>> tlist, coeffs = processor.load_circuit(; ... qc, setting_args=setting_args, merge_gates=False). Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors. The typical approaches are either applying bit/sign flipping gate probabilistically or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous time evolution. Instead, the error is added to the driving Hamiltonian list (coherent control error) or the collapse operators (decoherent error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-qip.html:13810,error,error,13810,docs/4.5/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-qip.html,1,['error'],['error']
Availability,"ch argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters:pairs : tuple. One or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns:cqobj : Qobj. The original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http:/",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:42919,mask,mask,42919,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['mask'],['mask']
Availability,"ciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:34461,avail,available,34461,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['avail'],['available']
Availability,"class, for representing quantum states and; operators, and related functions. dag(A)[source]¶; Adjont operator (dagger) of a quantum object. Parameters. Aqutip.QobjInput quantum object. Returns. operqutip.QobjAdjoint of input operator. Notes; This function is for legacy compatibility only. It is recommended to use; the dag() Qobj method. dims(inpt)[source]¶; Returns the dims attribute of a quantum object. Parameters. inptqutip.QobjInput quantum object. Returns. dimslistA list of the quantum objects dimensions. Notes; This function is for legacy compatibility only. Using the Qobj.dims; attribute is recommended. isbra(Q)[source]¶; Determines if given quantum object is a bra-vector. Parameters. Qqutip.QobjQuantum object. Returns. isbraboolTrue if Qobj is bra-vector, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isbra; attribute is recommended.; Examples; >>> psi = basis(5,2); >>> isket(psi); False. isequal(A, B, tol=None)[source]¶; Determines if two qobj objects are equal to within given tolerance. Parameters. Aqutip.QobjQobj one. Bqutip.QobjQobj two. tolfloatTolerence for equality to be valid. Returns. isequalboolTrue if qobjs are equal, False otherwise. Notes; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. isherm(Q)[source]¶; Determines if given operator is Hermitian. Parameters. Qqutip.QobjQuantum object. Returns. ishermboolTrue if operator is Hermitian, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isherm; attribute is recommended.; Examples; >>> a = destroy(4); >>> isherm(a); False. isket(Q)[source]¶; Determines if given quantum object is a ket-vector. Parameters. Qqutip.QobjQuantum object. Returns. isketboolTrue if qobj is ket-vector, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isket; attribute is recommended.; Examples; >>> psi = basis(5,2); >>> is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:33348,toler,tolerance,33348,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['toler'],['tolerance']
Availability,"classes are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at http://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Krista",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html:2088,error,error,2088,docs/4.6/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.6/development/ideas/quantum-error-mitigation.html,2,['error'],['error']
Availability,"cludes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms.; We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶; The default Anaconda environment has all the Python packages needed for running QuTiP.; You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment.; You may wish to this for many reasons:. It is a good idea generally; You are using MS Windows and want to use Python 3; You are using Miniconda because you do not have the disk space for full Anaconda. To create a Conda env for QuTiP called qutip:-; (note the python=3 can be ommited if you want the default Python version, if you want to use Python 3 with MS Windows, then it must be python=3.4); recommended:; conda create -n qutip python=3 mkl numpy scipy cython matplotlib nose multiprocess jupyter notebook spyder. minimum (recommended):; c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:2649,avail,available,2649,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['avail'],['available']
Availability,"complete guidelines in the documentation. (#1549 by Jake Lishman); The release documentation was reworked after the initial 4.6.1 to match the actual release process. (#1544 by Jake Lishman). Version 4.6.3 (February 9, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:15276,fault,faults,15276,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['fault'],['faults']
Availability,"complex); data.measurement = []; data.solver = sso.solver_name; data.ntraj = sso.ntraj; data.num_expect = len(sso.e_ops). nt = sso.ntraj; task = _single_trajectory; map_kwargs = {'progress_bar': sso.progress_bar}; map_kwargs.update(sso.map_kwargs); task_args = (sso,); task_kwargs = {}. results = sso.map_func(task, list(range(sso.ntraj)),; task_args, task_kwargs, **map_kwargs); noise = []; for result in results:; states_list, dW, m, expect = result; data.states.append(states_list); noise.append(dW); data.measurement.append(m); data.expect += expect; data.ss += expect * expect; data.noise = np.stack(noise). if sso.store_all_expect:; paths_expect = []; for result in results:; paths_expect.append(result[3]); data.runs_expect = np.stack(paths_expect). # average density matrices; if options.average_states and np.any(data.states):; data.states = [sum([data.states[mm][n] for mm in range(nt)]).unit(); for n in range(len(data.times))]. # average; data.expect = data.expect / nt. # standard error; if nt > 1:; data.se = (data.ss - nt * (data.expect ** 2)) / (nt * (nt - 1)); else:; data.se = None. # convert complex data to real if hermitian; data.expect = [np.real(data.expect[n, :]); if e.isherm else data.expect[n, :]; for n, e in enumerate(sso.e_ops)]. return data. def _single_trajectory(i, sso):; # Only one step?; ssolver = sso.solver_obj(); #ssolver.set_data(sso); ssolver.set_solver(sso); result = ssolver.cy_sesolve_single_trajectory(i)#, sso); return result. # The code for ssepdpsolve have been moved to the file pdpsolve.; # The call is still in stochastic for consistance.; [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector (ket). times : *list* / *array*; List of times",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:40867,error,error,40867,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['error'],['error']
Availability,"components; remaining. Return type:qobj. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. sinm()[source]¶; Sine of a quantum operator.; Operator must be square. Returns:oper – Matrix sine of operator. Return type:qobj. Raises:TypeError – Quantum object is not square. Notes; Uses the Q.expm() method. sqrtm(sparse=False, tol=0, maxiter=100000)[source]¶; Sqrt of a quantum operator.; Operator must be square. Parameters:; sparse (bool) – Use sparse eigenvalue/vector solver.; tol (float) – Tolerance used by sparse solver (0 = machine precision).; maxiter (int) – Maximum number of iterations used by sparse solver. Returns:oper – Matrix square root of operator. Return type:qobj. Raises:TypeError – Quantum object is not square. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. tidyup(atol=None)[source]¶; Removes small elements from the quantum object. Parameters:atol (float) – Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns:oper – Quantum object with small elements removed. Return type:qobj. tr()[source]¶; Trace of a quantum object. Returns:trace – Returns real if operator is Hermitian, returns complex; otherwise. Return type:float. trans()[source]¶; Transposed operator. Returns:oper – Transpose of input operator. Return type:qobj. transform(inpt, inverse=False, sparse=True)[source]¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters:; inpt (array_like) – A matrix or list of kets defining the transformation.; inverse (bool) – Whether to return inverse transformation.; sparse (bool) – Use sparse matrices when possible. Can be slower. Returns:oper – Operator in new basis. Return type:qobj. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormal",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:13907,toler,tolerance,13907,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:14612,down,downarrow,14612,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,4,['down'],['downarrow']
Availability,"cs generator for the control; Not implemented in the base class. Choose a subclass; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. [docs] def ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self.decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self.decomp_curr[k]:; self.spectral_decomp(k). [docs] def spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Limbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'. def get_dyn_gen(self, k):; """"""; Get the combined dynamics generator for the timeslot; This base class method simply returns dyn_gen[k]; other subcla",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:21092,error,errors,21092,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['error'],['errors']
Availability,"cstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Changelog Generation¶; We use towncrier for tracking changes and generating a changelog.; When making a pull request, we require that you add a towncrier entry along with the code changes.; You should create a file named <PR number>.<change type> in the doc/changes directory, where the PR number should be substituted for <PR number>, and <change type> is either feature, bugfix, doc, removal, misc, or deprecation,; depending on the type of change included in the PR.; You can also create this file by installing towncrier and running. towncrier create <PR number>.<change typ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/contributing.html:8686,failure,failures,8686,docs/4.7/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html,4,"['error', 'failure']","['error', 'failures']"
Availability,"cstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on oc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:8639,failure,failures,8639,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,4,"['error', 'failure']","['error', 'failures']"
Availability,"ct is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:58443,ERROR,ERROR,58443,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,1,['ERROR'],['ERROR']
Availability,"ct is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/solver.html:11673,toler,tolerance,11673,docs/3.1.0/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html,1,['toler'],['tolerance']
Availability,"ct is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix da",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/solver.html:10706,toler,tolerance,10706,docs/4.0.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/solver.html,2,['toler'],['tolerance']
Availability,"ct is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem; ; self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs ; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/solver.html:11208,toler,tolerance,11208,docs/4.2/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/solver.html,2,['toler'],['tolerance']
Availability,"ct. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/C",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:58139,mask,mask,58139,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['mask'],['mask']
Availability,"ct. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; https://en.wikipedia.org/wiki/",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:58374,mask,mask,58374,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,4,['mask'],['mask']
Availability,"ction during the optimisation algorithm. accuracy_factor; (float) Determines the accuracy of the result. Typical values for accuracy_factor are: 1e12 for low accuracy; 1e7 for moderate accuracy; 10.0 for extremely high accuracy scipy.optimize.fmin_l_bfgs_b factr argument. Only set for specific methods (fmin_l_bfgs_b) that uses this Otherwise the same thing is passed as method_option ftol (although the scale is different) Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt; Attributes. termination_reason; (string) Description of the reason for terminating the optimisation. fidelity; (float) final (normalised) fidelity that was achieved. initial_fid_err; (float) fidelity error before optimisation starting. fid_err; (float) final fidelity error that was achieved. goal_achieved; (boolean) True is the fidely error achieved was below the target. grad_norm_final; (float) Final value of the sum of the squares of the (normalised) fidelity error gradients. grad_norm_min_reached; (float) True if the optimisation terminated due to the minimum value of the gradient being reached. num_iter; (integer) Number of iterations of the optimisation algorithm completed. max_iter_exceeded; (boolean) True if the iteration limit was reached. max_fid_func_exceeded; (boolean) True if the fidelity function call limit was reached. wall_time; (float) time elapsed during the optimisation. wall_time_limit_exceeded; (boolean) True if the wall time limit was reached. time; (array[num_tslots+1] of float) Time are the start of each timeslot with the final value being the total evolution time. initial_amps; (array[num_tslots, n_ctrls]) The amplitudes at the start of the optimisation. final_amps; (array[num_tslots, n_ctrls]) The amplitudes at the end of the optimisation. evo_full_final; (Qobj) The evolution operator from t=0 to t=T based on the final amps. stats; (Stats) Object contaning the stats for the run (i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:71289,error,error,71289,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['error'],['error']
Availability,"culate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. c_op : Qobj. operator C. solver : str. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_vec : array. An array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:H : Qobj. system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj. Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:88071,error,errors,88071,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['errors']
Availability,"culations were taken from DYNAMO; (see file header); Attributes. phase_option; (string) determines how global phase is treated in fidelity calculations: PSU - global phase ignored SU - global phase included. fidelity_prenorm; (complex) Last computed value of the fidelity before it is normalised It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current; (boolean) flag to specify whether fidelity_prenorm are based on the current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:91404,error,error,91404,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['error'],['error']
Availability,"d (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every patch release. Copying New Files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML File Updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases sec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:17027,down,downloads,17027,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['down'],['downloads']
Availability,"d QuTiP from source is to use a PEP-517-compatible builder such as the build package available on pip.; These will automatically install all build dependencies for you, and the pip installation step afterwards will install the minimum runtime dependencies.; You can do this by doing (for example); pip install build; python -m build <path to qutip>; pip install <path to qutip>/dist/qutip-<version>.whl. The first command installs the reference PEP-517 build tool, the second effects the build and the third uses pip to install the built package.; You will need to replace <path to qutip> with the actual path to the QuTiP source code.; The string <version> will depend on the version of QuTiP, the version of Python and your operating system.; It will look something like 4.6.0-cp39-cp39-manylinux1_x86_64, but there should only be one .whl file in the dist/ directory, which will be the correct one. Direct Setuptools Source Builds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library suppo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/installation.html:6288,error,error-prone,6288,docs/4.6/installation.html,https://qutip.org,https://qutip.org/docs/4.6/installation.html,2,['error'],['error-prone']
Availability,"d dims is None:; raise ValueError('Specify either the number of rows of state vector'; '(N) or dimensions of quantum object (dims)'); if N and dims:; _check_dims(dims, N, 1); elif dims:; N = np.prod(dims[0]); _check_dims(dims, N, 1); else:; dims = [[N], [1]]; psi = rand_unitary_haar(N, seed=seed) * basis(N, 0); psi.dims = dims; return psi. [docs]def rand_dm(N, density=0.75, pure=False, dims=None, seed=None):; r""""""Creates a random NxN density matrix. Parameters; ----------; N : int, ndarray, list; If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix.; density : float; Density between [0,1] of output density matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]].; seed : int; Seed for the random number generator. Returns; -------; oper : qobj; NxN density matrix quantum operator. Notes; -----; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that :math:`Tr(\rho)=1`. """"""; if isinstance(N, (np.ndarray, list)):; if np.abs(np.sum(N)-1.0) > 1e-15:; raise ValueError('Eigenvalues of a density matrix '; 'must sum to one.'); H = sp.diags(N, 0, dtype=complex, format='csr'); N = len(N); if dims:; _check_dims(dims, N, N); nvals = N**2*density; H = rand_jacobi_rotation(H, seed=seed); while H.nnz < 0.95*nvals:; H = rand_jacobi_rotation(H); H.sort_indices(); elif isinstance(N, (int, np.int32, np.int64)):; if dims:; _check_dims(dims, N, N); if pure:; dm_density = np.sqrt(density); psi = rand_ket(N, dm_density, seed=seed); H = psi * psi.dag(); H.data.sort_indices(); else:; non_zero = 0; tries = 0; while non_zero == 0 and tries < 10:; H = rand_herm(N, density, seed=seed); H = H.dag() * H; non_zero = H.tr(); tries += 1; if tries >= 10:; raise ValueError(; ""Requested density is too low to generate density matrix.""); H = H / H.tr(); H.data.sort_indices(); else:; raise TypeError('Input N must be an integer or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/random_objects.html:12156,error,error,12156,docs/4.6/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/random_objects.html,4,['error'],['error']
Availability,"d ensure that they build against Numpy versions >= 1.16.6 and < 1.20 (not including 1.20 itself), but after that or for those installing from conda, an installation will support any current Numpy version >= 1.16.6. Improvements¶. Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in fa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:17053,error,errors,17053,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['error'],['errors']
Availability,"d for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way to install QuTiP in Ubuntu (12.04 and later) is to use the QuTiP PPA; sudo add-apt-repository ppa:jrjohansson/qutip-releases;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/installation.html:3726,avail,available,3726,docs/3.0.0/installation.html,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html,1,['avail'],['available']
Availability,"d here, i.e. the dynamics generators (Hamiltonians,; Limbladians etc). The dynamics for the time slices are calculated here, along; with the evolution as determined by the control amplitudes. See the subclass descriptions and choose the appropriate class for the; application. The choice depends on the type of matrix used to define; the dynamics. These class implement functions for getting the dynamics generators for; the combined (drift + ctrls) dynamics with the approriate operator applied. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """"""; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip.qobj import Qobj; from qutip.sparse import sp_eigs, eigh; import qutip.settings as settings; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.tslotcomp as tslotcomp; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.symplectic as sympl; import qutip.control.dump as qtrldump. DEF_NUM_TSLOTS = 10; DEF_EVO_TIME = 1.0. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. def _check_ctrls_container(ctrls):; """"""; Check through the controls container.; Convert to an array if its a list of lists; return the processed container; raise type error if the container structure is invalid; """"""; if isinstance(ctrls, (list, tuple)):; # Check to see if list of lists; try:; if isinstance(ctrls[0], (list, tuple)):; ctrls_ = np.empty((len(ctrls), len(ctrls[0])), dtype=object); for i, ctrl in enumerate(ctrls):; ctrls_[i, :] = ctrl; ctrls = ctrls_; except:; pass. if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; rais",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html:3401,error,errors,3401,docs/4.6/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dynamics.html,8,['error'],['errors']
Availability,"d is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:17852,avail,available,17852,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,3,['avail'],['available']
Availability,"d)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]¶; r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:112219,error,error,112219,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability,"d. Return type:array. dnorm(B=None)[source]¶; Calculates the diamond norm, or the diamond distance to another operator. Parameters:B (Qobj or None) – If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns:d – Either the diamond norm of this operator, or the diamond distance; from this operator to B. Return type:float. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:; sparse (bool) – Use sparse Eigensolver; sort (str) – Sort eigenvalues ‘low’ to high, or ‘high’ to low.; eigvals (int) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:eigvals – Array of eigenvalues for operator. Return type:array. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; sort (str) – Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low.; eigvals (int) – Number of requested eigenvalues. Default is all eigenvalues.; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals (array) – Array of eigenvalues for op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:6062,toler,tolerance,6062,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"d. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which bei",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html:16696,avail,available,16696,docs/4.6/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-time.html,4,['avail'],['available']
Availability,"d. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained.; Here psi0 is the initial value used for tests before the evolution begins.; qutip.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html:17237,avail,available,17237,docs/4.4/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.4/guide/dynamics/dynamics-time.html,2,['avail'],['available']
Availability,"d. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when usi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:40431,toler,tolerance,40431,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,4,['toler'],['tolerance']
Availability,"d.; """"""; # The method will destruct the graph, therefore we make a copy.; graph = deepcopy(self.nodes); cycles_list = []; available_nodes = list(self.start) # a list of available instructions; # pairs of instructions that are limited by hardware constraint; constraint_dependency = set(). while available_nodes:; if random:; shuffle(available_nodes); if priority:; available_nodes.sort(key=cmp_to_key(self._compare_priority)); current_cycle = []; if apply_constraint is None: # if no constraits; current_cycle = deepcopy(available_nodes); else: # check if constraits allow the parallelization; for node1 in available_nodes:; approval = True; for node2 in current_cycle:; if not apply_constraint(node1, node2, graph):; approval = False; # save the conflicted pairs of instructions; constraint_dependency.add((node2, node1)); if approval:; current_cycle.append(node1); # add this cycle to cycles_list; cycles_list.append(current_cycle). # update the list of available nodes; # remove the executed nodes from available_node; for node in current_cycle:; available_nodes.remove(node); # add new nodes to available_nodes; # if they have no other predecessors; for node in current_cycle:; for successor_ind in graph[node].successors:; graph[successor_ind].predecessors.remove(node); if not graph[successor_ind].predecessors:; available_nodes.append(successor_ind); graph[node].successors = set(). return cycles_list, constraint_dependency. def compute_distance(self, cycles_list):; """"""; Compute the longest distance of each node; to the start and end nodes.; The weight for each dependency arrow is; the duration of the source instruction; (which should be 1 for gates schedule).; The method solves the longest path problem; by using the topological order in cycles_list.; It makes sure that by following the list,; the distance to the predecessors (successors) of; the source (target) node is always calculated; before the target (source) node. Parameters; ----------; cycles_list: list; A `cycles_list` ob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html:9136,avail,available,9136,docs/4.6/modules/qutip/qip/compiler/scheduler.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/compiler/scheduler.html,4,['avail'],['available']
Availability,"d.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version numb",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:6269,down,download,6269,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['down'],['download']
Availability,"d_qobjevo.expect(t, state). def finish(self):; if self.isfunc:; result = self.raw_out; else:; result = []; for ii in range(self.e_num):; if self.e_ops_isherm[ii]:; result.append(np.real(self.raw_out[ii, :])); else:; result.append(self.raw_out[ii, :]); if self.e_ops_dict:; result = {e: result[n]; for n, e in enumerate(self.e_ops_dict.keys())}; return result. def __eq__(self, other):; if isinstance(other, ExpectOps):; other = other.raw_e_ops; return self.raw_e_ops == other. def __ne__(self, other):; return not (self == other). def __bool__(self):; return bool(self.e_num). [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:4960,toler,tolerance,4960,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,4,['toler'],['tolerance']
Availability,"data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:225810,error,error,225810,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability,"data, 0); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; raise TypeError(""Can only calculate overlap for state vector Qobjs""). raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); new_dims = [self.dims[0], [1] * len(self.dims[0])]; ekets = np.array([Qobj(vec, dims=new_dims) for vec in evecs],; dtype=object); norms = np.array([ket.norm() for ket in ekets]); return evals, ekets / norms. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Para",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/qobj.html:40839,toler,tolerance,40839,docs/4.4/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/qobj.html,1,['toler'],['tolerance']
Availability,data.js; pygments.css; searchtools.js; underscore.js. /4.6; . /apidoc; ; API documentation — QuTiP 4.6 Documentation; Classes — QuTiP 4.6 Documentation; Functions — QuTiP 4.6 Documentation. Bibliography — QuTiP 4.6 Documentation; Change Log — QuTiP 4.6 Documentation; Developers — QuTiP 4.6 Documentation. /development; . /ideas; ; GPU implementation of the Hierarchical Equations of Motion — QuTiP 4.6 Documentation; Pulse level description of quantum circuits — QuTiP 4.6 Documentation; Quantum Error Mitigation — QuTiP 4.6 Documentation; QuTiP Interactive — QuTiP 4.6 Documentation; TensorFlow Data Backend — QuTiP 4.6 Documentation. Contributing to QuTiP Development — QuTiP 4.6 Documentation; Development Documentation — QuTiP 4.6 Documentation; Working with the QuTiP Documentation — QuTiP 4.6 Documentation; docs-1.pdf; Ideas for future QuTiP development — QuTiP 4.6 Documentation; Release and Distribution — QuTiP 4.6 Documentation; QuTiP Development Roadmap — QuTiP 4.6 Documentation. /downloads; . /12a86e4dcaaba8c4a8de323bd441ab96; ; plot_qip_relaxation.py. /1b50abbe88595fe251e07102f532b361; ; plot_qip_amplitude_noise.ipynb. /3f58cb72e9b73bcbfbeb9e0f6960b60b; ; plot_qip_relaxation.ipynb. /5bc733f4cdb3729576a991efbdd8c026; ; plot_qip_intro_processor.ipynb. /7aaebc4b1d6f7b38aa6c893905ac98ef; ; plot_qip_intro_processor.py. /aacc19a817412ec042804206e9c23202; ; plot_qip_amplitude_noise.py. /e1a1bbebf99cf434ac461d7e6da91f40; ; qutip_tree.pdf. Frontmatter — QuTiP 4.6 Documentation. /gallery; . /build; . /qip; ; Control Amplitude Noise — QuTiP 4.6 Documentation; Basic use of Processor — QuTiP 4.6 Documentation; T2 Relaxation — QuTiP 4.6 Documentation. Gallery — QuTiP 4.6 Documentation. Index — QuTiP 4.6 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 4.6 Documentation; dynamics-bloch-redfield-3.pdf; dynamics-bloch-redfield-6.pdf; dynamics-bloch-redfield-8.pdf; Dynamics Simulation Results — QuTiP 4.6 Documentation; Floquet Formalism — QuTiP 4.6 Docume,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/index-wcopy.html:48896,down,downloads,48896,index-wcopy.html,https://qutip.org,https://qutip.org/index-wcopy.html,1,['down'],['downloads']
Availability,"delity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option). @property; def phase_option(self):; return self._phase_option. @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)). [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html:11176,error,errors,11176,docs/4.4/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/fidcomp.html,1,['error'],['errors']
Availability,"dels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2533,error,error,2533,docs/4.7/development/ideas/quantum-error-mitigation.html,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html,2,['error'],['error']
Availability,"der). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:223410,error,error,223410,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability,"diag_pivot_thresh': 0.1, 'maxiter': 1000,; 'permc_spec': 'COLAMD', 'ILU_MILU': 'smilu_2',; 'restart': 20,; 'max_iter_refine': 10,; 'scaling_vectors': True,; 'weighted_matching': True,; 'return_info': False, 'info': _empty_info_dict(),; 'verbose': False, 'solver': 'scipy', 'weight': None,; 'tol': 1e-12, 'matol': 1e-15, 'mtol': None}; return def_args. [docs]def steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs):; """"""; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators. If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters; ----------; A : :obj:`~qutip.Qobj`; A Hamiltonian or Liouvillian operator. c_op_list : list; A list of collapse operators. solver : {'scipy', 'mkl'}, optional; Selects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. method : str, default 'direct'; The allowed methods are. - 'direct'; - 'eigen'; - 'iterative-gmres'; - 'iterative-lgmres'; - 'iterative-bicgstab'; - 'svd'; - 'power'; - 'power-gmres'; - 'power-lgmres'; - 'power-bicgstab'. Method for solving the underlying linear equation. Direct LU solver; 'direct' (default), sparse eigenvalue problem 'eigen', iterative GMRES; method 'iterative-gmres', iterative LGMRES method 'iterative-lgmres',; iterative BICGSTAB method 'iterative-bicgstab', SVD 'svd' (dense), or; inverse-power method 'power'. The iterative power methods; 'power-gmres', 'power-lgmres', 'power-bicgstab' use the same solvers as; their direct counterparts. return_info : bool, default False; Return a dictionary of solver-specific infomation about the solution; and how it was obtained. sparse : bool, default True; Solve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:4748,avail,availability,4748,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['avail'],['availability']
Availability,"ding using the now-supported PEP 517 mechanisms (e.g. python -mbuild /path/to/qutip), all build dependencies will be correctly satisfied. Improvements¶. MAJOR Add saving, loading and resetting functionality to qutip.settings for easy re-configuration. (by Eric Giguère); MAJOR Add a quantum gate scheduler in qutip.qip.scheduler, to help parallelise the operations of quantum gates. This supports two scheduling modes: as late as possible, and as soon as possible. (by Boxi Li); MAJOR Improved qubit circuit simulators, including OpenQASM support and performance optimisations. (by Sidhant Saraogi); MAJOR Add tools for quantum measurements and their statistics. (by Simon Cross and Sidhant Saraogi); Add support for Numpy 1.20. QuTiP should be compiled against a version of Numpy >= 1.16.6 and < 1.20 (note: does _not_ include 1.20 itself), but such an installation is compatible with any modern version of Numpy. Source installations from pip understand this constraint.; Improve the error message when circuit plotting fails. (by Boxi Li); Add support for parsing M1 Mac hardware information. (by Xiaoliang Wu); Add more single-qubit gates and controlled gates. (by Mateo Laguna and Martín Sande Costa); Support decomposition of X, Y and Z gates in circuits. (by Boxi Li); Refactor QubitCircuit.resolve_gate() (by Martín Sande Costa). Bug Fixes¶. Fix dims in the returns from Qobj.eigenstates on superoperators. (by Jake Lishman); Calling Numpy ufuncs on Qobj will now correctly raise a TypeError rather than returning a nonsense ndarray. (by Jake Lishman); Convert segfault into Python exception when creating too-large tensor products. (by Jake Lishman); Correctly set num_collapse in the output of mesolve. (by Jake Lishman); Fix ptrace when all subspaces are being kept, or the subspaces are passed in order. (by Jake Lishman); Fix sorting bug in Bloch3d.add_points(). (by pschindler); Fix invalid string literals in docstrings and some unclosed files. (by Élie Gouzien); Fix Hermicity tests f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:12805,error,error,12805,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['error'],['error']
Availability,"dit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Optional Installation Options¶. UMFPACK Linear Solver¶; As of SciPy 0.14+, the umfpack linear solver routines for solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/nonhermitian/umfpack that can be installed to have SciPy find and use the umfpack library. Optimized BLAS Libraries¶; QuTiP is designed to take advantage of some of the optimized BLAS libraries that are available for NumPy. At present, this includes the OPENBLAS and MKL libraries. If NumPy is built against these libraries, then QuTiP will take advantage of the performance gained by using these optimized tools. As these libraries are multi-threaded, you can change the number of threads used in these packages by adding:; >>> import os; >>> os.environ['OPENBLAS_NUM_THREADS'] = '4'; >>> os.environ['MKL_NUM_THREADS'] = '4'. at the top of your Python script files, or iPython notebooks, and then loading the QuTiP framework. If these commands are not present, then QuTiP automatically sets the number of threads to one. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of test",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/installation.html:10556,avail,available,10556,docs/3.0.1/installation.html,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html,2,['avail'],['available']
Availability,"ditioner. weight : float, optional; Sets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refine : int {10}; MKL ONLY. Max. number of iterative refinements to perform. scaling_vectors : bool {True, False}; MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matching : bool {True, False}; MKL ONLY. Use weighted matching to better condition diagonal. x0 : ndarray, optional; ITERATIVE ONLY. Initial guess for solution vector. maxiter : int, optional, default=1000; ITERATIVE ONLY. Maximum number of iterations to perform. tol : float, optional, default=1e-12; ITERATIVE ONLY. Tolerance used for terminating solver. mtol : float, optional, default=None; ITERATIVE 'power' methods ONLY. Tolerance for lu solve method.; If None given then `max(0.1*tol, 1e-15)` is used. matol : float, optional, default=1e-15; ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_spec : str, optional, default='COLAMD'; ITERATIVE ONLY. Column ordering used internally by superLU for the; 'direct' LU decomposition method. Options include 'COLAMD' and; 'NATURAL'. If using RCM then this is set to 'NATURAL' automatically; unless explicitly specified. use_precond : bool optional, default = False; ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the 'iterative' GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M : {sparse matrix, dense matrix, LinearOperator}, optional; ITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and ``use_precond = True``, then one; is generated automatically. fill_factor : float, optional, default = 100; ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:7571,toler,tolerance,7571,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,3,['toler'],['tolerance']
Availability,"dows (Thank lrunze for reporting); Removed warning when mesolve fall back on sesolve (by Michael Goerz).; Fixed dimension check and confusing documentation in random ket (by Yariv Yanay).; Fixed Qobj isherm not working after using Qobj.permute (Thank llorz1207 for reporting).; Correlation functions call now properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek Marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed b",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/changelog.html:5760,avail,available,5760,docs/4.5/changelog.html,https://qutip.org,https://qutip.org/docs/4.5/changelog.html,3,['avail'],['available']
Availability,"ds[k]]; ....: for k in range(len(lbls_list))])); ....: . In [72]: fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). In [73]: ax.view_init(azim=-55, elev=45). In [74]: plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; In [75]: rho_ss = steadystate(H, [sqrt(0.1) * a, sqrt(0.4) * b.dag()]). In [76]: fig, ax = hinton(rho_ss) #, xlabels=xlabels, ylabels=xlabels). In [77]: plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the ma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-visualization.html:12060,error,errors,12060,docs/3.0.0/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html,2,['error'],['errors']
Availability,"duce numerical errors. options : :class:`qutip.solver.Options`; Generic solver options. Only options.average_states and; options.store_states are used. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance. *; time-dependent Qobj can be used for H, c_ops and sc_ops.; The format for time-dependent system hamiltonian is:; H = [Qobj0,[Qobj1,coeff1],[Qobj2,coeff2],...]; = Qobj0 + Qobj1 * coeff1(t) + Qobj2 * coeff2(t). coeff function can be:; function: coeff(t, args) -> complex; str: ""sin(1j*w*t)""; np.array[complex, 1d] of length equal to the times array; The argument args for the function coeff is the args keyword argument of; the stochastic solver.; Likewisem in str cases, the parameters ('w' in this case) are taken from; the args keywords argument.; *While mixing coeff type does not results in errors, it is not recommended.*. For the collapse operators (c_ops, sc_ops):; Each operators can only be composed of 1 Qobj.; c_ops = [c_op1, c_op2, ...]; where, c_opN = Qobj or [Qobj,coeff]; The coeff format is the same as for the Hamiltonian.; """"""; def __init__(self, me, H=None, c_ops=[], sc_ops=[], state0=None,; e_ops=[], m_ops=None, store_all_expect=False,; store_measurement=False, dW_factors=None,; solver=None, method=""homodyne"", normalize=None,; times=None, nsubsteps=1, ntraj=1, tol=None,; generate_noise=None, noise=None,; progress_bar=None, map_func=None, map_kwargs=None,; args={}, options=None, noiseDepth=20):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). # System; # Cast to QobjEvo so the code has only one version for both the; # constant and time-dependent case.; self.me = me. if H is not None:; msg = ""The Hamiltonian format is not valid. ""; try:; self.H = QobjEvo(H, args=args, tlist=times,; e_ops=e_ops, state0=",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/stochastic.html:11934,error,errors,11934,docs/4.5/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/stochastic.html,1,['error'],['errors']
Availability,"duce numerical errors. options : :class:`qutip.solver.Options`; Generic solver options. Only options.average_states and; options.store_states are used. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance. *; time-dependent Qobj can be used for H, c_ops and sc_ops.; The format for time-dependent system hamiltonian is:; H = [Qobj0,[Qobj1,coeff1],[Qobj2,coeff2],...]; = Qobj0 + Qobj1 * coeff1(t) + Qobj2 * coeff2(t). coeff function can be:; function: coeff(t, args) -> complex; str: ""sin(1j*w*t)""; np.array[complex, 1d] of length equal to the times array; The argument args for the function coeff is the args keyword argument of; the stochastic solver.; Likewisem in str cases, the parameters ('w' in this case) are taken from; the args keywords argument.; *While mixing coeff type does not results in errors, it is not recommended.*. For the collapse operators (c_ops, sc_ops):; Each operators can only be composed of 1 Qobj.; c_ops = [c_op1, c_op2, ...]; where, c_opN = Qobj or [Qobj,coeff]; The coeff format is the same as for the Hamiltonian.; """"""; def __init__(self, me, H=None, c_ops=[], sc_ops=[], state0=None,; e_ops=[], m_ops=None, store_all_expect=False,; store_measurement=False, dW_factors=None,; solver=None, method=""homodyne"", normalize=None,; times=None, nsubsteps=1, ntraj=1, tol=None,; generate_noise=None, noise=None,; progress_bar=None, map_func=None, map_kwargs=None,; args={}, options=None, noiseDepth=20):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). # System; # Cast to QobjEvo so the code has only one version for both the; # constant and time-dependent case.; self.me = me; if H is not None:; try:; self.H = QobjEvo(H, args=args, tlist=times); except:; raise Exception(""The hamiltonian format is not valid""); el",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/stochastic.html:11882,error,errors,11882,docs/4.4/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/stochastic.html,1,['error'],['errors']
Availability,"dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13409,error,errors,13409,docs/4.3/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html,7,['error'],['errors']
Availability,"dy-state’ is only implemented; for the me and es solvers. tlist : list / array; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. :math:`t. ightarrow infty`; here tlist is. automatically set, ignoring user input. taulist : list / array; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list of qutip.qobj.Qobj; list of collapse operators. a_op : qutip.qobj.Qobj; operator A. b_op : qutip.qobj.Qobj; operator B. reverse : bool; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : qutip.solver.Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat: array. An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args=None, options=<qutip.solver.Options instance at 0x105963908>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math: tau<0. Parameters:H : qutip.qobj.Qobj. system Hamiltonian. rho0 : qutip.qobj.Qobj. Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial sta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:75189,error,errors,75189,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['error'],['errors']
Availability,"dy-state’ is only implemented; for the me and es solvers. tlist : list / array; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. :math:`t. ightarrow infty`; here tlist is. automatically set, ignoring user input. taulist : list / array; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list of qutip.qobj.Qobj; list of collapse operators. a_op : qutip.qobj.Qobj; operator A. b_op : qutip.qobj.Qobj; operator B. reverse : bool; If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : qutip.solver.Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat: array. An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args=None, options=<qutip.solver.Options instance at 0x105963a28>)[source]¶; Calculate the two-operator two-time correlation function:. \[\begin{split}\lim_{t o \infty} \left<A(t+\tau)B(t)\right>\end{split}\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters:H : qutip.qobj.Qobj. system Hamiltonian. taulist : list / array. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list of qutip.qobj.Qobj. list of collapse operators. a_op : qutip.qobj.Qobj. operator A. b_op : qu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:70342,error,errors,70342,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['error'],['errors']
Availability,"dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.f",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:63192,error,errors,63192,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['error'],['errors']
Availability,"e # Placeholder for TD col_expect function.; config.string = None # Holds string of variables to be passed to solver; config.tdname = None # Name of td .pyx file (used in parallel mc code); if ""sesolve"" in solver_safe:; del solver_safe[""sesolve""]; if ""mesolve"" in solver_safe:; del solver_safe[""mesolve""]; if ""mcsolve"" in solver_safe:; del solver_safe[""mcsolve""]. [docs]def rhs_generate(H, c_ops, args={}, options=Options(), name=None,; cleanup=True):; """"""; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters; ----------; H : qobj; System Hamiltonian. c_ops : list; ``list`` of collapse operators. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. name: str; Name of generated RHS. cleanup: bool; Whether the generated cython file should be automatically removed or; not. Notes; -----; Using this function with any solver other than the mesolve function; will result in an error. """"""; config.reset(); config.options = options. if name:; config.tdname = name; else:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num). Lconst = 0. Ldata = []; Linds = []; Lptrs = []; Lcoeff = []; Lobj = []. # loop over all hamiltonian terms, convert to superoperator form and; # add the data of sparse matrix represenation to. msg = ""Incorrect specification of time-dependence: "". for h_spec in H:; if isinstance(h_spec, Qobj):; h = h_spec. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; Lconst += -1j * (spre(h) - spost(h)); elif h.issuper:; Lconst += h; else:; raise TypeError(msg + ""expected operator or superoperator""). elif isinstance(h_spec, list):; h = h_spec[0]; h_coeff = h_spec[1]. if not isinstance(h, Qobj):; raise TypeError(msg + ""expected Qobj""). if h.isoper:; L = -1j * (spre(h) - spost(h)); elif h.issuper:; L = h; else:; raise TypeError(msg + ""expected operator or superoperat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html:3853,error,error,3853,docs/4.4/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/rhs_generate.html,4,['error'],['error']
Availability,"e A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist must be positive and contain; the element 0.; c_ops (list) – list of collapse operators, may be time-dependent for solver choice of; me or mc.; a_op (Qobj) – operator A.; solver (str) – choice of solver (me for master-equation and; es for exponential series).; options (Options) – solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:g1, G1 – The normalized and unnormalized second-order coherence function. Return type:tuple. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters:; H (Qobj) – system Hamiltonian, may be time-dependent for solver choice of me or; mc.; state0 (Qobj) – Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers.; taulist (array_like) – list of times for \(\tau\). taulist mus",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:99140,error,errors,99140,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['errors']
Availability,e Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the s,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html:2228,toler,tolerance,2228,docs/4.6/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-options.html,4,['toler'],['tolerance']
Availability,"e `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html:3461,mask,mask,3461,docs/4.2/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/partial_transpose.html,4,['mask'],['mask']
Availability,"e `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op], args=args).expect[0]. # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, state0, taulist, c_ops,; a_op.dag(), a_op.dag()*a_op, a_op,; solver=solver, args=args, options=options); g2 = G2 / (n[0] * n). return g2, G2. # spectrum. [docs]def spectrum(H, wlist, c_ops, a_op, b_op, solver=""es"", use_pinv=False):; r""""""; Calculate the spectrum of the correlation function; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`,; i.e., the Fourier transform of the correlation function:. .. math::. S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:15623,error,errors,15623,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['error'],['errors']
Availability,"e a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Getting the Built Documentation¶; The documentation will have been built automatically for you by a GitHub Action when you merged the final pull request into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:14845,Down,Download,14845,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['Down'],['Download']
Availability,"e a positive \; integer or a list of positive integers.""); self._length_for_site = l_v; self.cell_tensor_config = [self.cell_num_site] + self.cell_site_dof; self.lattice_tensor_config = [self.num_cell] + self.cell_tensor_config; # remove any 1 present in self.cell_tensor_config and; # self.lattice_tensor_config unless all the eleents are 1. if all(x == 1 for x in self.cell_tensor_config):; self.cell_tensor_config = [1]; else:; while 1 in self.cell_tensor_config:; self.cell_tensor_config.remove(1). if all(x == 1 for x in self.lattice_tensor_config):; self.lattice_tensor_config = [1]; else:; while 1 in self.lattice_tensor_config:; self.lattice_tensor_config.remove(1). dim_ih = [self.cell_tensor_config, self.cell_tensor_config]; self._length_of_unit_cell = self.cell_num_site*self._length_for_site. if boundary == ""periodic"":; self.period_bnd_cond_x = 1; elif boundary == ""aperiodic"" or boundary == ""hardwall"":; self.period_bnd_cond_x = 0; else:; raise Exception(""Error in boundary: Only recognized bounday \; options are:\""periodic \"",\""aperiodic\"" and \""hardwall\"" ""). if Hamiltonian_of_cell is None: # There is no user input for; # Hamiltonian_of_cell, so we set it ourselves; H_site = np.diag(np.zeros(cell_num_site-1)-1, 1); H_site += np.diag(np.zeros(cell_num_site-1)-1, -1); if cell_site_dof == [1] or cell_site_dof == 1:; Hamiltonian_of_cell = Qobj(H_site, type='oper'); self._H_intra = Hamiltonian_of_cell; else:; Hamiltonian_of_cell = tensor(Qobj(H_site),; qeye(self.cell_site_dof)); dih = Hamiltonian_of_cell.dims[0]; if all(x == 1 for x in dih):; dih = [1]; else:; while 1 in dih:; dih.remove(1); self._H_intra = Qobj(Hamiltonian_of_cell, dims=[dih, dih],; type='oper'); elif not isinstance(Hamiltonian_of_cell, Qobj): # The user; # input for Hamiltonian_of_cell is not a Qobj and hence is invalid; raise Exception(""Hamiltonian_of_cell is required to be a Qobj.""); else: # We check if the user input Hamiltonian_of_cell have the; # right shape or not. If approved, we give it the pr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/lattice.html:11057,Error,Error,11057,docs/4.6/modules/qutip/lattice.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/lattice.html,2,['Error'],['Error']
Availability,"e assumed to be attribute name value pairs.; They applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:231969,ERROR,ERROR,231969,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['ERROR'],['ERROR']
Availability,"e assumed to be attribute name value pairs.; They applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:244087,ERROR,ERROR,244087,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['ERROR'],['ERROR']
Availability,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_param",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:38227,error,error,38227,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,10,['error'],['error']
Availability,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; gue",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:37860,error,error,37860,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"e described above. qutip user docs migration¶. tag; qmain-docs. status; completed. admin lead; Jake Lishman. main dev; Jake Lishman. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. QIP migration¶. tag; qip-mig. status; completed. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; completed. admin lead; Neill. main dev; Simon Cross, Tarun Raheja. An overhaul of the HEOM solver, to incorporate the improvements pioneered in BoFiN. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction (completed); qutip main reorganization (completed); qutip user docs migration (completed); Solver data layer integration (in-progress); QIP migration (completed); Qtrl migration; HEOM revamp (completed). The planned timeline for the release is:. alpha version, September 2022. Core features packaged and available for; experienced users to test.; beta version, November 2022. All required features and documentation complete,; packaged and ready for community testing.; full release, January 2023. Full tested version released. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/roadmap.html:15642,avail,available,15642,docs/4.7/development/roadmap.html,https://qutip.org,https://qutip.org/docs/4.7/development/roadmap.html,2,['avail'],['available']
Availability,"e device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc. Note; The run_state method of DispersiveCavityQED; returns the full simulation result of the solver,; hence including the cavity.; To obtain the circuit result, one needs to first trace out the cavity state. OptPulseProcessor; The OptPulseProcessor uses the function in optimize_pulse_unitary in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows. \[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d + \sum_j u_j H_j] )\]; To let it find the optimal pulses, we need to give the parameters for optimize_pulse_unitary as keyword arguments to load_circuit. Usually, the minimal requirements are the evolution time evo_time and the number of time slices num_tslots for each gate. Other parameters can also be given in the keyword arguments. For available choices, see optimize_pulse_unitary. It is also possible to specify different parameters for different gates, as shown in the following example:; from qutip.qip.device import OptPulseProcessor; from qutip.operators import sigmaz, sigmax, sigmay; from qutip.tensor import tensor. # Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). # Different parameters for different gates; qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigma",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:8557,avail,available,8557,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,4,['avail'],['available']
Availability,"e equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]¶. normalize_SU(self, A)[source]¶. normalize_gradient_PSU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:111661,error,error,111661,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,4,['error'],['error']
Availability,"e fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily hel",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:102692,error,error,102692,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability,"e from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See FidelityCo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:212485,error,error,212485,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['error'],['error']
Availability,"e from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for; details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:224572,error,error,224572,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['error'],['error']
Availability,"e from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComput",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:186552,error,error,186552,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['error'],['error']
Availability,"e from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringdetermines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotCo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:195000,error,error,195000,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['error'],['error']
Availability,"e logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params¶; Dictionary – The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg¶; string – Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params¶; Dictionary – options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg¶; bool – Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method¶; string – a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params¶; Dictionary – Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad¶; bool – If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound¶; float or list of floats – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound¶; float or list of floats – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds¶; List of floats – Bounds for the paramete",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:60698,error,error,60698,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"e may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases sec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:11240,down,downloads,11240,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['down'],['downloads']
Availability,"e message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:6292,error,error,6292,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"e message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:6292,error,error,6292,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['error'],['error']
Availability,"e minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not N",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:21554,error,errors,21554,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['errors']
Availability,"e needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> q * x; TypeError: Incompatible Qobj shapes. In addition, the logic operators is equal == and is not equal != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Conjugate; Q.conj(); Conjugate of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Eigenenergies; Q.eigenenergies(); Eigenenergies (values) of operator. Eigenstates; Q.eigenstates(); Returns eigenvalues and eigenvectors. Exponential; Q.expm(); Matrix exponential of operator. Full; Q.full(); Returns full (not sparse) array of; Q’s data. Groundstate; Q.groundstate(); Eigenval & eigket of Qobj groundstate. Matrix Element; Q.matrix_element(bra,ket); Matrix element <bra|Q|ket>. Norm; Q.norm(); Returns L2 norm for states,; trace norm for operators. Pa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-basics.html:9730,error,error,9730,docs/3.0.0/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html,2,['error'],['error']
Availability,"e of dephasing for; each qubit. targets: int or listThe indices of qubits that are acted on. get_noisy_dynamics(self, dims)[source]¶; Return a list of Pulse object with only trivial ideal pulse (H=0) but; non-trivial relaxation noise. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. Returns. lindblad_noise: list of qutip.qip.PulseA list of Pulse object with only trivial ideal pulse (H=0) but; non-trivial relaxation noise. class ControlAmpNoise(coeff, tlist=None, indices=None)[source]¶; The noise in the amplitude of the control pulse. Parameters. coeff: listA list of the coefficients for the control Hamiltonians.; For available choices, see qutip.QobjEvo. tlist: array_like, optionalA NumPy array specifies the time of each coefficient. indices: list of int, optionalThe indices of target pulse in the list of pulses. Attributes; ———-; coeff: listA list of the coefficients for the control Hamiltonians.; For available choices, see qutip.QobjEvo. tlist: array_likeA NumPy array specifies the time of each coefficient. indices: list of intThe indices of target pulse in the list of pulses. get_noisy_dynamics(self, pulses)[source]¶; Return a list of pulses containing the input pulse with additional; coherent noise. Parameters. pulses: list of :class:`qutip.qip.Pulse`The input pulses, on which the noise object will be applied. Returns. noisy_pulses: list of qutip.qip.PulseThe input Pulse object with additional coherent noise. class RandomNoise(dt, rand_gen, indices=None, **kwargs)[source]¶; Random noise in the amplitude of the control pulse. The arguments for; the random generator need to be given as key word arguments. Parameters. dt: float, optionalThe time interval between two random amplitude. The coefficients; of the noise are the same within this time range. rand_gen: numpy.random, optionalA random generator in numpy.random, it has to take a size; parameter as the size of random numbers in the output a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:134339,avail,available,134339,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['avail'],['available']
Availability,"e on; Attributes. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging_utils, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN. dimensional_norm; (float) Normalisation constant. fid_norm_func; (function) Used to normalise the fidelity See SU and PSU options for the unitary dynamics. grad_norm_func; (function) Used to normalise the fidelity gradient See SU and PSU options for the unitary dynamics. uses_onwd_evo; (boolean) flag to specify whether the onwd_evo evolution operator (see Dynamics) is used by the FidelityComputer. uses_onto_evo; (boolean) flag to specify whether the onto_evo evolution operator (see Dynamics) is used by the FidelityComputer. fid_err; (float) Last computed value of the fidelity error. fidelity; (float) Last computed value of the normalised fidelity. fidelity_current; (boolean) flag to specify whether the fidelity / fid_err are based on the current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the control in the timeslot. grad_norm; (float) Last computed value for the norm of the fidelity error gradients (sqrt of the sum of the squares). fid_err_grad_current; (boolean) flag to specify whether the fidelity / fid_err are based on the current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten i",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:88715,error,error,88715,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['error'],['error']
Availability,"e requested number state |n>. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qotoolbox:; basis(N, 1) = ground state. Examples; >>> basis(5,2); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]. bell_state(state='00')[source]¶; Returns the Bell state:. |B00> = 1 / sqrt(2)*[|0>|0>+|1>|1>]; |B01> = 1 / sqrt(2)*[|0>|0>-|1>|1>]; |B10> = 1 / sqrt(2)*[|0>|1>+|1>|0>]; |B11> = 1 / sqrt(2)*[|0>|1>-|1>|0>]. Returns:; Bell_state : qobj; Bell state. bra(seq, dim=2)[source]¶; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters:; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:; - ‘g’/’e’ (ground and excited state); - ‘u’/’d’ (spin up and down); - ‘H’/’V’ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns:; bra : qobj. Examples; >>> bra(""10""); Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue""); Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3); Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]); Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method='operator')[source]¶; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters:; N : int; Number of",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:2867,down,down,2867,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['down'],['down']
Availability,"e summary) is to be dumped""""""; if (self.dump_fid_err and self.dump_grad_norm and self.dump_grad):; return True; else:; return False. def _apply_level(self, level=None):; if level is None:; level = self._level. if not _is_string(level):; raise ValueError(""Dump level must be a string""); level = level.upper(); if level == 'CUSTOM':; if self._level == 'CUSTOM':; # dumping level has not changed keep the same specific config; pass; else:; # Switching to custom, start from SUMMARY; level = 'SUMMARY'. if level == 'SUMMARY':; self.dump_summary = True; self.dump_fid_err = False; self.dump_grad_norm = False; self.dump_grad = False; elif level == 'FULL':; self.dump_summary = True; self.dump_fid_err = True; self.dump_grad_norm = True; self.dump_grad = True; else:; raise ValueError(""No option for dumping level '{}'"".format(level)). [docs] def add_iter_summary(self):; """"""add copy of current optimizer iteration summary""""""; optim = self.parent; if optim.iter_summary is None:; raise RuntimeError(""Cannot add iter_summary as not available""); ois = copy.copy(optim.iter_summary); ois.idx = len(self.iter_summary); self.iter_summary.append(ois); if self.write_to_file:; if ois.idx == 0:; f = open(self.summary_file, 'w'); f.write(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep))); else:; f = open(self.summary_file, 'a'); f.write(""{}\n"".format(; ois.get_value_line(self.summary_sep))). f.close(); return ois. @property; def fid_err_file(self):; if self._fid_err_file is None:; fname = ""{}-fid_err_log.{}"".format(self.fname_base,; self.dump_file_ext); self._fid_err_file = os.path.join(self.dump_dir, fname); return self._fid_err_file. [docs] def update_fid_err_log(self, fid_err):; """"""add an entry to the fid_err log""""""; self.fid_err_log.append(fid_err); if self.write_to_file:; if len(self.fid_err_log) == 1:; mode = 'w'; else:; mode = 'a'; f = open(self.fid_err_file, mode); f.write(""{}\n"".format(fid_err)); f.close(). @property; def grad_norm_file(self):",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:9850,avail,available,9850,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,10,['avail'],['available']
Availability,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:10602,avail,available,10602,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,4,['avail'],['available']
Availability,"e"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. - ``OptimConfig`` instance - various configuration options; - ``Dynamics`` instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:6720,ERROR,ERROR,6720,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,2,['ERROR'],['ERROR']
Availability,"e, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_params()[source]¶; Save the parameters in the attribute params and check the validity.; (Defined in subclasses); Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)[source]¶; Transfer a parameter to an array. class SpinChain(N, correct_global_phase, sx, sz, sxsy, t1, t2)[source]¶; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses qutip.qip.device.LinearSpinChain and; qutip.qip.device.CircularSpinChain.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:117201,avail,available,117201,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['avail'],['available']
Availability,"e, for the Liouvillian; superoperator L. w : double; frequency at which to evaluate pseudo-inverse. Can be zero for dense; systems and large sparse systems. Small sparse systems can fail for; zero frequencies. sparse : bool; Flag that indicate whether to use sparse or dense matrix methods when; computing the pseudo inverse. method : string; Name of method to use. For sparse=True, allowed values are 'spsolve',; 'splu' and 'spilu'. For sparse=False, allowed values are 'direct' and; 'numpy'. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L. Note; ----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in; nanostructures"" C. Flindt, PhD Thesis available online:; http://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/; file_4732600/content. Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto; the subspace defined by the projector Q. """"""; pseudo_args = _default_steadystate_args(); for key in kwargs.keys():; if key in pseudo_args.keys():; pseudo_args[key] = kwargs[key]; else:; raise Exception(; ""Invalid keyword argument '""+key+""' passed to pseudo_inverse.""); if 'method' not in kwargs.keys():; pseudo_args['method'] = 'splu'. # Set column perm to NATURAL if using RCM and not specified by user; if pseudo_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; pseudo_args['permc_spec'] = 'NATURAL'. if rhoss is None:; rhoss = steadystate(L, **pseudo_args). if sparse:; return _pseudo_inverse_sparse(L, rhoss, w=w, **pseudo_args); else:; if pseudo_args['method'] != 'splu':; pseudo_args['method'] = pseudo_args['method']; else:; pseudo_args['method",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/steadystate.html:39505,avail,available,39505,docs/4.3/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/steadystate.html,5,['avail'],['available']
Availability,"e, for the Liouvillian; superoperator L. w : double; frequency at which to evaluate pseudo-inverse. Can be zero for dense; systems and large sparse systems. Small sparse systems can fail for; zero frequencies. sparse : bool; Flag that indicate whether to use sparse or dense matrix methods when; computing the pseudo inverse. method : string; Name of method to use. For sparse=True, allowed values are 'spsolve',; 'splu' and 'spilu'. For sparse=False, allowed values are 'direct' and; 'numpy'. kwargs : dictionary; Additional keyword arguments for setting parameters for solver methods. Returns; -------; R : Qobj; Returns a Qobj instance representing the pseudo inverse of L. Note; ----; In general the inverse of a sparse matrix will be dense. If you; are applying the inverse to a density matrix then it is better to; cast the problem as an Ax=b type problem where the explicit calculation; of the inverse is not required. See page 67 of ""Electrons in; nanostructures"" C. Flindt, PhD Thesis available online:; https://orbit.dtu.dk/fedora/objects/orbit:82314/datastreams/; file_4732600/content. Note also that the definition of the pseudo-inverse herein is different; from numpys pinv() alone, as it includes pre and post projection onto; the subspace defined by the projector Q. """"""; pseudo_args = _default_steadystate_args(); for key in kwargs.keys():; if key in pseudo_args.keys():; pseudo_args[key] = kwargs[key]; else:; raise TypeError(; ""Invalid keyword argument '""+key+""' passed to pseudo_inverse.""); pseudo_args['method'] = method. # Set column perm to NATURAL if using RCM and not specified by user; if pseudo_args['use_rcm'] and ('permc_spec' not in kwargs.keys()):; pseudo_args['permc_spec'] = 'NATURAL'. if rhoss is None:; rhoss = steadystate(L, **pseudo_args). if sparse:; return _pseudo_inverse_sparse(L, rhoss, w=w, **pseudo_args); else:; if pseudo_args['method'] != 'splu':; pseudo_args['method'] = pseudo_args['method']; else:; pseudo_args['method'] = 'direct'; return _pseudo_inver",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/steadystate.html:39983,avail,available,39983,docs/4.7/modules/qutip/steadystate.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/steadystate.html,2,['avail'],['available']
Availability,"e, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0] # <- expectation values for 1 trajectory; expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories; expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories; expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; >>> options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call:; from qutip import *; from pylab import *. times = linspace(0.0, 10.0, 200); psi0 = ten",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:10487,down,down,10487,docs/3.0.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html,2,['down'],['down']
Availability,"e,; tag=None,; ):; self._check_cks_and_vks(ck_real, vk_real, ck_imag, vk_imag); self._check_coup_op(Q). exponents = []; exponents.extend(; BathExponent(""R"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_real, vk_real); ); exponents.extend(; BathExponent(""I"", None, Q, ck, vk, tag=tag); for ck, vk in zip(ck_imag, vk_imag); ). if combine:; exponents = self.combine(exponents). super().__init__(exponents). [docs] @classmethod; def combine(cls, exponents, rtol=1e-5, atol=1e-7):; """"""; Group bosonic exponents with the same frequency and return a; single exponent for each frequency present. Exponents with the same frequency are only combined if they share the; same coupling operator ``.Q``. Note that combined exponents take their tag from the first; exponent in the group being combined (i.e. the one that occurs first; in the given exponents list). Parameters; ----------; exponents : list of BathExponent; The list of exponents to combine. rtol : float, default 1e-5; The relative tolerance to use to when comparing frequencies and; coupling operators. atol : float, default 1e-7; The absolute tolerance to use to when comparing frequencies and; coupling operators. Returns; -------; list of BathExponent; The new reduced list of exponents.; """"""; groups = []; remaining = exponents[:]. while remaining:; e1 = remaining.pop(0); group = [e1]; for e2 in remaining[:]:; if (; np.isclose(e1.vk, e2.vk, rtol=rtol, atol=atol) and; np.allclose(e1.Q, e2.Q, rtol=rtol, atol=atol); ):; group.append(e2); remaining.remove(e2); groups.append(group). new_exponents = []; for combine in groups:; exp1 = combine[0]; if (exp1.type != exp1.types.RI) and all(; exp2.type == exp1.type for exp2 in combine; ):; # the group is either type I or R; ck = sum(exp.ck for exp in combine); new_exponents.append(BathExponent(; exp1.type, None, exp1.Q, ck, exp1.vk, tag=exp1.tag,; )); else:; # the group includes both type I and R exponents; ck_R = (; sum(exp.ck for exp in combine if exp.type == exp.types.R) +; sum(exp.ck fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html:7739,toler,tolerance,7739,docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_baths.html,2,['toler'],['tolerance']
Availability,"e. Parameters; ----------; N : int; Dimension of the state vector to be returned. dims : list of ints, or None; Left-dimensions of the resultant quantum object.; If None, [N] is used. Returns; -------; psi : Qobj; A random state vector drawn from the Haar measure.; """"""; if dims:; _check_ket_dims(dims, N); else:; dims = [N]; psi = rand_unitary_haar(N) * basis(N, 0); psi.dims = [dims, [1]]; return psi. [docs]def rand_dm(N, density=0.75, pure=False, dims=None):; """"""Creates a random NxN density matrix. Parameters; ----------; N : int, ndarray, list; If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix.; density : float; Density between [0,1] of output density matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns; -------; oper : qobj; NxN density matrix quantum operator. Notes; -----; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that :math:`Tr(\\rho)=1`. """"""; if isinstance(N,(np.ndarray,list)):; if np.abs(np.sum(N)-1.0) > 1e-15:; raise ValueError('Eigenvalues of a density matrix must sum to one.'); H = sp.diags(N,0, dtype=complex, format='csr'); N = len(N); if dims:; _check_dims(dims, N, N); nvals = N**2*density; while H.nnz < 0.95*nvals:; H = rand_jacobi_rotation(H); H.sort_indices(); elif isinstance(N,int):; if dims:; _check_dims(dims, N, N); if pure:; dm_density = sqrt(density); psi = rand_ket(N, dm_density); H = psi * psi.dag(); H.data.sort_indices(); else:; non_zero = 0; tries = 0; while non_zero == 0 and tries < 10:; H = rand_herm(N, density); H = H.dag() * H; non_zero = H.tr(); tries += 1; if tries >= 10:; raise ValueError(; ""Requested density is too low to generate density matrix.""); H = H / H.tr(); H.data.sort_indices(); if dims:; return Qobj(H, dims=dims); else:; return Qobj(H). [docs]def rand_dm_ginibre(N=2, rank=None, dims=None):; """"""; Returns a Ginibre random de",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/random_objects.html:10024,error,error,10024,docs/4.0.2/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/random_objects.html,1,['error'],['error']
Availability,"e.targets[1]) % N]); else:; qc_t.add_gate(gate.name,; [(end + gate.targets[0]) % N,; (end + gate.targets[1]) % N]); j = j + 1. else:; qc_t.add_gate(gate.name, gate.targets, gate.controls,; gate.arg_value, gate.arg_label). return qc_t. [docs] def eliminate_auxillary_modes(self, U):; return U. [docs] def optimize_circuit(self, qc):; """"""; Take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters; ----------; qc: :class:`.QubitCircuit`; Takes the quantum circuit to be implemented. Returns; -------; qc: :class:`.QubitCircuit`; The circuit representation with elementary gates; that can be implemented in this model.; """"""; self.qc0 = qc; self.qc1 = self.adjacent_gates(self.qc0); self.qc2 = self.qc1.resolve_gates(; basis=[""SQRTISWAP"", ""ISWAP"", ""RX"", ""RZ""]); return self.qc2. [docs]class LinearSpinChain(SpinChain):; """"""; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters; ----------; N: int; The number of qubits in the system. correct_global_phase: float; Save the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or list; The delta for each of the qubits in the system. sz: int or list; The epsilon for each of the qubits in the system. sxsy: int or list; The interaction strength for each of the qubit pair in the system. t1: list or float, optional; Characterize the decoherence of amplitude damping for; each qubit. t2: list of float, optional; Characterize the decoherence of dephasing for; each qubit.; """"""; def __init__(self, N, correct_global_phase=True,; sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None):. super(LinearSpinChain, self).__init__(; N, correct_global_phase=correct_global_phase,; sx=sx, sz=sz, sxsy=sxsy, t1=t1, t2=t2); self.set_u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html:13823,avail,available,13823,docs/4.6/modules/qutip/qip/device/spinchain.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/spinchain.html,4,['avail'],['available']
Availability,"e:; if isinstance(fid_params, dict):; if not 'phase_option' in fid_params:; fid_params['phase_option'] = phase_option; else:; fid_params = {'phase_option':phase_option}; _param_deprecation(; ""The 'phase_option' parameter is deprecated. ""; ""Use 'phase_option' in fid_params instead""). # fid_err_scale_factor; if not fid_err_scale_factor is None:; if isinstance(fid_params, dict):; if not 'fid_err_scale_factor' in fid_params:; fid_params['scale_factor'] = fid_err_scale_factor; else:; fid_params = {'scale_factor':fid_err_scale_factor}; _param_deprecation(; ""The 'fid_err_scale_factor' parameter is deprecated. ""; ""Use 'scale_factor' in fid_params instead""). # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""). # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_lev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:60878,error,errors,60878,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,5,['error'],['errors']
Availability,"e:; optim = optimizer.Optimizer(cfg, dyn). optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn,; pulse_params=ramping_pulse_params); if alg_up == 'CRAB':; # Create a pulse generator for each ctrl; crab_pulse_params = None; num_coeffs = None; init_coeff_scaling = None; if isinstance(alg_params, dict):; num_coeffs = alg_params.get('num_coeffs'); init_coeff_scaling = alg_params.get('init_coeff_scaling'); if 'crab_pulse_params' in alg_params:; crab_pulse_params = alg_params.get('crab_pulse_params'). guess_pulse_type = init_pulse_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:66193,error,errors,66193,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,5,['error'],['errors']
Availability,"e:; sgn = 1 if self.reverse_states else -1; store_tag = sgn * (n - measurement.targets[0]); col.append(r"" \qw \cwx[%d] "" % store_tag); else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states_quantum = [r""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states[:self.N]]; input_states_classical = [r""\lstick{"" + x + ""}"" if x is not None; else """" for x in self.input_states[self.N:]]; input_states = input_states_quantum + input_states_classical. code = """"; n_iter = (reversed(range(self.N+self.num_cbits)) if self.reverse_states; else range(self.N+self.num_cbits)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(ops)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. # This slightly convoluted dance with the conversion formats is because; # image conversion has optional dependencies. We always want the `png` and; # `svg` methods to be available so that they are discoverable by the user,; # however if one is called without the required dependency, then they'll; # get a `RuntimeError` explaining the problem. We only want the IPython; # magic methods `_repr_xxx_` to be defined if we know that the image; # conversion is available, so the user doesn't get exceptions on display; # because IPython tried to do something behind their back. def _raw_png(self):; return _latex.image_from_latex(self.latex_code(), ""png""). if 'png' in _latex.CONVERTERS:; _repr_png_ = _raw_png. @property; def png(self):; return DisplayImage(self._raw_png(), embed=True). def _raw_svg(self):; return _latex.image_from_latex(self.latex_code(), ""svg""). if 'svg' in _latex.CONVERTERS:; _repr_svg_ = _raw_svg. @property; def svg(self):; return DisplaySVG(self._raw_svg()). def _to_qasm(self, qasm_out):; """"""; Pipe output of circuit object to QasmOutput object. Parameters; ----------; qasm_out: QasmOutput; object to store QASM output.; """""". qasm_out.output(""qreg q[{}];"".format(self.N)); if self.num_cbits:; qasm_out.outp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qip/circuit.html:50514,avail,available,50514,docs/4.7/modules/qutip/qip/circuit.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qip/circuit.html,2,['avail'],['available']
Availability,"e; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It wil",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:84575,error,error,84575,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability,"e; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes:; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes:; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:80718,error,error,80718,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability,"e=False, args={}, options=<qutip.solver.Options object at 0x1a2041a3c8>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate; \(\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x1a2041a278>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:102615,error,errors,102615,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['error'],['errors']
Availability,"e_A_ops_Euler. elif sso.solver == 'fast-milstein':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_single_fast; elif len(sc_ops) == 2:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast. elif sso.method == 'heterodyne':; sso.d2_len = 1; sso.sc_ops = []; for sc in iter(sc_ops):; sso.sc_ops += [sc / np.sqrt(2), -1.0j * sc / np.sqrt(2)]; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast. elif sso.solver == 'taylor15':; sso.generate_A_ops = _generate_A_ops_simple; sso.generate_noise = _generate_noise_Taylor_15; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'taylor15-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:17012,avail,available,17012,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['avail'],['available']
Availability,"e_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html:3307,mask,mask,3307,docs/4.3/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/partial_transpose.html,14,['mask'],['mask']
Availability,"e_types_num.add(qu.args[""_step_func_coeff""]); except Exception:; pass; args.update(qu.args); if len(spline_types_num) > 1:; raise ValueError(""Cannot merge Qobjevo with different spline kinds.""). for i, qobjevo in enumerate(qobjevo_list):; if isinstance(qobjevo, Qobj):; qobjevo_list[i] = QobjEvo(qobjevo); qobjevo = qobjevo_list[i]; for j, ele in enumerate(qobjevo.ops):; if isinstance(ele.coeff, np.ndarray):; new_coeff = _fill_coeff(; ele.coeff, qobjevo.tlist, full_tlist, args); qobjevo_list[i].ops[j].coeff = new_coeff; qobjevo_list[i].tlist = full_tlist. qobjevo = sum(qobjevo_list); return qobjevo. def _fill_coeff(old_coeffs, old_tlist, full_tlist, args=None, tol=1.0e-10):; """"""; Make a step function coefficients compatible with a longer `tlist` by; filling the empty slot with the nearest left value. The returned `coeff` always have the same size as the `tlist`.; If `step_func`, the last element is 0.; """"""; if args is None:; args = {}; if ""_step_func_coeff"" in args and args[""_step_func_coeff""]:; if len(old_coeffs) == len(old_tlist) - 1:; old_coeffs = np.concatenate([old_coeffs, [0]]); new_n = len(full_tlist); old_ind = 0 # index for old coeffs and tlist; new_coeff = np.zeros(new_n); for new_ind in range(new_n):; t = full_tlist[new_ind]; if old_tlist[0] - t > tol:; new_coeff[new_ind] = 0.; continue; if t - old_tlist[-1] > tol:; new_coeff[new_ind] = 0.; continue; # tol is required because of the floating-point error; if old_tlist[old_ind+1] <= t + tol:; old_ind += 1; new_coeff[new_ind] = old_coeffs[old_ind]; else:; sp = CubicSpline(old_tlist, old_coeffs); new_coeff = sp(full_tlist); new_coeff *= (full_tlist <= old_tlist[-1]); new_coeff *= (full_tlist >= old_tlist[0]); return new_coeff. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html:17708,error,error,17708,docs/4.6/modules/qutip/qip/pulse.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/pulse.html,2,['error'],['error']
Availability,"ean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:H_d : Qobj or list of Qobj. Drift (aka system) the underlying Hamiltonian of the system; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:150947,error,error,150947,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['error'],['error']
Availability,"ean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters:H_d : Qobj or list of Qobj. Drift (aka system) the underlying Hamiltonian of the system; can",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:153139,error,error,153139,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['error'],['error']
Availability,"easure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes:; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:107098,error,error,107098,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability,"eats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude dam",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:13896,error,errors,13896,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,2,['error'],['errors']
Availability,"ects; c_str += c_obj; else:; # Combine Hamiltonian objects; if len(h_func) > 0:; h_func += h_obj; elif len(h_str) > 0:; h_str += h_obj. #Combine collapse objects; if len(c_func) > 0:; c_func += c_obj; elif len(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:10275,Error,Error,10275,docs/4.6/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html,2,['Error'],['Error']
Availability,"ed as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:63472,error,error,63472,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,7,['error'],['error']
Availability,"ed as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \\rightarrow \\infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options); else:; return _correlation_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; """"""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\\tau) =; \\frac{\\langle A^\\dagger(\\tau)A(0)\\rangle}; {\\sqrt{\\",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:11422,error,errors,11422,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,6,['error'],['errors']
Availability,"ed then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes; ----------; dump",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/dump.html:12995,error,errors,12995,docs/4.6/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/dump.html,4,['error'],['errors']
Availability,"ed then it must be a byte mode file; as numpy.savetxt is used, and requires this.; """"""; fall = None; # If specific file given then write everything to it; if hasattr(f, 'write'):; if not 'b' in f.mode:; raise RuntimeError(""File stream must be in binary mode""); # write all to this stream; fall = f; fs = f; closefall = False; closefs = False; elif f:; # Assume f is a filename; fall = open(f, 'wb'); fs = fall; closefs = False; closefall = True; else:; self.create_dump_dir(); closefall = False; if self.dump_summary:; fs = open(self.summary_file, 'wb'); closefs = True. if self.dump_summary:; for ois in self.iter_summary:; if ois.idx == 0:; fs.write(asbytes(""{}\n{}\n"".format(; ois.get_header_line(self.summary_sep),; ois.get_value_line(self.summary_sep)))); else:; fs.write(asbytes(""{}\n"".format(; ois.get_value_line(self.summary_sep)))). if closefs:; fs.close(); logger.info(""Optim dump summary saved to {}"".format(; self.summary_file)). if self.dump_fid_err:; if fall:; fall.write(asbytes(""Fidelity errors:\n"")); np.savetxt(fall, self.fid_err_log); else:; np.savetxt(self.fid_err_file, self.fid_err_log). if self.dump_grad_norm:; if fall:; fall.write(asbytes(""gradients norms:\n"")); np.savetxt(fall, self.grad_norm_log); else:; np.savetxt(self.grad_norm_file, self.grad_norm_log). if self.dump_grad:; g_num = 0; for grad in self.grad_log:; g_num += 1; if fall:; fall.write(asbytes(""gradients (call {}):\n"".format(g_num))); np.savetxt(fall, grad); else:; fname = ""{}-fid_err_gradients{}.{}"".format(self.fname_base,; g_num,; self.dump_file_ext); fpath = os.path.join(self.dump_dir, fname); np.savetxt(fpath, grad, delimiter=self.data_sep). if closefall:; fall.close(); logger.info(""Optim dump saved to {}"".format(f)); else:; if fall:; logger.info(""Optim dump saved to specified stream""); else:; logger.info(""Optim dump saved to {}"".format(self.dump_dir)). [docs]class DynamicsDump(Dump):; """"""; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes; ----------; dum",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/dump.html:12975,error,errors,12975,docs/4.1/modules/qutip/control/dump.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/dump.html,6,['error'],['errors']
Availability,"ed, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object at 0x2b225f631c18>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]¶; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters. waveguide_emission_indiceslist or tupleList of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:111633,error,error,111633,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['error'],['error']
Availability,"ed, let us use the qutip.operators.sigmaz operator:; In [51]: sigmaz(); Out[51]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [52]: sigmaz() * spin; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:14000,down,downarrow,14000,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,1,['down'],['downarrow']
Availability,"ed, let us use the qutip.operators.sigmaz operator:; In [52]: sigmaz(); Out[52]: ; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [53]: sigmaz() * spin; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-states.html:14328,down,downarrow,14328,docs/4.4/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-states.html,1,['down'],['downarrow']
Availability,"ed. log_level : integer; Level of messaging output from the logger. Options are attributes of; :obj:`qutip.logging_utils`, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_ext : string or None; Files containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_stats : boolean; If set to ``True`` then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns; -------; opt : OptimResult; Returns instance of :obj:`~qutip.control.optimresult.OptimResult`,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc.; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict):; alg_params = {'num_coeffs':num_coeffs,; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling. # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type:; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:47797,error,error,47797,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"ed.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:101700,error,error,101700,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability,"ed.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_curre",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:5794,error,error,5794,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['error'],['error']
Availability,"eeded to explicitly; create an instance of this class. Attributes:; H : qutip.Qobj; System Hamiltonian. state0 : qutip.Qobj; Initial state vector (ket) or density matrix. times : list / array; List of times for \(t\). Must be uniformly spaced. c_ops : list of qutip.Qobj; List of deterministic collapse operators. sc_ops : list of qutip.Qobj; List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_ops : list of qutip.Qobj; Single operator or list of operators for which to evaluate; expectation values. m_ops : list of qutip.Qobj; List of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. args : dict / list; List of dictionary of additional problem-specific parameters.; Implicit methods can adjust tolerance via args = {‘tol’:value}. ntraj : int; Number of trajectors. nsubsteps : int; Number of sub steps between each time-spep given in times. d1 : function; Function for calculating the operator-valued coefficient to the; deterministic increment dt. d2 : function; Function for calculating the operator-valued coefficient to the; stochastic increment(s) dW_n, where n is in [0, d2_len[. d2_len : int (default 1); The number of stochastic increments in the process. dW_factors : array; Array of length d2_len, containing scaling factors for each; measurement operator in m_ops. rhs : function; Function for calculating the deterministic and stochastic contributions; to the right-hand side of the stochastic differential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : functi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:43186,toler,tolerance,43186,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"efault NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm¶; float – Normalisation constant. fid_norm_func¶; function – Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func¶; function – Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo¶; boolean – flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo¶; boolean –. flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err¶; float – Last computed value of the fidelity error. fidelity¶; float – Last computed value of the normalised fidelity. fidelity_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad¶; array[num_tslot, num_ctrls] of float – Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm¶; float – Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:93390,error,error,93390,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"efine initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:14044,error,errors,14044,docs/4.7/guide/dynamics/dynamics-time.html,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html,2,['error'],['errors']
Availability,"egrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation values for time-dependent; # norm collapse operators; exec(_cy_col_expect_call_func, globals(), _locals); n_dp = np.array(_locals['n_dp']). elif config.tflag in [2, 20, 22]:; # some Python function based collapse operators; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]; n_dp += [abs(config.c_funcs[i](; ODE.t, config.c_func_args)) ** 2 *; cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_td_inds]; n_dp = np.array(n_dp); else:; # all constant collapse operators",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html:25713,toler,tolerance,25713,docs/4.2/modules/qutip/mcsolve.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/mcsolve.html,5,['toler'],['tolerance']
Availability,"egression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * n). return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; """"""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\\tau) =; \\frac{\\langle A^\\dagger(0)A^\\dagger(\\tau)A(\\tau)A(0)\\rangle}; {\\langle A^\\dagger(\\tau)A(\\tau)\\rangle; \\langle A^\\dagger(0)A(0)\\rangle}.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:13522,error,errors,13522,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,6,['error'],['errors']
Availability,"egression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op]).expect[0]. # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, state0, taulist, c_ops,; a_op.dag(), a_op.dag()*a_op, a_op,; solver=solver, args=args, options=options); g2 = G2 / (n[0] * n). return g2, G2. # spectrum. [docs]def spectrum(H, wlist, c_ops, a_op, b_op, solver=""es"", use_pinv=False):; """"""; Calculate the spectrum of the correlation function; :math:`\lim_{t \\to \\infty} \left<A(t+\\tau)B(t)\\right>`,; i.e., the Fourier transform of the correlation function:. .. math::. S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \\to \\infty} \left<A(t+\\tau)B(t)\\right>; e^{-i\omega\\ta",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/correlation.html:15543,error,errors,15543,docs/4.2/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/correlation.html,3,['error'],['errors']
Availability,"el with lowest priority using:; conda config --append channels conda-forge. Otherwise you should consider reinstalling Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Github repository. http://github.com/qutip. In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/installation.html:4830,avail,available,4830,docs/4.4/installation.html,https://qutip.org,https://qutip.org/docs/4.4/installation.html,2,['avail'],['available']
Availability,"elease to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:12578,Down,Download,12578,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,1,['Down'],['Download']
Availability,"elease to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirm",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:7830,Down,Download,7830,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,1,['Down'],['Download']
Availability,"elf, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:13345,error,errors,13345,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,3,['error'],['errors']
Availability,"elf.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.time = self.dynamics.time; result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:13203,error,errors,13203,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,3,['error'],['errors']
Availability,"elf.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). # %%%%%%%%%%% remove ?; class SolverConfiguration():; def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_tdterms = [] # List of td strs and funcs; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op ish",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:13500,toler,tolerance,13500,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,1,['toler'],['tolerance']
Availability,"elf.options.order,; atol=self.options.atol,; rtol=self.options.rtol,; nsteps=self.options.nsteps,; first_step=self.options.first_step,; min_step=self.options.min_step,; max_step=self.options.max_step,; ). self._ode = solver; self.RHSmat = RHSmat. [docs] def steady_state(; self,; use_mkl=True, mkl_max_iter_refine=100, mkl_weighted_matching=False; ):; """"""; Compute the steady state of the system. Parameters; ----------; use_mkl : bool, default=False; Whether to use mkl or not. If mkl is not installed or if; this is false, use the scipy splu solver instead. mkl_max_iter_refine : int; Specifies the the maximum number of iterative refinement steps that; the MKL PARDISO solver performs. For a complete description, see iparm(8) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. mkl_weighted_matching : bool; MKL PARDISO can use a maximum weighted matching algorithm to; permute large elements close the diagonal. This strategy adds an; additional level of reliability to the factorization methods. For a complete description, see iparm(13) in; http://cali2.unilim.fr/intel-xe/mkl/mklman/GUID-264E311E-ACED-4D56-AC31-E9D3B11D1CBF.htm. Returns; -------; steady_state : Qobj; The steady state density matrix of the system. steady_ados : :class:`HierarchyADOsState`; The steady state of the full ADO hierarchy. A particular ADO may be; extracted from the full state by calling :meth:`.extract`.; """"""; n = self._sys_shape. b_mat = np.zeros(n ** 2 * self._n_ados, dtype=complex); b_mat[0] = 1.0. L = deepcopy(self.RHSmat); L = L.tolil(); L[0, 0: n ** 2 * self._n_ados] = 0.0; L = L.tocsr(); L += sp.csr_matrix((; np.ones(n),; (np.zeros(n), [num * (n + 1) for num in range(n)]); ), shape=(n ** 2 * self._n_ados, n ** 2 * self._n_ados)). if mkl_spsolve is not None and use_mkl:; L.sort_indices(); solution = mkl_spsolve(; L,; b_mat,; perm=None,; verbose=False,; max_iter_refine=mkl_max_iter_refine,; scaling_vectors=True,; weighted_matching=mkl_weighted_matching,",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:21065,reliab,reliability,21065,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,2,['reliab'],['reliability']
Availability,"elf.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Comput",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:8300,error,error,8300,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,9,['error'],['error']
Availability,"elif fid_type == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type). if isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer.set_phase_option(phase_option). if isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer.scale_factor = fid_err_scale_factor. # Create the Optimiser instance; # The class of the object will determine which multivar optimisation; # algorithm is used; if optim_alg == 'BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_alg == 'LBFGSB':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:29544,error,errors,29544,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['error'],['errors']
Availability,"elimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir(self)[source]¶; Checks dump directory exists, creates it if not. property level¶. The level of data dumping that will occur; SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary(self)[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(self, fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(self, grad)[source]¶; add an entry to the grad log. update_grad_norm_log(self, grad_norm)[source]¶; add an entry to the grad_norm log. writeout(self, f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:131306,error,error,131306,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability,"eling operator with elements of the form; \(\sum |N><N+m| + |N+m><N|\). Parameters:N : int. Number of basis states in Hilbert space. m : int (default = 1). Number of excitations in tunneling event. Returns:T : Qobj. Tunneling operator. Notes. New in version 3.2. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None)[source]¶; Creates a random NxN density matrix. Parameters:N : int, ndarray, list. If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix. density : float. Density between [0,1] of output density matrix. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_dm_ginibre(N=2, rank=None, dims=None)[source]¶; Returns a Ginibre random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. If rank is None, a full-rank; (Hilbert-Schmidt ensemble) random density operator will be; returned. Parameters:N : int. Dimension of the density operator to be returned. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. rank : int or None. Rank of the sampled density operator. If None, a full-rank; density operator is generated. Returns:rho : Qobj. An N × N density operator sampled from the Ginibre; or Hilbert-Schmidt distribution. rand_dm_hs(N=2, dims=None)[source]¶; Returns a Hilbert-Schmidt random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. Parameters:N : int. Dimension of the density operator to be returned. dims : list. Dimensions of quantum object. Used for spec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:30320,error,error,30320,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability,"elity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.deb",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:18918,error,error,18918,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,3,['error'],['error']
Availability,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/guide-overview.html:2342,avail,available,2342,docs/3.0.0/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html,1,['avail'],['available']
Availability,"em.; Qobj diag method now returns real array if all imaginary parts are zero.; Examples GUI now links to new documentation.; Fixed zero-dimensional array output from metrics module. Version 1.1.2 (October 27, 2011)¶. Bug Fixes¶. Fixed issue where Monte Carlo states were not output properly. Version 1.1.1 (October 25, 2011)¶; THIS POINT-RELEASE INCLUDES VASTLY IMPROVED TIME-INDEPENDENT MCSOLVE AND ODESOLVE PERFORMANCE. New Functions¶. Added linear entropy function.; Number of CPU’s can now be changed. Bug Fixes¶. Metrics no longer use dense matrices.; Fixed Bloch sphere grid issue with matplotlib 1.1.; Qobj trace operation uses only sparse matrices.; Fixed issue where GUI windows do not raise to front. Version 1.1.0 (October 04, 2011)¶; THIS RELEASE NOW REQUIRES THE GCC COMPILER TO BE INSTALLED. New Functions¶. tidyup function to remove small elements from a Qobj.; Added concurrence function.; Added simdiag for simultaneous diagonalization of operators.; Added eigenstates method returning eigenstates and eigenvalues to Qobj class.; Added fileio for saving and loading data sets and/or Qobj’s.; Added hinton function for visualizing density matrices. Bug Fixes¶. Switched Examples to new Signals method used in PySide 1.0.6+.; Switched ProgressBar to new Signals method.; Fixed memory issue in expm functions.; Fixed memory bug in isherm.; Made all Qobj data complex by default.; Reduced ODE tolerance levels in Odeoptions.; Fixed bug in ptrace where dense matrix was used instead of sparse.; Fixed issue where PyQt4 version would not be displayed in about box.; Fixed issue in Wigner where xvec was used twice (in place of yvec). Version 1.0.0 (July 29, 2011)¶. Initial release. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:47050,toler,tolerance,47050,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,1,['toler'],['tolerance']
Availability,"email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:3190,error,error,3190,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['error'],['error']
Availability,"email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; ar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3219,error,error,3219,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"emely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (see PulseGen classes for details). pulse_scaling : float; Linear scale factor for generated pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Line offset for the pulse. That is this value will be added; to any initial pulses generated. log_level : integer; lev",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:8915,error,error,8915,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"ement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can also carry out measurements on individual qubit (both in the middle and at the end of the circuit).; Each measurement is saved as a class object Measurement with parameters such as targets,; the target qubit on which the measurement will be carried out, and classical_store,; the index of the classical register which stores the result of the measurement. A circuit with the various gates and registers available is demonstrated below:; from qutip.qip.circuit import QubitCircuit, Gate; from qutip import tensor, basis. qc = QubitCircuit(N=2, num_cbits=1); swap_gate = Gate(name=""SWAP"", targets=[0, 1]). qc.add_gate(swap_gate); qc.a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-basics.html:1925,avail,available,1925,docs/4.6/guide/qip/qip-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html,2,['avail'],['available']
Availability,"ement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-measurement.html:3397,down,down,3397,docs/4.7/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html,2,['down'],['down']
Availability,"emoved qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the installation requirements in the documentation to match what is specified in setup.py. (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:5800,fault,fault,5800,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['fault'],['fault']
Availability,"en studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hires.png, pdf). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). (png, hires.png, pdf). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). where we have removed the extra show() commands. Replaci",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-bloch.html:2167,avail,available,2167,docs/4.6/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html,2,['avail'],['available']
Availability,"en the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:161150,error,error,161150,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['error'],['error']
Availability,"en the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringdetermines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics objec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:169826,error,error,169826,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['error'],['error']
Availability,"en the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:177450,error,error,177450,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['error'],['error']
Availability,"en the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~Optimizer` object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the ``scipy.optimize.minimize``; method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:9388,error,error,9388,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"en the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A ``scipy.optimize.minimize`` method that will be used to optimise the; pulse for minimum fidelity error. Note that ``FMIN``, ``FMIN_BFGS`` &; ``FMIN_L_BFGS_B`` will all result in calling these specific; ``scipy.optimize methods``. Note the ``LBFGSB`` is equivalent to; ``FMIN_L_BFGS_B`` for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. - GRAPE - Default ``optim_method`` is ``FMIN_L_BFGS_B``; - CRAB - Default ``optim_method`` is ``FMIN``. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be method_options; for the ``scipy.optimize.minimize`` method. optim_alg : string; Deprecated. Use ``optim_method``. max_metric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matri",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:7669,error,error,7669,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"en the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:236710,error,error,236710,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,2,['error'],['error']
Availability,"en the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or; the termination_conditions matching the key that attribute.; Otherwise, and in some case also, they are assumed to be; method_options for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:248828,error,error,248828,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['error'],['error']
Availability,"en there). num_coeffs : integer; Number of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by ``alg_params`` (if given there). optim_method : string; Multi-variable optimisation method. The only tested options are 'fmin'; and 'Nelder-mead'. In theory any non-gradient method implemented in; ``scipy.optimize.minimize`` could be used. method_params : dict; Parameters for the ``optim_method``. Note that where there is an; attribute of the :obj:`~qutip.control.optimizer.Optimizer` object or; the termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; ``scipy.optimize.minimize`` method. The commonly used parameter are:. - xtol - limit on variable change for convergence; - ftol - limit on fidelity error change for convergence. phase_option : string; Determines how global phase is treated in fidelity calculations; (``fid_type='UNIT'`` only). Options:. - PSU - global phase ignored; - SU - global phase included. dyn_params : dict; Parameters for the :obj:`~qutip.control.dynamics.Dynamics` object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_params : dict; Parameters for the :obj:`~qutip.control.propcomp.PropagatorComputer`; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_params : dict; Parameters for the :obj:`~qutip.control.fidcomp.FidelityComputer`; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:44202,error,error,44202,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"en(c_str) > 0:; c_str += c_obj. if solver == 'me':; return (len(h_const + c_const),; len(h_func) + len(c_func),; len(h_str) + len(c_str)). elif solver == 'mc':. # H C_ops #; # -- ----- --; # NO NO 00; # NO STR 01; # NO FUNC 02; #; # STR NO 10; # STR STR 11; #; # FUNC NO 20; #; # FUNC FUNC 22. if isinstance(H, FunctionType):; time_type = 3; # Time-indepdent problems; elif ((len(h_func) == len(h_str) == 0) and; (len(c_func) == len(c_str) == 0)):; time_type = 0. # constant Hamiltonian, time-dependent collapse operators; elif len(h_func) == len(h_str) == 0:; if len(c_str) > 0:; time_type = 1; elif len(c_func) > 0:; time_type = 2; else:; raise Exception(""Error determining time-dependence.""). # list style Hamiltonian; elif len(h_str) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 10; elif len(c_str) > 0:; time_type = 11; else:; raise Exception(""Error determining time-dependence.""). # Python function style Hamiltonian; elif len(h_func) > 0:; if len(c_func) == len(c_str) == 0:; time_type = 20; elif len(c_func) > 0:; time_type = 22; else:; raise Exception(""Error determining time-dependence.""). return time_type, [h_const, h_func, h_str], [c_const, c_func, c_str]. def _td_wrap_array_str(H, c_ops, args, times):; """"""; Wrap numpy-array based time-dependence in the string-based time dependence; format; """"""; n = 0; H_new = []; c_ops_new = []; args_new = {}. if not isinstance(H, list):; H_new = H; else:; for Hk in H:; if isinstance(Hk, list) and isinstance(Hk[1], np.ndarray):; H_op, H_td = Hk; td_array_name = ""_td_array_%d"" % n; H_td_str = '(0 if (t > %f) else %s[int(round(%d * (t/%f)))])' %\; (times[-1], td_array_name, len(times) - 1, times[-1]); args_new[td_array_name] = H_td; H_new.append([H_op, H_td_str]); n += 1; else:; H_new.append(Hk). if not isinstance(c_ops, list):; c_ops_new = c_ops; else:; for ck in c_ops:; if isinstance(ck, list) and isinstance(ck[1], np.ndarray):; c_op, c_td = ck; td_array_name = ""_td_array_%d"" % n; c_td_str = '(0 if (t > %f) else %s[int(round(%d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html:10488,Error,Error,10488,docs/4.6/modules/qutip/rhs_generate.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/rhs_generate.html,2,['Error'],['Error']
Availability,"enerators. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float. Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffs : integer. Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algori",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:180456,error,error,180456,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['error'],['error']
Availability,"enerators. U_0 : Qobj. starting point for the evolution.; Typically the identity matrix. U_targ : Qobj. target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None. number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None. total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None. durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats. lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats. upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float. Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.mini",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:155378,error,error,155378,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['error'],['error']
Availability,"ense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/partial_transpose.html:4613,mask,mask,4613,docs/4.5/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/partial_transpose.html,3,['mask'],['mask']
Availability,"ent contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; J.R. Johansson. Author; Chris Grenade. Author; P.D. Nation. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. version; 4.4. status; Released (July 18, 2018). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the syst",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/frontmatter.html:1377,down,download,1377,docs/4.4/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html,1,['down'],['download']
Availability,"ent_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configurati",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:225719,error,error,225719,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability,"ential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: 'euler-maruyama', 'fast-euler-maruyama',; 'pc-euler' is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: 'milstein', 'fast-milstein', 'platen',; 'milstein-imp' is semi-implicit Milstein method,; 3/2 order algorithms: 'taylor15',; 'taylor15-imp' is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {'tol':value},; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the evolution. options : :class:`qutip.solver.Options`; Generic solver options. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:6898,toler,tolerance,6898,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['toler'],['tolerance']
Availability,"ential equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are:; 1/2 order algorithms: ‘euler-maruyama’, ‘fast-euler-maruyama’,; ‘pc-euler’ is a predictor-corrector method which is more; stable than explicit methods,; 1 order algorithms: ‘milstein’, ‘fast-milstein’, ‘platen’,; ‘milstein-imp’ is semi-implicit Milstein method,; 3/2 order algorithms: ‘taylor15’,; ‘taylor15-imp’ is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {‘tol’:value},; default is {‘tol’:1e-6}. method : string (‘homodyne’, ‘heterodyne’, ‘photocurrent’); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string (‘normal’, ‘poission’); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; qutip.solver.SolverResult instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the evolution. options : qutip.solver.Options; Generic solver options. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function func",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:44889,toler,tolerance,44889,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"epare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname); ; if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html:20056,error,error,20056,docs/4.2/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/bloch_redfield.html,1,['error'],['error']
Availability,"er 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html:9598,avail,available,9598,docs/4.6/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/4.6/guide/dynamics/dynamics-monte.html,4,['avail'],['available']
Availability,"er is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:43410,mask,mask,43410,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['mask'],['mask']
Availability,"er is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sp",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:32780,mask,mask,32780,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['mask'],['mask']
Availability,"er is deprecated. ""; ""Use 'scale_factor' in fid_params instead""); ; # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pa",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:62015,error,errors,62015,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,2,['error'],['errors']
Availability,"er is deprecated. ""; ""Use 'scale_factor' in fid_params instead""); ; # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:61552,error,errors,61552,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['error'],['errors']
Availability,"er). def __rsub__(self, other):; """"""; SUBTRACTION with Qobj on RIGHT [ ex. 4-Qobj ]; """"""; return (-self) + other. def __mul__(self, other):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup:; out.tidyup(); if (settings.auto_tidyup_dims; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1; for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching; # dims are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. elif self.shape[1] == 1 and other.shape[0] == 1:; out = Qobj(); out.data = self.data * other.data; out.dims = [self.dims[0], other.dims[1]]; return out.tidyu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:16040,mask,mask,16040,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,4,['mask'],['mask']
Availability,"er); if self.type == 'super':; new_dims = [self.dims[0], [1]]; new_type = 'operator-ket'; else:; new_dims = [self.dims[0], [1] * len(self.dims[0])]; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims, type=new_type) for vec in evecs]; norms = np.array([ket.norm() for ket in ekets]); if phase_fix is None:; phase = np.array([1] * len(ekets)); else:; phase = np.array([np.abs(ket[phase_fix, 0]) / ket[phase_fix, 0]; if ket[phase_fix, 0] else 1; for ket in ekets]); return evals, ekets / norms * phase. [docs] def eigenenergies(self, sparse=False, sort='low',; eigvals=0, tol=0, maxiter=100000):; """"""Eigenenergies of a quantum object. Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; sort : str; Sort eigenvalues 'low' to high, or 'high' to low.; eigvals : int; Number of requested eigenvalues. Default is all eigenvalues.; tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns; -------; eigvals : array; Array of eigenvalues for operator. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; return sp_eigs(self.data, self.isherm, vecs=False, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol, maxiter=maxiter). [docs] def groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True):; """"""Ground state Eigenvalue and Eigenvector. Defined for quantum operators or superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver; tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter : int; Maximum number of iterations performed by sparse solver (if used).; safe : bool (defau",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:44876,Toler,Tolerance,44876,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['Toler'],['Tolerance']
Availability,"er. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string. Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict. Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_type : string. Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict. Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_option : string. Deprecated. Pass in fid_params instead. fid_err_scale_factor : float. Deprecated. Use scale_factor key in fid_params instead. tslot_type : string. Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_params : dict. Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_mode : string. Deprecated. Use tslot_type instead. init_pulse_type : string. type / shape of pulse(s) used to initialise the; the control amplitudes.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:149180,error,error,149180,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,8,['error'],['error']
Availability,"er.OptimizerLBFGSB(cfg, dyn); elif optim_alg is None:; raise errors.UsageError(""Optimisation algorithm must be specified ""; ""via 'optim_alg' parameter""); else:; raise errors.UsageError(""No option for optim_alg: "" + optim_alg). # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc. if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; dyn.get_num_ctrls(). # Create a pulse generator of the type specified; p_gen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn); p_gen.scaling = pulse_scaling; p_gen.offset = pulse_offset; p_gen.lbound = amp_lbound; p_gen.ubound = amp_ubound. # If the pulse is a periodic type, then set the pulse to be one complete; # wave; if isinstance(p_gen, pulsegen.PulseGenPeriodic):; p_gen.num_waves = 1.0; optim.pulse_generator = p_gen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:30560,error,errors,30560,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,1,['error'],['errors']
Availability,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:15122,error,error,15122,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['error'],['error']
Availability,"eral system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error u",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:18373,error,errors,18373,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,3,['error'],['errors']
Availability,"erally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html:4777,error,errors,4777,docs/4.5/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/control/optimizer.html,2,['error'],['errors']
Availability,"erating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; """""". if self.oper_dtype == Qobj:; H = self._dyn_gen[k]; # Returns eigenvalues as array (row); # and eigenvectors as rows of an array; eig_val, eig_vec = sp_eigs(H.data, H.isherm,; sparse=self.sparse_eigen_decomp); eig_vec = eig_vec.T. elif self.oper_dtype == np.ndarray:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = np.linalg.eigh(H); else:; if sparse:; H = self._dyn_gen[k].toarray(); else:; H = self._dyn_gen[k]; # returns row vector of eigenvals, columns with the eigenvecs; eig_val, eig_vec = la.eigh(H). # assuming H is an nxn matrix, find n; n = self.get_drift_dim(). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvectors, propagator and factor matric; # for use in propagator computations; self._decomp_curr[k] = True; if isin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html:48859,down,down,48859,docs/4.4/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/dynamics.html,2,['down'],['down']
Availability,"erator with elements of the form; \(\sum |N><N+m| + |N+m><N|\). Parameters:; N : int; Number of basis states in Hilbert space. m : int (default = 1); Number of excitations in tunneling event. Returns:; T : Qobj; Tunneling operator. Notes. New in version 3.2. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None)[source]¶; Creates a random NxN density matrix. Parameters:; N : int, ndarray, list; If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix. density : float; Density between [0,1] of output density matrix. dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:; oper : qobj; NxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_dm_ginibre(N=2, rank=None, dims=None)[source]¶; Returns a Ginibre random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. If rank is None, a full-rank; (Hilbert-Schmidt ensemble) random density operator will be; returned. Parameters:; N : int; Dimension of the density operator to be returned. dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. rank : int or None; Rank of the sampled density operator. If None, a full-rank; density operator is generated. Returns:; rho : Qobj; An N × N density operator sampled from the Ginibre; or Hilbert-Schmidt distribution. rand_dm_hs(N=2, dims=None)[source]¶; Returns a Hilbert-Schmidt random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. Parameters:; N : int; Dimension of the density operator to be returned. dims : list; Dimensions of quantum object. Used fo",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:30525,error,error,30525,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['error']
Availability,"erators is Hermitian,; otherwise complex values are returned. dnorm(B=None)[source]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real posi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:6322,toler,tolerance,6322,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['toler'],['tolerance']
Availability,"ern version of Numpy. Source installations from pip understand this constraint. Version 4.5.2 (July 14, 2020)¶; This is predominantly a hot-fix release to add support for Scipy 1.5, due to changes in private sparse matrix functions that QuTiP also used. Improvements¶. Add support for Scipy 1.5. (by Jake Lishman); Improved speed of zcsr_inner, which affects Qobj.overlap. (by Jake Lishman); Better error messages when installation requirements are not satisfied. (by Eric Giguère). Bug Fixes¶. Fix zcsr_proj acting on matrices with unsorted indices. (by Jake Lishman); Fix errors in Milstein’s heterodyne. (by Eric Giguère); Fix datatype bug in qutip.lattice module. (by Boxi Li); Fix issues with eigh on Mac when using OpenBLAS. (by Eric Giguère). Developer Changes¶. Converted more of the codebase to PEP 8.; Fix several instances of unsafe mutable default values and unsafe is comparisons. Version 4.5.1 (May 15, 2020)¶. Improvements¶. husimi and wigner now accept half-integer spin (by maij); Better error messages for failed string coefficient compilation. (issue raised by nohchangsuk). Bug Fixes¶. Safer naming for temporary files. (by Eric Giguère); Fix clebsch function for half-integer (by Thomas Walker); Fix randint’s dtype to uint32 for compatibility with Windows. (issue raised by Boxi Li); Corrected stochastic’s heterodyne’s m_ops (by eliegenois); Mac pool use spawn. (issue raised by goerz); Fix typos in QobjEvo._shift. (by Eric Giguère); Fix warning on Travis CI. (by Ivan Carvalho). Deprecations¶. qutip.graph functions will be deprecated in QuTiP 5.0 in favour of scipy.sparse.csgraph. Developer Changes¶. Add Boxi Li to authors. (by Alex Pitchford); Skip some tests that cause segfaults on Mac. (by Nathan Shammah and Eric Giguère); Use Python 3.8 for testing on Mac and Linux. (by Simon Cross and Eric Giguère). Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:17484,error,error,17484,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['error'],['error']
Availability,"erodyne'); The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expect : bool (default False); Whether or not to store the e_ops expect values for all paths. store_measurement : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.Result` instance returned by the solver. noise : int, or 1D array of int, or 4D array of float; - int : seed of the noise; - 1D array : length = ntraj, seeds for each trajectories.; - 4D array : ``(ntraj, len(times), nsubsteps, len(sc_ops)*[1|2])``.; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepth : int; Number of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalize : bool; (default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. options : :class:`qutip.solver.Options`; Generic solver options. Only options.average_states and; options.store_states are used. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function. progress_bar : :class:`qutip.ui.BaseProgressBar`; Optional progress bar class instance.; """"""; def __init__(self, me, H=None, c_ops=[], sc_ops=[], state0=None,; e_ops=[], m_ops=None, store_all_expect=False,; store_measurement=False, dW_factors=None,; solver=None, method=""homodyne"", normalize=None,; times=None, nsubsteps=1, ntraj=1, tol=None,; generate_noise=None, noise=None,; progress_bar=None, map_func=None, map_kwargs=None,; args={}, options=None, noiseDepth=20):. if options is None:; options = Options(). if progress_bar is None:; progress_bar = TextProgressBar(). # System; # Cast to QobjEvo so the code has only one version for both the; # constant and time-d",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/stochastic.html:11937,error,errors,11937,docs/4.6/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/stochastic.html,4,['error'],['errors']
Availability,"error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. epsilon¶; float – control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. class TimeslotComputer(dynamics, params=None)[source]¶; Base cla",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:98515,error,error,98515,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"ers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; >>> ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0] # <- expectation values for 1 trajectory; expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories; expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories; expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; >>> options = Options(rhs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html:10116,avail,available,10116,docs/3.0.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html,2,['avail'],['available']
Availability,"ers; ----------; state : :class:`.Qobj`; The ket or density matrix specifying the state to measure. op : :class:`.Qobj`; The measurement operator. targets : list of ints, optional; Specifies a list of target ""qubit"" indices on which to apply the; measurement using :func:`qutip.qip.gates.expand_operator` to expand op; into full dimension. Returns; -------; measured_value : float; The result of the measurement (one of the eigenvalues of op). state : :class:`.Qobj`; The new state (a ket if a ket was given, otherwise a density matrix). Examples; --------. Measure the z-component of the spin of the spin-up basis state:. >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase). Measure the x-component of the spin of the spin-down basis state:. >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax. One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:. >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix.; """"""; eigenvalues, eigenstates_or_projectors, probabilities = (; measurement_statistics_observable(state, op, targets)); i = np.random.choice(range(len(eigenvalues)), p=probabilities); if state.isket:; eigenstat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/measurement.html:9610,down,down,9610,docs/4.6/modules/qutip/measurement.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/measurement.html,2,['down'],['down']
Availability,"ers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:Alexander Pitchford. Author:Chris Grenade. Author:Arne Grimsmo. Author:P.D. Nation. Author:J.R. Johansson. version:4.0. status:Released (XX YY, 2017). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/frontmatter.html:1256,down,download,1256,docs/4.0.2/frontmatter.html,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html,1,['down'],['download']
Availability,"ersion 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.4.0 (July 03, 2019)¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/changelog.html:1604,avail,available,1604,docs/4.4/changelog.html,https://qutip.org,https://qutip.org/docs/4.4/changelog.html,1,['avail'],['available']
Availability,"ersion 3.1.0 (January 1, 2015)¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014)¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator re",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/changelog.html:34969,error,errors,34969,docs/4.6/changelog.html,https://qutip.org,https://qutip.org/docs/4.6/changelog.html,2,['error'],['errors']
Availability,"erwise complex values are returned. dnorm(B=None)[source]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters:; B : Qobj or None; If B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns:; d : float; Either the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). Returns:; eigvals : array; Array of eigenvalues for operator. eigvecs : arr",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:6325,toler,tolerance,6325,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"es of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom)",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:91007,error,error,91007,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,4,['error'],['error']
Availability,"es of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:204845,error,error,204845,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,6,['error'],['error']
Availability,"es ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, nor",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:7114,toler,tolerance,7114,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['toler'],['tolerance']
Availability,"es, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html:2765,down,downside,2765,docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-bloch-redfield.html,13,['down'],['downside']
Availability,"eslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityCom",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:17355,error,error,17355,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,12,['error'],['error']
Availability,"eslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:17341,error,error,17341,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,6,['error'],['error']
Availability,"esponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [56]: sigmaz() * spin; Out[56]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [57]: vac = basis(5, 0). In [58]: one = basis(5, 1). In [59]: c = create(5). In [60]: N = num(5). In [61]: expect(N, vac); Out[61]: 0.0. In [62]: expect(N, one); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/guide/guide-states.html:14963,down,downarrow,14963,docs/4.3/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.3/guide/guide-states.html,1,['down'],['downarrow']
Availability,"esponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [58]: vac = basis(5, 0). In [59]: one = basis(5, 1). In [60]: c = create(5). In [61]: N = num(5). In [62]: expect(N, vac); Out[62]: 0.0. In [63]: expect(N, one); ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-states.html:15291,down,downarrow,15291,docs/4.4/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-states.html,1,['down'],['downarrow']
Availability,"esponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; In [58]: vac = basis(5, 0). In [59]: one = basis(5, 1). In [60]: c = create(5). In [61]: N = num(5). In [62]: expect(N, vac); Out[62]: 0.0. In [63]: expect(N, one); Out[63]: 1.0. In [64]: coh = coherent_dm(5, 1.0j). In [65]: expect(N, coh); Out[65]: 0.9970555745806596. In [66]: cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). In [67]: expect(c, cat); Out[67]: 0.9999999999999998j. The qutip.expect function also accepts lists or arrays o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-states.html:14951,down,downarrow,14951,docs/4.5/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-states.html,1,['down'],['downarrow']
Availability,"ess the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, len(ctrls)] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:H_d : Qobj or list of Qobj. Drift (aka syste",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:175666,error,error,175666,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['error'],['error']
Availability,"ess the output of files. gen_stats : boolean. if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns:opt : OptimResult. Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters:H_d : Qobj or list of Qobj. Drift (aka system) ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:178187,error,error,178187,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,1,['error'],['error']
Availability,"ess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE',; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the tim",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:41384,error,error,41384,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"et of qubits in either; the 'up' :math:`\lvert0\rangle` or 'down' :math:`\lvert1\rangle` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu') # doctest: +SKIP; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]; """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # spin down; 'H': 0, # horizontal polarization; 'V': 1} # vertical polarization. def _character_to_qudit(x):; """"""; Converts a character representing a one-particle state into int.; """"""; if x in _qubit_dict:; return _qubit_dict[x]; else:; return int(x). [docs]def ket(seq, dim=2):; """"""; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters; ----------; seq : str / list of ints or characters; Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string ""1101"").; For qubits it is also possible to use the following conventions:; - 'g'/'e' (ground and excited state); - 'u'/'d' (spin up and down); - 'H'/'V' (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints; Space dimension for each particle:; int if there are the same, list if they are different. Returns; -------; ket : qobj. Examples; ----",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/states.html:16917,down,down,16917,docs/4.6/modules/qutip/states.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/states.html,4,['down'],['down']
Availability,"eterodyne':; sso.d2_len = 1; sso.sc_ops = []; for sc in iter(sc_ops):; sso.sc_ops += [sc / np.sqrt(2), -1.0j * sc / np.sqrt(2)]; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_homodyne_two_fast; else:; sso.rhs = _rhs_rho_milstein_homodyne_fast; ; elif sso.solver == 'taylor15':; sso.generate_A_ops = _generate_A_ops_simple; sso.generate_noise = _generate_noise_Taylor_15; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available"") . elif sso.solver == 'taylor15-imp': ; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:17436,avail,available,17436,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,3,['avail'],['available']
Availability,"eters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """""". if issuper(L):. # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.matrix(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/essolve.html:5576,error,error,5576,docs/4.5/modules/qutip/essolve.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/essolve.html,1,['error'],['error']
Availability,"eters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isoper : bool; True if Qobj is operator, False otherwise. Examples; --------; >>> a = destroy(5); >>> isoper(a); True. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isoper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isoper else False. [docs]def issuper(Q):; """"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isherm`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isherm else False. # TRAILING IMPOR",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:61083,Toler,Tolerence,61083,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['Toler'],['Tolerence']
Availability,"etric_corr : integer; Deprecated. Use ``method_params`` instead. accuracy_factor : float; Deprecated. Use ``method_params`` instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe the dynamics.; Options are ``UNIT``, ``GEN_MAT``, ``SYMPL`` (see :obj:`~Dynamics`; classes for details). dyn_params : dict; Parameters for the :obj:`~Dynamics` object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_type : string; Propagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; ``dyn_type`` (see :obj:`~PropagatorComputer` classes for details). prop_params : dict; Parameters for the :obj:`~PropagatorComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_type : string; Fidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific ``dyn_type`` (See :obj:`~FidelityComputer` classes for; details). fid_params : dict; Parameters for the :obj:`~FidelityComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. phase_option : string; Deprecated. Pass in ``fid_params`` instead. fid_err_scale_factor : float; Deprecated. Use ``scale_factor`` key in ``fid_params`` instead. tslot_type : string; Method for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See :obj:`~TimeslotComputer`; classes for details.). tslot_params : dict; Parameters for the :obj:`~TimeslotComputer` object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. amp_update_mode : string; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:11125,error,error,11125,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"etting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). [docs] def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecate",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:9292,error,error,9292,docs/4.3/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html,7,['error'],['error']
Availability,"etting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:9292,error,error,9292,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,3,['error'],['error']
Availability,"eturn _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:2670,mask,mask,2670,docs/4.7/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html,8,['mask'],['mask']
Availability,"eturn self.func([t])[0]. class _StateAsArgs:; # old with state (f(t, psi, args)) to new (args[""state""] = psi); def __init__(self, coeff_func):; self.coeff_func = coeff_func. def __call__(self, t, args={}):; return self.coeff_func(t, args[""_state_vec""], args). # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; class StateArgs:; """"""Object to indicate to use the state in args outside solver.; args[key] = StateArgs(type, op); """""". def __init__(self, type=""Qobj"", op=None):; self.dyn_args = (type, op). def __call__(self):; return self.dyn_args. # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%; # object for each time dependent element of the QobjEvo; # qobj : the Qobj of element ([*Qobj*, f]); # get_coeff : a callable that take (t, args) and return the coeff at that t; # coeff : The coeff as a string, array or function as provided by the user.; # type : flag for the type of coeff; class EvoElement:; """"""; Internal type used to represent the time-dependent parts of a; :class:`~qutip.QobjEvo`. Availables ""types"" are. 1. function; 2. string; 3. ``np.ndarray``; 4. :class:`.Cubic_Spline`; """""". def __init__(self, qobj, get_coeff, coeff, type):; self.qobj = qobj; self.get_coeff = get_coeff; self.coeff = coeff; self.type = type. @classmethod; def make(cls, list_):; return cls(*list_). def __getitem__(self, i):; if i == 0:; return self.qobj; if i == 1:; return self.get_coeff; if i == 2:; return self.coeff; if i == 3:; return self.type. [docs]class QobjEvo:; """"""; A class for representing time-dependent quantum objects, such as quantum; operators and states. Basic math operations are defined:. - ``+``, ``-`` : :class:`~qutip.QobjEvo`, :class:`~qutip.Qobj`, scalars.; - ``*``: :class:`~qutip.Qobj`, C number; - ``/`` : C number. This object is constructed by passing a list of :obj:`~qutip.Qobj`; instances, each of which *may* have an associated scalar time dependence.; The list is summed to produce the final result. In other words, if an; instance of this class is :math:`Q(t)`, then it is construc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html:4199,Avail,Availables,4199,docs/4.7/modules/qutip/qobjevo.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/qobjevo.html,1,['Avail'],['Availables']
Availability,"eturn zcsr_inner(self.data, other.data, 0); elif other.isoper:; return (qutip.states.ket2dm(self).dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err). elif self.isoper:; if other.isket or other.isbra:; return (self.dag() * qutip.states.ket2dm(other)).tr(); elif other.isoper:; return (self.dag() * other).tr(); else:; err = ""Can only calculate overlap for state vector Qobjs""; raise TypeError(err); raise TypeError(""Can only calculate overlap for state vector Qobjs""). [docs] def eigenstates(self, sparse=False, sort='low', eigvals=0,; tol=0, maxiter=100000, phase_fix=None):; """"""Eigenstates and eigenenergies. Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters; ----------; sparse : bool; Use sparse Eigensolver. sort : str; Sort eigenvalues (and vectors) 'low' to high, or 'high' to low. eigvals : int; Number of requested eigenvalues. Default is all eigenvalues. tol : float; Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int; Maximum number of iterations performed by sparse solver (if used). phase_fix : int, None; If not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns; -------; eigvals : array; Array of eigenvalues for operator. eigvecs : array; Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; sort=sort, eigvals=eigvals, tol=tol,; maxiter=maxiter); if self.type == 'super':; new_dims = [self.dims[0], [1]]; new_type = 'operator-ket'; else:; new_dims = [self.dims[0], [1] * len(self.dims[0])]; new_type = 'ket'; ekets = np.empty((len(evecs),), dtype=object); ekets[:] = [Qobj(vec, dims=new_dims",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:43123,Toler,Tolerance,43123,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['Toler'],['Tolerance']
Availability,"eturns:P : qobj. Permuted quantum object. ptrace(sel)¶; Partial trace of the quantum object. Parameters:sel : int/list. An int or list of components to keep after partial trace. Returns:oper: qobj. Quantum object representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. sqrtm(sparse=False, tol=0, maxiter=100000)¶; Sqrt of a quantum operator.; Operator must be square. Parameters:sparse : bool. Use sparse eigenvalue/vector solver. tol : float. Tolerance used by sparse solver (0 = machine precision). maxiter : int. Maximum number of iterations used by sparse solver. Returns:oper: qobj. Matrix square root of operator. Raises:TypeError. Quantum object is not square. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. tidyup(atol=None)¶; Removes small elements from the quantum object. Parameters:atol : float. Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns:oper: qobj. Quantum object with small elements removed. tr()¶; Trace of a quantum object. Returns:trace: float. Returns real if operator is Hermitian, returns complex; otherwise. trans()¶; Transposed operator. Returns:oper : qobj. Transpose of input operator. transform(inpt, inverse=False)¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters:inpt : array_like. A matrix or list of kets defining the transformation. inverse : bool. Whether to return inverse transformation. Returns:oper : qobj. Operator in new basis. Notes; This function is still in development. unit(norm=None, sparse=False, tol=0, maxiter=100000)¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters:norm : str. Requested norm for states / operators. sparse : bool. Use sparse eigensolver for trace norm. Does not af",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:13475,toler,tolerance,13475,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"eturns:a – Instance representing the propagator \(U(t)\). Return type:qobj. propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U (qobj) – Operator representing the propagator. Returns:a – Instance representing the steady-state density matrix. Return type:qobj. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:; H (qobj) – System Hamiltonian.; c_ops (list) – list of collapse operators.; args (dict) – Arguments for time-dependent Hamiltonian and collapse operator terms.; options (Options) – Instance of ODE solver options.; name (str) – Name of generated RHS; cleanup (bool) – Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:. Return type:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:; state (qobj) – A state vector or density matrix.; xvec (array_like) – x-coordinates at which to calculate the Wigner function.; yvec (array_like) – y-coordinates at which to calculate the Wigner function.; g (float) – Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q – Values representing the Q-function calculated over the specified range; [xvec,yvec]. Return type:array. spin_q_function(rho, theta, phi)[source]¶; Husimi Q-function for spins. Parameters:; state (qobj) – A state vector or density matrix for a spin-j quantum system.; theta (array_like) – theta-c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:110480,error,error,110480,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability,"evelopers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.partial_transpose. Source code for qutip.partial_transpose; __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """""". mask = [int(i) for i in mask]. if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Impleme",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html:1140,mask,mask,1140,docs/4.7/modules/qutip/partial_transpose.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/partial_transpose.html,4,['mask'],['mask']
Availability,"evious deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download Built Files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring Progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:12893,down,download,12893,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['down'],['download']
Availability,"evious deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/release_distribution.html:8145,down,download,8145,docs/4.6/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html,2,['down'],['download']
Availability,"evo_time (float or None) – total time for the evolution; None implies that timeslots will be given in the tau array; tau (array[num_tslots] of floats or None) – durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots; amp_lbound (float or list of floats) – lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; amp_ubound (float or list of floats) – upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control; fid_err_targ (float) – Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value; max_iter (integer) – Maximum number of iterations of the optimisation algorithm; max_wall_time (float) – Maximum allowed elapsed time for the optimisation algorithm; alg_params (Dictionary) – options that are specific to the algorithm see above; optim_params (Dictionary) – The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; coeff_scaling (float) – Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); num_coeffs (integer) – Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); optim_method (string) – Multi-variable optimisation method; The only tested options are ‘fmin’ and ‘Nelder-mead’; In theory any non",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:173496,error,error,173496,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,2,['error'],['error']
Availability,"extProgressBar will be used. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x10569e200>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str. Name of generated RHS. cleanup: bool. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)[source]¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)[source]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:97555,error,error,97555,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['error'],['error']
Availability,"ey applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:207320,ERROR,ERROR,207320,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['ERROR'],['ERROR']
Availability,"f L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import functools; import numpy as np; import timeit; import warnings; from packaging.version import parse as _parse_version; import scipy; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. # Older versions of SciPy use the method numpy.ndarray.tostring(), which has; # been deprecated since Numpy 1.19 in favour of the identical-in-all-but-name; # tobytes() method. This is simply a deprecated call in SciPy, there's nothing; # we or our users can do about it, and the function shouldn't actually be; # removed from Numpy until at least 1.22, by which point we'll have been able; # to drop support for SciPy 1.4.; if _parse_version(scipy.__version__) < _parse_version(""1.5""):; @functools.wraps(spopt.fmin_l_bfgs_b); def fmin_l_bfgs_b(*args, **kwargs):; with warnings.catch_warnings():; message = r""tostring\(\) is deprecated\. Use tobytes\(\) instead\.""; warnings.filterwarnings(""ignore"", message=message,; category=DeprecationWarning); return spopt.fmin_l_bfgs_b(*args, **kwargs); else:; fmin_l_bfgs_b = spopt.fmin_l_bfgs_b. def _is_string(var):; try:; if isins",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:4884,error,errors,4884,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,8,['error'],['errors']
Availability,"f the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:225161,error,error,225161,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,6,['error'],['error']
Availability,"f the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes:; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:105891,error,error,105891,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,2,['error'],['error']
Availability,"f the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:84007,error,error,84007,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability,"f the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:70199,error,error,70199,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"f the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:67204,error,error,67204,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,3,['error'],['error']
Availability,"f the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fid",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:197850,error,error,197850,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability,"f they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:192871,error,error,192871,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability,"f times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. :math:`t \rightarrow \infty`; here tlist is; automatically set, ignoring user input. taulist : *list* / *array*; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list of :class:`qutip.qobj.Qobj`; list of collapse operators. a_op : :class:`qutip.qobj.Qobj`; operator A. b_op : :class:`qutip.qobj.Qobj`; operator B. reverse : bool; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : :class:`qutip.solver.Options`; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat: *array*; An 2-dimensional *array* (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional *array* of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options); else:; if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, tlist, taulist,; c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args=None,; options=Options(ntraj=[20, 100])):; """"""; Calculate the three-operator two-time correlation function",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:8177,error,errors,8177,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['error'],['errors']
Availability,"f times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. :math:`t \rightarrow \infty`; here tlist is; automatically set, ignoring user input. taulist : *list* / *array*; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list of :class:`qutip.qobj.Qobj`; list of collapse operators. a_op : :class:`qutip.qobj.Qobj`; operator A. b_op : :class:`qutip.qobj.Qobj`; operator B. reverse : bool; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : :class:`qutip.solver.Options`; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat: *array*; An 2-dimensional *array* (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional *array* of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlation_2op_2t()"",; FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args=None,; options=Options(ntraj=[20, 100])):; """"""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t+\\tau)D(t)\\right>`; along one time axis using the quantum regression theorem and the; evolution solver indica",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:22838,error,errors,22838,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['error'],['errors']
Availability,"f you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:6136,reliab,reliably,6136,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,4,['reliab'],['reliably']
Availability,"f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. options : :class:`qutip.solver.Options`; Options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spect",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:4001,Toler,Tolerance,4001,docs/4.7/modules/qutip/bloch_redfield.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html,1,['Toler'],['Tolerance']
Availability,"f):; if self.isfunc:; result = self.raw_out; else:; result = []; for ii in range(self.e_num):; if self.e_ops_isherm[ii]:; result.append(np.real(self.raw_out[ii, :])); else:; result.append(self.raw_out[ii, :]); if self.e_ops_dict:; result = {e: result[n]; for n, e in enumerate(self.e_ops_dict.keys())}; return result. def __eq__(self, other):; if isinstance(other, ExpectOps):; other = other.raw_e_ops; return self.raw_e_ops == other. def __ne__(self, other):; return not (self == other). def __bool__(self):; return bool(self.e_num). [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/solver.html:5002,toler,tolerance,5002,docs/4.4/modules/qutip/solver.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/solver.html,6,['toler'],['tolerance']
Availability,"f.dyn_gen[k]. [docs] def get_ctrl_dyn_gen(self, j):; """"""; Get the dynamics generator for the control; including the -i factor; """"""; return -1j*self.ctrl_dyn_gen[j]. def get_num_ctrls(self):; if not self._dyn_gen_mapped:; self._map_dyn_gen_to_ham(); return Dynamics.get_num_ctrls(self). def get_owd_evo_target(self):; return self.target.conj().T. [docs] def spectral_decomp(self, k):; """"""; Calculates the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; """"""; H = self.H[k]; # assuming H is an nxn matrix, find n; n = H.shape[0]; # returns row vector of eigen values,; # columns with the eigenvectors; eig_val, eig_vec = np.linalg.eig(H). # Calculate the propagator in the diagonalised basis; eig_val_tau = -1j*eig_val*self.tau[k]; prop_eig = np.exp(eig_val_tau). # Generate the factor matrix through the differences; # between each of the eigenvectors and the exponentiations; # create nxn matrix where each eigen val is repeated n times; # down the columns; o = np.ones([n, n]); eig_val_cols = eig_val_tau*o; # calculate all the differences by subtracting it from its transpose; eig_val_diffs = eig_val_cols - eig_val_cols.T; # repeat for the propagator; prop_eig_cols = prop_eig*o; prop_eig_diffs = prop_eig_cols - prop_eig_cols.T; # the factor matrix is the elementwise quotient of the; # differeneces between the exponentiated eigen vals and the; # differences between the eigen vals; # need to avoid division by zero that would arise due to denegerate; # eigenvalues and the diagonals; degen_mask = np.abs(eig_val_diffs) < self.fact_mat_round_prec; eig_val_diffs[degen_mask] = 1; factors = prop_eig_diffs / eig_val_diffs; # for degenerate eigenvalues the factor is just the exponent; factors[degen_mask] = prop_eig_cols[degen_mask]. # Store eigenvals and eigenvectors for use by other functions, e.g.; # gradient_exact; self.decomp_curr[k] = True; self.prop_e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html:25737,down,down,25737,docs/3.1.0/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/dynamics.html,1,['down'],['down']
Availability,"ferent physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrice",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:4568,avail,available,4568,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,4,['avail'],['available']
Availability,"ffset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_ts",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:234315,error,error,234315,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"fidelity error gradients wrt the; control in the timeslot. grad_norm¶; float – Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current¶; boolean – flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradie",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:94384,error,error,94384,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"first one, qutip.qip.device.ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the CQED model for quantum computing. In those models, the driving Hamiltonians are predefined. The other approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called qutip.qip.device.OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In the model bases processor, the Hamiltonians are predefined and one only need to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method qutip.qip.device.Processor.load_circuit, which takes a qutip.qip.QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method qutip.qip.device.Processor.run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for qutip.qip.QubitCircuit.propagators. However, this does not consider the collapse operators or the noise. As the system size gets larger, this approach will become v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-qip.html:9060,avail,available,9060,docs/4.5/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-qip.html,1,['avail'],['available']
Availability,"float – Minimum normalised gradient after which optimisation will terminate. max_iterations¶; integer – Maximum iterations of the optimisation algorithm. max_fid_func_calls¶; integer – Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor¶; float – Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. termination_reason¶; string – Description of the reason for terminating the optimisation. fidelity¶; float – final (normalised) fidelity that was achieved. initial_fid_err¶; float – fidelity error before optimisation starting. fid_err¶; float – final fidelity error that was achieved. goal_achieved¶; boolean – True is the fidely error achieved was below the target. grad_norm_final¶; float – Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached¶; float – True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter¶; integer – Number of iterations of the optimisation algorithm completed. max_iter_exceeded¶; boolean – True if the iteration limit was reached. max_fid_func_exceeded¶; boolean – True if the fidelity function call limit was reached. wall_time¶; float – time elapsed during the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the opt",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:74008,error,error,74008,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/contributing.html:9602,down,down,9602,docs/4.6/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html,2,['down'],['down']
Availability,"form; \(\sum |N><N+m| + |N+m><N|\). Parameters:; N (int) – Number of basis states in Hilbert space.; m (int (default = 1)) – Number of excitations in tunneling event. Returns:T – Tunneling operator. Return type:Qobj. Notes. New in version 3.2. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None)[source]¶; Creates a random NxN density matrix. Parameters:; N (int, ndarray, list) – If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix.; density (float) – Density between [0,1] of output density matrix.; dims (list) – Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper – NxN density matrix quantum operator. Return type:qobj. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_dm_ginibre(N=2, rank=None, dims=None)[source]¶; Returns a Ginibre random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. If rank is None, a full-rank; (Hilbert-Schmidt ensemble) random density operator will be; returned. Parameters:; N (int) – Dimension of the density operator to be returned.; dims (list) – Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]].; rank (int or None) – Rank of the sampled density operator. If None, a full-rank; density operator is generated. Returns:rho – An N × N density operator sampled from the Ginibre; or Hilbert-Schmidt distribution. Return type:Qobj. rand_dm_hs(N=2, dims=None)[source]¶; Returns a Hilbert-Schmidt random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. Parameters:; N (int) – Dimension of the density operator to be returned.; dims (list) – Dimensions of quant",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:31126,error,error,31126,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,1,['error'],['error']
Availability,"fter partial trace. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object representing partial trace with selected components; remaining. Notes; -----; This function is identical to the :func:`qutip.qobj.ptrace` function; that has been deprecated. """"""; if sparse is None:; if self.isket:; sparse = False; elif (self.data.nnz / (self.shape[0] * self.shape[1])) >= 0.1:; sparse = False; if sparse:; q = Qobj(); q.data, q.dims, _ = _ptrace(self, sel); return q.tidyup() if settings.auto_tidyup else q; else:; return _ptrace_dense(self, sel). [docs] def permute(self, order):; """"""Permutes a composite quantum object. Parameters; ----------; order : list/array; List specifying new tensor order. Returns; -------; P : :class:`qutip.Qobj`; Permuted quantum object. """"""; q = Qobj(); q.data, q.dims = _permute(self, order); q.data.sort_indices(); return q. [docs] def tidyup(self, atol=settings.auto_tidyup_atol):; """"""Removes small elements from the quantum object. Parameters; ----------; atol : float; Absolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns; -------; oper : :class:`qutip.Qobj`; Quantum object with small elements removed. """"""; if self.data.nnz:; # This does the tidyup and returns True if; # The sparse data needs to be shortened; if use_openmp() and self.data.nnz > 500:; if omp_tidyup(self.data.data,atol, self.data.nnz,; settings.num_cpus):; self.data.eliminate_zeros(); else:; if cy_tidyup(self.data.data,atol, self.data.nnz):; self.data.eliminate_zeros(); return self; else:; return self. [docs] def transform(self, inpt, inverse=False, sparse=True):; """"""Basis transform defined by input array. Input array can be a ``matrix`` defining the transformation,; or a ``list`` of kets that defines the new basis. Parameters; ----------; inpt : array_like; A ``matrix`` or ``list`` of kets defining the transformation.; inverse : bool; Whether to return inverse transformation.; sparse : bool; Use sparse matrices when possible. Can be slower.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:35305,toler,tolerance,35305,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['toler'],['tolerance']
Availability,"fter the configuration is complete; before any dynamics can be calculated; """"""; if not isinstance(self.prop_computer, propcomp.PropagatorComputer):; raise errors.UsageError(; ""No prop_computer (propagator computer) ""; ""set. A default should be assigned by the Dynamics subclass""). if not isinstance(self.tslot_computer, tslotcomp.TimeslotComputer):; raise errors.UsageError(; ""No tslot_computer (Timeslot computer)""; "" set. A default should be assigned by the Dynamics class""). if not isinstance(self.fid_computer, fidcomp.FidelityComputer):; raise errors.UsageError(; ""No fid_computer (Fidelity computer)""; "" set. A default should be assigned by the Dynamics subclass""). self.ctrl_amps = None; if not self._timeslots_initialized:; init_tslots = True; if init_tslots:; self.init_timeslots(); self._init_evo(); self.tslot_computer.init_comp(); self.fid_computer.init_comp(); self._ctrls_initialized = True; self.update_ctrl_amps(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html:28615,error,errors,28615,docs/4.2/modules/qutip/control/dynamics.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/dynamics.html,8,['error'],['errors']
Availability,"ful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_vec : array; An array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters:; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0 : Qobj; Initial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:92496,error,errors,92496,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['errors']
Availability,"fun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generat",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:32993,error,error,32993,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,4,['error'],['error']
Availability,"fun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.abc.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse gen",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html:33053,error,error,33053,docs/4.4/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html,6,['error'],['error']
Availability,"g Anaconda / Miniconda. In theory:; conda update conda. will update your conda to the latest version, but this can lead to breaking your default Ananconda enviroment.; Alternatively, this will add conda-forge as the highest priority channel.; conda config --add channels conda-forge. It is almost certainly better to have defaults as the highest priority channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; import qutip.testing as qt; qt.run(). If successful, these tests indicate that all of the QuTiP fu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/installation.html:5129,avail,available,5129,docs/4.0.2/installation.html,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html,1,['avail'],['available']
Availability,"g the requested number state |n>. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qotoolbox:; basis(N, 1) = ground state. Examples; >>> basis(5,2); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]. bell_state(state='00')[source]¶; Returns the Bell state:. |B00> = 1 / sqrt(2)*[|0>|0>+|1>|1>]; |B01> = 1 / sqrt(2)*[|0>|0>-|1>|1>]; |B10> = 1 / sqrt(2)*[|0>|1>+|1>|0>]; |B11> = 1 / sqrt(2)*[|0>|1>-|1>|0>]. Returns:Bell_state : qobj. Bell state. bra(seq, dim=2)[source]¶; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters:seq : str / list of ints or characters. Each element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:; - ‘g’/’e’ (ground and excited state); - ‘u’/’d’ (spin up and down); - ‘H’/’V’ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dim : int (default: 2) / list of ints. Space dimension for each particle:; int if there are the same, list if they are different. Returns:bra : qobj. Examples; >>> bra(""10""); Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue""); Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3); Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]); Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method='operator')[source]¶; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters:N : int. Number of Foc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:2794,down,down,2794,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['down'],['down']
Availability,"gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compar",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:14268,error,error,14268,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,2,['error'],['error']
Availability,"ges from 0, for states with unit fidelity, to pi/2. Parameters; ----------; A : qobj; Density matrix or state vector.; B : qobj; Density matrix or state vector with same dimensions as A. Returns; -------; angle : float; Bures angle between density matrices.; """"""; if A.isket or A.isbra:; A = ket2dm(A); if B.isket or B.isbra:; B = ket2dm(B). if A.dims != B.dims:; raise TypeError('A and B do not have same dimensions.'). return np.arccos(fidelity(A, B)). [docs]def hellinger_dist(A, B, sparse=False, tol=0):; """"""; Calculates the quantum Hellinger distance between two density matrices. Formula:; hellinger_dist(A, B) = sqrt(2-2*Tr(sqrt(A)*sqrt(B))). See: D. Spehner, F. Illuminati, M. Orszag, and W. Roga, ""Geometric; measures of quantum correlations with Bures and Hellinger distances""; arXiv:1611.03449. Parameters; ----------; A : :class:`qutip.Qobj`; Density matrix or state vector.; B : :class:`qutip.Qobj`; Density matrix or state vector with same dimensions as A.; tol : float; Tolerance used by sparse eigensolver, if used. (0=Machine precision); sparse : {False, True}; Use sparse eigensolver. Returns; -------; hellinger_dist : float; Quantum Hellinger distance between A and B. Ranges from 0 to sqrt(2). Examples; --------; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(hellinger_dist(x,y), 1.3725145002591095); """"""; if A.isket or A.isbra:; sqrtmA = ket2dm(A); else:; sqrtmA = A.sqrtm(sparse=sparse, tol=tol); if B.isket or B.isbra:; sqrtmB = ket2dm(B); else:; sqrtmB = B.sqrtm(sparse=sparse, tol=tol). if sqrtmA.dims != sqrtmB.dims:; raise TypeError(""A and B do not have compatible dimensions.""). product = sqrtmA*sqrtmB; eigs = sp_eigs(product.data,; isherm=product.isherm, vecs=False, sparse=sparse, tol=tol); # np.maximum() is to avoid nan appearing sometimes due to numerical; # instabilities causing np.sum(eigs) slightly (~1e-8) larger than 1; # when hellinger_dist(A, B) is called for A=B; return np.sqrt(2.0 * np.maximum(0., (1.0 - np.real(np.sum(e",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/metrics.html:7240,Toler,Tolerance,7240,docs/4.7/modules/qutip/metrics.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/metrics.html,1,['Toler'],['Tolerance']
Availability,"ging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the pulse optim algorithm ``alg``. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:7589,error,error,7589,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['error'],['error']
Availability,"gmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvecto",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-measurement.html:3173,down,down,3173,docs/4.6/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html,2,['down'],['down']
Availability,"gmax()]); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). Different parameters for different gates:. .. code-block:: python. qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigmay(), sigmay()])); setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}; tlist, coeffs = processor.load_circuit(qc,; setting_args=setting_args,; merge_gates=False). Parameters; ----------; qc: :class:`.QubitCircuit` or list of Qobj; The quantum circuit to be translated. min_fid_err: float, optional; The minimal fidelity tolerance, if the fidelity error of any; gate decomposition is higher, a warning will be given.; Default is infinite. merge_gates: boolean, optimal; If True, merge all gate/Qobj into one Qobj and then; find the optimal pulses for this unitary matrix. If False,; find the optimal pulses for each gate/Qobj. setting_args: dict, optional; Only considered if merge_gates is False.; It is a dictionary containing keyword arguments; for different gates. E.g.: ::. setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. verbose: boolean, optional; If true, the information for each decomposed gate; will be shown. Default is False. **kwargs; keyword arguments for `qutip.control.optimize_pulse_unitary`. Returns; -------; tlist: array_like; A NumPy array specifies the time of each coefficient. coeffs: array_like; A 2d NumPy array of the shape (len(ctrls), len(tlist)-1). Each; row corresponds to the control pulse sequence for; one Ha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html:5550,toler,tolerance,5550,docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/device/optpulseprocessor.html,8,"['error', 'toler']","['error', 'tolerance']"
Availability,"gstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-steady.html:7431,avail,available,7431,docs/4.2/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-steady.html,10,['avail'],['available']
Availability,"gstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; False, True; Attempt to generate a preconditioner when using the 'iter",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-steady.html:8031,avail,available,8031,docs/3.1.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html,1,['avail'],['available']
Availability,"gth. offsetint or list of ints, optional (default 0 for all dimensions)The lowest number state that is included in the finite number state; representation of the state in the relevant dimension. Returns. dmqobjDensity matrix representation of Fock state. Examples; >>> fock_dm(3,1) ; Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]]. ghz_state(N=3)[source]¶; Returns the N-qubit GHZ-state. Parameters. Nint (default=3)Number of qubits in state. Returns. GqobjN-qubit GHZ-state. ket(seq, dim=2)[source]¶; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:; - ‘g’/’e’ (ground and excited state); - ‘u’/’d’ (spin up and down); - ‘H’/’V’ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. ketqobj. Examples; >>> ket(""10"") ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue"") ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) ; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) ; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. ket2dm(Q)[source]¶; Takes input ket or bra vector and returns density matrix; formed by outer ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:12532,down,down,12532,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['down'],['down']
Availability,"guration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.abc.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html:34483,error,errors,34483,docs/4.4/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/optimizer.html,6,['error'],['errors']
Availability,"h University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html:3230,error,errors,3230,docs/4.6/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/fidcomp.html,8,['error'],['errors']
Availability,"h matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class ModelProcessor(N, correct_global_phase=True, t1=None, t2=None)[source]¶; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class Processor). Parameters. N: intThe number of component systems. correct_global_phase: boolean, optionalIf true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. Attributes. params: dictA Python dictionary contains the name and the value of the parameters; in the physical realization, such as laser frequency, detuning etc. correct_global_phase: floatSave the global phase, the analytical solution; will track t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:108181,avail,available,108181,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,1,['avail'],['available']
Availability,"h options for the ODE solver. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2ac685b5c998>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/functions.html:75001,error,error,75001,docs/3.0.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html,1,['error'],['error']
Availability,"h options for the ODE solver. Returns:a : qobj. Instance representing the propagator \(U(t)\). propagator_steadystate(U)¶; Find the steady state for successive applications of the propagator; \(U\). Parameters:U : qobj. Operator representing the propagator. Returns:a : qobj. Instance representing the steady-state density matrix. Time-dependent problems¶. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options instance at 0x2b11f5a5c950>, name=None, cleanup=True)¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters:H : qobj. System Hamiltonian. c_ops : list. list of collapse operators. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. name: str :. Name of generated RHS. cleanup: bool :. Whether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()¶; Resets the string-format time-dependent Hamiltonian parameters. Returns:Nothing, just clears data from internal config module. :. Visualization¶. Pseudoprobability Functions¶. qfunc(state, xvec, yvec, g=1.4142135623730951)¶; Q-function of a given state vector or density matrix; at points xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like. x-coordinates at which to calculate the Wigner function. yvec : array_like. y-coordinates at which to calculate the Wigner function. g : float. Scaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). Returns:Q : array. Values representing the Q-function calculated over the specified range; [xvec,yvec]. wigner(psi, xvec, yvec, method='iterative', g=1.4142135623730951, parfor=False)¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters:state : qobj. A state vector or density matrix. xvec : array_like",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.1/apidoc/functions.html:75061,error,error,75061,docs/3.0.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html,1,['error'],['error']
Availability,"h, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array :. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that cont",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/apidoc/classes.html:5651,toler,tolerance,5651,docs/3.0.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html,2,['toler'],['tolerance']
Availability,"hape; rho_shape = (n, n); rho_dims = self._sys_dims; hierarchy_shape = (self._n_ados, n, n). output = Result(); output.solver = ""HEOMSolver""; output.times = tlist; if e_ops:; output.expect = expected; if not e_ops or self.options.store_states:; output.states = []. if ado_init:; if isinstance(rho0, HierarchyADOsState):; rho0_he = rho0._ado_state; else:; rho0_he = rho0; if rho0_he.shape != hierarchy_shape:; raise ValueError(; f""ADOs passed with ado_init have shape {rho0_he.shape}""; f""but the solver hierarchy shape is {hierarchy_shape}""; ); rho0_he = rho0_he.reshape(n ** 2 * self._n_ados); else:; rho0_he = np.zeros([n ** 2 * self._n_ados], dtype=complex); rho0_he[:n ** 2] = rho0.full().ravel('F'). if ado_return:; output.ado_states = []. solver = self._ode; solver.set_initial_value(rho0_he, tlist[0]). self.progress_bar.start(len(tlist)); for t_idx, t in enumerate(tlist):; self.progress_bar.update(t_idx); if t_idx != 0:; solver.integrate(t); if not solver.successful():; raise RuntimeError(; ""HEOMSolver ODE integration error. Try increasing""; "" the nsteps given in the HEOMSolver options""; "" (which increases the allowed substeps in each""; "" step between times given in tlist).""). rho = Qobj(; solver.y[:n ** 2].reshape(rho_shape, order='F'),; dims=rho_dims,; ); if self.options.store_states or not e_ops:; output.states.append(rho); if ado_return or e_ops_callables:; ado_state = HierarchyADOsState(; rho, self.ados, solver.y.reshape(hierarchy_shape); ); if ado_return:; output.ado_states.append(ado_state); for e_key, e_op in e_ops.items():; if isinstance(e_op, Qobj):; e_result = (rho * e_op).tr(); else:; e_result = e_op(t, ado_state); output.expect[e_key].append(e_result). self.progress_bar.finished(); return output. [docs]class HSolverDL(HEOMSolver):; """"""; A helper class for creating an :class:`HEOMSolver` that is backwards; compatible with the ``HSolverDL`` provided in ``qutip.nonmarkov.heom``; in QuTiP 4.6 and below. See :class:`HEOMSolver` and :class:`DrudeLorentzBath` for m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html:27274,error,error,27274,docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/nonmarkov/bofin_solvers.html,2,['error'],['error']
Availability,"hape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:250184,ERROR,ERROR,250184,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,1,['ERROR'],['ERROR']
Availability,"hastic differential equation. This only needs to be specified when implementing a custom SDE solver. generate_A_ops; (function) Function that generates a list of pre-computed operators or super- operators. These precomputed operators are used in some d1 and d2 functions. generate_noise; (function) Function for generate an array of pre-computed noise signal. homogeneous; (bool (True)) Wheter or not the stochastic process is homogenous. Inhomogenous processes are only supported for poisson distributions. solver; (string) Name of the solver method to use for solving the stochastic equations. Valid values are: 1/2 order algorithms: ‘euler-maruyama’, ‘fast-euler-maruyama’, ‘pc-euler’ is a predictor-corrector method which is more stable than explicit methods, 1 order algorithms: ‘milstein’, ‘fast-milstein’, ‘platen’, ‘milstein-imp’ is semi-implicit Milstein method, 3/2 order algorithms: ‘taylor15’, ‘taylor15-imp’ is semi-implicit Taylor 1.5 method. Implicit methods can adjust tolerance via args = {‘tol’:value}, default is {‘tol’:1e-6}. method; (string (‘homodyne’, ‘heterodyne’, ‘photocurrent’)) The name of the type of measurement process that give rise to the stochastic equation to solve. Specifying a method with this keyword argument is a short-hand notation for using pre-defined d1 and d2 functions for the corresponding stochastic processes. distribution; (string (‘normal’, ‘poission’)) The name of the distribution used for the stochastic increments. store_measurements; (bool (default False)) Whether or not to store the measurement results in the qutip.solver.SolverResult instance returned by the solver. noise; (array) Vector specifying the noise. normalize; (bool (default True)) Whether or not to normalize the wave function during the evolution. options; (qutip.solver.Options) Generic solver options. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_func function function.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:43846,toler,tolerance,43846,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['toler'],['tolerance']
Availability,"hat the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[so",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:220692,error,error,220692,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability,"hat the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clea",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:107092,error,error,107092,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/development/development.html:1573,Error,Error,1573,docs/4.6/development/development.html,https://qutip.org,https://qutip.org/docs/4.6/development/development.html,2,"['Down', 'Error']","['Download', 'Error']"
Availability,"he initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object at 0x1a2041a2e8>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘s",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:105980,error,errors,105980,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['error'],['errors']
Availability,"he initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624ea9e8>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:88017,error,errors,88017,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['error'],['errors']
Availability,"he initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:120214,error,errors,120214,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['errors']
Availability,"he logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX';",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html:6235,error,errors,6235,docs/4.1/modules/qutip/control/propcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/propcomp.html,9,['error'],['errors']
Availability,"he qutip.qip.circuit.Gate object with qutip.qip.compiler.instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the r",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-processor.html:14496,error,error,14496,docs/4.6/guide/qip/qip-processor.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-processor.html,6,['error'],['error']
Availability,"he scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_type (string) – Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); dyn_params (dict) – Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; prop_type (string) – Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details); prop_params (dict) – Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; fid_type (string) – Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details); fid_params (dict) – Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; tslot_type (string) – Method for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); tslot_params (dict) – Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; guess_pulse_type (string) – type / shape of pulse(s) used modulate the control amplitudes.; Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None. guess_pulse_params (dict) – Parameters for the guess p",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/functions.html:176024,error,error,176024,docs/4.0.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/functions.html,2,['error'],['error']
Availability,"he single-qubit rotation together with the qubits-cavity interaction \(a^{\dagger} \sigma^{-} + a \sigma^{+}\). The device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc. OptPulseProcessor¶; The qutip.qip.device.OptPulseProcessor uses the function in qutip.control.pulseoptim.optimize_pulse_unitary in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows. \[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d + \sum_j u_j H_j] )\]; To let it find the optimal pulses, we need to give the parameters for qutip.control.pulseoptim.optimize_pulse_unitary as keyword arguments to qutip.qip.device.OptPulseProcessor.load_circuit. Usually the minimal requirements are the evolution time evo_time and the number of time slices num_tslots for each gate. Other parameters can also be given in the keyword arguments. For available choices, see qutip.control.pulseoptim.optimize_pulse_unitary. It is also possible to specify different parameters for different gates, as shown in the following example:; >>> from qutip.qip.device import OptPulseProcessor; >>> from qutip.operators import sigmaz, sigmax, sigmay; >>> from qutip.tensor import tensor; >>>; >>> # Same parameter for all the gates; ... qc = QubitCircuit(N=1); >>> qc.add_gate(""SNOT"", 0); >>>; >>> num_tslots = 10; >>> evo_time = 10; >>> processor = OptPulseProcessor(N=1, drift=sigmaz()); >>> processor.add_control(sigmax()); >>> # num_tslots and evo_time are two keyword arguments; ... tlist, coeffs = processor.load_circuit(; ... qc, num_tslots=num_tslots, evo_time=evo_time); >>>; >>> # Different parameters for different gates; ... qc = QubitCircuit(N=2); >>> qc.add_gate(""SNOT"", 0); >>> qc.add_gate(""SWAP"", targets=[0, 1]); >>> qc.add_gate('CNOT', controls=1, targets=[0]); >>>; >>> processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); >>> processor.add_con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/guide/guide-qip.html:11832,avail,available,11832,docs/4.5/guide/guide-qip.html,https://qutip.org,https://qutip.org/docs/4.5/guide/guide-qip.html,1,['avail'],['available']
Availability,"he steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like. list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like. list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list. list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj. operator A. b_op : Qobj. operator B. c_op : Qobj. operator C. d_op : Qobj. operator D. solver : str. choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options. solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:corr_mat : array. An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters:H : qutip.qobj. system Hamiltonian. wlist : array_like. list of frequencies for \(\omega\). c_ops : list. list of collapse operators. a_op : Qob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:93633,error,errors,93633,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['errors']
Availability,"he steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlist : array_like; list of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for \(\tau\). taulist must be positive and contain; the element 0. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; me or mc. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). options : Options; solver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns:; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters:; H : qutip.qobj; system Hamiltonian. wlist : array_like; list of frequencies for \(\omega\). c_ops : list; list of collapse operators. a_op :",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:94447,error,errors,94447,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['errors']
Availability,"he two-operator two-time correlation function:. .. math::. \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>. along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate; :math:`\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>` instead of; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec : array; An array of correlation values for the times specified by `tlist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_ss() now legacy, please use correlation_2op_1t() with"" +; ""initial state as None"", FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_1t(H, None, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:20230,error,errors,20230,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['error'],['errors']
Availability,"he; measurement is the corresponding eigenvalue. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opQobjThe measurement operator. targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply the; measurement using qutip.qip.operations.gates.expand_operator; to expand op into full dimension. Returns. measured_valuefloatThe result of the measurement (one of the eigenvalues of op). stateQobjThe new state (a ket if a ket was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measure_povm(state, ops, targets=None)[source]¶; Perform a measurement specified by list of POVMs.; This function simulates a POVM measurement. The measurement collapses the; state to one of the resultant states of the measurement and ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:74002,down,down,74002,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['down'],['down']
Availability,"hen you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda Forge¶; If not done previously then fork the qutip-feedstock.; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Find the sha256 checksum for the tarball that the GitHub web interface generated when you produced the release called “Source code”.; This is not the sdist that you downloaded earlier, it’s a new file that GitHub labels “Source code”.; When you download it, though, it will have a name that looks like it’s the sdist; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version at the top of the file, and update the sha256 checksum.; Check that the recipe package version requirements at least match those in setup.cfg, and that any changes to the build process are reflected in meta.yml.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are foun",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:18969,down,downloaded,18969,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['down'],['downloaded']
Availability,"her). def __rsub__(self, other):; """"""; SUBTRACTION with Qobj on RIGHT [ ex. 4-Qobj ]; """"""; return (-self) + other. def __mul__(self, other):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup: out.tidyup(); if (settings.auto_tidyup_dims ; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1 for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching dims; # are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype=='object':; return np.array([self * item for item in o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/qobj.html:15117,mask,mask,15117,docs/4.3/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qobj.html,1,['mask'],['mask']
Availability,"her). def __rsub__(self, other):; """"""; SUBTRACTION with Qobj on RIGHT [ ex. 4-Qobj ]; """"""; return (-self) + other. def __mul__(self, other):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; self._isunitary = None. if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup: out.tidyup(); if (settings.auto_tidyup_dims; and not isinstance(dims[0][0], list); and not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1 for l, r in zip_longest(dims[0],; dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching; # dims are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. elif self.shape[1] == 1 and other.shape[0] == 1:; out = Qobj(); out.data = self.data * other.data; out.dims = [self.dims[0], other.dims[1]]; return out.tidyu",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/qobj.html:15376,mask,mask,15376,docs/4.5/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/qobj.html,1,['mask'],['mask']
Availability,"hey have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:21779,error,error,21779,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['error']
Availability,"high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : Qobj. A new instance of qutip.Qobj that co",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:6862,toler,tolerance,6862,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['toler'],['tolerance']
Availability,"his is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:34328,error,error,34328,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,6,['error'],['error']
Availability,"his value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for the Dy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:147570,error,error,147570,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability,"his value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. phase_option : string. determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict. Par",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:156454,error,error,156454,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability,"his value. mim_grad : float. Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer. Maximum number of iterations of the optimisation algorithm. max_wall_time : float. Maximum allowed elapsed time for the optimisation algorithm. alg : string. Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary. options that are specific to the algorithm see above. optim_params : Dictionary. The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string. a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict. Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string. Deprecated. Use optim_method. max_metric_corr : integer. Deprecated. Use method_params instead. accuracy_factor : float. Deprecated. Use method_params instead. dyn_type : string. Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict. Parameters for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:164266,error,error,164266,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,2,['error'],['error']
Availability,"his value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for the Dy",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:162359,error,error,162359,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['error']
Availability,"his value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type=’UNIT’ only). Options:. PSU - global phase ignored; SU - global phase included. dyn_params : dict; Par",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:171247,error,error,171247,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['error']
Availability,"his value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_params : dict; Parameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_params : dict; Parameters for",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:179063,error,error,179063,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['error']
Availability,"hm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,...) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,....). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for dir",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-control.html:11930,down,down,11930,docs/4.2/guide/guide-control.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-control.html,1,['down'],['down']
Availability,"hnes et.al., arXiv.1011.4874; """""". import warnings; import numpy as np; import timeit; # QuTiP; from qutip.qobj import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The ke",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html:4473,ERROR,ERROR,4473,docs/4.6/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/tslotcomp.html,2,['ERROR'],['ERROR']
Availability,"ho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/entropy.html:4966,mask,mask,4966,docs/4.2/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/entropy.html,10,['mask'],['mask']
Availability,"ho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueE",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/entropy.html:7036,Toler,Tolerance,7036,docs/4.6/modules/qutip/entropy.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/entropy.html,2,['Toler'],['Tolerance']
Availability,"ho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object at 0x1a2041a438>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/functions.html:109489,error,errors,109489,docs/4.5/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/functions.html,1,['error'],['errors']
Availability,"ho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eab38>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:91530,error,errors,91530,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,1,['error'],['errors']
Availability,"ho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:123691,error,errors,123691,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['errors']
Availability,"hod is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_one; #elif len(sc_ops) == 2:; # sso.rhs = _rhs_rho_taylor_15_two; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'milstein-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Milstein; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_milstein_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'taylor15-imp':; sso.generate_A_ops = _generate_A_ops_implicit; sso.generate_noise = _generate_noise_Taylor_15; if sso.args == None:; sso.args = {'tol':1e-6}; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_taylor_15_implicit; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). elif sso.solver == 'pc-euler':; sso.generate_A_ops = _generate_A_ops_Milstein; sso.generate_noise = _generate_noise_Milstein # could also work without this; if sso.method == 'homodyne' or sso.method is None:; if len(sc_ops) == 1:; sso.rhs = _rhs_rho_pred_corr_homodyne_single; else:; raise Exception(""Only one stochastic operator is supported""); else:; raise Exception(""Only homodyne is available""). else:; raise Exception(""Unrecognized solver '%s'."" % sso.solver). res = _smesolve_generic(sso, sso.options, sso.progress_bar). if e_ops_dict:; res.expect = {e: res.expect[n]; for n, e in enumerate(e_ops_dict.keys())}. return res. [docs]def ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs):; """"""; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use :func:`qutip.mcsolve` instead for quantum; trajectory simulations. Parameters; ----------. H : :class:`qutip.Qobj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/modules/qutip/stochastic.html:17838,avail,available,17838,docs/4.3/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/stochastic.html,1,['avail'],['available']
Availability,"hods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_ty",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:199322,error,error,199322,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"hods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF'",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/functions.html:143200,error,error,143200,docs/4.2/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/functions.html,6,['error'],['error']
Availability,"how the guess pulse is applied to the pulse generated by the; basis expansion. Options are: MODULATE, ADD. pulse_scalingfloatLinear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:223491,ERROR,ERROR,223491,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,1,['ERROR'],['ERROR']
Availability,"how the guess pulse is applied to the pulse generated by the; basis expansion. Options are: MODULATE, ADD. pulse_scalingfloatLinear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult,; which has attributes giving the reason for termination, final fidelity; error, final evolution final amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:235606,ERROR,ERROR,235606,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['ERROR'],['ERROR']
Availability,"ial : Qobj; Starting point for the evolution. Typically the identity matrix. target : Qobj; Target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; Number of timeslots. ``None`` implies that timeslots will be given in; the tau array. evo_time : float or None; Total time for the evolution. ``None`` implies that timeslots will be; given in the tau array. tau : array[num_tslots] of floats or None; Durations for the timeslots. If this is given then ``num_tslots`` and; ``evo_time`` are derived from it. ``None`` implies that timeslot; durations will be equal and calculated as ``evo_time/num_tslots``. amp_lbound : float or list of floats; Lower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_ubound : float or list of floats; Upper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation. Options are:. - 'GRAPE' (default) - GRadient Ascent Pulse Engineering; - 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; Options that are specific to the algorithm see above. optim_params : Dictionary; The key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: ``method_params`` are; applied afterwards and so may override these. optim_method : string; A `",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:8301,error,error,8301,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"ial equation. This; only needs to be specified when implementing a custom SDE solver. generate_A_ops : function; Function that generates a list of pre-computed operators or super-; operators. These precomputed operators are used in some d1 and d2; functions. generate_noise : function; Function for generate an array of pre-computed noise signal. homogeneous : bool (True); Wheter or not the stochastic process is homogenous. Inhomogenous; processes are only supported for poisson distributions. solver : string; Name of the solver method to use for solving the stochastic; equations. Valid values are: ; 1/2 order algorithms: 'euler-maruyama', 'fast-euler-maruyama',; 'pc-euler' is a predictor-corrector method which is more ; stable than explicit methods,; 1 order algorithms: 'milstein', 'fast-milstein', 'platen',; 'milstein-imp' is semi-implicit Milstein method,; 3/2 order algorithms: 'taylor15', ; 'taylor15-imp' is semi-implicit Taylor 1.5 method.; Implicit methods can adjust tolerance via args = {'tol':value},; default is {'tol':1e-6}. method : string ('homodyne', 'heterodyne', 'photocurrent'); The name of the type of measurement process that give rise to the; stochastic equation to solve. Specifying a method with this keyword; argument is a short-hand notation for using pre-defined d1 and d2; functions for the corresponding stochastic processes. distribution : string ('normal', 'poission'); The name of the distribution used for the stochastic increments. store_measurements : bool (default False); Whether or not to store the measurement results in the; :class:`qutip.solver.SolverResult` instance returned by the solver. noise : array; Vector specifying the noise. normalize : bool (default True); Whether or not to normalize the wave function during the evolution. options : :class:`qutip.solver.Options`; Generic solver options. map_func: function; A map function or managing the calls to single-trajactory solvers. map_kwargs: dictionary; Optional keyword arguments to the map_",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/stochastic.html:6901,toler,tolerance,6901,docs/4.1/modules/qutip/stochastic.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/stochastic.html,3,['toler'],['tolerance']
Availability,"ial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). # spectrum. [docs]def spectrum_ss(H, wlist, c_ops, a_op, b_op):; r""""""; Calculate the spectrum of the correlation function; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`,; i.e., the Fourier transform of the correlation ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/correlation.html:27041,error,errors,27041,docs/4.6/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/correlation.html,4,['error'],['errors']
Availability,"ialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note tha",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:227047,error,error,227047,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"ian. rho0 : :class:`qutip.qobj.Qobj`; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. taulist : *list* / *array*; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list of :class:`qutip.qobj.Qobj`; list of collapse operators. a_op : :class:`qutip.qobj.Qobj`; operator A. b_op : :class:`qutip.qobj.Qobj`; operator B. c_op : :class:`qutip.qobj.Qobj`; operator C. d_op : :class:`qutip.qobj.Qobj`; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : :class:`qutip.solver.Options`; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec: *array*; An *array* of correlation values for the times specified by `taulist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_1t(H, state0, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). [docs]def correlation_4op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op, c_op, d_op, solver=""me"", args=None,; options=Options(ntraj=[20, 100])):; """"""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t+\\tau)D(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html:25050,error,errors,25050,docs/3.1.0/modules/qutip/correlation.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html,1,['error'],['errors']
Availability,"iation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True);",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/changelog.html:8135,avail,available,8135,docs/4.0.2/changelog.html,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html,6,['avail'],['available']
Availability,"ic_noise). if device_noise:; return noisy_pulses + [systematic_noise]; else:; return noisy_pulses. [docs]class Noise(object):; """"""; The base class representing noise in a processor.; The noise object can be added to :class:`.Processor` and; contributes to evolution.; """"""; def __init__(self):; pass. [docs] def get_noisy_dynamics(self, dims, pulses, systematic_noise):; """"""; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters; ----------; dims: list, optional; The dimension of the components system, the default value is; [2,2...,2] for qubits system. pulses: list of :class:`.Pulse`; The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`; The dummy pulse with no ideal control element. Returns; -------; noisy_pulses: list of :class:`.Pulse`; Noisy pulses. systematic_noise: :class:`.Pulse`; The dummy pulse representing pulse independent noise.; """"""; raise NotImplementedError(; ""Subclass error needs a method""; ""`get_noisy_dynamics` to process the noise.""). def _apply_noise(self, pulses=None, systematic_noise=None, dims=None):; """"""; For backward compatibility, in case the method has no return value; or only return the pulse.; """"""; result = self.get_noisy_dynamics(; pulses=pulses, systematic_noise=systematic_noise, dims=dims); if result is None: # in-place change; pass; elif isinstance(result, tuple) and len(result) == 2:; pulses, systematic_noise = result; # only pulse; elif isinstance(result, list) and len(result) == len(pulses):; pulses = result; else:; raise TypeError(; ""Returned value of get_noisy_dynamics not understood.""); return pulses, systematic_noise. [docs]class DecoherenceNoise(Noise):; """"""; The decoherence noise in a processor. It generates lindblad noise; according to the given collapse operator `c_ops`. Parameters; ----------; c_ops: :class:`qutip.Qobj` or list; The Hamiltonian representing the dynamics of the noise.; targets: int or list, optional; The indices of q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html:3197,error,error,3197,docs/4.6/modules/qutip/qip/noise.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qip/noise.html,4,['error'],['error']
Availability,"icensing. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. QuTiP 4.7.5 (2024-01-29)¶; Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes¶. Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15)¶. Bug Fixes¶. Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); Fix name of temp files for removal after use. (#2251, reported by Qile Su); Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); Ignore DeprecationWarning from pyximport (#2287); Add partial support and tests for python 3.12. (#2294). Miscellaneous¶. Rework choi_to_kraus, making it rely on an eigenstates solver that can choose eigh if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); Rework kraus_to_choi, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22)¶. Bug Fixes¶. Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); Fixed issue where extract_states did not preserve hermiticity.; Fixed issue where rand_herm did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous¶. Exclude cython 3.0.0 from requirement (#2204); Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/changelog.html:3331,error,error,3331,docs/4.7/changelog.html,https://qutip.org,https://qutip.org/docs/4.7/changelog.html,1,['error'],['error']
Availability,ics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values,MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-options.html:2097,toler,tolerance,2097,docs/4.2/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-options.html,4,['toler'],['tolerance']
Availability,"ics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”.",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-measurement.html:1914,down,down,1914,docs/4.7/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html,2,['down'],['down']
Availability,"id_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:24421,error,errors,24421,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,10,['error'],['errors']
Availability,"ide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-overview.html:1752,avail,available,1752,docs/4.7/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html,2,['avail'],['available']
Availability,"idelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html:19360,error,error,19360,docs/4.1/modules/qutip/control/fidcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/fidcomp.html,10,['error'],['error']
Availability,"idering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. scale_factor¶; float – The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Ge",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:97424,error,error,97424,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,2,['error'],['error']
Availability,"idering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; Attributes. scale_factor; (float) The fidelity error calculated is of some arbitary scale. This factor can be used to scale the fidelity error such that it may represent some physical measure If None is given then it is caculated as 1/2N, where N is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[sourc",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:93063,error,error,93063,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,4,['error'],['error']
Availability,"idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_op",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html:36957,error,error,36957,docs/4.1/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/optimizer.html,6,['error'],['error']
Availability,"ies. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1]_, [2]_.; It uses the ``scipy.optimize.fmin`` function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB. References; ----------; .. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011).; .. [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or t",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html:37398,error,error,37398,docs/4.6/modules/qutip/control/optimizer.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/optimizer.html,4,['error'],['error']
Availability,"iew of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-overview.html:2443,avail,available,2443,docs/3.1.0/guide/guide-overview.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-overview.html,1,['avail'],['available']
Availability,"iff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; >>> options = Options(); >>> options.num_cpus = 3; >>> options.gui = False; >>> options.atol = 1e-10. or one can use an inline method,; >>> options = Options(num_cpus=3, gui=False, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; >>> print options; Options properties:; ----------------------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 3; rhs_filename: None; rhs_reuse: False; gui: False; mc_avg: True. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-options.html:3520,toler,tolerance,3520,docs/3.0.0/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-options.html,2,['toler'],['tolerance']
Availability,"iff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; or one can use an inline method,; Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [3]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, opti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/dynamics/dynamics-options.html:3224,toler,tolerance,3224,docs/4.2/guide/dynamics/dynamics-options.html,https://qutip.org,https://qutip.org/docs/4.2/guide/dynamics/dynamics-options.html,5,['toler'],['tolerance']
Availability,"ig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). In [72]: ax.view_init(azim=-55, elev=45). In [73]: plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; In [74]: rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). In [75]: hinton(rho_ss); Out[75]: ; (<Figure size 800x600 with 2 Axes>,; <matplotlib.axes._subplots.AxesSubplot at 0x2b226b54e7f0>). In [76]: plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/guide/guide-visualization.html:11435,error,errors,11435,docs/4.4/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.4/guide/guide-visualization.html,1,['error'],['errors']
Availability,"igh, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that cont",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/classes.html:6777,toler,tolerance,6777,docs/3.1.0/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"ill select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension \(1\). However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state \(\ket{0+}\); state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-measurement.html:5351,down,down,5351,docs/4.6/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html,8,['down'],['down']
Availability,"ill suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:191069,error,error,191069,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['error'],['error']
Availability,"ill suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) th",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:217008,error,error,217008,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"ill terminate. max_iterations; (integer) Maximum iterations of the optimisation algorithm. max_fid_func_calls; (integer) Maximum number of calls to the fidelity function during the optimisation algorithm. accuracy_factor; (float) Determines the accuracy of the result. Typical values for accuracy_factor are: 1e12 for low accuracy; 1e7 for moderate accuracy; 10.0 for extremely high accuracy scipy.optimize.fmin_l_bfgs_b factr argument. Only set for specific methods (fmin_l_bfgs_b) that uses this Otherwise the same thing is passed as method_option ftol (although the scale is different) Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt; Attributes. termination_reason; (string) Description of the reason for terminating the optimisation. fidelity; (float) final (normalised) fidelity that was achieved. initial_fid_err; (float) fidelity error before optimisation starting. fid_err; (float) final fidelity error that was achieved. goal_achieved; (boolean) True is the fidely error achieved was below the target. grad_norm_final; (float) Final value of the sum of the squares of the (normalised) fidelity error gradients. grad_norm_min_reached; (float) True if the optimisation terminated due to the minimum value of the gradient being reached. num_iter; (integer) Number of iterations of the optimisation algorithm completed. max_iter_exceeded; (boolean) True if the iteration limit was reached. max_fid_func_exceeded; (boolean) True if the fidelity function call limit was reached. wall_time; (float) time elapsed during the optimisation. wall_time_limit_exceeded; (boolean) True if the wall time limit was reached. time; (array[num_tslots+1] of float) Time are the start of each timeslot with the final value being the total evolution time. initial_amps; (array[num_tslots, n_ctrls]) The amplitudes at the start of the optimisation. final_amps; (array[num_tslots, n_ctrls]) The amplitudes at the end ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:71091,error,error,71091,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['error'],['error']
Availability,"ill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the precond",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/guide-steady.html:6088,down,downside,6088,docs/3.1.0/guide/guide-steady.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html,1,['down'],['downside']
Availability,"im_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; duratio",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/functions.html:225514,error,error,225514,docs/4.6/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html,4,['error'],['error']
Availability,"im_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html:20187,error,error,20187,docs/4.2/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/control/pulseoptim.html,3,['error'],['error']
Availability,"ime, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:81446,error,error,81446,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,2,['error'],['error']
Availability,"imes \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.transfertensor.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:210185,error,error,210185,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,2,['error'],['error']
Availability,"imes, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]); 10.0%. Run time: 2.47s. Est. time left: 00:00:00:22; 20.0%. Run time: 4.83s. Est. time left: 00:00:00:19; 30.0%. Run time: 7.15s. Est. time left: 00:00:00:16; 40.0%. Run time: 9.51s. Est. time left: 00:00:00:14; 50.0%. Run time: 11.84s. Est. time left: 00:00:00:11; 60.0%. Run time: 14.18s. Est. time left: 00:00:00:09; 70.0%. Run time: 16.65s. Est. time left: 00:00:00:07; 80.0%. Run time: 18.97s. Est. time left: 00:00:00:04; 90.0%. Run time: 21.36s. Est. time left: 00:00:00:02; 100.0%. Run time: 23.81s. Est. time left: 00:00:00:00; Total run time: 23.88s. we can extract the relevant expectation values using:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Option",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html:12274,avail,available,12274,docs/3.1.0/guide/dynamics/dynamics-monte.html,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html,1,['avail'],['available']
Availability,"imisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s. [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=No",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html:4863,error,errors,4863,docs/4.4/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.4/modules/qutip/control/pulseoptim.html,2,['error'],['errors']
Availability,"imisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_param",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html:4867,error,errors,4867,docs/4.1/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/pulseoptim.html,8,['error'],['errors']
Availability,"ims : list of ints, or None; Dimensions of the resultant quantum object.; If None, [[N],[1]] is used. Returns; -------; psi : Qobj; A random state vector drawn from the Haar measure.; """"""; if N and dims:; _check_dims(dims, N, 1); elif dims:; N = prod(dims[0]); _check_dims(dims, N, 1); else:; dims = [[N],[1]]; psi = rand_unitary_haar(N, seed=seed) * basis(N, 0); psi.dims = dims; return psi. [docs]def rand_dm(N, density=0.75, pure=False, dims=None, seed=None):; """"""Creates a random NxN density matrix. Parameters; ----------; N : int, ndarray, list; If int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix.; density : float; Density between [0,1] of output density matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns; -------; oper : qobj; NxN density matrix quantum operator. Notes; -----; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that :math:`Tr(\\rho)=1`. """"""; if isinstance(N, (np.ndarray, list)):; if np.abs(np.sum(N)-1.0) > 1e-15:; raise ValueError('Eigenvalues of a density matrix '; 'must sum to one.'); H = sp.diags(N, 0, dtype=complex, format='csr'); N = len(N); if dims:; _check_dims(dims, N, N); nvals = N**2*density; H = rand_jacobi_rotation(H, seed=seed); while H.nnz < 0.95*nvals:; H = rand_jacobi_rotation(H); H.sort_indices(); elif isinstance(N, (int, np.int32, np.int64)):; if dims:; _check_dims(dims, N, N); if pure:; dm_density = sqrt(density); psi = rand_ket(N, dm_density); H = psi * psi.dag(); H.data.sort_indices(); else:; non_zero = 0; tries = 0; while non_zero == 0 and tries < 10:; H = rand_herm(N, density, seed=seed); H = H.dag() * H; non_zero = H.tr(); tries += 1; if tries >= 10:; raise ValueError(; ""Requested density is too low to generate density matrix.""); H = H / H.tr(); H.data.sort_indices(); else:; raise TypeError('Input N must be an integer or array_like.'",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/modules/qutip/random_objects.html:11699,error,error,11699,docs/4.5/modules/qutip/random_objects.html,https://qutip.org,https://qutip.org/docs/4.5/modules/qutip/random_objects.html,1,['error'],['error']
Availability,"in library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/contributing.html:13686,error,errors,13686,docs/4.7/development/contributing.html,https://qutip.org,https://qutip.org/docs/4.7/development/contributing.html,2,['error'],['errors']
Availability,"in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. iter_num¶; int – Iteration number of the pulse optimisation. fid_func_call_num¶; int – Fidelity function call number of the pulse optimisation. grad_func_call_num¶; int – Gradient function call number of the pulse optimisation. fid_err¶; float – Fidelity error. grad_norm¶; float – fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time¶; float – Time spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. fid_err_targ¶; float – Target fidelity error. fid_goal¶; float – goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time¶; float – # maximum time for optimisation (seconds). min_gradient_norm¶; float – Minimum normalised gradient after which optimisation will terminate. max_iterations¶; integer – Maximum iterations of the optimisation algorithm. max_fid_func_calls¶; integer – Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor¶; fl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:72308,error,error,72308,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"in tomography._index_permutations([len(lbls) for lbls in lbls_list]):; xlabels.append("""".join([lbls_list[k][inds[k]] for k in range(len(lbls_list))])). fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). ax.view_init(azim=-55, elev=45). plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). hinton(rho_ss). plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the m",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-visualization.html:11169,error,errors,11169,docs/4.7/guide/guide-visualization.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html,2,['error'],['errors']
Availability,"inal Qobj with all named index pairs contracted; away. Expectation Values¶. expect(oper, state)[source]¶; Calculates the expectation value for operator(s) and state(s). Parameters:oper : qobj/array-like. A single or a list or operators for expectation value. state : qobj/array-like. A single or a list of quantum states or density matrices. Returns:expt : float/complex/array-like. Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http:/",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:32289,mask,mask,32289,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,4,['mask'],['mask']
Availability,"inal; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find firs",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html:14206,mask,masks,14206,docs/4.1/modules/qutip/control/tslotcomp.html,https://qutip.org,https://qutip.org/docs/4.1/modules/qutip/control/tslotcomp.html,10,['mask'],['masks']
Availability,"ing the `Qobj.isoperbra`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.isoperbra else False. def isoper(Q):; """"""Determines if given quantum object is a operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isoper : bool; True if Qobj is operator, False otherwise. Examples; --------; >>> a = destroy(5); >>> isoper(a); True. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isoper`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.isoper else False. def issuper(Q):; """"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended.; ; """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : qobj; Qobj one; B : qobj; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B.; ; """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : qobj; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.ish",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html:52749,toler,tolerance,52749,docs/4.0.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.0.2/modules/qutip/qobj.html,1,['toler'],['tolerance']
Availability,"ing the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/guide/guide-bloch.html:2233,avail,available,2233,docs/4.7/guide/guide-bloch.html,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html,2,['avail'],['available']
Availability,"ing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.pulseoptim. Source code for qutip.control.pulseoptim; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal con",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html:1247,error,error,1247,docs/4.7/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/pulseoptim.html,2,['error'],['error']
Availability,"ingle or a list of quantum states or density matrices. Returns:expt : float/complex/array-like. Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters:rho : qobj. Density matrix of composite ob",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/apidoc/functions.html:43244,mask,mask,43244,docs/4.1/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.1/apidoc/functions.html,1,['mask'],['mask']
Availability,"ingle or a list of quantum states or density matrices. Returns:expt : float/complex/array-like. Expectation value. real if oper is Hermitian, complex; otherwise. A (nested) array of expectaction values of state or operator; are arrays. Examples; >>> expect(num(4), basis(4, 3)); 3. variance(oper, state)[source]¶; Variance of an operator for the given state vector or density matrix. Parameters:oper : qobj. Operator for expectation value. state : qobj/list. A single or list of quantum states or density matrices.. Returns:var : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite obj",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:32614,mask,mask,32614,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['mask'],['mask']
Availability,"ining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement tranforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-measurement.html:1855,down,down,1855,docs/4.6/guide/guide-measurement.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-measurement.html,2,['down'],['down']
Availability,"init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. iter_num¶; int – Iteration number of the pulse optimisation. fid_func_call_num¶; int – Fidelity function call number of the pulse optimisation. grad_func_call_num¶; int – Gradient function call number of the pulse optimisation. fid_err¶; float – Fi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:71206,error,error,71206,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"into the release branch before building the wheels.; You do not need to re-release the documentation on either GitHub or the website if this is a patch release, unless there were changes within it.; Go to the “Actions” tab at the top of the qutip/qutip repository, and click the “Build HTML documentation” heading in the left column.; You should see a list of times this action has run; click the most recent one whose name is exactly “Build HTML documentation”, with the release branch name next to it (e.g. qutip-4.6.X).; Download the qutip_html_docs artifact to your local machine and unzip it somewhere safe.; These are all the HTML files for the built documentation; you should be able to open index.html in your own web browser and check that everything is working. Making a Release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version>”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a patch release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field (for example, GitHub’s markdown typically maintains hard-wrap linebreaks, which is probably not what you wanted).; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zi",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/development/release_distribution.html:15326,down,down,15326,docs/4.7/development/release_distribution.html,https://qutip.org,https://qutip.org/docs/4.7/development/release_distribution.html,2,['down'],['down']
Availability,"ions for the; scipy.optimize.minimize method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the qutip.control.dynamics.Dynamics object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for; details). prop_paramsdictParameters for the PropagatorComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type.; (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC UPDATE_ALL is the; only one that currently works.; (See TimeslotComputer classes; for details). tslot_paramsdictParameters for the TimeslotComputer; object. The key value pairs are assumed to be attribute name value; pairs. They applied after the object is created. guess_pulse_typestring, default NoneType / shape of pulse(s) used modulate the control amplitudes.; Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. guess_pulse_paramsdictParameters for the guess pulse generator objec",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:225403,error,error,225403,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,4,['error'],['error']
Availability,"ions. Returns:; output: :class:`qutip.solver.Result`; An instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/functions.html:157314,error,error,157314,docs/4.3/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/functions.html,1,['error'],['error']
Availability,"ip.control.optimresult — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.control.optimresult. Source code for qutip.control.optimresult; # -*- coding: utf-8 -*-; # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/modules/qutip/control/optimresult.html:976,error,error,976,docs/4.7/modules/qutip/control/optimresult.html,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/control/optimresult.html,4,['error'],['error']
Availability,"ircuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can also carry out measurements on individual qubit (both in the middle and at the end of the circuit).; Each measurement is saved as a class object Measurement with parameters such as targets,; the target qubit on which the measurement will be carried out, and classical_store,; the index of the classical register which stores the result of the measurement. A circuit with the various gates and registers available is demonstrated below:; from qutip.qip.circuit import QubitCircuit, Gate; from qutip import tensor, basis. qc = QubitCircuit(N=2, num_cbits=1); swap_gate = Gate(name=""SWAP"", targets=[0, 1]). qc.add_gate(swap_gate); qc.add_measurement(""M0"", targets=[1], classical_store=0) # measurement gate; qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""X"", targets=0, classical_controls=[0]) # classically controlled gate; qc.add_gate(swap_gate). print(qc.gates). Output:; [Gate(SWAP, targets=[0, 1], controls=None, classical controls=None, control_value=None),; Measurement(M0, target=[1], classical_store=0),; Gate(CNOT, targets=[1], controls=[0], classical controls=None, control_value=None),; Gate(X, targets=[0], controls=None, classical controls=[0], control_value=None),; Gate(SWAP, targets=[0, 1], controls=None, classical controls=None, control_value=None)]. Unitaries¶; There are a few useful functions associated with the circuit object. For example,; the propagators method returns",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/qip/qip-basics.html:2636,avail,available,2636,docs/4.6/guide/qip/qip-basics.html,https://qutip.org,https://qutip.org/docs/4.6/guide/qip/qip-basics.html,4,['avail'],['available']
Availability,"irst things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; In [2]: import numpy as np. In [3]: import matplotlib.pyplot as plt. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-basics.html:1214,avail,available,1214,docs/4.2/guide/guide-basics.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-basics.html,5,['avail'],['available']
Availability,"is module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation. References; ----------; 1. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip.qobj import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import quti",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html:3897,error,error,3897,docs/4.6/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"is nearly always dense, method='dense'; is set as default.s. Returns; -------; oper : :class:`qutip.Qobj`; Exponentiated quantum operator. Raises; ------; TypeError; Quantum operator is not square. """"""; if self.dims[0][0] != self.dims[1][0]:; raise TypeError('Invalid operand for matrix exponential'). if method == 'dense':; F = sp_expm(self.data, sparse=False). elif method == 'sparse':; F = sp_expm(self.data, sparse=True). else:; raise ValueError(""method must be 'dense' or 'sparse'.""). out = Qobj(F, dims=self.dims); return out.tidyup() if settings.auto_tidyup else out. [docs] def check_herm(self):; """"""Check if the quantum object is hermitian. Returns; -------; isherm : bool; Returns the new value of isherm property.; """"""; self._isherm = None; return self.isherm. [docs] def sqrtm(self, sparse=False, tol=0, maxiter=100000):; """"""Sqrt of a quantum operator. Operator must be square. Parameters; ----------; sparse : bool; Use sparse eigenvalue/vector solver.; tol : float; Tolerance used by sparse solver (0 = machine precision).; maxiter : int; Maximum number of iterations used by sparse solver. Returns; -------; oper : :class:`qutip.Qobj`; Matrix square root of operator. Raises; ------; TypeError; Quantum object is not square. Notes; -----; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. """"""; if self.dims[0][0] == self.dims[1][0]:; evals, evecs = sp_eigs(self.data, self.isherm, sparse=sparse,; tol=tol, maxiter=maxiter); numevals = len(evals); dV = sp.spdiags(np.sqrt(evals, dtype=complex), 0, numevals,; numevals, format='csr'); if self.isherm:; spDv = dV.dot(evecs.T.conj().T); else:; spDv = dV.dot(np.linalg.inv(evecs.T)). out = Qobj(evecs.T.dot(spDv), dims=self.dims); return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError('Invalid operand for matrix square root'). [docs] def cosm(self):; """"""Cosine of a quantum operator. Operator must be square. Returns; -------; oper : :class:`qutip.Qobj`;",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:31743,Toler,Tolerance,31743,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,2,['Toler'],['Tolerance']
Availability,"is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isoperbra else False. [docs]def isoper(Q):; """"""Determines if given quantum object is a operator. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isoper : bool; True if Qobj is operator, False otherwise. Examples; --------; >>> a = destroy(5); >>> isoper(a); True. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.isoper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.isoper else False. [docs]def issuper(Q):; """"""Determines if given quantum object is a super-operator. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; issuper : bool; True if Qobj is superoperator, False otherwise. Notes; -----; This function is for legacy compatibility only. Using the `Qobj.issuper`; attribute is recommended. """"""; return True if isinstance(Q, Qobj) and Q.issuper else False. [docs]def isequal(A, B, tol=None):; """"""Determines if two qobj objects are equal to within given tolerance. Parameters; ----------; A : :class:`qutip.Qobj`; Qobj one; B : :class:`qutip.Qobj`; Qobj two; tol : float; Tolerence for equality to be valid. Returns; -------; isequal : bool; True if qobjs are equal, False otherwise. Notes; -----; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. """"""; if tol is None:; tol = settings.atol. if not isinstance(A, Qobj) or not isinstance(B, Qobj):; return False. if A.dims != B.dims:; return False. Adat = A.data; Bdat = B.data; elems = (Adat - Bdat).data; if np.any(np.abs(elems) > tol):; return False. return True. [docs]def isherm(Q):; """"""Determines if given operator is Hermitian. Parameters; ----------; Q : :class:`qutip.Qobj`; Quantum object. Returns; -------; isherm : bool; True if operator is Hermitian, False otherwise. Examples; --------; >>> a = destroy(4); >>> isherm(a); False. Notes; -----; This function is",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/modules/qutip/qobj.html:60965,toler,tolerance,60965,docs/4.6/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.6/modules/qutip/qobj.html,4,['toler'],['tolerance']
Availability,"is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint {10}MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsbool {True, False}MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingbool {True, False}MKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, optional, default=1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, optional, default=1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optional, default=NoneITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matolfloat, optional, default=1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optional, default=’COLAMD’ITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool optional, default = FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, optional, default = 100ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower v",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/functions.html:104685,toler,tolerance,104685,docs/4.4/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html,2,['toler'],['tolerance']
Availability,"is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument; (used only in L-BFGS-B). accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; (used only in L-BFGS-B). dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FideliyComputer classes for details). phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. fid_err_scale_factor : float; (used in TRACEDIFF FidelityComputer and subclasses only); The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift. amp_update_mode : string; determines whether propagators are calculated; Options: DEF, ALL, DYNAMIC (needs work); DEF will use the default for the specific dyn_type; (See TimeslotComputer classes for details). init_pulse_type : string; type / shape of pulse(s) used to initialise the; the control amplitudes. Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW; (",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html:8440,error,error,8440,docs/3.1.0/modules/qutip/control/pulseoptim.html,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/control/pulseoptim.html,4,['error'],['error']
Availability,"isation algorithm. max_fid_func_calls¶; integer – Maximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factor¶; float – Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. termination_reason¶; string – Description of the reason for terminating the optimisation. fidelity¶; float – final (normalised) fidelity that was achieved. initial_fid_err¶; float – fidelity error before optimisation starting. fid_err¶; float – final fidelity error that was achieved. goal_achieved¶; boolean – True is the fidely error achieved was below the target. grad_norm_final¶; float – Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached¶; float – True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter¶; integer – Number of iterations of the optimisation algorithm completed. max_iter_exceeded¶; boolean – True if the iteration limit was reached. max_fid_func_exceeded¶; boolean – True if the fidelity function call limit was reached. wall_time¶; float – time elapsed during the optimisation. wall_time_limit_exceeded¶; boolean – True if the wall time limit was reached. time¶; array[num_tslots+1] of float – Time are the start of each timeslot; with the final value being the total evolution time. initial_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the start of the optimisation. final_amps¶; array[num_tslots, n_ctrls] – The amplitudes at the end of the optimisation. evo_full_final¶; Qobj – The evolut",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:74147,error,error,74147,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"isplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/functions.html:268522,Toler,Tolerance,268522,docs/4.7/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/functions.html,1,['Toler'],['Tolerance']
Availability,"ist of integer) – The states that should be kept.; normalize (True / False) – Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q – A new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Return type:Qobj. Notes; Experimental. full(squeeze=False)[source]¶; Dense array from quantum object. Returns:data – Array of complex data from quantum objects data attribute. Return type:array. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters:; sparse (bool) – Use sparse Eigensolver; tol (float) – Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low.; maxiter (int) – Maximum number of iterations performed by sparse solver (if used).; safe (bool (default=True)) – Check for degenerate ground state. Returns:; eigval (float) – Eigenvalue for the ground state of quantum operator.; eigvec (qobj) – Eigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters:; bra (qobj) – Quantum object of type ‘bra’.; ket (qobj) – Quantum object of type ‘ket’. Returns:elem – Complex valued matrix element. Return type:complex. Raises:TypeError – Can only calculate matrix elements between a bra and ket; quantum object. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:10313,toler,tolerance,10313,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"itation mode. vkcomplexThe frequency of the exponent of the excitation term. ckcomplexThe coefficient of the excitation term. ck2optional, complexFor exponents of type “RI” this is the coefficient of the term in the; imaginary expansion (and ck is the coefficient in the real; expansion). sigma_bar_k_offsetoptional, intFor exponents of type “+” this gives the offset (within the list of; exponents within the bath) of the corresponding “-” bath exponent.; For exponents of type “-” it gives the offset of the corresponding; “+” exponent. tagoptional, str, tuple or any other objectA label for the exponent (often the name of the bath). It; defaults to None. Attributes. All of the parameters are available as attributes. types¶; alias of qutip.nonmarkov.bofin_baths.ExponentType. class Bath(exponents)[source]¶; Represents a list of bath expansion exponents. Parameters. exponentslist of BathExponentThe exponents of the correlation function describing the bath. Attributes. All of the parameters are available as attributes. class BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag, combine=True, tag=None)[source]¶; A helper class for constructing a bosonic bath from the expansion; coefficients and frequencies for the real and imaginary parts of; the bath correlation function.; If the correlation functions C(t) is split into real and imaginary; parts:; C(t) = C_real(t) + i * C_imag(t). then:; C_real(t) = sum(ck_real * exp(- vk_real * t)); C_imag(t) = sum(ck_imag * exp(- vk_imag * t)). Defines the coefficients ck and the frequencies vk.; Note that the ck and vk may be complex, even through C_real(t); and C_imag(t) (i.e. the sum) is real. Parameters. QQobjThe coupling operator for the bath. ck_reallist of complexThe coefficients of the expansion terms for the real part of the; correlation function. The corresponding frequencies are passed as; vk_real. vk_reallist of complexThe frequencies (exponents) of the expansion terms for the real part of; the correlation function. The correspond",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.7/apidoc/classes.html:51651,avail,available,51651,docs/4.7/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.7/apidoc/classes.html,2,['avail'],['available']
Availability,"ite quantum; system. excitations : integer. The maximum number of excitations that are to be included in the; state space. state : list of integers. The state in the number basis representation. Returns:op : Qobj. A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by dims and; exciations. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None)[source]¶; Creates a random NxN density matrix. Parameters:N : int. Shape of output density matrix. density : float. Density between [0,1] of output density matrix. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_herm(N, density=0.75, dims=None)[source]¶; Creates a random NxN sparse Hermitian quantum object.; Uses \(H=X+X^{+}\) where \(X\) is; a randomly generated quantum operator with a given density. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Hermitian operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Hermitian quantum operator. rand_ket(N, density=1, dims=None)[source]¶; Creates a random Nx1 sparse ket vector. Parameters:N : int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)[source]¶; Creates a random NxN sparse unitary q",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/3.1.0/apidoc/functions.html:23492,error,error,23492,docs/3.1.0/apidoc/functions.html,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html,1,['error'],['error']
Availability,"ite. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation or; qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_ss or; qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_4op_1t; \(\left<A(0)B(\tau)C(\tau)D(0)\right>\). qutip.correlation.correlation_4op_2t; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/guide/guide-correlation.html:2611,avail,available,2611,docs/4.2/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.2/guide/guide-correlation.html,6,['avail'],['available']
Availability,"ite. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_3op_1t; \(\left<A(0)B(\tau)C(0)\right>\). qutip.correlation.correlation_3op_2t; \(\left<A(t)B(t+\tau)C(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a vector or matrix (in general complex) with the correlations as a function of the delays",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-correlation.html:2670,avail,available,2670,docs/4.6/guide/guide-correlation.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-correlation.html,4,['avail'],['available']
Availability,"ith Qobj on LEFT [ ex. Qobj-4 ]; """"""; return self + (-other). def __rsub__(self, other):; """"""; SUBTRACTION with Qobj on RIGHT [ ex. 4-Qobj ]; """"""; return (-self) + other. def __mul__(self, other):; """"""; MULTIPLICATION with Qobj on LEFT [ ex. Qobj*4 ]; """"""; if isinstance(other, Qobj):; if self.dims[1] == other.dims[0]:; out = Qobj(); out.data = self.data * other.data; dims = [self.dims[0], other.dims[1]]; out.dims = dims; if settings.auto_tidyup: out.tidyup(); if (not isinstance(dims[0][0], list) and; not isinstance(dims[1][0], list)):; # If neither left or right is a superoperator,; # we should implicitly partial trace over; # matching dimensions of 1.; # Using izip_longest allows for the left and right dims; # to have uneven length (non-square Qobjs).; # We use None as padding so that it doesn't match anything,; # and will never cause a partial trace on the other side.; mask = [l == r == 1 for l, r in zip_longest(dims[0], dims[1],; fillvalue=None)]; # To ensure that there are still any dimensions left, we; # use max() to add a dimensions list of [1] if all matching dims; # are traced out of that side.; out.dims = [max([1],; [dim for dim, m in zip(dims[0], mask); if not m]),; max([1],; [dim for dim, m in zip(dims[1], mask); if not m])]. else:; out.dims = dims. out._isherm = None. if self.superrep and other.superrep:; if self.superrep != other.superrep:; msg = (""Multiplying superoperators with different "" +; ""representations""); warnings.warn(msg). out.superrep = self.superrep. return out. elif np.prod(self.shape) == 1:; out = Qobj(other); out.data *= self.data[0, 0]; out.superrep = other.superrep; return out.tidyup() if settings.auto_tidyup else out. elif np.prod(other.shape) == 1:; out = Qobj(self); out.data *= other.data[0, 0]; out.superrep = self.superrep; return out.tidyup() if settings.auto_tidyup else out. else:; raise TypeError(""Incompatible Qobj shapes""). elif isinstance(other, np.ndarray):; if other.dtype=='object':; return np.array([self * item for item in o",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/modules/qutip/qobj.html:14346,mask,mask,14346,docs/4.2/modules/qutip/qobj.html,https://qutip.org,https://qutip.org/docs/4.2/modules/qutip/qobj.html,1,['mask'],['mask']
Availability,"itian,; otherwise complex values are returned. dnorm(self, B=None)[source]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan(self)[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/apidoc/classes.html:6220,toler,tolerance,6220,docs/4.4/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"itian,; otherwise complex values are returned. dnorm(self, B=None)[source]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan(self)[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representin",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.5/apidoc/classes.html:6332,toler,tolerance,6332,docs/4.5/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.5/apidoc/classes.html,1,['toler'],['tolerance']
Availability,"itudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the a",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/apidoc/classes.html:222310,error,error,222310,docs/4.6/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html,3,['error'],['error']
Availability,"itudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes:; phase_option : string. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[sour",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.3/apidoc/classes.html:103024,error,error,103024,docs/4.3/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.3/apidoc/classes.html,1,['error'],['error']
Availability,"itudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). phase_option¶; string –. determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm¶; complex – Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current¶; boolean – flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.0.2/apidoc/classes.html:94716,error,error,94716,docs/4.0.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.0.2/apidoc/classes.html,1,['error'],['error']
Availability,"itudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header); Attributes. phase_option; (string) determines how global phase is treated in fidelity calculations: PSU - global phase ignored SU - global phase included. fidelity_prenorm; (complex) Last computed value of the fidelity before it is normalised It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current; (boolean) flag to specify whether fidelity_prenorm are based on the current amplitude values. Set False when amplitudes change. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_grad",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.2/apidoc/classes.html:90351,error,error,90351,docs/4.2/apidoc/classes.html,https://qutip.org,https://qutip.org/docs/4.2/apidoc/classes.html,2,['error'],['error']
Availability,"ity channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Github repository. http://github.com/qutip. In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scient",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.4/installation.html:5301,avail,available,5301,docs/4.4/installation.html,https://qutip.org,https://qutip.org/docs/4.4/installation.html,2,['avail'],['available']
Availability,"ity channel.; You can edit your .condarc (user home folder) file manually, so that conda-forge is below defaults in the channels list. Installing via pip¶; For other types of installation, it is often easiest to use the Python package manager pip.; pip install qutip. More detailed platform-dependent installation alternatives are given below. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scient",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.1/installation.html:5205,avail,available,5205,docs/4.1/installation.html,https://qutip.org,https://qutip.org/docs/4.1/installation.html,3,['avail'],['available']
Availability,"ity matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, than the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondance between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). ",MatchSource.WIKI,qutip,qutip,v5.0.4,https://qutip.org/docs/4.6/guide/guide-states.html:16579,down,down,16579,docs/4.6/guide/guide-states.html,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-states.html,2,['down'],['down']
