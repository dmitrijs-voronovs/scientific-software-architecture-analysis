quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Safety,// This silly cast below avoids a C++ warning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp:25,avoid,avoids,25,interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.cpp,1,['avoid'],['avoids']
Safety,"// This simple PRE (partial redundancy elimination) pass doesn't actually; // eliminate partial redundancy but transforms it to full redundancy,; // anticipating that the next CSE step will eliminate this created redundancy.; // If CSE doesn't eliminate this, than created instruction will remain dead; // and eliminated later by Remove Dead Machine Instructions pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:28,redund,redundancy,28,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,4,['redund'],['redundancy']
Safety,"// This static function is a hop of TCling::IsLibraryLoaded, which is taking a lock and calling; // into this function. This is because we wanted to avoid a duplication in TCling::IsLoaded, which; // was already taking a lock.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:149,avoid,avoid,149,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avoid'],['avoid']
Safety,"// This still will detect consecutive loads, but we might have ""holes""; // in some cases. It is ok for non-power-2 vectorization and may produce; // better results. It should not affect current vectorization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:19,detect,detect,19,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['detect'],['detect']
Safety,"// This stores info about each operand or comparison result we make copies; // of. The real ValueInfos start at index 1, index 0 is unused so that we; // can more easily detect invalid indexing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:170,detect,detect,170,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,1,['detect'],['detect']
Safety,"// This stores the first instruction where it's safe to switch from Strict; // mode to Exact/WQM or to switch to Strict mode. It must always be the same; // as, or after, FirstWQM since if it's safe to switch to/from Strict, it must; // be safe to switch to/from WQM as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:48,safe,safe,48,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,3,['safe'],['safe']
Safety,// This stores the first instruction where it's safe to switch from WQM to; // Exact or vice versa.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:48,safe,safe,48,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['safe'],['safe']
Safety,"// This table translates the non-standard microsoft characters between 0x80; // and 0x9f into plain ASCII so that the characters will be visible on Unix; // systems. Care is taken to translate the characters into values less than; // 0x80, to avoid UTF-8 problems.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx:243,avoid,avoid,243,gui/guihtml/src/TGHtmlParse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guihtml/src/TGHtmlParse.cxx,1,['avoid'],['avoid']
Safety,"// This template-id is terminated by a token that starts with a '>'.; // Outside C++11 and Objective-C, this is now error recovery.; //; // C++11 allows this when the token is '>>', and in CUDA + C++11 mode, we; // extend that treatment to also apply to the '>>>' token.; //; // Objective-C allows this in its type parameter / argument lists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:122,recover,recovery,122,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['recover'],['recovery']
Safety,"// This test aims to exercise some limits of RNTuple that are expected to be upper bounds for realistic applications.; // The theoretical limits may be higher: for example, the specification supports up to 4B clusters per group, but the; // expectation is less than 10k. For good measure, we test up to 100k clusters per group below.; //; // By nature, such limit tests will use considerable resources. For that reason, we disable the tests by default to; // avoid running them in our CI. Locally they can be run by passing `--gtest_also_run_disabled_tests` to the gtest; // executable. This may be combined with `--gtest_filter` to select a particular test. For example, to run said test; // for many clusters in a single group, the invocation would be; // ```; // ./tree/ntuple/v7/test/ntuple_limits --gtest_also_run_disabled_tests --gtest_filter=*Limits_ManyClusters; // ```",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx:459,avoid,avoid,459,tree/ntuple/v7/test/ntuple_limits.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_limits.cxx,1,['avoid'],['avoid']
Safety,"// This transform increases uses of N0, so freeze it to be safe.; // binop N0, (vselect Cond, IDC, FVal) --> vselect Cond, N0, (binop N0, FVal)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:59,safe,safe,59,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,"// This transform is safe if we do not have (do not care about) -0.0 or if; // at least one operand is known to not be -0.0. Otherwise, the select can; // change the sign of a zero operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:21,safe,safe,21,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['safe'],['safe']
Safety,"// This transformation has a high risk of corrupting the dominator tree, and; // the below steps to rebuild loop structures will result in hard to debug; // errors in that case so verify that the dominator tree is sane first.; // FIXME: Remove this when the bugs stop showing up and rely on existing; // verification steps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:34,risk,risk,34,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['risk'],['risk']
Safety,"// This transforms need to run before all integer types have been legalized; // to i64 (so that the vector element type matches the add type), and while; // it's safe to introduce odd sized vector types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:162,safe,safe,162,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['safe'],['safe']
Safety,"// This union is to avoid a warning message:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooCFunction1Binding.h:20,avoid,avoid,20,roofit/roofit/inc/RooCFunction1Binding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/inc/RooCFunction1Binding.h,6,['avoid'],['avoid']
Safety,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:257,detect,detector,257,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,2,"['detect', 'predict']","['detector', 'predictor']"
Safety,// This use is no longer unsafe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:25,unsafe,unsafe,25,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,3,['unsafe'],['unsafe']
Safety,"// This value has uses not accounted for by the expression, so it is; // not safe to modify. Mark it as being a leaf.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:77,safe,safe,77,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['safe'],['safe']
Safety,// This was one use so it's safe to remove it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:28,safe,safe,28,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['safe'],['safe']
Safety,"// This was, in fact, an attempt to scroll. Abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:44,Abort,Abort,44,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['Abort'],['Abort']
Safety,"// This will remove unused phis, i.e. phis where each def does not reach; // any uses or other defs. This will not detect or remove circular phi; // chains that are otherwise dead. Unused/dead phis are created during; // the build process and this function is intended to remove these cases; // that are easily determinable to be unnecessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp:115,detect,detect,115,interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RDFGraph.cpp,1,['detect'],['detect']
Safety,"// This wrapper class allow to avoid putting #include <map> in the; // TROOT.h header file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx:31,avoid,avoid,31,core/cont/src/TClassTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx,2,['avoid'],['avoid']
Safety,// Those attributes cannot be propagated safely. Explicitly list them; // here so we get a warning if new attributes are added.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:41,safe,safely,41,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['safe'],['safely']
Safety,// Those attributes should be safe to propagate to the extracted function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:30,safe,safe,30,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,1,['safe'],['safe']
Safety,"// Thought this might return a non-BUILD_VECTOR (e.g. CONCAT_VECTORS), if so,; // abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:82,abort,abort,82,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['abort'],['abort']
Safety,// Thread safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:10,safe,safe,10,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,1,['safe'],['safe']
Safety,// Thread safety attributes:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:10,safe,safety,10,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['safe'],['safety']
Safety,"// Thread safety: Each thread works on a distinct zipItem which owns its; // compression buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx:10,safe,safety,10,tree/ntuple/v7/src/RPageSinkBuf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RPageSinkBuf.cxx,1,['safe'],['safety']
Safety,"// Thread safety: this solution is not elegant, but given the action performed; // by the method, this construct can be considered non-problematic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFileDrawMap.cxx:10,safe,safety,10,tree/treeplayer/src/TFileDrawMap.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFileDrawMap.cxx,1,['safe'],['safety']
Safety,// Thread-safe static variables which aren't thread-specific have a; // per-variable guard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp:10,safe,safe,10,interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/MicrosoftCXXABI.cpp,1,['safe'],['safe']
Safety,// Three checks are required to ensure safety:; // . Offset >= 0 (since the offset is given from the base ptr); // . Size >= Offset (unsigned); // . Size - Offset >= NeededSize (unsigned),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:39,safe,safety,39,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['safe'],['safety']
Safety,// Threshold to avoid excessive cost to compute isProfitableToCSE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:16,avoid,avoid,16,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['avoid'],['avoid']
Safety,"// Thumb1 has very limited immediate modes, so turning an ""and"" into a; // shift can save multiple instructions.; //; // If we have (x & C1), and C1 is an appropriate mask, we can transform it; // into ""((x << n) >> n)"". But that isn't necessarily profitable on its; // own. If it's the operand to an unsigned comparison with an immediate,; // we can eliminate one of the shifts: we transform; // ""((x << n) >> n) == C2"" to ""(x << n) == (C2 << n)"".; //; // We avoid transforming cases which aren't profitable due to encoding; // details:; //; // 1. C2 fits into the immediate field of a cmp, and the transformed version; // would not; in that case, we're essentially trading one immediate load for; // another.; // 2. C1 is 255 or 65535, so we can use uxtb or uxth.; // 3. C2 is zero; we have other code for this special case.; //; // FIXME: Figure out profitability for Thumb2; we usually can't save an; // instruction, since the AND is always one instruction anyway, but we could; // use narrow instructions in some cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:460,avoid,avoid,460,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Tie breaker.; // To avoid scheduling indeterminism, we need a tie breaker; // for the case when cost is identical for two nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp:23,avoid,avoid,23,interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/VLIWMachineScheduler.cpp,1,['avoid'],['avoid']
Safety,"// Timeout counter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:3,Timeout,Timeout,3,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,2,['Timeout'],['Timeout']
Safety,"// Timeout exception",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:3,Timeout,Timeout,3,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['Timeout'],['Timeout']
Safety,"// Timeout for (some) collect actions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:3,Timeout,Timeout,3,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['Timeout'],['Timeout']
Safety,"// Timeout for some collect actions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:3,Timeout,Timeout,3,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['Timeout'],['Timeout']
Safety,"// Timeout in millisecs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:3,Timeout,Timeout,3,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['Timeout'],['Timeout']
Safety,"// Timeout value; // ID of the main thread as unique identifier",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:3,Timeout,Timeout,3,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['Timeout'],['Timeout']
Safety,"// To ""insert"" Select_* instructions, we actually have to insert the triangle; // control-flow pattern. The incoming instructions know the destination vreg; // to set, the condition code register to branch on, the true/false values to; // select between, and the condcode to use to select the appropriate branch.; //; // We produce the following control flow:; // HeadMBB; // | \; // | IfFalseMBB; // | /; // TailMBB; //; // When we find a sequence of selects we attempt to optimize their emission; // by sharing the control flow. Currently we only handle cases where we have; // multiple selects with the exact same condition (same LHS, RHS and CC).; // The selects may be interleaved with other instructions if the other; // instructions meet some requirements we deem safe:; // - They are not pseudo instructions.; // - They are debug instructions. Otherwise,; // - They do not have side-effects, do not access memory and their inputs do; // not depend on the results of the select pseudo-instructions.; // The TrueV/FalseV operands of the selects cannot depend on the result of; // previous selects in the sequence.; // These conditions could be further relaxed. See the X86 target for a; // related approach and more information.; //; // Select_FPRX_ (rs1, rs2, imm, rs4, (Select_FPRX_ rs1, rs2, imm, rs4, rs5)); // is checked here and handled by a separate function -; // EmitLoweredCascadedSelect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:771,safe,safe,771,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['safe'],['safe']
Safety,"// To avoid ""sign extending"" i1 to an arbitrary aggregate type, we just do; // an extra ""select"". This results in much more compact IR.; // Sa = select Sb, poisoned, (select b, Sc, Sd)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['avoid'],['avoid']
Safety,"// To avoid accidental cleanups from anywhere else; // remove objects from gDirectory and clone the list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:6,avoid,avoid,6,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['avoid'],['avoid']
Safety,"// To avoid allocations, the creation of the name is delayed; // as much as possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepoint.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepoint.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/UnicodeNameToCodepoint.cpp,1,['avoid'],['avoid']
Safety,"// To avoid ambiguities in case of removal of some elements",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx:6,avoid,avoid,6,proof/proof/src/TProofMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofMgr.cxx,2,['avoid'],['avoid']
Safety,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:6,avoid,avoid,6,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['avoid'],['avoid']
Safety,"// To avoid changing the bits of the constant due to extension to a larger; // type and then using G_FPTRUNC, we simply convert to a G_CONSTANT.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LegalizerHelper.cpp,1,['avoid'],['avoid']
Safety,// To avoid combining conditionals in the same basic block by; // instrcombine optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,2,['avoid'],['avoid']
Safety,"// To avoid compiler complains",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:6,avoid,avoid,6,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['avoid'],['avoid']
Safety,"// To avoid creating ""top"" entries, return a const reference to; // this cell in ""get"". Also, have a ""Bottom"" cell to return from; // get when a value of a physical register is requested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonConstPropagation.cpp,1,['avoid'],['avoid']
Safety,// To avoid cycle construction make sure that neither the load nor the add; // are predecessors to each other or the Vector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// To avoid cycles, as well as for efficiency sake, we will sometimes prune; // parts of the graph.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['avoid'],['avoid']
Safety,"// To avoid dead locks, caused by shared library opening and/or static initialization; // taking the same lock as 'tls_get_addr_tail', we can not use UniqueLockRecurseCount.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx:6,avoid,avoid,6,core/thread/src/TThread.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx,1,['avoid'],['avoid']
Safety,"// To avoid deadlocks, gInterpreterMutex and gROOTMutex need; // to point at the same instance.; // Both are now deprecated in favor of ROOT::gCoreMutex",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx:6,avoid,avoid,6,core/thread/src/TThread.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx,1,['avoid'],['avoid']
Safety,"// To avoid deleted move assignment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BatchModeDataHelpers.cxx:6,avoid,avoid,6,roofit/roofitcore/src/BatchModeDataHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BatchModeDataHelpers.cxx,3,['avoid'],['avoid']
Safety,"// To avoid depending on the order of slices, Ty and TyIsCommon must not; // depend on types skipped above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['avoid'],['avoid']
Safety,"// To avoid emitting a switch, we expect that all those rules are in order.; // That way we can just get the RuleID from the enum by subtracting; // (GICXXPred_Invalid + 1).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['avoid'],['avoid']
Safety,"// To avoid extra codegen and be profitable, we need Outer >= Inner",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// To avoid false positives (Ex: finding user defined functions with; // similar names), only perform fuzzy name matching when it's a builtin.; // Using a string compare is slow, we might want to switch on BuiltinID here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp:6,avoid,avoid,6,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/CheckerContext.cpp,1,['avoid'],['avoid']
Safety,"// To avoid having these optimizations undone by constant folding,; // we convert to a pseudo that will be expanded later into one of; // the above forms.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// To avoid having to have a CK_BooleanToSignedFloating cast kind, we cast; // in two steps: boolean to signed integral, then to floating.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:6,avoid,avoid,6,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,"// To avoid inserting redundant assumptions, we should check for assumptions; // already in the caller. To do this, we might need a DT of the caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// To avoid join/split of directory+filename, the integrated assembler prefers; // the directory form of .file on all DWARF versions. GNU as doesn't allow the; // form before DWARF v5.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:6,avoid,avoid,6,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['avoid'],['avoid']
Safety,"// To avoid needlessly dropping large volumes of variable locations, propagate; // variables through aritifical blocks, i.e. those that don't have any; // instructions in scope at all. To accurately replicate VarLoc; // LiveDebugValues, this means exploring all artificial successors too.; // Perform a depth-first-search to enumerate those blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avoid'],['avoid']
Safety,"// To avoid overflow down, we need to make sure that MIN + Magnitude <= LHS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,"// To avoid overflow up, we need to make sure that LHS <= MAX - Magnitude.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,"// To avoid printing parentheses around an empty argument list or; // printing spurious commas at the end of an argument list, we need to; // determine where the last provided non-fake argument is.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp:6,avoid,avoid,6,interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/ClangAttrEmitter.cpp,1,['avoid'],['avoid']
Safety,"// To avoid problems in future; // Cleanup",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:6,avoid,avoid,6,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['avoid'],['avoid']
Safety,"// To avoid problems with counters we must set the total entries in each packetizer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerMulti.cxx:6,avoid,avoid,6,proof/proofplayer/src/TPacketizerMulti.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerMulti.cxx,1,['avoid'],['avoid']
Safety,// To avoid problems with overflow do everything the same as above but using; // a larger type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['avoid'],['avoid']
Safety,// To avoid processing the same predecessor more than once.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,3,['avoid'],['avoid']
Safety,"// To avoid redefinitions in descendant classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:6,avoid,avoid,6,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['avoid'],['avoid']
Safety,"// To avoid repeatedly running the PHI placement algorithm, leverage the; // fact that a def of register MUST also def its register units. Find the; // units for registers, place PHIs for them, and then replicate them for; // aliasing registers. Some inputs that are never def'd (DBG_PHIs of; // arguments) don't lead to register units being tracked, just place PHIs for; // those registers directly. Stack slots have their own form of ""unit"",; // store them to one side.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avoid'],['avoid']
Safety,"// To avoid repeating the same string literals that can potentially get out of; // sync.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONFactories_HistFactory.cxx:6,avoid,avoid,6,roofit/hs3/src/JSONFactories_HistFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONFactories_HistFactory.cxx,1,['avoid'],['avoid']
Safety,// To avoid reviewing the same predecessors twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['avoid'],['avoid']
Safety,// To avoid sign-extension we have to explicitly cast to the appropriate; // unsigned type. The overloads are here so that every type that is implicitly; // convertible to an integer (including enums and endian helpers) can be used; // without requiring type traits or call-site changes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ScopedPrinter.h:6,avoid,avoid,6,interpreter/llvm-project/llvm/include/llvm/Support/ScopedPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ScopedPrinter.h,1,['avoid'],['avoid']
Safety,// To avoid speculative hoisting certain computations out of; // a basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BPFAdjustOpt.cpp,1,['avoid'],['avoid']
Safety,"// To avoid spurious auto parsing, let's check if the name as-is is; // known in the TClassTable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:6,avoid,avoid,6,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['avoid'],['avoid']
Safety,"// To avoid the BP value clobbered by a function call, we need to choose a; // callee saved register to save the value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/CSKY/CSKYFrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// To avoid the BP value clobbered by a function call, we need to choose a; // callee saved register to save the value. RV32E only has X8 and X9 as callee; // saved registers and X8 will be used as fp. So we choose X9 as bp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp,1,['avoid'],['avoid']
Safety,"// To avoid the BP value clobbered by a function call, we need to choose a; // callee saved register to save the value. The `last` `S` register (s9) is; // used for FP. So we choose the previous (s8) as BP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchBaseInfo.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchBaseInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/LoongArch/MCTargetDesc/LoongArchBaseInfo.cpp,1,['avoid'],['avoid']
Safety,// To avoid the need for FP division:; // (CostA / A.Width) < (CostB / B.Width); // <=> (CostA * B.Width) < (CostB * A.Width),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avoid'],['avoid']
Safety,"// To avoid to create a lot a copies of the often used layouts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:6,avoid,avoid,6,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['avoid'],['avoid']
Safety,"// To avoid to rebuild the particle list from multiple threads, we check if at; // the moment of invoked ReadPDGTableImpl, the list was initialized. If it was not, and now it is, another; // thread filled it. Doing so again would result in an error.; // However, if the particle list was not initialized when ReadPDGTableImpl was invoked and it is still empty,; // we fill it.; // With the protection described above, ReadPDGTable can be invoked multiple times, for example once; // automatically by the system lazily and a second time by the user to complement the information; // already in memory with a second input file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TDatabasePDG.cxx:6,avoid,avoid,6,montecarlo/eg/src/TDatabasePDG.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/montecarlo/eg/src/TDatabasePDG.cxx,1,['avoid'],['avoid']
Safety,// To avoid triggering an assertion in the lazy call graph we will not delete; // any internal library functions. We should modify the assertion though and; // allow internals to be deleted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['avoid'],['avoid']
Safety,"// To avoid undefined behavior for extracting with out of range index, use; // the minimum of evl and element count as trip count.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['avoid'],['avoid']
Safety,"// To avoid uninitialization problems when Init is not called ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx:6,avoid,avoid,6,net/net/src/TPSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx,1,['avoid'],['avoid']
Safety,"// To avoid unnecessary dependence on nlohman json in the interface. Note that; // we should not forward declare nlohmann::json directly, since its declaration; // might change (it is currently a typedef). With this wrapper type, we are; // completely decoupled on nlohmann::json in the RMetaData interface.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/inc/RooFit/MultiProcess/HeatmapAnalyzer.h:6,avoid,avoid,6,roofit/multiprocess/inc/RooFit/MultiProcess/HeatmapAnalyzer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/inc/RooFit/MultiProcess/HeatmapAnalyzer.h,2,['avoid'],['avoid']
Safety,"// To avoid walking constant expressions multiple times and other IR; // objects, we keep several helper maps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/TypeFinder.h:6,avoid,avoid,6,interpreter/llvm-project/llvm/include/llvm/IR/TypeFinder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/TypeFinder.h,1,['avoid'],['avoid']
Safety,"// To avoids scanning a part of a sequence repeatedly, it finds out; // the common suffix of two hald in the window. The common suffix will; // serve as the common prefix of next possible pair of duplicate; // sequences. The non-common part will be ignored and never scanned; // again.; // For example.; // Input: [a, b1], c1, b2, c2; // I = 2; //; // 1) For the window [a, b1, c1, b2], non-common-suffix for the right; // part is 'c1', copy it and only slide the window 1 step.; // Result: [a, b1, c1], b2, c2; //; // 2) Next window is [b1, c1, b2, c2], so duplication happen.; // Result after resize: [a, b, c]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.h:6,avoid,avoids,6,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfileGenerator.h,1,['avoid'],['avoids']
Safety,"// To be safe that the loads can be combined, iterate over all loads and test; // that the corresponding defining access dominates first LI. This guarantees; // that there are no aliasing stores in between the loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:9,safe,safe,9,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['safe'],['safe']
Safety,"// To compute the iteration count, we would need this computation:; // Count = (End - Start + (IVBump-1)) / IVBump; // or, when CmpHasEqual:; // Count = (End - Start + (IVBump-1)+1) / IVBump; // The ""IVBump-1"" part is the adjustment (AdjV). We can avoid; // generating an instruction specifically to add it if we can adjust; // the immediate values for Start or End.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp:248,avoid,avoid,248,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHardwareLoops.cpp,1,['avoid'],['avoid']
Safety,"// To conserve compile-time, we avoid walking to the next clobbering def.; // Instead, we just try to get the optimized access, if it exists. DSE; // will try to optimize defs during the earlier traversal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['avoid'],['avoid']
Safety,"// To consider a PHI profitable to break, we need to see some interesting; // incoming values. At least 2/3rd (rounded up) of all PHIs in the worklist; // must have one to consider all PHIs breakable.; //; // This threshold has been determined through performance testing.; //; // Note that the computation below is equivalent to; //; // (unsigned)ceil((K / 3.0) * 2); //; // It's simply written this way to avoid mixing integral/FP arithmetic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:408,avoid,avoid,408,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"// To detect BFI queries for unknown blocks, add entries for unreachable; // blocks, if any. This is to distinguish between known/existing unreachable; // blocks and unknown blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:6,detect,detect,6,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,1,['detect'],['detect']
Safety,"// To detect recursive response files, we maintain a stack of files and the; // position of the last argument in the file. This position is updated; // dynamically as we recursively expand files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp:6,detect,detect,6,interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CommandLine.cpp,1,['detect'],['detect']
Safety,"// To flag an abort condition: use a local static variable to avoid; // warnings about problems with longjumps",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:14,abort,abort,14,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,2,"['abort', 'avoid']","['abort', 'avoid']"
Safety,"// To get the source name, first consult the FileEntry (if one exists); // before the MemBuffer as this will avoid unnecessarily paging in the; // MemBuffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:109,avoid,avoid,109,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['avoid'],['avoid']
Safety,"// To handle the case like the following:; // struct t;; // typedef struct t _t;; // struct s1 { _t *c; };; // int test1(struct s1 *arg) { ... }; //; // struct t { int a; int b; };; // struct s2 { _t c; }; // int test2(struct s2 *arg) { ... }; //; // During traversing test1() argument, ""_t"" is recorded; // in DIToIdMap and a forward declaration fixup is created; // for ""struct t"" to avoid pointee type traversal.; //; // During traversing test2() argument, even if we see ""_t"" is; // already defined, we should keep moving to eventually; // bring in types for ""struct t"". Otherwise, the ""struct s2""; // definition won't be correct.; //; // In the above, we have following debuginfo:; // {ptr, struct_member} -> typedef -> struct; // and BTF type for 'typedef' is generated while 'struct' may; // be in FixUp. But let us generalize the above to handle; // {different types} -> [various derived types]+ -> another type.; // For example,; // {func_param, struct_member} -> const -> ptr -> volatile -> struct; // We will traverse const/ptr/volatile which already have corresponding; // BTF types and generate type for 'struct' which might be in Fixup; // state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:386,avoid,avoid,386,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,1,['avoid'],['avoid']
Safety,"// To prevent poison from leaking across what used to be sequential,; // safe, scalar boolean logic operations, the reduction operand must be; // frozen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:73,safe,safe,73,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safe']
Safety,"// To prevent poison from leaking across what used to be; // sequential, safe, scalar boolean logic operations, the; // reduction operand must be frozen.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:73,safe,safe,73,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safe']
Safety,"// To print stack traces when caching errors are detected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:49,detect,detected,49,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['detect'],['detected']
Safety,"// To start, set the number of redundant path components to the maximum; // possible value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:31,redund,redundant,31,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redund'],['redundant']
Safety,"// To track the registers used in instructions that can potentially modify the; // inactive lanes. The WWM instructions and the writelane instructions for; // spilling SGPRs to VGPRs fall under such category of operations. The VGPRs; // modified by them should be spilled/restored at function prolog/epilog to; // avoid any undesired outcome. Each entry in this map holds a pair of values,; // the VGPR and its stack slot index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h:314,avoid,avoid,314,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIMachineFunctionInfo.h,1,['avoid'],['avoid']
Safety,"// To update r = r - c * m, it suffices to know c * (-2 ** 240 + 1); // because the 2 ** 576 will cancel out. Also note that c may be zero, but; // the operation is still performed to avoid branching.; // c * (-2 ** 240 + 1) in 576 bits looks as follows, depending on c:; // - if c = 0, the number is zero.; // - if c = 1: bits 576 to 240 are set,; // bits 239 to 1 are zero, and; // the last one is set; // - if c = -1, which corresponds to all bits set (signed int64_t):; // bits 576 to 240 are zero and the rest is set.; // Note that all bits except the last are exactly complimentary (unless c = 0); // and the last byte is conveniently represented by c already.; // Now construct the three bit patterns from c, their names correspond to the; // assembly implementation by Alexei Sibidanov.; // c = 0 -> t0 = 0; c = 1 -> t0 = 0; c = -1 -> all bits set (sign extension); // (The assembly implementation shifts by 63, which gives the same result.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/ranluxpp/mulmod.h:184,avoid,avoid,184,math/mathcore/src/ranluxpp/mulmod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/ranluxpp/mulmod.h,1,['avoid'],['avoid']
Safety,// Too costly to compute if NumOfUses is very large. Conservatively assume; // MayIncreasePressure to avoid spending too much time here.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:102,avoid,avoid,102,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['avoid'],['avoid']
Safety,"// Total Energy loss by particles into the detector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h:43,detect,detector,43,test/RootShower/MyDetector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.h,1,['detect'],['detector']
Safety,"// Total Energy loss into the detector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyParticle.h:30,detect,detector,30,test/RootShower/MyParticle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyParticle.h,1,['detect'],['detector']
Safety,"// Touch the block then extend it. This is done on the opposite side of; // static probe where we allocate then touch, to avoid the need of probing the; // tail of the static alloca. Possible scenarios are:; //; // + ---- <- ------------ <- ------------- <- ------------ +; // | |; // [free probe] -> [page alloc] -> [alloc probe] -> [tail alloc] + -> [dyn probe] -> [page alloc] -> [dyn probe] -> [tail alloc] +; // | |; // + <- ----------- <- ------------ <- ----------- <- ------------ +; //; // The property we want to enforce is to never have more than [page alloc] between two probes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:122,avoid,avoid,122,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Trace the arguments of an incomplete Phi node to see if they have the same; // canonical definition. If so, mark the Phi node as redundant.; // getCanonicalVal() will recursively call simplifyIncompletePhi().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:132,redund,redundant,132,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['redund'],['redundant']
Safety,"// Track the chain of nodes for the Floyd's 'tortoise and hare'; // cycle-detection algorithm, since getSyntaxNode(S) is impure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h:74,detect,detection,74,interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,1,['detect'],['detection']
Safety,"// Track the next DPValue to clone. If we have a sequence where an; // instruction is hoisted instead of being cloned:; // DPValue blah; // %foo = add i32 0, 0; // DPValue xyzzy; // %bar = call i32 @foobar(); // where %foo is hoisted, then the DPValue ""blah"" will be seen twice, once; // attached to %foo, then when %foo his hoisted it will ""fall down"" onto the; // function call:; // DPValue blah; // DPValue xyzzy; // %bar = call i32 @foobar(); // causing it to appear attached to the call too.; //; // To avoid this, cloneDebugInfoFrom takes an optional ""start cloning from; // here"" position to account for this behaviour. We point it at any DPValues; // on the next instruction, here labelled xyzzy, before we hoist %foo.; // Later, we only only clone DPValues from that position (xyzzy) onwards,; // which avoids cloning DPValue ""blah"" multiple times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:508,avoid,avoid,508,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,2,['avoid'],"['avoid', 'avoids']"
Safety,// Track the operand that kill Reg. We would unset the kill flag of; // the operand if there is a following redundant load immediate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp:108,redund,redundant,108,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCPreEmitPeephole.cpp,1,['redund'],['redundant']
Safety,"// Track the scopes used by !alias.scope and !noalias. In a function, a; // @llvm.experimental.noalias.scope.decl is only useful if that scope is used; // by both sets. If not, the declaration of the scope can be safely omitted.; // The MDNode of the scope can be omitted as well for the instructions that are; // part of this function. We do not do that at this point, as this might become; // too time consuming to do.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:213,safe,safely,213,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['safe'],['safely']
Safety,"// Track whether it's ok to mark objc_storeStrong calls with the ""tail""; // keyword. Be conservative if the function has variadic arguments.; // It seems that functions which ""return twice"" are also unsafe for the; // ""tail"" argument, because they are setjmp, which could need to; // return to an earlier stack state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:199,unsafe,unsafe,199,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['unsafe'],['unsafe']
Safety,"// Track whether it's safe to split the value at the top of the DWARF stack,; // assuming that it'll be used as an implicit location value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:22,safe,safe,22,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,1,['safe'],['safe']
Safety,// Tracked nullability is contradicted by an explicit cast. Do; // not report any nullability related issue for this symbol.; // This nullability is propagated aggressively to avoid false; // positive results. See the comment on getMostNullable method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerHelpers.h:176,avoid,avoid,176,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerHelpers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CheckerHelpers.h,1,['avoid'],['avoid']
Safety,// Transaction safe function type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h:15,safe,safe,15,interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,1,['safe'],['safe']
Safety,"// Transcriber is not thread-safe, so create a new instance on copy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h:29,safe,safe,29,interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h,1,['safe'],['safe']
Safety,"// Transfer late parsed template instantiations over to the pending template; // instantiation list. During normal compilation, the late template parser; // will be installed and instantiating these templates will succeed.; //; // If we are building a TU prefix for serialization, it is also safe to; // transfer these over, even though they are not parsed. The end of the TU; // should be outside of any eager template instantiation scope, so when this; // AST is deserialized, these templates will not be parsed until the end of; // the combined TU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:292,safe,safe,292,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['safe'],['safe']
Safety,// Transfer metadata from Op to the instructions in CV if it is known; // to be safe to do so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:80,safe,safe,80,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,1,['safe'],['safe']
Safety,"// Transfer the 'returned' attribute from the intrinsic to the call site.; // By applying this only to intrinsic call sites, we avoid applying it to; // non-ARC explicit calls to things like objc_retain which have not been; // auto-upgraded to use the intrinsics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp:128,avoid,avoid,128,interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PreISelIntrinsicLowering.cpp,1,['avoid'],['avoid']
Safety,"// Transform ""(X >> (8-C1)) & (0xff << C1)"" to ""((X >> 8) & 0xff) << C1"" if; // safe. This allows us to convert the shift and and into an h-register; // extract and a scaled index. Returns false if the simplification is; // performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:80,safe,safe,80,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,"// Transform ""a == 0.0 ? 0.0 : x"" to ""a == 0.0 ? a : x"" and; // ""a != 0.0 ? x : 0.0"" to ""a != 0.0 ? x : a"" to avoid materializing 0.0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:110,avoid,avoid,110,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Transform ""a == C ? C : x"" to ""a == C ? a : x"" and ""a != C ? x : C"" to; // ""a != C ? x : a"" to avoid materializing C.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:98,avoid,avoid,98,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Transform (fneg/fabs (bitconvert x)) to avoid loading constant pool values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:43,avoid,avoid,43,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// Transform a scalar conversion of a value from a lane extract into a; // lane extract of a vector conversion. E.g., from foo1 to foo2:; // double foo1(int64x2_t a) { return vcvtd_n_f64_s64(a[1], 9); }; // double foo2(int64x2_t a) { return vcvtq_n_f64_s64(a, 9)[1]; }; //; // The second form interacts better with instruction selection and the; // register allocator to avoid cross-class register copies that aren't; // coalescable due to a lane reference.; // Check the operand and see if it originates from a lane extract.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:371,avoid,avoid,371,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Transform a scalar load that is REPLICATEd as well as having other; // use(s) to the form where the other use(s) use the first element of the; // REPLICATE instead of the load. Otherwise instruction selection will not; // produce a VLREP. Avoid extracting to a GPR, so only do this for floating; // point loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:242,Avoid,Avoid,242,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,"// Transforms ""(X << C1) & C2"" to ""(X & (C2>>C1)) << C1"" if safe and if this; // allows us to fold the shift into this addressing mode. Returns false if the; // transform succeeded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:60,safe,safe,60,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,// Transition WQM -> StrictWQM -> WQM detected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp:38,detect,detected,38,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIWholeQuadMode.cpp,1,['detect'],['detected']
Safety,"// Transitively Incoming Values (TIV) is a set of Values that can ""feed"" a; // value to the initial PHI-node. It is defined like this:; //; // * the initial PHI-node belongs to TIV.; //; // * for every PHI-node in TIV, its operands belong to TIV; //; // If TIV for the initial PHI-node (P) contains more than one constant or a; // value that is not a PHI-node, then P cannot be folded to a constant.; //; // As soon as we detect these cases, we bail, without constructing the; // full TIV.; // Otherwise P can be folded to the one constant in TIV.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h:422,detect,detect,422,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/FunctionSpecialization.h,1,['detect'],['detect']
Safety,// Translate the high level `-mretpoline` flag to the specific target feature; // flags. We also detect if the user asked for retpoline external thunks but; // failed to ask for retpolines themselves (through any of the different; // flags). This is a bit hacky but keeps existing usages working. We should; // consider deprecating this and instead warn if the user requests external; // retpoline thunks and *doesn't* request some form of retpolines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp:97,detect,detect,97,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/X86.cpp,1,['detect'],['detect']
Safety,// Traverse the CFG to detect cycles `UsersDominator` would be part of.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp:23,detect,detect,23,interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp,1,['detect'],['detect']
Safety,// Treat a signal (usually SIGSEGV) or timeout as part of the program output; // so that crash-causing miscompilation is handled seamlessly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp:39,timeout,timeout,39,interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ToolRunner.cpp,1,['timeout'],['timeout']
Safety,"// Treat all globals in explicit sections as small, except for the standard; // large sections of .lbss, .ldata, .lrodata. This reduces the risk of linking; // together small and large sections, resulting in small references to large; // data sections. The code model attribute overrides this above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp:140,risk,risk,140,interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/TargetMachine.cpp,1,['risk'],['risk']
Safety,"// Treat the presence of convergent functions conservatively. The; // transformation is invalid if calls to certain convergent; // functions (like an AMDGPU barrier) get included in the resulting; // inner loop. But blocks meant for the inner loop will be; // identified later at a point where it's too late to abort the; // transformation. Also, the convergent attribute is not really; // sufficient to express the semantics of functions that are; // affected by this transformation. So we choose to back off if such; // a function call is present until a better alternative becomes; // available. This is similar to the conservative treatment of; // convergent function calls in GVNHoist and JumpThreading.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:311,abort,abort,311,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,1,['abort'],['abort']
Safety,"// Tries to find a possibility to optimize a v_cmp ..., s_and_saveexec; // sequence by looking at an instance of an s_and_saveexec instruction.; // Returns a pointer to the v_cmp instruction if it is safe to replace the; // sequence (see the conditions in the function body). This is after register; // allocation, so some checks on operand dependencies need to be considered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp:200,safe,safe,200,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIOptimizeExecMasking.cpp,1,['safe'],['safe']
Safety,// Trivial roots are always non-redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h:32,redund,redundant,32,interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericDomTreeConstruction.h,1,['redund'],['redundant']
Safety,// True dest is safe if BranchCond => GuardCond.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:16,safe,safe,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['safe'],['safe']
Safety,"// True if all buffered resources are in-order, and there is at least one; // buffer which is a dispatch hazard (BufferSize = 0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h:105,hazard,hazard,105,interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/Instruction.h,1,['hazard'],['hazard']
Safety,"// True if the roots can be zero-extended back to their original type, rather; // than sign-extended. We know that if the leading bits are not demanded, we; // can safely zero-extend. So we initialize IsKnownPositive to True.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:164,safe,safely,164,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safely']
Safety,// True if this block contains a safepoint and thus AvailableIn does not; // contribute to AvailableOut.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:33,safe,safepoint,33,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['safe'],['safepoint']
Safety,// True if this macro is unsafe in headers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h:25,unsafe,unsafe,25,interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/IdentifierTable.h,1,['unsafe'],['unsafe']
Safety,// Try a redundant low-level type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp:9,redund,redundant,9,interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MIRParser/MIParser.cpp,1,['redund'],['redundant']
Safety,// Try and recover a few more locations with entry values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:11,recover,recover,11,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['recover'],['recover']
Safety,"// Try and vectorize the indices. We are currently only interested in; // gather-like cases of the form:; //; // ... = g[a[0] - b[0]] + g[a[1] - b[1]] + ...; //; // where the loads of ""a"", the loads of ""b"", and the subtractions can be; // performed in parallel. It's likely that detecting this pattern in a; // bottom-up phase will be simpler and less costly than building a; // full-blown top-down phase beginning at the consecutive loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:279,detect,detecting,279,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['detect'],['detecting']
Safety,// Try generic GCC detection first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:19,detect,detection,19,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,1,['detect'],['detection']
Safety,"// Try hard to avoid looking up in the Cling database as this could enduce; // an unwanted autoparsing.; // Note: this is always done by the callers and thus is redundant.; // Maybe replace with",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:15,avoid,avoid,15,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// Try hard to fold loads from bitcasted strange and non-type-safe things.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:62,safe,safe,62,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['safe'],['safe']
Safety,// Try hoisting the instruction out to the preheader. We can only do; // this if all of the operands of the instruction are loop invariant and; // if it is safe to hoist the instruction. We also check block frequency; // to make sure instruction only gets hoisted into colder blocks.; // TODO: It may be safe to hoist if we are hoisting to a conditional block; // and we have accurately duplicated the control flow from the loop header; // to that block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:156,safe,safe,156,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,2,['safe'],['safe']
Safety,// Try if we can determine constant lengths for all array sections and avoid; // the VLA.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:71,avoid,avoid,71,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['avoid'],['avoid']
Safety,// Try recovering from missing { after base-clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:7,recover,recovering,7,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recovering']
Safety,// Try sinking IRG as deep as possible to avoid hurting shrink wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTagging.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTagging.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64StackTagging.cpp,1,['avoid'],['avoid']
Safety,"// Try the standard symbol resolution first, but ask it not to abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:63,abort,abort,63,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,4,['abort'],['abort']
Safety,// Try to add additional zero indices to reach the desired result element; // type.; // TODO: Should we avoid extra zero indices if ResElemTy can't be reached and; // we'll have to insert a bitcast anyway?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:104,avoid,avoid,104,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['avoid'],['avoid']
Safety,"// Try to avoid autoparsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx:10,avoid,avoid,10,io/io/src/TGenCollectionProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TGenCollectionProxy.cxx,1,['avoid'],['avoid']
Safety,// Try to avoid calling GetGVALinkageForFunction.; // All cases of this require the 'inline' keyword.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,avoid,avoid,10,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,// Try to avoid cases where sinking/duplicating is likely to increase register; // pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:10,avoid,avoid,10,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,// Try to avoid emitting a bit operation when we only need to touch half of; // the 64-bit pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp:10,avoid,avoid,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUInstructionSelector.cpp,1,['avoid'],['avoid']
Safety,"// Try to avoid emitting dead SP adjustments if the block end is unreachable,; // typically because the function is marked noreturn (abort, throw,; // assert_fail, etc).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:10,avoid,avoid,10,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,2,"['abort', 'avoid']","['abort', 'avoid']"
Safety,// Try to avoid exploding compile time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:10,avoid,avoid,10,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['avoid'],['avoid']
Safety,// Try to avoid folding immediates with multiple uses for optsize.; // This code tries to select to register form directly to avoid going; // through the isel table which might fold the immediate. We can't change; // the patterns on the add/sub/and/or/xor with immediate paterns in the; // tablegen files to check immediate use count without making the patterns; // unavailable to the fast-isel table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:10,avoid,avoid,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['avoid'],['avoid']
Safety,"// Try to avoid jumping back to the previous page and jumping back to the previous cluster",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx:10,avoid,avoid,10,tree/ntuple/v7/inc/ROOT/RColumn.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RColumn.hxx,1,['avoid'],['avoid']
Safety,"// Try to avoid spurious warning from memory leak checkers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx:10,avoid,avoid,10,core/cont/src/TClassTable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TClassTable.cxx,1,['avoid'],['avoid']
Safety,// Try to avoid the warning when the shadowed decl isn't captured.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,avoid,avoid,10,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,"// Try to avoid using an extload by loading earlier than the argument address,; // and extracting the relevant bits. The load should hopefully be merged with; // the previous argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:10,avoid,avoid,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Try to avoid warnings for lambdas with an explicit capture; // list. Warn only when the lambda captures the shadowed decl; // explicitly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:10,avoid,avoid,10,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,"// Try to change the name of the function in module inline asm. We only do; // this for specific asm directives, currently only "".symver"", to try to avoid; // corrupting asm which happens to contain the symbol name as a substring.; // Note that the substitution for .symver assumes that the versioned symbol; // also has an instrumented name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:149,avoid,avoid,149,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,1,['avoid'],['avoid']
Safety,"// Try to complete the type. Under ARC, this is a hard error from which; // we don't try to recover.; // FIXME: In the non-ARC case, this will still be a hard error if the; // definition is found in a module that's not visible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:92,recover,recover,92,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['recover'],['recover']
Safety,"// Try to convert an ""is positive"" signbit masking operation into arithmetic; // shift and ""andn"". This saves a materialization of a -1 vector constant.; // The ""is negative"" variant should be handled more generally because it only; // requires ""and"" rather than ""andn"":; // and (pcmpgt X, -1), Y --> pandn (vsrai X, BitWidth - 1), Y; //; // This is limited to the original type to avoid producing even more bitcasts.; // If the bitcasts can't be eliminated, then it is unlikely that this fold; // will be profitable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:382,avoid,avoid,382,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Try to detect AVG pattern first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,detect,detect,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,// Try to detect PMADD,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:10,detect,detect,10,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,"// Try to detect a braced list. Note that regardless how we mark inner; // braces here, we will overwrite the BlockKind later if we parse a; // braced list (where all blocks inside are by default braced lists),; // or when we explicitly detect blocks (for example while parsing; // lambdas).; // If we already marked the opening brace as braced list, the closing; // must also be part of it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:10,detect,detect,10,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,2,['detect'],['detect']
Safety,// Try to detect mistyped 'range:' comments to ensure tests don't miss; // anything.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp:10,detect,detect,10,interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-refactor/TestSupport.cpp,1,['detect'],['detect']
Safety,// Try to detect target regions in the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp:10,detect,detect,10,interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGOpenMPRuntime.cpp,1,['detect'],['detect']
Safety,"// Try to detect the case where the current inlining candidate caller (call; // it B) is a static or linkonce-ODR function and is an inlining candidate; // elsewhere, and the current candidate callee (call it C) is large enough; // that inlining it into B would make B too big to inline later. In these; // circumstances it may be best not to inline C into B, but to inline B into; // its callers.; //; // This only applies to static and linkonce-ODR functions because those are; // expected to be available for inlining in the translation units where they; // are used. Thus we will always have the opportunity to make local inlining; // decisions. Importantly the linkonce-ODR linkage covers inline functions; // and templates in C++.; //; // FIXME: All of this logic should be sunk into getInlineCost. It relies on; // the internal implementation of the inline cost metrics rather than; // treating them as truly abstract units etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp:10,detect,detect,10,interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineAdvisor.cpp,1,['detect'],['detect']
Safety,"// Try to determine the length of the source, substituting its size; // when it's not nul-terminated (as it's required to be) to avoid; // reading past its end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:129,avoid,avoid,129,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,1,['avoid'],['avoid']
Safety,"// Try to eliminate redundant copy to register which we're going to; // spill, i.e. try to change:; // X = COPY Y; // SPILL X; // to; // SPILL Y; // If there are no uses of X between copy and STATEPOINT, that COPY; // may be eliminated.; // Reg - register we're about to spill; // RI - On entry points to statepoint.; // On successful copy propagation set to new spill point.; // IsKill - set to true if COPY is Kill (there are no uses of Y); // Returns either found source copy register or original one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp:20,redund,redundant,20,interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/FixupStatepointCallerSaved.cpp,1,['redund'],['redundant']
Safety,// Try to find a larger VBROADCAST_LOAD/SUBV_BROADCAST_LOAD that we can extract; // from. Limit this to cases where the loads have the same input chain and the; // output chains are unused. This avoids any memory ordering issues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:195,avoid,avoids,195,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoids']
Safety,// Try to find a region in `SafeBufferOptOutMap` where `Loc` is in:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:28,Safe,SafeBufferOptOutMap,28,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['Safe'],['SafeBufferOptOutMap']
Safety,"// Try to find ptxas binary. If the executable is located in a directory; // called 'bin/', its parent directory might be a good guess for a valid; // CUDA installation.; // However, some distributions might installs 'ptxas' to /usr/bin. In that; // case the candidate would be '/usr' which passes the following checks; // because '/usr/include' exists as well. To avoid this case, we always; // check for the directory potentially containing files for libdevice,; // even if the user passes -nocudalib.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp:365,avoid,avoid,365,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.cpp,1,['avoid'],['avoid']
Safety,// Try to find redundant copies b/w vregs of the same register class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp:15,redund,redundant,15,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/InstructionSelect.cpp,1,['redund'],['redundant']
Safety,// Try to find safe point based on dominance and block frequency without; // any change in IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:15,safe,safe,15,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['safe'],['safe']
Safety,"// Try to fold like below:; // %1:i64 = ORim 0, 0(1); // %2:i64 = CMPSLrr %0, %1; // To; // %2:i64 = CMPSLrm %0, 0(1); //; // Another example:; // %1:i64 = ORim 6, 0(1); // %2:i64 = CMPSLrr %1, %0; // To; // %2:i64 = CMPSLir 6, %0; //; // Support commutable instructions like below:; // %1:i64 = ORim 6, 0(1); // %2:i64 = ADDSLrr %1, %0; // To; // %2:i64 = ADDSLri %0, 6; //; // FIXME: Need to support i32. Current implementtation requires; // EXTRACT_SUBREG, so input has following COPY and it avoids folding:; // %1:i64 = ORim 6, 0(1); // %2:i32 = COPY %1.sub_i32; // %3:i32 = ADDSWSXrr %0, %2; // FIXME: Need to support shift, cmov, and more instructions.; // FIXME: Need to support lvl too, but LVLGen runs after peephole-opt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp:495,avoid,avoids,495,interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEInstrInfo.cpp,1,['avoid'],['avoids']
Safety,"// Try to fold; //; // (neg (csel X, Y)) -> (csel (neg X), (neg Y)); //; // The folding helps csel to be matched with csneg without generating; // redundant neg instruction, which includes negation of the csel expansion; // of abs node lowered by lowerABS.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:147,redund,redundant,147,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['redund'],['redundant']
Safety,// Try to fuse comparison instruction Compare into a later branch.; // Return true on success and if Compare is therefore redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp:122,redund,redundant,122,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZElimCompare.cpp,1,['redund'],['redundant']
Safety,"// Try to get out easy if proposed step within safe region",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:47,safe,safe,47,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,2,['safe'],['safe']
Safety,// Try to handle some simple cases to avoid spilling and reloading every; // value inside a self looping block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:38,avoid,avoid,38,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['avoid'],['avoid']
Safety,"// Try to improve a sequence of srl (and X, C1), C2 by inverting the order.; // TODO: This is a generic DAG combine that became an x86-only combine to; // avoid shortcomings in other folds such as bswap, bit-test ('bt'), and; // and-not ('andn').",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:155,avoid,avoid,155,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Try to inline the call.; // The origin expression here is just used as a kind of checksum;; // this should still be safe even for CallEvents that don't come from exprs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:119,safe,safe,119,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['safe'],['safe']
Safety,"// Try to load TrueType font renderer. Only try to load if not in batch; // mode and Root.UseTTFonts is true and Root.TTFontPath exists. Abort silently; // if libttf or libGX11TTF are not found in $ROOTSYS/lib or $ROOTSYS/ttf/lib.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:137,Abort,Abort,137,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['Abort'],['Abort']
Safety,"// Try to mask before the extension to avoid having to generate a larger mask,; // possibly over several sub-vectors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// Try to match an arithmetic-sequence BUILD_VECTOR [X,X+S,X+2*S,...,X+(N-1)*S]; // to the (non-zero) step S and start value X. This can be then lowered as the; // RVV sequence (VID * S) + X, for example.; // The step S is represented as an integer numerator divided by a positive; // denominator. Note that the implementation currently only identifies; // sequences in which either the numerator is +/- 1 or the denominator is 1. It; // cannot detect 2/3, for example.; // Note that this method will also match potentially unappealing index; // sequences, like <i32 0, i32 50939494>, however it is left to the caller to; // determine whether this is worth generating code for.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:445,detect,detect,445,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['detect'],['detect']
Safety,"// Try to match the following:; // bb1:; // G_BRCOND %c1, %bb2; // G_BR %bb3; // bb2:; // ...; // bb3:; // The above pattern does not have a fall through to the successor bb2, always; // resulting in a branch no matter which path is taken. Here we try to find; // and replace that pattern with conditional branch to bb3 and otherwise; // fallthrough to bb2. This is generally better for branch predictors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:394,predict,predictors,394,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['predict'],['predictors']
Safety,// Try to merge the required wait with preexisting waitcnt instructions.; // Also erase redundant waitcnt.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:88,redund,redundant,88,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['redund'],['redundant']
Safety,// Try to optimize vXi1 selects if both operands are either all constants or; // bitcasts from scalar integer type. In that case we can convert the operands; // to integer and use an integer select which will be converted to a CMOV.; // We need to take a little bit of care to avoid creating an i64 type after; // type legalization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:277,avoid,avoid,277,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Try to parse a shifter (e.g., ""lsl <amt>""). On success, return 0.; // If a recoverable error occurs, return 1. If an irrecoverable error; // occurs, return -1. An irrecoverable error is one where tokens have been; // consumed in the process of trying to parse the shifter (i.e., when it is; // indeed a shifter operand, but malformed).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:78,recover,recoverable,78,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['recover'],['recoverable']
Safety,"// Try to pull __CUDA_FTZ from the nvvm-reflect-ftz module flag. Our; // choice here must be kept in sync with AutoUpgrade, which uses the same; // technique to detect whether ftz is enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp:161,detect,detect,161,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVVMReflect.cpp,1,['detect'],['detect']
Safety,// Try to re-use an already extended operand of a vector SetCC feeding a; // extended select. Doing so avoids requiring another full extension of the; // SET_CC result when lowering the select.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:103,avoid,avoids,103,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoids']
Safety,// Try to recover by calling this function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recover']
Safety,// Try to recover by implicitly importing this module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['recover'],['recover']
Safety,// Try to recover by looking for viable functions which the user might; // have meant to call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recover']
Safety,// Try to recover from an empty lookup with typo correction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recover']
Safety,"// Try to recover from the typo, by dropping the tag definition and parsing; // the problematic tokens as a type.; //; // FIXME: Split the DeclSpec into pieces for the standalone; // declaration and pieces for the following declaration, instead; // of assuming that all the other pieces attach to new declaration,; // and call ParsedFreeStandingDeclSpec as appropriate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Safety,"// Try to recover if we have something like sizeof(T::X) where X is a type.; // Notably, there must be *exactly* one set of parens if X is a type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:10,recover,recover,10,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['recover'],['recover']
Safety,// Try to recover some path sensitivity in case we couldn't; // compute the value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,1,['recover'],['recover']
Safety,"// Try to recover some path-sensitivity. Right now casts of symbolic; // integers that promote their values are currently not tracked well.; // If 'Condition' is such an expression, try and recover the; // underlying value and use that instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngine.cpp,2,['recover'],['recover']
Safety,// Try to recover; create a SLocEntry so the rest of clang can handle it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:10,recover,recover,10,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['recover'],['recover']
Safety,"// Try to remove redundant sext operations on Hexagon. The hardware; // already sign extends many 16 bit intrinsic operations to 32 bits.; // For example:; // %34 = tail call i32 @llvm.hexagon.A2.addh.l16.sat.ll(i32 %x, i32 %y); // %sext233 = shl i32 %34, 16; // %conv52 = ashr exact i32 %sext233, 16",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp:17,redund,redundant,17,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonOptimizeSZextends.cpp,1,['redund'],['redundant']
Safety,// Try to respect gcc-config on Gentoo if --gcc-toolchain is not provided.; // This avoids accidentally enforcing the system GCC version when using a; // custom toolchain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp:84,avoid,avoids,84,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.cpp,1,['avoid'],['avoids']
Safety,// Try to sink a splat shuffle after a binop with a uniform constant.; // This is limited to cases where neither the shuffle nor the constant have; // undefined elements because that could be poison-unsafe or inhibit; // demanded elements analysis. It is further limited to not change a splat; // of an inserted scalar because that may be optimized better by; // load-folding or other target-specific behaviors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:199,unsafe,unsafe,199,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['unsafe'],['unsafe']
Safety,// Try to transform this shift into a multiply-high if; // it matches the appropriate pattern detected in combineShiftToMULH.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:94,detect,detected,94,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['detect'],['detected']
Safety,"// Try to turn a partially redundant memset + memcpy into; // smaller memset + memcpy. We don't need the memcpy size for this.; // The memcpy must post-dom the memset, so limit this to the same basic; // block. A non-local generalization is likely not worthwhile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:27,redund,redundant,27,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['redund'],['redundant']
Safety,// Try to use leading zeros of the dividend to reduce the multiplier and; // avoid expensive fixups.; // TODO: Support vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:77,avoid,avoid,77,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['avoid'],['avoid']
Safety,"// Try to vectorize chain in store, if this is the only store to the; // address in the block.; // TODO: This is just a temporarily solution to save compile time. Need; // to investigate if we can safely turn on slp-vectorize-hor-store; // instead to allow lookup for reduction chains in all non-vectorized; // stores (need to check side effects and compile time).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:197,safe,safely,197,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safely']
Safety,// Try to vectorize the first found set to avoid duplicate analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:43,avoid,avoid,43,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,// Try unscheduling up to the point where it's safe to schedule; // this node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:47,safe,safe,47,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['safe'],['safe']
Safety,// Try using find_as first to avoid creating extra value handles just for the; // purpose of doing the lookup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:30,avoid,avoid,30,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,1,['avoid'],['avoid']
Safety,// Turn ## into 'unknown' to avoid # ## # from looking like a paste; // operator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp:29,avoid,avoid,29,interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenLexer.cpp,1,['avoid'],['avoid']
Safety,// Turn 'a' into a mask suitable for VSELECT: a = a << 5;; // We can safely do this using i16 shifts as we're only interested in; // the 3 lower bits of each byte.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:69,safe,safely,69,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['safe'],['safely']
Safety,"// Turn 'store float 1.0, Ptr' -> 'store int 0x12345678, Ptr'; //; // Make sure to do this only after attempting to merge stores in order to; // avoid changing the types of some subset of stores due to visit order,; // preventing their merging.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:145,avoid,avoid,145,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// Turn load->store of MMX types into GPR load/stores. This avoids clobbering; // the FP state in cases where an emms may be missing.; // A preferable solution to the general problem is to figure out the right; // places to insert EMMS. This qualifies as a quick hack.; // Similarly, turn load->store of i64 into double load/stores in 32-bit mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:60,avoid,avoids,60,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// Turn off buffering on OS, which we now own, to avoid allocating a buffer; // when the destructor writes only to be immediately flushed again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:50,avoid,avoid,50,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['avoid'],['avoid']
Safety,"// Turn off commute-with-shift transform after legalization, so it doesn't; // conflict with PerformSHLSimplify. (We could try to detect when; // PerformSHLSimplify would trigger more precisely, but it isn't; // really necessary.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:130,detect,detect,130,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['detect'],['detect']
Safety,"// Turn on colon protection early, while parsing declspec, although there is; // nothing to protect there. It prevents from false errors if error recovery; // incorrectly determines where the declspec ends, as in the example:; // struct A { enum class B { C }; };; // const int C = 4;; // struct D { A::B : C; };",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:146,recover,recovery,146,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recovery']
Safety,"// Turn-off the global mutex to avoid recreating mutexes that have; // already been deleted during the destruction phase",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:32,avoid,avoid,32,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,1,['avoid'],['avoid']
Safety,"// Turns a class name into a CSS selector matching it, with some wrinkles:; // - we treat id=""foo"" just like class=""foo"" to avoid repetition in the HTML; // - cls can be an array of strings, we match them all",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js:124,avoid,avoid,124,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/HTMLLogger.js,1,['avoid'],['avoid']
Safety,// Two instrs are partial redundant if their basic blocks are reachable; // from one to another but one doesn't dominate another.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp:26,redund,redundant,26,interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCSE.cpp,1,['redund'],['redundant']
Safety,"// Type check the data argument. It should be an 'int'.; // Although not in conformance with C99, we also allow the argument to be; // an 'unsigned int' as that is a reasonably safe case. GCC also; // doesn't emit a warning for that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:177,safe,safe,177,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['safe'],['safe']
Safety,"// Type information is 4 bits, so 16 is safely out of range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSStub.h:40,safe,safely,40,interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSStub.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/InterfaceStub/IFSStub.h,1,['safe'],['safely']
Safety,// Type safety attributes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp:8,safe,safety,8,interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclAttr.cpp,1,['safe'],['safety']
Safety,// Type safety checking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:8,safe,safety,8,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['safe'],['safety']
Safety,"// Types: We do not do IO of functions, so it is safe to; // put in some heuristics",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/LinkdefReader.cxx:49,safe,safe,49,core/dictgen/src/LinkdefReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/LinkdefReader.cxx,1,['safe'],['safe']
Safety,// ULT with 'add' of a constant is canonical. See foldICmpAddConstant().; // FIXME: Are there more magic icmp predicate+constant pairs we must avoid?; // Or should we just abandon this transform entirely?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:143,avoid,avoid,143,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['avoid'],['avoid']
Safety,"// Uh, oh, overflow detected!!!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp:20,detect,detected,20,interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLLexer.cpp,2,['detect'],['detected']
Safety,// Unconditionally claim the printf option now to avoid unused diagnostic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp:50,avoid,avoid,50,interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Clang.cpp,1,['avoid'],['avoid']
Safety,// Undef can safely be skipped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp:13,safe,safely,13,interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/WinEHPrepare.cpp,1,['safe'],['safely']
Safety,"// UndefCapturedBlockVarChecker.cpp - Uninitialized captured vars -*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This checker detects blocks that capture uninitialized values.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefCapturedBlockVarChecker.cpp:396,detect,detects,396,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefCapturedBlockVarChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/UndefCapturedBlockVarChecker.cpp,1,['detect'],['detects']
Safety,"// Under ARC, self can't be assigned, and doing a direct call to `self`; // when it's a Class is hence safe. For other cases, we can't trust `self`; // is what we think it is, so we reject it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:103,safe,safe,103,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['safe'],['safe']
Safety,"// Under the large code model, we cannot assume that __morestack lives; // within 2^31 bytes of the call site, so we cannot use pc-relative; // addressing. We cannot perform the call via a temporary register,; // as the rax register may be used to store the static chain, and all; // other suitable registers may be either callee-save or used for; // parameter passing. We cannot use the stack at this point either; // because __morestack manipulates the stack directly.; //; // To avoid these issues, perform an indirect call via a read-only memory; // location containing the address.; //; // This solution is not perfect, as it assumes that the .rodata section; // is laid out within 2^31 bytes of each function body, but this seems; // to be sufficient for JIT.; // FIXME: Add retpoline support and remove the error here..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:482,avoid,avoid,482,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// Under unsafe-math, evaluate calls if possible.; // According to Brian Sumner, we can do this for all f32 function calls; // using host's double function calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:9,unsafe,unsafe-math,9,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['unsafe'],['unsafe-math']
Safety,"// Unfortunately, Objective-C does not enforce that overridden methods have; // covariant return types, so we can't assert that that never happens.; // Be safe and return UnknownVal().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp:155,safe,safe,155,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCallAndReturn.cpp,1,['safe'],['safe']
Safety,"// Unfortunately, we have to bail out instead of recovering by; // ignoring the parameters, just in case the nested name specifier; // depends on the parameters.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:49,recover,recovering,49,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['recover'],['recovering']
Safety,"// Universal Mach-O files can't have an archicture slice that starts; // beyond the 4GB boundary. ""lipo"" can create a 64 bit universal; // header, but not all tools can parse these files so we want to return; // an error if the file can't be encoded as a file with a 32 bit; // universal header. To detect this, we check the size of each; // architecture's skinny Mach-O file and add up the offsets. If they; // exceed 4GB, then we return an error.; // First we compute the right offset where the first architecture will; // fit followin the 32 bit universal header. The 32 bit universal header; // starts with a uint32_t magic and a uint32_t number of architecture; // infos. Then it is followed by 5 uint32_t values for each; // architecture. So we set the start offset to the right value so we can; // calculate the exact offset that the first architecture slice can; // start at.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:299,detect,detect,299,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,1,['detect'],['detect']
Safety,"// Unknown constant, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:21,abort,abort,21,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,1,['abort'],['abort']
Safety,"// Unknown family 6 CPU, try to guess.; // Don't both with Type/Subtype here, they aren't used by the caller.; // They're used above to keep the code in sync with compiler-rt.; // TODO detect tigerlake host from model",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:185,detect,detect,185,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,1,['detect'],['detect']
Safety,// Unknown: Assume not safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp:23,safe,safe,23,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFixCortexA57AES1742098Pass.cpp,1,['safe'],['safe']
Safety,"// Unless EH cleanup is required, we don't need this anymore, so kill; // it. It's not quite worth the annoyance to avoid creating it in the; // first place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:116,avoid,avoid,116,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['avoid'],['avoid']
Safety,"// Unless noted otherwise, an instruction is considered; // safe for the optimization. There are a large number of; // such true-SIMD instructions (all vector math, logical,; // select, compare, etc.). However, if the instruction; // mentions a partial vector register and does not have; // special handling defined, it is not swappable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp:60,safe,safe,60,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCVSXSwapRemoval.cpp,1,['safe'],['safe']
Safety,"// Unless the instruction has the same !dbg location as the original; // branch, drop it. When we fold the bonus instructions we want to make; // sure we reset their debug locations in order to avoid stepping on; // dead code caused by folding dead branches.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:194,avoid,avoid,194,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"// Unless the macro indicates that the intended type is clearly not; // a pointer type, we should avoid warning on comparing pointers; // to zero literals in non-pedantic mode.; // FIXME: Introduce an AST matcher to implement the macro-related logic?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp:98,avoid,avoid,98,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NumberObjectConversionChecker.cpp,1,['avoid'],['avoid']
Safety,"// Unlike a regular null dereference, initializing a reference with a; // dereferenced null pointer does not actually cause a runtime exception in; // Clang's implementation of references.; //; // int &r = *p; // safe??; // if (p != NULL) return; // uh-oh; // r = 5; // trap here; //; // The standard says this is invalid as soon as we try to create a ""null; // reference"" (there is no such thing), but turning this into an assumption; // that 'p' is never null will not match our actual runtime behavior.; // So we do not record this assumption, allowing us to warn on the last line; // of this example.; //; // We do need to add a transition because we may have generated a sink for; // the ""implicit"" null dereference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp:213,safe,safe,213,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DereferenceChecker.cpp,1,['safe'],['safe']
Safety,"// Unlike loads, we never try to eliminate stores, so we do not check if they; // are simple and avoid value numbering them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:97,avoid,avoid,97,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['avoid'],['avoid']
Safety,"// Unlike most transforms, this one is not safe to propagate nsz unless; // it is present on the original select. We union the flags from the select; // and fneg and then remove nsz if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:43,safe,safe,43,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['safe'],['safe']
Safety,"// Unlike the Apple non-fragile runtimes, which also uses; // unwind-based zero cost exceptions, the GNU Objective C runtime's; // EH support isn't a veneer over C++ EH. Instead, exception; // objects are created by objc_exception_throw and destroyed by; // the personality function; this avoids the need for bracketing; // catch handlers with calls to __blah_begin_catch/__blah_end_catch; // (or even _Unwind_DeleteException), but probably doesn't; // interoperate very well with foreign exceptions.; //; // In Objective-C++ mode, we actually emit something equivalent to the C++; // exception handler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:289,avoid,avoids,289,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['avoid'],['avoids']
Safety,"// Unnamed bitfields are only used for padding and do not appear in; // `InitListExpr`'s inits. However, those fields do appear in `RecordDecl`'s; // field list, and we thus need to remove them before mapping inits to; // fields to avoid mapping inits to the wrongs fields.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp:232,avoid,avoid,232,interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/FlowSensitive/DataflowEnvironment.cpp,1,['avoid'],['avoid']
Safety,// Unreachable code analysis and thread safety require a linearized CFG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:40,safe,safety,40,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['safe'],['safety']
Safety,"// Unreachable, single pred, or full redundancy. Note that FRE is handled by; // phase 3.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:37,redund,redundancy,37,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['redund'],['redundancy']
Safety,// Unrelated loads are definitely safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,safe,safe,34,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['safe'],['safe']
Safety,"// Unroll metadata for the inner loop.; // This needs to take into account the remainder portion of the unrolled loop,; // hence `unroll(full)` does not apply here, even though the LoopUnroll pass; // supports multiple loop exits. Instead, unroll using a factor equivalent to; // the maximum trip count, which will also generate a remainder loop. Just; // `unroll(enable)` (which could have been useful if the user has not; // specified a concrete factor; even though the outer loop cannot be; // influenced anymore, would avoid more code bloat than necessary) will refuse; // the loop because ""Won't unroll; remainder loop could not be generated when; // assuming runtime trip count"". Even if it did work, it must not choose a; // larger unroll factor than the maximum loop length, or it would always just; // execute the remainder loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:523,avoid,avoid,523,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['avoid'],['avoid']
Safety,// Unroll small loops to hide loop backedge latency and saturate any; // parallel execution resources of an out-of-order processor. We also then; // need to clean up redundancies and loop invariant code.; // FIXME: It would be really good to use a loop-integrated instruction; // combiner for cleanup here so that the unrolling and LICM can be pipelined; // across the loop nests.; // We do UnrollAndJam in a separate LPM to ensure it happens before unroll,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp:166,redund,redundancies,166,interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilderPipelines.cpp,1,['redund'],['redundancies']
Safety,// Unsafe Math optimization; // Remember that ci_opr1 is set if opr1 is integral,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp:3,Unsafe,Unsafe,3,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULibCalls.cpp,1,['Unsafe'],['Unsafe']
Safety,"// Unsafe casts terminate a chain unsuccessfully. We can't do anything; // useful with bitcasts, ptrtoints or inttoptrs and it'd be unsafe to; // transform anything that relies on them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp:3,Unsafe,Unsafe,3,interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/VectorUtils.cpp,2,"['Unsafe', 'unsafe']","['Unsafe', 'unsafe']"
Safety,// Unsafe if the minimum distance needed is greater than smallest dependence; // distance distance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:3,Unsafe,Unsafe,3,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['Unsafe'],['Unsafe']
Safety,// Unsafe stack always grows down.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:3,Unsafe,Unsafe,3,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['Unsafe'],['Unsafe']
Safety,// Unsafe to rename the address-taken function (which can be used in; // function comparison).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp:3,Unsafe,Unsafe,3,interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/InstrProf.cpp,1,['Unsafe'],['Unsafe']
Safety,// UnsafeBufferUsage analysis settings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:3,Unsafe,UnsafeBufferUsage,3,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['Unsafe'],['UnsafeBufferUsage']
Safety,"// UnsafeClaimRV is a frontend peephole for RetainRV + Release. Since the; // AutoreleaseRV and RetainRV cancel out, replace UnsafeClaimRV with Release.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:3,Unsafe,UnsafeClaimRV,3,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,2,['Unsafe'],['UnsafeClaimRV']
Safety,"// Unused constrained FP intrinsic calls may have declared side effect, which; // prevents it from being removed. In some cases however the side effect is; // actually absent. To detect this case, call SimplifyConstrainedFPCall. If it; // returns a replacement, the call may be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:179,detect,detect,179,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,1,['detect'],['detect']
Safety,// Update Acc:; // Acc -= Iter * Prod; // Check if there is at least one more inner loop to avoid; // multiplication by 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:92,avoid,avoid,92,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['avoid'],['avoid']
Safety,// Update CFG to skip the old jump table block. Remove shared successors; // before transferring to avoid duplicated successors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:100,avoid,avoid,100,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,1,['avoid'],['avoid']
Safety,"// Update CurrMOps after calling bumpCycle to handle stalls, since bumpCycle; // resets CurrMOps. Loop to handle instructions with more MOps than issue in; // one cycle. Since we commonly reach the max MOps here, opportunistically; // bump the cycle to avoid uselessly checking everything in the readyQ.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:253,avoid,avoid,253,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['avoid'],['avoid']
Safety,// Update LiveRegGen only if was empty before this unscheduling.; // This is to avoid incorrect updating LiveRegGen set in previous run.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:80,avoid,avoid,80,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avoid'],['avoid']
Safety,"// Update buflen, as Clobber clamps length to MaxSize (if Fatal does not abort)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:73,abort,abort,73,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,1,['abort'],['abort']
Safety,// Update debug users without use-before-def risk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:45,risk,risk,45,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,1,['risk'],['risk']
Safety,"// Update existing Phi.; // FIXME: some updates may be redundant, try to optimize and skip some.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp:55,redund,redundant,55,interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemorySSAUpdater.cpp,1,['redund'],['redundant']
Safety,"// Update flags that impact how we outline across the entire block,; // regardless of safety.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:86,safe,safety,86,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['safe'],['safety']
Safety,"// Update info about the previous instruction, for detecting if; // the next one can be made a UOP_SaveNext",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp:51,detect,detecting,51,interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCWin64EH.cpp,1,['detect'],['detecting']
Safety,// Update liveness of predecessors before successors to avoid treating a; // two-address node as a live range def.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:56,avoid,avoid,56,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avoid'],['avoid']
Safety,// Update machine locations <=> variable locations maps. Defer updating; // ActiveMLocs to avoid invalidating the ActiveMLocIt iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:91,avoid,avoid,91,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avoid'],['avoid']
Safety,// Update structural hazard information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:21,hazard,hazard,21,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,1,['hazard'],['hazard']
Safety,"// Update the CompoundStmt body, avoiding alloc/dealloc of all the el.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinterSynthesizer.cpp:33,avoid,avoiding,33,interpreter/cling/lib/Interpreter/ValuePrinterSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/ValuePrinterSynthesizer.cpp,1,['avoid'],['avoiding']
Safety,"// Update the estimated integral and maximum value. Increase our; // maximum estimate slightly to give a safety margin with a; // corresponding loss of efficiency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAcceptReject.cxx:105,safe,safety,105,roofit/roofitcore/src/RooAcceptReject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAcceptReject.cxx,1,['safe'],['safety']
Safety,// Update the stack pointer by pushing a register. This is the instruction; // emitted that would be end up being emitted by a call to `emitSPUpdate`.; // Hard-coding the update to a push avoids emitting a second; // `STACKALLOC_W_PROBING` instruction in the save block: We know that stack; // probing isn't needed anyways for an 8-byte update.; // Pushing a register leaves us in a similar situation to a regular; // function call where we know that the address at (rsp-8) is writeable.; // That way we avoid any off-by-ones with stack probing for additional; // stack pointer updates later on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp:188,avoid,avoids,188,interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FrameLowering.cpp,2,['avoid'],"['avoid', 'avoids']"
Safety,// Update the store map after all chains have been added to avoid adding; // self-loop edge if multiple underlying objects are present.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp:60,avoid,avoid,60,interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ScheduleDAGInstrs.cpp,1,['avoid'],['avoid']
Safety,"// Upgrade ""Linker Options"" module flag to ""llvm.linker.options"" module-level; // metadata. Only upgrade if the new option doesn't exist to avoid upgrade; // multiple times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:140,avoid,avoid,140,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['avoid'],['avoid']
Safety,"// Upload and Enable methods are intelligent and avoid; // re-uploading or re-enabling of a package to a node that has it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:49,avoid,avoid,49,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['avoid'],['avoid']
Safety,"// Upon failure, verify that the masked-out part of the loaded value; // has been modified. If it didn't, abort the cmpxchg, since the; // masked-in part must've.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp:106,abort,abort,106,interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AtomicExpandPass.cpp,1,['abort'],['abort']
Safety,// Use 'neg(...)' instead of '-' to avoid ambiguity.; // This is important for integer literals because; // -1 is not the same value as neg(1).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUInstPrinter.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/MCTargetDesc/AMDGPUInstPrinter.cpp,1,['avoid'],['avoid']
Safety,// Use .vbyte for data definition to avoid directives that apply an implicit; // alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmInfoXCOFF.cpp:37,avoid,avoid,37,interpreter/llvm-project/llvm/lib/MC/MCAsmInfoXCOFF.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAsmInfoXCOFF.cpp,1,['avoid'],['avoid']
Safety,// Use 128 bit APInt to do the arithmetic to avoid overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,1,['avoid'],['avoid']
Safety,// Use 128 bits APInt to avoid overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp:25,avoid,avoid,25,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,1,['avoid'],['avoid']
Safety,// Use CachedFunctionScope to avoid allocating memory when possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:30,avoid,avoid,30,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['avoid'],['avoid']
Safety,"// Use EIZ/RIZ for a few ambiguous cases where the SIB byte is present,; // but no index is used and modrm alone should have been enough.; // -No base register in 32-bit mode. In 64-bit mode this is used to; // avoid rip-relative addressing.; // -Any base register used other than ESP/RSP/R12D/R12. Using these as a; // base always requires a SIB byte.; // -A scale other than 1 is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp:211,avoid,avoid,211,interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/Disassembler/X86Disassembler.cpp,1,['avoid'],['avoid']
Safety,// Use M1 or smaller to avoid over constraining register allocation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:24,avoid,avoid,24,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Use ODR linkage to avoid duplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp:22,avoid,avoid,22,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64LowerHomogeneousPrologEpilog.cpp,1,['avoid'],['avoid']
Safety,// Use RTZ to avoid rounding influencing exponent of FloatVal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Use SCALAR_TO_VECTOR for lane zero to; // a) Avoid a RMW dependency on the full vector register, and; // b) Allow the register coalescer to fold away the copy if the; // value is already in an S or D register, and we're forced to emit an; // INSERT_SUBREG that we can't fold anywhere.; //; // We also allow types like i8 and i16 which are illegal scalar but legal; // vector element types. After type-legalization the inserted value is; // extended (i32) and it is safe to cast them to the vector type by ignoring; // the upper bits of the lowest lane (e.g. v8i8, v4i16).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:48,Avoid,Avoid,48,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,2,"['Avoid', 'safe']","['Avoid', 'safe']"
Safety,"// Use STOCOpcode if possible. We could use different store patterns in; // order to avoid matching the index register, but the performance trade-offs; // might be more complicated in that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:85,avoid,avoid,85,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Use SetVector to avoid duplicates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-extract/llvm-extract.cpp:20,avoid,avoid,20,interpreter/llvm-project/llvm/tools/llvm-extract/llvm-extract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-extract/llvm-extract.cpp,1,['avoid'],['avoid']
Safety,// Use WorkList to avoid stack overflow on excessively large IRs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:19,avoid,avoid,19,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avoid'],['avoid']
Safety,"// Use a CSINV to transform ""a == C ? 1 : -1"" to ""a == C ? a : -1"" to; // avoid materializing C.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:74,avoid,avoid,74,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// Use a ScoreboardHazardRecognizer for prepass ARM scheduling. TargetInstrImpl; // currently defaults to no prepass hazard recognizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:117,hazard,hazard,117,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['hazard'],['hazard']
Safety,// Use a VL of 1 to avoid processing more elements than we need.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:20,avoid,avoid,20,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['avoid'],['avoid']
Safety,// Use a X86 specific opcode to avoid DAG combine messing with it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Use a class-member buffer to avoid repeated heap allocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:32,avoid,avoid,32,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,2,['avoid'],['avoid']
Safety,// Use a mask to avoid undefined behavior.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:17,avoid,avoid,17,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,2,['avoid'],['avoid']
Safety,// Use a namespace to avoid conflicts because there's some fairly generic names; // in there (e.g. Matcher).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:22,avoid,avoid,22,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,1,['avoid'],['avoid']
Safety,// Use a set to avoid extra readfirstlanes in the case where multiple operands; // are the same register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:16,avoid,avoid,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['avoid'],['avoid']
Safety,// Use a set to avoid extra readfirstlanes in the case where multiple; // operands are the same register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp:16,avoid,avoid,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPURegisterBankInfo.cpp,1,['avoid'],['avoid']
Safety,// Use a splat constant if it is not safe to use undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:37,safe,safe,37,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['safe'],['safe']
Safety,"// Use a very simple parse step that dectect whether the name search (which; // is already supposed to be an unqualified name) is a simple identifier,; // a constructor name or a destructor name. In those 3 cases, we can easily; // create the UnqualifiedId object that would have resulted from the 'real'; // parse. By using this direct creation of the UnqualifiedId, we avoid the; // 'permanent' cost associated with creating a memory buffer and the; // associated FileID.; // If the name is a template or an operator, we revert to the regular parse; // (and its associated permanent cost).; // In the operator case, the additional work is in the case of a conversion; // operator where we would need to 'quickly' parse the type itself (if want; // to avoid the permanent cost).; // In the case with the template the problem gets a bit worse as we need to; // handle potentially arbitrary spaces and ordering; // ('const int' vs 'int const', etc.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:371,avoid,avoid,371,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,2,['avoid'],['avoid']
Safety,"// Use an array type for the alloca, to avoid potentially huge alignment; // requirements for large vector types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:40,avoid,avoid,40,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['avoid'],['avoid']
Safety,// Use an f64/i64 load and a scalar_to_vector for v2f32/v2i32 loads. This; // avoids scalarizing in 32-bit mode. In 64-bit mode this avoids a int->fp; // cast since type legalization will try to use an i64 load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:78,avoid,avoids,78,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avoid'],['avoids']
Safety,// Use an iterator to avoid repeated lookups.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:22,avoid,avoid,22,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['avoid'],['avoid']
Safety,// Use block handles instead of iterating over function blocks directly; // to avoid using iterators invalidated by erasing blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp:79,avoid,avoid,79,interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/FlattenCFGPass.cpp,1,['avoid'],['avoid']
Safety,// Use caching to avoid redundant md5 computation for build speed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp:18,avoid,avoid,18,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/PseudoProbePrinter.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// Use explicit storage to avoid accessing cl::opt in a signal handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Signals.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/Support/Signals.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Signals.cpp,1,['avoid'],['avoid']
Safety,"// Use gROOTLocal to avoid triggering undesired initialization of gROOT.; // For example in compiled C++ programs that don't use it directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx:21,avoid,avoid,21,core/base/src/TDirectory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx,1,['avoid'],['avoid']
Safety,// Use hazard variants of the jump register instructions for indirect; // function calls and jump tables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:7,hazard,hazard,7,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,1,['hazard'],['hazard']
Safety,// Use int64_t as a key to avoid needing special handling for map keys.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:27,avoid,avoid,27,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,// Use logical and to avoid propagating poison from later conditions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:22,avoid,avoid,22,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['avoid'],['avoid']
Safety,"// Use movw+movt when possible, it avoids constant pool entries.; // Non-darwin targets only support static movt relocations in FastISel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp:35,avoid,avoids,35,interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMFastISel.cpp,1,['avoid'],['avoids']
Safety,// Use operator[] before creating the thread to avoid data race in .size(); // in “safe libc++” mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Parallel.cpp:48,avoid,avoid,48,interpreter/llvm-project/llvm/lib/Support/Parallel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Parallel.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,// Use processor id to detect cpu name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp:23,detect,detect,23,interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TargetParser/Host.cpp,1,['detect'],['detect']
Safety,"// Use query 3 to avoid storing a void * in the root file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_sqlite.cxx:18,avoid,avoid,18,tree/dataframe/test/datasource_sqlite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/datasource_sqlite.cxx,1,['avoid'],['avoid']
Safety,// Use std::less to avoid UB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:20,avoid,avoid,20,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,2,['avoid'],['avoid']
Safety,"// Use the Module pointer as the key into the cache. This is a; // nullptr if the ""Module"" is a PCH, which is safe because we don't; // support chained PCH debug info, so there can only be a single PCH.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:110,safe,safe,110,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['safe'],['safe']
Safety,// Use the hack that clang uses to avoid SelectionDAG ruining v3 loads,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp:35,avoid,avoid,35,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULowerKernelArguments.cpp,1,['avoid'],['avoid']
Safety,// Use the noexcept variant with -fno-exceptions to avoid the extra overhead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp:52,avoid,avoid,52,interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Fuchsia.cpp,1,['avoid'],['avoid']
Safety,"// Use the precise location size specified by the 3rd argument; // for determining KillingI overwrites DeadLoc if it is a memset_chk; // instruction. memset_chk will write either the amount specified as 3rd; // argument or the function will immediately abort and exit the program.; // NOTE: AA may determine NoAlias if it can prove that the access size; // is larger than the allocation size due to that being UB. To avoid; // returning potentially invalid NoAlias results by AA, limit the use of; // the precise location size to isOverwrite.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:253,abort,abort,253,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,2,"['abort', 'avoid']","['abort', 'avoid']"
Safety,"// Use these flags to help us avoid creating redundant edges. If there; // are more than one edges from an outside node to inside nodes, we only; // keep one edge from that node to the pi-block node. Similarly, if; // there are more than one edges from inside nodes to an outside node,; // we only keep one edge from the pi-block node to the outside node.; // There is a flag defined for each direction (incoming vs outgoing) and; // for each type of edge supported, using a two-dimensional boolean; // array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp:30,avoid,avoid,30,interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DependenceGraphBuilder.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// Use these short names with rdf:: qualification to avoid conflicts with; // preexisting names. Do not use 'using namespace rdf'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h:53,avoid,avoid,53,interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RDFGraph.h,1,['avoid'],['avoid']
Safety,"// Use this syntax to avoid the redudant tests in substr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp:22,avoid,avoid,22,interpreter/cling/lib/Interpreter/LookupHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/LookupHelper.cpp,1,['avoid'],['avoid']
Safety,// Use this to diagnose that an unexpected Decl was encountered; // or no difference was detected. This causes a generic error; // message to be emitted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRDiagsEmitter.h:89,detect,detected,89,interpreter/llvm-project/clang/include/clang/AST/ODRDiagsEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ODRDiagsEmitter.h,1,['detect'],['detected']
Safety,// Use to avoid redundant warning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.h:10,avoid,avoid,10,interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profgen/ProfiledBinary.h,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// Use uaddo_carry if we can, otherwise use a compare to detect overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:57,detect,detect,57,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['detect'],['detect']
Safety,// Use zeros for the widening if we already have some zeroes. This can; // allow SimplifyDemandedBits to remove scalar ANDs that may be down; // stream of this.; // FIXME: It might make sense to detect a concat_vectors with a mix of; // zeroes and undef and turn it into insert_subvector for i1 vectors as; // a separate combine. What we can't do is canonicalize the operands of; // such a concat or we'll get into a loop with SimplifyDemandedBits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:195,detect,detect,195,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,// Used for SME ABI routines to avoid lazy saves,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/Utils/AArch64SMEAttributes.h,1,['avoid'],['avoid']
Safety,"// Used to avoid allocating long-term (BPAlloc'd) memory for default retain; // summaries. If a function or method looks like it has a default summary, but; // it has annotations, the annotations are added to the stack-based template; // and then copied into managed memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h:11,avoid,avoid,11,interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,1,['avoid'],['avoid']
Safety,// Used to avoid overload ambiguity on APInt constructor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/RecordSerialization.cpp:11,avoid,avoid,11,interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/RecordSerialization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/CodeView/RecordSerialization.cpp,1,['avoid'],['avoid']
Safety,// Used to avoid printing Mips1 warnings multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,avoid,avoid,11,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,1,['avoid'],['avoid']
Safety,// Used to avoid printing crc warnings multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,avoid,avoid,11,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,1,['avoid'],['avoid']
Safety,// Used to avoid printing dsp warnings multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,avoid,avoid,11,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,1,['avoid'],['avoid']
Safety,// Used to avoid printing ginv warnings multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,avoid,avoid,11,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,1,['avoid'],['avoid']
Safety,// Used to avoid printing msa warnings multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,avoid,avoid,11,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,1,['avoid'],['avoid']
Safety,// Used to avoid printing virt warnings multiple times.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h:11,avoid,avoid,11,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSubtarget.h,1,['avoid'],['avoid']
Safety,"// Used to keep track of which base types we have already seen, so; // that we can properly diagnose redundant direct base types. Note; // that the key is always the unqualified canonical type of the base; // class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:101,redund,redundant,101,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['redund'],['redundant']
Safety,"// Useless def, and we don't want to risk creating an invalid ORR (which; // would really write to sp).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp:37,risk,risk,37,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ExpandPseudoInsts.cpp,1,['risk'],['risk']
Safety,"// User gave overlapping ranges. This leads to double-counting events and integrals, and must; // therefore be avoided. If a NormRange has been given, the overlap is already gone.; // It's safe to plot even with overlap now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:111,avoid,avoided,111,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,2,"['avoid', 'safe']","['avoided', 'safe']"
Safety,"// Users in the OrigPreHeader need to use the value to which the; // original definitions are mapped and anything else can be handled by; // the SSAUpdater. To avoid adding PHINodes, check if the value is; // available in UserBB, if not substitute undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:160,avoid,avoid,160,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,2,['avoid'],['avoid']
Safety,// Users often add up multiple BlockFrequency values or multiply them with; // things like instruction costs. Leave some room to avoid saturating; // operations reaching UIN64_MAX too early.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp:129,avoid,avoid,129,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfoImpl.cpp,1,['avoid'],['avoid']
Safety,// Uses this way to avoid add an annotation attr to the AST.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/CallSuperAttribute/CallSuperAttrInfo.cpp:20,avoid,avoid,20,interpreter/llvm-project/clang/examples/CallSuperAttribute/CallSuperAttrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/examples/CallSuperAttribute/CallSuperAttrInfo.cpp,1,['avoid'],['avoid']
Safety,// Usially debug label intrinsic corresponds to label in LLVM IR. In these; // cases we should not move it here.; // TODO: Possible special processing needed to detect it is related to a; // hoisted instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:161,detect,detect,161,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,1,['detect'],['detect']
Safety,// Using .data() is safe because of how GlobalObject::setSection is; // implemented.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp:20,safe,safe,20,interpreter/llvm-project/llvm/lib/IR/Core.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Core.cpp,1,['safe'],['safe']
Safety,"// Using CINT to avoid a dependency in TParallelCoord",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx:17,avoid,avoid,17,tree/treeplayer/src/TSelectorDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorDraw.cxx,1,['avoid'],['avoid']
Safety,"// Using PyTorch User Defined predict function for predictions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx:30,predict,predict,30,tmva/pymva/src/MethodPyTorch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyTorch.cxx,2,['predict'],"['predict', 'predictions']"
Safety,// Using doubles to avoid overflow of ExecutionCounts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:20,avoid,avoid,20,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['avoid'],['avoid']
Safety,"// Using std::map to benefit from its iterator / reference non-invalidating; // semantics, which make it easy to use `getCachedFPI` results from multiple; // calls without needing to copy to avoid invalidation effects.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h:191,avoid,avoid,191,interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h,1,['avoid'],['avoid']
Safety,// Using temporaries to avoid messing up operand ordering for later; // transformations if this doesn't work.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:24,avoid,avoid,24,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// Usually the return expression is evaluated before the cleanup; // code. If the function contains only a simple return statement,; // such as a constant, the location before the cleanup code becomes; // the last useful breakpoint in the function, because the simple; // return expression will be evaluated after the cleanup code. To be; // safe, set the debug location for cleanup code to the location of; // the return statement. Otherwise the cleanup code should be at the; // end of the function's lexical scope.; //; // If there are multiple branches to the return block, the branch; // instructions will get the location of the return statements and; // all will be fine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:342,safe,safe,342,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['safe'],['safe']
Safety,"// Utility function to determine whether we should avoid selecting; // immediate forms of instructions for better code size or not.; // At a high level, we'd like to avoid such instructions when; // we have similar constants used within the same basic block; // that can be kept in a register.; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['avoid'],['avoid']
Safety,// VALU access to any SGPR or literal constant other than HazardReg; // mitigates hazard. No need to check HazardReg here as this will; // only be called when !IsHazardFn.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:58,Hazard,HazardReg,58,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,3,"['Hazard', 'hazard']","['HazardReg', 'hazard']"
Safety,"// VPDPBUSD(<16 x i32>C, <16 x i8>A, <16 x i8>B). For each dst element; // C[0] = C[0] + A[0]B[0] + A[1]B[1] + A[2]B[2] + A[3]B[3].; // The src A, B element type is i8, but the dst C element type is i32.; // When we calculate the reduce stage, we use src vector type vXi8 for it; // so we need logbias 2 to avoid extra 2 stages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:307,avoid,avoid,307,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// VPXOR is safe to use because it doesn't affect flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safe']
Safety,// VPXORY is safe to use because it doesn't affect flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['safe'],['safe']
Safety,// Validated by static_assert in APValue.cpp; hardcoded to avoid needing; // to include Type.h.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/APValue.h:59,avoid,avoid,59,interpreter/llvm-project/clang/include/clang/AST/APValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/APValue.h,1,['avoid'],['avoid']
Safety,// Value has no outstanding references it is safe to delete it now...,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:45,safe,safe,45,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp,1,['safe'],['safe']
Safety,// Value subclass ID: Pick largest possible value to avoid any clashes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:53,avoid,avoid,53,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['avoid'],['avoid']
Safety,"// VarIndex = Scale*V0 + (-Scale)*V1.; // If V0 != V1 then abs(VarIndex) >= abs(Scale).; // Check that MayBeCrossIteration is false, to avoid reasoning about; // inequality of values across loop iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:136,avoid,avoid,136,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['avoid'],['avoid']
Safety,"// Variables changed between a setjmp and a longjump can have undefined value; // after the longjmp. This behaviour can be observed if such a variable is; // spilled, so longjmp won't restore the value in the spill slot.; // RegisterCoalescer should not run in functions with a setjmp to avoid; // merging such undefined variables with predictable ones.; //; // TODO: Could specifically disable coalescing registers live across setjmp; // calls",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:288,avoid,avoid,288,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,2,"['avoid', 'predict']","['avoid', 'predictable']"
Safety,// Variables to help detecting enclosing problems in data environment nests.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp:21,detect,detecting,21,interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOpenMP.cpp,1,['detect'],['detecting']
Safety,"// Vector GEPs are partially broken (e.g. for overaligned element types),; // and may be forbidden in the future, so avoid generating GEPs into; // vectors. See https://discourse.llvm.org/t/67497",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp:117,avoid,avoid,117,interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DataLayout.cpp,1,['avoid'],['avoid']
Safety,// Verify offset using the real max displacement without the safety; // adjustment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp:61,safe,safety,61,interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMConstantIslandPass.cpp,1,['safe'],['safety']
Safety,// Verify that all actions are possible otherwise abort the whole transaction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:50,abort,abort,50,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,1,['abort'],['abort']
Safety,// Verify that it would be safe to try to add those two shift amounts.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:27,safe,safe,27,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,3,['safe'],['safe']
Safety,// Verify that the incoming and outgoing arguments from the callee are; // safe to tail call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp:75,safe,safe,75,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64CallLowering.cpp,2,['safe'],['safe']
Safety,"// Verify that there are no isolated flow components; // One could modify FlowFunction to hold edges indexed by the sources, which; // will avoid a creation of the object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:140,avoid,avoid,140,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,1,['avoid'],['avoid']
Safety,"// Verify that this GlobalValue is only used in this module.; // This map is used to avoid visiting uses twice. We can arrive at a user; // twice, if they have multiple operands. In particular for very large; // constant expressions, we can arrive at a particular user many times.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:85,avoid,avoid,85,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['avoid'],['avoid']
Safety,"// Virtual functions might still be referenced by one or more vtables,; // but if we've proven them to be unused then it's safe to replace the; // virtual function pointers with null, allowing us to remove the; // function itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:123,safe,safe,123,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,1,['safe'],['safe']
Safety,// Virtual register uses are always safe to sink.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:36,safe,safe,36,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['safe'],['safe']
Safety,"// Visit BBs from header to current BB, if hoisting this doesn't cause; // high register pressure, then it's safe to proceed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:109,safe,safe,109,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['safe'],['safe']
Safety,"// Visit blocks in dominator tree post-order. The post-order enables nested; // if-conversion in a single pass. The tryConvertIf() function may erase; // blocks, but only blocks dominated by the head block. This makes it safe to; // update the dominator tree while the post-order iterator is still active.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:221,safe,safe,221,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,2,['safe'],['safe']
Safety,// Visited is used to avoid running into an infinite loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp:22,avoid,avoid,22,interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopNestAnalysis.cpp,1,['avoid'],['avoid']
Safety,"// Visualization of Load-Op-Store fusion:; // -------------------------; // Legend:; // *-lines = Chain operand dependencies.; // |-lines = Normal operand dependencies.; // Dependencies flow down and right. n-suffix references multiple nodes.; //; // C Xn C; // * * *; // * * *; // Xn A-LD Yn TF Yn; // * * \ | * |; // * * \ | * |; // * * \ | => A--LD_OP_ST; // * * \| \; // TF OP \; // * | \ Zn; // * | \; // A-ST Zn; //; // This merge induced dependences from: #1: Xn -> LD, OP, Zn; // #2: Yn -> LD; // #3: ST -> Zn; // Ensure the transform is safe by checking for the dual; // dependencies to make sure we do not induce a loop.; // As LD is a predecessor to both OP and ST we can do this by checking:; // a). if LD is a predecessor to a member of Xn or Yn.; // b). if a Zn is a predecessor to ST.; // However, (b) can only occur through being a chain predecessor to; // ST, which is the same as Zn being a member or predecessor of Xn,; // which is a subset of LD being a predecessor of Xn. So it's; // subsumed by check (a).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:546,safe,safe,546,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,"// Void and FP expressions cannot be reduced.; // IVUsers is used by LSR which assumes that all SCEV expressions are safe to; // pass to SCEVExpander. Expressions are not safe to expand if they represent; // operations that are not safe to speculate, namely integer division.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp:117,safe,safe,117,interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVUsers.cpp,3,['safe'],['safe']
Safety,"// WARNING to developers: people use RooFormula a lot via RooGenericPdf and; // RooFormulaVar! Performance matters here. Avoid non-static std::regex,; // because constructing these can become a bottleneck because of the regex; // compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFormula.cxx:121,Avoid,Avoid,121,roofit/roofitcore/src/RooFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFormula.cxx,1,['Avoid'],['Avoid']
Safety,"// WVE --- This needs to be public to avoid CINT problems",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h:38,avoid,avoid,38,roofit/roofitcore/inc/RooAbsData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h,1,['avoid'],['avoid']
Safety,// Walk all basic blocks reachable in depth-first iteration on the inverse; // CFG from OldBB to NewBB. These blocks are all the blocks that may be; // executed between the execution of NewBB and OldBB. Hoisting an expression; // from OldBB into NewBB has to be safe on all execution paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:262,safe,safe,262,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['safe'],['safe']
Safety,// Walk all basic blocks reachable in depth-first iteration on; // the inverse CFG from BBInsn to NewHoistPt. These blocks are all the; // blocks that may be executed between the execution of NewHoistPt and; // BBInsn. Hoisting an expression from BBInsn into NewHoistPt has to be safe; // on all execution paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:280,safe,safe,280,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['safe'],['safe']
Safety,// Walk all the CHI-nodes to find ones which have a empty-entry and remove; // them Then collect all the instructions which are safe to hoist and see if; // they form a list of anticipable values. OutValues contains CHIs; // corresponding to each basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:128,safe,safe,128,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,1,['safe'],['safe']
Safety,// Walk back through any unconditional executed blocks and see if we can find; // a widenable condition which seems to control execution of this loop. Note; // that we predict that maythrow calls are likely untaken and thus that it's; // profitable to widen a branch before a maythrow call with a condition; // afterwards even though that may cause the slow path to run in a case where; // it wouldn't have otherwise.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:168,predict,predict,168,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['predict'],['predict']
Safety,"// Walk back through the IR for a pointer, looking for a select like the; // following:; //; // %offset = select i1 %cmp, i64 %a, i64 %b; // %addr = getelementptr double, double* %base, i64 %offset; // %ld = load double, double* %addr, align 8; //; // We won't be able to form a single SCEVAddRecExpr from this since the; // address for each loop iteration depends on %cmp. We could potentially; // produce multiple valid SCEVAddRecExprs, though, and check all of them for; // memory safety/aliasing if needed.; //; // If we encounter some IR we don't yet handle, or something obviously fine; // like a constant, then we just add the SCEV for that term to the list passed; // in by the caller. If we have a node that may potentially yield a valid; // SCEVAddRecExpr then we decompose it into parts and build the SCEV terms; // ourselves before adding to the list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:484,safe,safety,484,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['safe'],['safety']
Safety,// Walk clauses and process safelen/lastprivate.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:28,safe,safelen,28,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['safe'],['safelen']
Safety,"// Walk the DeclTypeInfo, building the recursive type as we go.; // DeclTypeInfos are ordered from the identifier out, which is; // opposite of what we want :).; // Track if the produced type matches the structure of the declarator.; // This is used later to decide if we can fill `TypeLoc` from; // `DeclaratorChunk`s. E.g. it must be false if Clang recovers from; // an error by replacing the type with `int`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp:351,recover,recovers,351,interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaType.cpp,1,['recover'],['recovers']
Safety,"// Walk the block backwards for efficiency. We're matching a chain of; // use->defs, so we're more likely to succeed by starting from the bottom.; // Also, we want to avoid matching partial patterns.; // TODO: It would be more efficient if we removed dead instructions; // iteratively in this loop rather than waiting until the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:167,avoid,avoid,167,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['avoid'],['avoid']
Safety,// Walk the inner SCCs to update their up-pointer and walk all the edges to; // update any parent sets.; // FIXME: We should try to find a way to avoid this (rather expensive) edge; // walk by updating the parent sets in some other manner.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp:146,avoid,avoid,146,interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyCallGraph.cpp,1,['avoid'],['avoid']
Safety,"// Walk through a subset of the changes, starting at StartAt, and find; // sequences of matching tokens to align. To do so, keep track of the lines and; // whether or not a matching token was found on a line. If a matching token is; // found, extend the current sequence. If the current line cannot be part of a; // sequence, e.g. because there is an empty line before it or it contains only; // non-matching tokens, finalize the previous sequence.; // The value returned is the token on which we stopped, either because we; // exhausted all items inside Changes, or because we hit a scope level higher; // than our initial scope.; // This function is recursive. Each invocation processes only the scope level; // equal to the initial level, which is the level of Changes[StartAt].; // If we encounter a scope level greater than the initial level, then we call; // ourselves recursively, thereby avoiding the pollution of the current state; // with the alignment requirements of the nested sub-level. This recursive; // behavior is necessary for aligning function prototypes that have one or more; // arguments.; // If this function encounters a scope level less than the initial level,; // it returns the current position.; // There is a non-obvious subtlety in the recursive behavior: Even though we; // defer processing of nested levels to recursive invocations of this; // function, when it comes time to align a sequence of tokens, we run the; // alignment on the entire sequence, including the nested levels.; // When doing so, most of the nested tokens are skipped, because their; // alignment was already handled by the recursive invocations of this function.; // However, the special exception is that we do NOT skip function parameters; // that are split across multiple lines. See the test case in FormatTest.cpp; // that mentions ""split function parameter alignment"" for an example of this.; // When the parameter RightJustify is true, the operator will be; // right-justified. It is used ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp:896,avoid,avoiding,896,interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/WhitespaceManager.cpp,1,['avoid'],['avoiding']
Safety,"// Walk through all uses in FC1. For each use, find the reaching def. If the; // def is located in FC0 then it is not safe to fuse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:118,safe,safe,118,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['safe'],['safe']
Safety,// Walk through the instructions in MBB and remove any redundant; // instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp:55,redund,redundant,55,interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLateInstrsCleanup.cpp,1,['redund'],['redundant']
Safety,"// Warn about arg1 || arg2 && arg3, as GCC 4.3+ does.; // We don't warn for 'assert(a || b && ""bad"")' since this is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:116,safe,safe,116,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['safe'],['safe']
Safety,"// Warn about externally-visible variables being defined without a; // prior declaration. We only want to do this for global; // declarations, but we also specifically need to avoid doing it for; // class members because the linkage of an anonymous class can; // change if it's later given a typedef name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:176,avoid,avoid,176,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoid']
Safety,// Warn about non-default alignment at #includes (without redundant; // warnings for the same directive in nested includes).; // The warning is delayed until the end of the file to avoid warnings; // for files that don't have any records that are affected by the modified; // alignment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp:58,redund,redundant,58,interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaAttr.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// Warn if we deduced 'id'. 'auto' usually implies type-safety, but using; // 'id' instead of a specific object type prevents most of our usual; // checks.; // We only want to warn outside of template instantiations, though:; // inside a template, the 'id' could have come from a parameter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:56,safe,safety,56,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['safe'],['safety']
Safety,// Warn only about known move-unsafe classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp:30,unsafe,unsafe,30,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MoveChecker.cpp,1,['unsafe'],['unsafe']
Safety,// Warning gadget for unsafe invocation of span::data method.; // Triggers when the pointer returned by the invocation is immediately; // cast to a larger type.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:22,unsafe,unsafe,22,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['unsafe'],['unsafe']
Safety,"// Warning if the dataset is binned. TODO: in some cases,; // people also use RooDataSet to encode binned data,; // e.g. for simultaneous fits. It would be useful to detect; // this in this future as well.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:166,detect,detect,166,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,1,['detect'],['detect']
Safety,// We add this transition in checkPostObjCMessage to avoid warning when; // we inline a call to [super dealloc] where the inlined call itself; // calls [super dealloc].,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp:53,avoid,avoid,53,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSuperDeallocChecker.cpp,1,['avoid'],['avoid']
Safety,"// We allow traversing cyclic Phi nodes.; // In case of success after this loop we ensure that traversing through; // Phi nodes ends up with all cases to compute address of the form; // BaseGV + Base + Scale * Index + Offset; // where Scale and Offset are constans and BaseGV, Base and Index; // are exactly the same Values in all cases.; // It means that BaseGV, Scale and Offset dominate our memory instruction; // and have the same value as they had in address computation represented; // as Phi. So we can safely sink address computation to memory instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:510,safe,safely,510,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['safe'],['safely']
Safety,"// We allow undefs in matching, but this transform removes those for safety.; // Demanded elements analysis should be able to recover some/all of that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:69,safe,safety,69,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,2,"['recover', 'safe']","['recover', 'safety']"
Safety,"// We already printed an error, and it's likely impossible to recover,; // so don't try to parse this method later.; // Skip over the rest of the decl and back to somewhere that looks; // reasonable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp:62,recover,recover,62,interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseCXXInlineMethods.cpp,1,['recover'],['recover']
Safety,"// We also generate each intrinsic under a name like __arm_vfooq; // (which is in C language implementation namespace, so it's; // safe to define in any conforming user program) and a shorter; // one like vfooq (which is in user namespace, so a user might; // reasonably have used it for something already). If so, they; // can #define __ARM_MVE_PRESERVE_USER_NAMESPACE before; // including the header, which will suppress the shorter names; // and leave only the implementation-namespace ones. Then they; // have to write __arm_vfooq everywhere, of course.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp:131,safe,safe,131,interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/MveEmitter.cpp,1,['safe'],['safe']
Safety,// We also handle the reversed case because this utility may get called; // when we detect a SHUFPS pattern but can't easily commute the shuffle to; // arrange things in the right direction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:84,detect,detect,84,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,// We also need to make sure it is safe to move the load.; // Assume there are stores between DefMI and UseMI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp:35,safe,safe,35,interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveRangeEdit.cpp,1,['safe'],['safe']
Safety,"// We also want to detect dead uses of arguments, but will only store; // demanded bits for instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp:19,detect,detect,19,interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/DemandedBits.cpp,1,['detect'],['detect']
Safety,"// We also want to do this peephole for cases like this: if (a*b == 0),; // and optimise away the CMP instruction from the generated code sequence:; // MULS, MOVS, MOVS, CMP. Here the MOVS instructions load the boolean values; // resulting from the select instruction, but these MOVS instructions for; // Thumb1 (V6M) are flag setting and are thus preventing this optimisation.; // However, if we only have MOVS instructions in between the CMP and the; // other instruction (the MULS in this example), then the CPSR is dead so we; // can safely reorder the sequence into: MOVS, MOVS, MULS, CMP. We do this; // reordering and then continue the analysis hoping we can eliminate the; // CMP. This peephole works on the vregs, so is still in SSA form. As a; // consequence, the movs won't redefine/kill the MUL operands which would; // make this reordering illegal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:538,safe,safely,538,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['safe'],['safely']
Safety,"// We always use a qualname symbol for a GV that represents; // a declaration, a function descriptor, or a common symbol.; // If a GV represents a GlobalVariable and -fdata-sections is enabled, we; // also return a qualname so that a label symbol could be avoided.; // It is inherently ambiguous when the GO represents the address of a; // function, as the GO could either represent a function descriptor or a; // function entry point. We choose to always return a function descriptor; // here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp:256,avoid,avoided,256,interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetLoweringObjectFileImpl.cpp,1,['avoid'],['avoided']
Safety,"// We are already above the hoist point. Stop here. This may be necessary; // when multiple scopes would independently hoist the same; // instruction. Since an outer (dominating) scope would hoist it to its; // entry before an inner (dominated) scope would to its entry, the inner; // scope may see the instruction already hoisted, in which case it; // potentially wrong for the inner scope to hoist it and could cause bad; // IR (non-dominating def), but safe to skip hoisting it instead because; // it's already in a block that dominates the inner scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:456,safe,safe,456,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,1,['safe'],['safe']
Safety,"// We are at the top of this chain.; // If the copy has a glue operand, we conservatively assume it; // isn't safe to perform a tail call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:110,safe,safe,110,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['safe'],['safe']
Safety,"// We are avoiding substitution in the case of; // ....;c:.... and of ...;root:/... where root can be any url protocol",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:10,avoid,avoiding,10,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['avoid'],['avoiding']
Safety,"// We are conservative and even though intrinsics are unlikely to touch; // reference counts, we white list them for safety.; //; // TODO: Expand this into a covered switch. There is a lot more here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:117,safe,safety,117,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,1,['safe'],['safety']
Safety,// We are constructing the OptimizationRemarkEmitter on the fly rather than; // using the analysis pass to avoid building DominatorTree and LoopInfo which; // are not available this late in the IR pipeline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp:107,avoid,avoid,107,interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackProtector.cpp,1,['avoid'],['avoid']
Safety,"// We are copying an unprimed accumulator to a primed accumulator.; // If the input to the copy is a PHI that is fed only by (i) copies in; // the other direction (ii) implicitly defined unprimed accumulators or; // (iii) other PHI nodes satisfying (i) and (ii), we can change; // the PHI to a PHI on primed accumulators (as long as we also change; // its operands). To detect and change such copies, we first get a list; // of all the PHI nodes starting from the root PHI node in BFS order.; // We then visit all these PHI nodes to check if they can be changed to; // primed accumulator PHI nodes and if so, we change them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:370,detect,detect,370,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['detect'],['detect']
Safety,"// We are creating a vector extend. If the original vector extend has another; // use, that would mean we end up with 2 vector extends, so avoid that.; // TODO: We could ease the use-clause to ""if at least one op has one use""; // (assuming that the source types match - see next TODO comment).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:139,avoid,avoid,139,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,1,['avoid'],['avoid']
Safety,"// We are going to try to rewrite this load to a larger zero-extending; // load. This is safe if all portions of the 32 bit super-register; // of the original destination register, except for the original destination; // register are dead. getSuperRegDestIfDead checks that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:89,safe,safe,89,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['safe'],['safe']
Safety,"// We are in LCSSA form. So, a value defined inside the Loop is used only; // inside the loop. So, the following is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp:116,safe,safe,116,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorLoopCarriedReuse.cpp,1,['safe'],['safe']
Safety,// We are looking for a shift of truncate. Truncate from i64 to i32 could; // be considered as setting high 32 bits as zero. Our strategy here is to; // always generate 64bit UBFM. This consistency will help the CSE pass; // later find more redundancy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp:241,redund,redundancy,241,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelDAGToDAG.cpp,1,['redund'],['redundancy']
Safety,"// We are looking up for something on the TU scope.; // FIXME: We do not want to go through TClingClassInfo(fInterpreter) because of redundant deserializations. That; // interface will actually construct iterators and walk over the decls on the global scope. In would return the first; // occurrence of a decl with the looked up name. However, that's not what C++ lookup would do: if we want to switch; // to a more complete C++ lookup interface we need sift through the found names and pick up the declarations which; // are only fulfilling ROOT's understanding for a Data Member.; // FIXME: We should probably deprecate the TClingClassInfo(fInterpreter) interface and replace it withe something; // similar as below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:133,redund,redundant,133,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['redund'],['redundant']
Safety,"// We are not in recursive loading, so it's safe to pass the ""interesting""; // decls to the consumer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:44,safe,safe,44,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['safe'],['safe']
Safety,"// We are on the top frame of the analysis. We do not know where is the; // object returned to. Conjure a symbolic region for the return value.; // TODO: We probably need a new MemRegion kind to represent the storage; // of that SymbolicRegion, so that we cound produce a fancy symbol; // instead of an anonymous conjured symbol.; // TODO: Do we need to track the region to avoid having it dead; // too early? It does die too early, at least in C++17, but because; // putting anything into a SymbolicRegion causes an immediate escape,; // it doesn't cause any leak false positives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:374,avoid,avoid,374,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,1,['avoid'],['avoid']
Safety,"// We are shutting down, there is no point in reloading, it only triggers; // redundant deserializations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:78,redund,redundant,78,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['redund'],['redundant']
Safety,// We are sorting on MDNode pointers here. For valid input IR this is ok.; // TODO: Sort on Metadata ID to avoid non-deterministic error messages.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:107,avoid,avoid,107,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['avoid'],['avoid']
Safety,"// We are storing the pointer into a memory location, potentially escaping.; // As an optimization, we try to detect simple cases where it doesn't; // actually escape, for example:; // %ptr = alloca ..; // %addr = alloca ..; // store %ptr, %addr; // %x = load %addr; // ..; // If %addr is only used by loading from it, we could simply treat %x as; // another alias of %ptr, and not considering %ptr being escaped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:110,detect,detect,110,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['detect'],['detect']
Safety,"// We are sure it's safe to pipe it through the transformers; // Consume late transformers init",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclCollector.cpp:20,safe,safe,20,interpreter/cling/lib/Interpreter/DeclCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclCollector.cpp,1,['safe'],['safe']
Safety,// We are trying to parse a simple-type-specifier but might not get such; // a token after error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:97,recover,recovery,97,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['recover'],['recovery']
Safety,"// We are unable to predict the size of debug data, so we request to write 0; // bytes. This should always return us an output stream unless CBA is already; // in an error state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp:20,predict,predict,20,interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/ELFEmitter.cpp,1,['predict'],['predict']
Safety,"// We are using the following formula for BC(It, K):; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / K!; //; // Suppose, W is the bitwidth of the return value. We must be prepared for; // overflow. Hence, we must assure that the result of our computation is; // equal to the accurate one modulo 2^W. Unfortunately, division isn't; // safe in modular arithmetic.; //; // However, this code doesn't use exactly that formula; the formula it uses; // is something like the following, where T is the number of factors of 2 in; // K! (i.e. trailing zeros in the binary representation of K!), and ^ is; // exponentiation:; //; // BC(It, K) = (It * (It - 1) * ... * (It - K + 1)) / 2^T / (K! / 2^T); //; // This formula is trivially equivalent to the previous formula. However,; // this formula can be implemented much more efficiently. The trick is that; // K! / 2^T is odd, and exact division by an odd number *is* safe in modular; // arithmetic. To do exact division in modular arithmetic, all we have; // to do is multiply by the inverse. Therefore, this step can be done at; // width W.; //; // The next issue is how to safely do the division by 2^T. The way this; // is done is by doing the multiplication step at a width of at least W + T; // bits. This way, the bottom W+T bits of the product are accurate. Then,; // when we perform the division by 2^T (which is equivalent to a right shift; // by T), the bottom W bits are accurate. Extra bits are okay; they'll get; // truncated out after the division by 2^T.; //; // In comparison to just directly using the first formula, this technique; // is much more efficient; using the first formula requires W * K bits,; // but this formula less than W + K bits. Also, the first formula requires; // a division step, whereas this formula only requires multiplies and shifts.; //; // It doesn't matter whether the subtraction step is done in the calculation; // width or the input iteration count's width; if the subtraction overflows,; // the res",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:345,safe,safe,345,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['safe'],['safe']
Safety,"// We assume that all pointers passed to deopt are base pointers; as an; // optimization, we can use this to avoid seperately materializing the base; // pointer graph. This is only relevant since we're very conservative about; // generating new conflict nodes during base pointer insertion. If we were; // smarter there, this would be irrelevant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:109,avoid,avoid,109,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['avoid'],['avoid']
Safety,"// We assume that objects with a constant base (e.g. a global) can't move; // and don't need to be reported to the collector because they are always; // live. Besides global references, all kinds of constants (e.g. undef,; // constant expressions, null pointers) can be introduced by the inliner or; // the optimizer, especially on dynamically dead paths.; // Here we treat all of them as having single null base. By doing this we; // trying to avoid problems reporting various conflicts in a form of; // ""phi (const1, const2)"" or ""phi (const, regular gc ptr)"".; // See constant.ll file for relevant test cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:445,avoid,avoid,445,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['avoid'],['avoid']
Safety,"// We assume the input buffers are valid for the lifetime of the interpreter.; // By default, tflite allocates memory in an arena and will periodically take; // away memory and reallocate it in a different location after evaluations in; // order to improve utilization of the buffers owned in the arena. So, we; // explicitly mark our input buffers as persistent to avoid this behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp:366,avoid,avoid,366,interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TFLiteUtils.cpp,1,['avoid'],['avoid']
Safety,"// We assume this is supposed to correspond to a C++0x-style; // sequentially-consistent fence (i.e. this is only usable for; // synchronization, not device I/O or anything like that). This intrinsic; // is really badly designed in the sense that in theory, there isn't; // any way to safely use it... but in practice, it mostly works; // to use it with non-atomic loads and stores to get acquire/release; // semantics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:285,safe,safely,285,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['safe'],['safely']
Safety,"// We avoid calling Type::isBlockPointerType(), since it operates on the; // canonical type. We only care if the top-level type is a closure pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp:6,avoid,avoid,6,interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/Rewrite/RewriteModernObjC.cpp,2,['avoid'],['avoid']
Safety,// We avoid copy constructors by not using accessors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h:6,avoid,avoid,6,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h,1,['avoid'],['avoid']
Safety,// We avoid creating host action in device-only mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:6,avoid,avoid,6,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['avoid'],['avoid']
Safety,"// We avoid doing analysis-based warnings when there are errors for; // two reasons:; // (1) The CFGs often can't be constructed (if the body is invalid), so; // don't bother trying.; // (2) The code already has problems; running the analysis just takes more; // time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:6,avoid,avoid,6,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['avoid'],['avoid']
Safety,"// We avoid getLocForEndOfToken here, because it doesn't do what we want for; // macro locations, which we just treat as expanded files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp:6,avoid,avoid,6,interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,1,['avoid'],['avoid']
Safety,// We avoid subtracting expressions here because this function is usually; // fairly deep in the call stack (i.e. is called many times).; // X - X = 0.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:6,avoid,avoid,6,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,// We bypass intrinsic calls for the following two reasons:; // 1) We want to avoid a non-deterministic assignment of; // discriminators.; // 2) We want to minimize the number of base discriminators used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:78,avoid,avoid,78,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,1,['avoid'],['avoid']
Safety,// We cache a non-const iterator so we're forced to resort to const_cast to; // get the begin/end in the case where 'this' is const. To avoid duplication; // of code with the only difference being whether the const cast is present; // 'this' is always const in this particular function and we sort out the; // difference in FindLowerBound and FindLowerBoundConst.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h:136,avoid,avoid,136,interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SparseBitVector.h,1,['avoid'],['avoid']
Safety,"// We cached PHINodes in PHIs. To avoid accessing deleted PHINodes later,; // do not delete PHINodes here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:34,avoid,avoid,34,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"// We call takeVector() here to avoid use-after-free.; // FIXME: DeferredEmptyCoverageMappingDecls is getting mutated because; // we deserialize function bodies to emit coverage info for them, and that; // deserializes more declarations. How should we handle that case?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp:32,avoid,avoid,32,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.cpp,1,['avoid'],['avoid']
Safety,// We can actually predict the result of comparisons between an; // alloca-derived value and null. Note that this fires regardless of; // SROA firing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:19,predict,predict,19,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['predict'],['predict']
Safety,"// We can assume that ptr is aligned at least to char2's alignment, but the; // load will assume that ptr is aligned to char2's alignment. This is only; // safe if alignof(c2) <= alignof(char2).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h:156,safe,safe,156,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_intrinsics.h,1,['safe'],['safe']
Safety,// We can avoid incrementing the generation count since we were able; // to eliminate this store.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:10,avoid,avoid,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['avoid'],['avoid']
Safety,// We can fold chains of FADD's of the same value into multiplications.; // This transform is not safe in general because we are reducing the number; // of rounding steps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:98,safe,safe,98,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,"// We can generate (solve) LVI values only for blocks that are dominated by; // the I's parent. However, to avoid generating LVI for all dominating blocks,; // that contain redundant/uninteresting information, we print LVI for; // blocks that may use this LVI information (such as immediate successor; // blocks, and blocks that contain uses of `I`).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:108,avoid,avoid,108,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// We can get a value-dependent initializer during error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:57,recover,recovery,57,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['recover'],['recovery']
Safety,// We can handle an insert into the last element (of a splat) via; // v(f)slide1down. This is slightly better than the vslideup insert; // lowering as it avoids the need for a vector group temporary. It; // is also better than using vmerge.vx as it avoids the need to; // materialize the mask in a vector register.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:154,avoid,avoids,154,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['avoid'],['avoids']
Safety,"// We can handle cases concerning bit-widening nodes containing setcc_c if; // we carefully interrogate the mask to make sure we are semantics; // preserving.; // The transform is not safe if the result of C1 << C2 exceeds the bitwidth; // of the underlying setcc_c operation if the setcc_c was zero extended.; // Consider the following example:; // zext(setcc_c) -> i32 0x0000FFFF; // c1 -> i32 0x0000FFFF; // c2 -> i32 0x00000001; // (shl (and (setcc_c), c1), c2) -> i32 0x0001FFFE; // (and setcc_c, (c1 << c2)) -> i32 0x0000FFFE",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:184,safe,safe,184,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['safe'],['safe']
Safety,// We can move insertion point only if there is no div or rem operations; // otherwise we are risky to move it over the check for zero denominator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:94,risk,risky,94,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['risk'],['risky']
Safety,// We can now safely identify the truncated version of the IV and limit for; // RangeCheckType.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:14,safe,safely,14,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['safe'],['safely']
Safety,// We can only avoid copying elements if neither set is small.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp:15,avoid,avoid,15,interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/SmallPtrSet.cpp,1,['avoid'],['avoid']
Safety,// We can only avoid copying elements if neither vector is small.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:15,avoid,avoid,15,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['avoid'],['avoid']
Safety,"// We can only avoid copying elements if neither vector is small.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:15,avoid,avoid,15,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['avoid'],['avoid']
Safety,"// We can only lose information if we are casting smaller signed type to; // bigger unsigned type. For e.g.,; // LHS (unsigned short): [2, USHRT_MAX]; // RHS (signed short): [SHRT_MIN, 0]; //; // Casting RHS to LHS type will leave us with overlapping values; // CastedRHS : [0, 0] U [SHRT_MAX + 1, USHRT_MAX]; //; // We can avoid this by checking if signed type's maximum value is lesser; // than unsigned type's minimum value.; // If both have different signs then only we can get more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp:324,avoid,avoid,324,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RangeConstraintManager.cpp,1,['avoid'],['avoid']
Safety,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:187,safe,safe,187,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['safe'],['safe']
Safety,// We can only remove pointers if we are known safe in both directions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:47,safe,safe,47,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['safe'],['safe']
Safety,// We can only transform this if it is safe to push the loads into the; // predecessor blocks. The only thing to watch out for is that we can't put; // a possibly trapping load in the predecessor if it is a critical edge.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:39,safe,safe,39,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['safe'],['safe']
Safety,"// We can pick any of the set names for the merged set. Go for the; // shortest one to avoid picking the name of one of the classes that are; // artificially created by tablegen. So ""FPR128_lo"" instead of; // ""QQQQ_with_qsub3_in_FPR128_lo"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp:87,avoid,avoid,87,interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenRegisters.cpp,1,['avoid'],['avoid']
Safety,"// We can safely assume that if the lock exist already when we are in Cling code,; // then the lock has (or should been taken) already. Any action (that caused callers; // to take the lock) is halted during ProcessLine. So it is fair to unlock it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:10,safe,safely,10,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['safe'],['safely']
Safety,"// We can safely assume the conversion won't overflow the output range,; // because (for example) (uint8_t)18293.f is undefined behavior.; // Since we can assume the conversion won't overflow, our decision as to; // whether the input will fit in the float should depend on the minimum; // of the input range and output range.; // This means this is also safe for a signed input and unsigned output, since; // a negative input would lead to undefined behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,safe,safely,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['safe'],"['safe', 'safely']"
Safety,"// We can safely preserve the nuw flag in all cases. It's also safe to turn a; // nuw nsw shl into a nuw nsw mul. However, nsw in isolation requires special; // handling. It can be preserved as long as we're not left shifting by; // bitwidth - 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:10,safe,safely,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,['safe'],"['safe', 'safely']"
Safety,"// We can safely preserve the nuw flag in all cases. It's also safe to; // turn a nuw nsw shl into a nuw nsw mul. However, nsw in isolation; // requires special handling. It can be preserved as long as we're not; // left shifting by bitwidth - 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,safe,safely,10,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,2,['safe'],"['safe', 'safely']"
Safety,"// We can safely replace *some* uses of the CondInst if it has; // exactly one value as returned by LVI. RAUW is incorrect in the; // presence of guards and assumes, that have the `Cond` as the use. This; // is because we use the guards/assume to reason about the `Cond` value; // at the end of block, but RAUW unconditionally replaces all uses; // including the guards/assumes themselves and the uses before the; // guard/assume.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:10,safe,safely,10,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,2,['safe'],['safely']
Safety,// We can safely skip PS inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:10,safe,safely,10,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['safe'],['safely']
Safety,"// We can safely tail call both fastcc and ccc callees from a c calling; // convention caller. If the caller is fastcc, we may have less stack space; // than a non-fastcc caller with the same signature so disable tail-calls in; // that case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:10,safe,safely,10,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['safe'],['safely']
Safety,// We can safely transfer the NSW flag as NSSW.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:10,safe,safely,10,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['safe'],['safely']
Safety,// We can safely use the byte offset FixItStart as the column offset; // because the characters up until FixItStart are all ASCII whitespace; // characters.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp:10,safe,safely,10,interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/TextDiagnostic.cpp,1,['safe'],['safely']
Safety,// We can safely vectorize loops where instructions within the loop are; // used outside the loop only if the SCEV predicates within the loop is; // same as outside the loop. Allowing the exit means reusing the SCEV; // outside the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:10,safe,safely,10,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['safe'],['safely']
Safety,"// We can use an unpack to do the blending rather than an or in some; // cases. Even though the or may be (very minorly) more efficient, we; // preference this lowering because there are common cases where part of; // the complexity of the shuffles goes away when we do the final blend as; // an unpack.; // FIXME: It might be worth trying to detect if the unpack-feeding; // shuffles will both be pshufb, in which case we shouldn't bother with; // this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:343,detect,detect,343,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,// We can't create address space casts here because we don't know if they're; // safe for the target.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:81,safe,safe,81,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['safe'],['safe']
Safety,"// We can't do PRE safely on a critical edge, so instead we schedule; // the edge to be split and perform the PRE the next time we iterate; // on the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:19,safe,safely,19,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['safe'],['safely']
Safety,// We can't extendRegion here or we risk overlapping with our new region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp:36,risk,risk,36,interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CoverageMappingGen.cpp,1,['risk'],['risk']
Safety,// We can't read the code to detect the language if there's no file name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp:29,detect,detect,29,interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-format/ClangFormat.cpp,1,['detect'],['detect']
Safety,// We can't recover from it being declared as a typedef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,recover,recover,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recover']
Safety,// We can't recover from this; the declaration might have already; // been used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:12,recover,recover,12,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['recover'],['recover']
Safety,// We can't recover unless there's a dependent scope specifier preceding the; // template name.; // FIXME: Typo correction?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:12,recover,recover,12,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Safety,"// We can't safely determine the primary context yet, so delay attaching the; // lookup table until we're done with recursive deserialization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:12,safe,safely,12,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['safe'],['safely']
Safety,// We can't safely propagate a vector zero constant with poison/undef lanes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:12,safe,safely,12,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,1,['safe'],['safely']
Safety,// We can't safely split arithmetic or shift operations into multiple; // fragments because we can't express carry-over between fragments.; //; // FIXME: We *could* preserve the lowest fragment of a constant offset; // operation if the offset fits into SizeInBits.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp:12,safe,safely,12,interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfoMetadata.cpp,1,['safe'],['safely']
Safety,"// We can't set the tail flag yet, because we haven't yet determined; // whether there are any escaping allocas. Remember this call, so that; // we can set the tail flag once we know it's safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:188,safe,safe,188,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['safe'],['safe']
Safety,"// We can't simply save the live set from the original insertion. One of; // the live values might be the result of a call which needs a safepoint.; // That Value* no longer exists and we need to use the new gc_result.; // Thankfully, the live set is embedded in the statepoint (and updated), so; // we just grab that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:137,safe,safepoint,137,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safepoint']
Safety,"// We can't use S_MOV_B32 directly, because there is no way to specify m0 as; // the destination register.; //; // We can't use CopyToReg, because MachineCSE won't combine COPY instructions,; // so we will end up with redundant moves to m0.; //; // We use a pseudo to ensure we emit s_mov_b32 with m0 as the direct result.; // A Null SDValue creates a glue result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:218,redund,redundant,218,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['redund'],['redundant']
Safety,"// We can't use `CK_IntegralCast` when the underlying type is 'bool', so we; // promote the boolean type, and all other promotable integer types, to; // avoid this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:153,avoid,avoid,153,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,"// We cannot RAUW or delete CS.getInstruction() because it could be in the; // live set of some other safepoint, in which case that safepoint's; // PartiallyConstructedSafepointRecord will hold a raw pointer to this; // llvm::Instruction. Instead, we defer the replacement and deletion to; // after the live sets have been made explicit in the IR, and we no longer; // have raw pointers to worry about.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:102,safe,safepoint,102,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,2,['safe'],['safepoint']
Safety,// We cannot backward compute values used to calculate; // GRANULATED_WAVEFRONT_SGPR_COUNT. Hence the original values for following; // directives can't be computed:; // .amdhsa_reserve_vcc; // .amdhsa_reserve_flat_scratch; // .amdhsa_reserve_xnack_mask; // They take their respective default values if not specified in the assembly.; //; // GRANULATED_WAVEFRONT_SGPR_COUNT; // = f(NEXT_FREE_SGPR + VCC + FLAT_SCRATCH + XNACK_MASK); //; // We compute the inverse as though all directives apart from NEXT_FREE_SGPR; // are set to 0. So while disassembling we consider that:; //; // GRANULATED_WAVEFRONT_SGPR_COUNT; // = f(NEXT_FREE_SGPR + 0 + 0 + 0); //; // The disassembler cannot recover the original values of those 3 directives.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:681,recover,recover,681,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['recover'],['recover']
Safety,"// We cannot do this optimization if any pair of {RLD, LLD} is a; // predecessor to {RLD, LLD, CondNode}. As we've already compared the; // Loads, we only need to check if CondNode is a successor to one of the; // loads. We can further avoid this if there's no use of their chain; // value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:236,avoid,avoid,236,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,// We cannot recover from llvm errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp:13,recover,recover,13,interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/driver/cc1as_main.cpp,1,['recover'],['recover']
Safety,"// We cannot recover from llvm errors. When reporting a fatal error, exit; // with status 70 to generate crash diagnostics. For BSD systems this is; // defined as an internal software error. Otherwise, exit with status 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp:13,recover,recover,13,interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-repl/ClangRepl.cpp,2,['recover'],['recover']
Safety,"// We cannot risk emitting FP_TO_XINT nodes with a source VT of [b]f16, as; // libcall emission cannot handle this. Large result types will fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp:13,risk,risk,13,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp,1,['risk'],['risk']
Safety,"// We check for partially redundant case.; // So far, we support cases with only two predecessors; // to avoid increasing the number of instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:26,redund,redundant,26,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"// We check for safety first because there might be multiple values in; // the same path, some of which are not safe to be hoisted, but overall; // each edge has at least one value which can be hoisted, making the; // value anticipable along that path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp:16,safe,safety,16,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVNHoist.cpp,2,['safe'],"['safe', 'safety']"
Safety,// We check the preconditions for the function prior to calling this to avoid; // the cost of building up a reversible post-order list. We assert them here; // to make sure none of the invariants this relies on were violated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:72,avoid,avoid,72,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['avoid'],['avoid']
Safety,"// We check whether the stores in StoreVec can form a vector by sorting them; // and checking whether they are consecutive.; // To avoid calling getPointersDiff() while sorting we create a vector of; // pairs {store, offset from first} and sort this instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:131,avoid,avoid,131,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"// We check with > instead of using Timeleft because if; // TotalTimeMiliseconds is greater than Timeout * 1000, TimeLeft would; // underflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp:97,Timeout,Timeout,97,interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/KillTheDoctor/KillTheDoctor.cpp,1,['Timeout'],['Timeout']
Safety,"// We consider PHI nodes as part of ""chains"", so given a PHI node I, we; // recursively consider all its users and incoming values that are also PHI; // nodes. We then make a decision about all of those PHIs at once. Either they; // all get broken up, or none of them do. That way, we avoid cases where a; // single PHI is/is not broken and we end up reforming/exploding a vector; // multiple times, or even worse, doing it in a loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:285,avoid,avoid,285,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,// We convert the floating point induction variable to a signed i32 value if; // we can. This is only safe if the comparison will not overflow in a way; // that won't be trapped by the integer equivalent operations. Check for this; // now.; // TODO: We could use i64 if it is native and the range requires it.; // The start/stride/exit values must all fit in signed i32.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp:102,safe,safe,102,interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp,1,['safe'],['safe']
Safety,"// We could avoid second lookup, but it would make the code ultra ugly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ImportedFunctionsInliningStatistics.cpp:12,avoid,avoid,12,interpreter/llvm-project/llvm/lib/Analysis/ImportedFunctionsInliningStatistics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ImportedFunctionsInliningStatistics.cpp,1,['avoid'],['avoid']
Safety,"// We could create all of the aligned loads, and generate the valigns; // at the location of the first load, but for large load groups, this; // could create highly suboptimal code (there have been groups of 140+; // loads in real code).; // Instead, place the loads/valigns as close to the users as possible.; // In any case we need to have a mapping from the blocks of VSpan (the; // span covered by the pre-existing loads) to ASpan (the span covered; // by the aligned loads). There is a small problem, though: ASpan needs; // to have pointers to the loads/valigns, but we don't have these loads; // because we don't know where to put them yet. We find out by creating; // a section of ASpan that corresponds to values (blocks) from VSpan,; // and checking where the new load should be placed. We need to attach; // this location information to each block in ASpan somehow, so we put; // distincts values for Seg.Val in each ASpan.Blocks[i], and use a map; // to store the location for each Seg.Val.; // The distinct values happen to be Blocks[i].Seg.Val = &Blocks[i],; // which helps with printing ByteSpans without crashing when printing; // Segments with these temporary identifiers in place of Val.; // Populate the blocks first, to avoid reallocations of the vector; // interfering with generating the placeholder addresses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:1240,avoid,avoid,1240,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['avoid'],['avoid']
Safety,// We could deal with more VL if we update the VSETVLI insert pass to; // avoid introducing more VSETVLI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp:74,avoid,avoid,74,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// We could not update the meta data for this block on the file.; // This is not fatal as this only means that we won't get it 'right'; // if we ever need to Recover the file before the block is actually; // (attempted to be reused.; // coverity[unchecked_value]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:158,Recover,Recover,158,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['Recover'],['Recover']
Safety,// We could see an undeduced auto type here during error recovery.; // Just ignore it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:57,recover,recovery,57,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['recover'],['recovery']
Safety,"// We could, if we wanted, build MemoryPhiExpressions and; // MemoryVariableExpressions, etc, and value number them the same way we value; // number phi expressions. For the moment, this seems like overkill. They; // can only exist in one of three states: they can be TOP (equal to; // everything), Equivalent to something else, or unique. Because we do not; // create expressions for them, we need to simulate leader change not just; // when they change class, but when they change state. Note: We can do the; // same thing for phis, and avoid having phi expressions if we wanted, We; // should eventually unify in one direction or the other, so this is a little; // bit of an experiment in which turns out easier to maintain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:539,avoid,avoid,539,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['avoid'],['avoid']
Safety,"// We couldn't find an inc/dec to merge. But if the base is dead, we; // can still change to a writeback form as that will save us 2 bytes; // of code size. It can create WAW hazards though, so only do it if; // we're minimizing code size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:175,hazard,hazards,175,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['hazard'],['hazards']
Safety,// We create ADJCALLSTACKUP and ADJCALLSTACKDOWN around _tls_get_addr; // as scheduling fence to avoid it is scheduled before; // mflr in the prologue and the address in LR is clobbered (PR25839).; // We don't really need to save data to the stack - the clobbered; // registers are already saved when the SDNode (e.g. PPCaddiTlsgdLAddr); // gets translated to the pseudo instruction (e.g. ADDItlsgdLADDR).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp:97,avoid,avoid,97,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCTLSDynamicCall.cpp,1,['avoid'],['avoid']
Safety,"// We decrease NumCurrentElementsDeserializing only after pending actions; // are finished, to avoid recursively re-calling finishPendingActions().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:95,avoid,avoid,95,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['avoid'],['avoid']
Safety,// We delay loading of the redeclaration chain to avoid deeply nested calls.; // We temporarily set the first (canonical) declaration as the previous one; // which is the one that matters and mark the real previous DeclID to be; // loaded & attached later on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:50,avoid,avoid,50,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['avoid'],['avoid']
Safety,// We detected undefined behavior (the caller will report it).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp:6,detect,detected,6,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/BitwiseShiftChecker.cpp,1,['detect'],['detected']
Safety,"// We didn't find a crash recovery context -- this means either we got a; // signal on a thread we didn't expect it on, the application got a signal; // outside of a crash recovery context, or something else went horribly; // wrong.; //; // Disable crash recovery and raise the signal again. The assumption here is; // that the enclosing application will terminate soon, and we won't want to; // attempt crash recovery again.; //; // This call of Disable isn't thread safe, but it doesn't actually matter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:26,recover,recovery,26,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,5,"['recover', 'safe']","['recovery', 'safe']"
Safety,// We do a simple search for mergeable stores prior to this one.; // Any potential alias hazard along the way terminates the search.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:89,hazard,hazard,89,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,1,['hazard'],['hazard']
Safety,// We do not call HazardRec->reset() here to make sure we are handling noop; // hazards at the start of basic blocks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp:18,Hazard,HazardRec,18,interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRAHazardRecognizer.cpp,2,"['Hazard', 'hazard']","['HazardRec', 'hazards']"
Safety,// We do not have any basic block in between now make sure the outer header; // and outer loop latch doesn't contain any unsafe instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:121,unsafe,unsafe,121,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['unsafe'],['unsafe']
Safety,"// We do not propagate the old load's debug location, because the new; // load now lives in a different BB, and we want to avoid a jumpy line; // table.; // FIXME: How do we retain source locations without causing poor debugging; // behavior?; // Add the newly created load.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:123,avoid,avoid,123,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['avoid'],['avoid']
Safety,// We do not support targeting NVPTX/AMDGCN for host compilation. Throw; // an error and abort pipeline construction early so we don't trip; // asserts that assume device-side compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:89,abort,abort,89,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['abort'],['abort']
Safety,// We do not want to follow the references when returning a pointer originating; // from a local owner to avoid the following false positive:; // int &p = *localUniquePtr;; // someContainer.add(std::move(localUniquePtr));; // return p;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:106,avoid,avoid,106,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['avoid'],['avoid']
Safety,"// We do the whole initialization in two passes, first for just one element,; // then for the whole array. It's possible we may find out we can't do const; // init in the first pass, in which case we avoid allocating a potentially; // large array. We don't do more passes because expanding array requires; // copying the data, which is wasteful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:200,avoid,avoid,200,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['avoid'],['avoid']
Safety,// We don't check hasOneUse to avoid increasing register pressure because; // the value we use is the same value this instruction was already using.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:31,avoid,avoid,31,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['avoid'],['avoid']
Safety,"// We don't erase corresponding items from `Freqs`, `RPOT` and other to; // avoid invalidating indices. Doing so would have saved some memory, but; // it's not worth it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:76,avoid,avoid,76,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,1,['avoid'],['avoid']
Safety,// We don't explicitly pass in LoopAccessInfo to the constructor since the; // loop versioning might return early due to instructions that are not safe; // for versioning. By passing the proxy instead the construction of; // LoopAccessInfo will take place only when it's necessary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:147,safe,safe,147,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,1,['safe'],['safe']
Safety,// We don't have 64-bit shifts. Thus we need either SHX i64 or SHX_PARTS i32; // to be Legal/Custom in order to avoid library calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp:112,avoid,avoid,112,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// We don't have a way to see if the symbol is compiler generated. Use; // the linkage name, to detect `scalar deleting destructor' functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:96,detect,detect,96,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,1,['detect'],['detect']
Safety,"// We don't have a way to update dead lanes, so keep track of the; // new register so that we avoid querying it later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp:94,avoid,avoid,94,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVRVVInitUndef.cpp,1,['avoid'],['avoid']
Safety,"// We don't have the ability to evaluate this, since it contains a; // RecoveryExpr, so we want to fail overload resolution. Otherwise,; // we'd potentially pick up a different overload, and cause confusing; // diagnostics. SO, add a failure detail that will cause us to make this; // overload set not viable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp:71,Recover,RecoveryExpr,71,interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaConcept.cpp,1,['Recover'],['RecoveryExpr']
Safety,"// We don't have the ability to slide mask vectors down indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when extracting a fixed-length vector; // from a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: v8i1 = extract nxv1i1 is valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:314,safe,safely,314,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['safe'],['safely']
Safety,"// We don't have the ability to slide mask vectors up indexed by their i1; // elements; the smallest we can do is i8. Often we are able to bitcast to; // equivalent i8 vectors. Note that when inserting a fixed-length vector; // into a scalable one, we might not necessarily have enough scalable; // elements to safely divide by 8: nxv1i1 = insert nxv1i1, v4i1 is valid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:311,safe,safely,311,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['safe'],['safely']
Safety,"// We don't know exactly what relocations are allowed in constant expressions,; // so we allow &global+constantoffset, which is safe and uniformly supported; // across targets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:128,safe,safe,128,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['safe'],['safe']
Safety,// We don't leave a note here since it is guaranteed the; // unique_ptr from this call is non-null (hence is safe to de-reference).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp:109,safe,safe,109,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/SmartPtrModeling.cpp,1,['safe'],['safe']
Safety,"// We don't need this if we only have spills since there is no user facing; // scratch.; // TODO: If we know we don't have flat instructions earlier, we can omit; // this from the input registers.; //; // TODO: We only need to know if we access scratch space through a flat; // pointer. Because we only detect if flat instructions are used at all,; // this will be used more often than necessary on VI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:303,detect,detect,303,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['detect'],['detect']
Safety,"// We don't need to do anything if there are no new servers or if the only; // new server is this RooAbsArg itself. And by returning early, we avoid; // potentially annoying side effects of the redirectServersHook.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:143,avoid,avoid,143,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['avoid'],['avoid']
Safety,// We don't need to harden either far calls or far jumps as they are; // safe from Spectre.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:73,safe,safe,73,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['safe'],['safe']
Safety,// We don't need to push PHINode into DeadInst since they are operands; // of rootPN DCE can safely delete rootPN's operands if rootPN is dead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp:93,safe,safely,93,interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86LowerAMXType.cpp,1,['safe'],['safely']
Safety,"// We don't retain the receiver in delegate init calls, and this is; // safe because the receiver value is always loaded from 'self',; // which we zero out. We don't want to Block_copy block receivers,; // though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:72,safe,safe,72,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['safe'],['safe']
Safety,"// We don't support GuaranteedTailCallOpt for ARM, only automatically; // detected sibcalls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:74,detect,detected,74,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['detect'],['detected']
Safety,"// We don't support GuaranteedTailCallOpt, only automatically-detected; // sibling calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp:62,detect,detected,62,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelLowering.cpp,1,['detect'],['detected']
Safety,"// We don't use the ADDR field until R600ControlFlowFinalizer pass, where; // it is safe to assume it is 0. However if we always put 0 here, the ifcvt; // pass may assume that identical ALU clause starter at the beginning of a; // true and false branch can be factorized which is not the case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp:84,safe,safe,84,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600EmitClauseMarkers.cpp,1,['safe'],['safe']
Safety,"// We don't want to layout the loop linearly in all cases. If the loop header; // is just a normal basic block in the loop, we want to look for what block; // within the loop is the best one to layout at the top. However, if the loop; // header has be pre-merged into a chain due to predecessors not having; // analyzable branches, *and* the predecessor it is merged with is *not* part; // of the loop, rotating the header into the middle of the loop will create; // a non-contiguous range of blocks which is Very Bad. So start with the; // header and only rotate if safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:567,safe,safe,567,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['safe'],['safe']
Safety,"// We don't want to read non-ASCII hex digits. std:: functions past; // 0xFF invoke UB.; //; // FIXME: actually, Microsoft version probably doesn't check this; // condition and uses their Unicode version of 'isxdigit'. However,; // there are some hex-digit Unicode character outside of ASCII, and; // some of these are actually accepted by rc.exe, the notable example; // being fullwidth forms (U+FF10..U+FF19 etc.) These can be written; // instead of ASCII digits in \x... escape sequence and get accepted.; // However, the resulting hexcodes seem totally unpredictable.; // We think it's infeasible to try to reproduce this behavior, nor to; // put effort in order to detect it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp:670,detect,detect,670,interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-rc/ResourceFileWriter.cpp,1,['detect'],['detect']
Safety,"// We don't write a symbol table on an archive with no members -- except on; // Darwin, where the linker will abort unless the archive has a symbol table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp:110,abort,abort,110,interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,1,['abort'],['abort']
Safety,"// We first collect all declarations that should not throw but not declared; // with noexcept. We then sort them based on the location before printing.; // This is to avoid emitting the same note multiple times on the same; // declaration, and also provide a deterministic order for the messages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:167,avoid,avoid,167,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,1,['avoid'],['avoid']
Safety,"// We first try with a lower MaxDepth, assuming that the path to common; // operands between From and To is relatively short. This significantly; // improves performance in the common case. The initial MaxDepth is big; // enough to avoid retry in the common case; the last MaxDepth is large; // enough to avoid having to use the fallback below (and protects from; // potential stack exhaustion from recursion).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:232,avoid,avoid,232,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,2,['avoid'],['avoid']
Safety,// We found at least one unresolved value. Nuke them all to avoid leaks.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp:60,avoid,avoid,60,interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp,1,['avoid'],['avoid']
Safety,// We found some types in dependent base classes. Recover as if the user; // wrote 'typename MyClass::II' instead of 'II'. We'll fully resolve the; // lookup during template instantiation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:50,Recover,Recover,50,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['Recover'],['Recover']
Safety,// We go through some convolutions here to avoid copying results; // between LookupResults.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:43,avoid,avoid,43,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['avoid'],['avoid']
Safety,// We got a unicode codepoint that is neither a space nor a; // a valid identifier part. Carry on as if the codepoint was; // valid for recovery purposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:136,recover,recovery,136,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['recover'],['recovery']
Safety,// We got a unicode codepoint that is neither a space nor a; // a valid identifier part.; // Carry on as if the codepoint was valid for recovery purposes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:136,recover,recovery,136,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['recover'],['recovery']
Safety,// We had viable candidates and couldn't recover; let the caller diagnose; // this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:41,recover,recover,41,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recover']
Safety,// We have a function we have information about. Check if it's something we; // can safely outline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:84,safe,safely,84,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['safe'],['safely']
Safety,// We have a function we have information about. Check it if it's something; // can safely outline.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:84,safe,safely,84,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['safe'],['safely']
Safety,"// We have a little hack here where keep the owned pointers private, and only; // expose a reference. This has two purposes:; // - Avoid derived classes messing with those pointers.; // - Keep the API consistent. CInfo, MF, MRI, etc. are all accessed as; // references. Accessing Observer/B as pointers unnecessarily leaks; // implementation details into derived classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h:131,Avoid,Avoid,131,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/Combiner.h,1,['Avoid'],['Avoid']
Safety,// We have an AST that has invalid nodes due to compiler errors.; // Use a crash recovery thread for protection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:81,recover,recovery,81,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['recover'],['recovery']
Safety,"// We have an array of character type with known size. However,; // the size may be smaller or larger than the string we are initializing.; // FIXME: Avoid truncation for 64-bit length strings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:150,Avoid,Avoid,150,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['Avoid'],['Avoid']
Safety,// We have an input that is not a truncation or another binary; // operation; we'll abort this transformation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,abort,abort,84,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['abort'],['abort']
Safety,// We have an input that is not an extension or another binary; // operation; we'll abort this transformation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:84,abort,abort,84,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['abort'],['abort']
Safety,// We have an umbrella header or directory that doesn't actually include; // all of the headers within the directory it covers. Complain about; // this missing submodule and recover by forgetting that we ever saw; // this submodule.; // FIXME: Should we detect this at module load time? It seems fairly; // expensive (and rare).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:174,recover,recover,174,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,2,"['detect', 'recover']","['detect', 'recover']"
Safety,// We have established how to parse the inline asm statement.; // Now we can safely lex any leading spaces to get to the; // first token.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:77,safe,safely,77,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['safe'],['safely']
Safety,"// We have matched a recurrence of the form:; // %iv = [R, %entry], [%iv.next, %backedge]; // %iv.next = shift_op %iv, L; // Recurse with the phi context to avoid concern about whether facts; // inferred hold at original context instruction. TODO: It may be; // correct to use the original context. IF warranted, explore and; // add sufficient tests to cover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:157,avoid,avoid,157,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['avoid'],['avoid']
Safety,// We have no guarantees about thread safety of the Receiver which is being; // used in both InitialScan and EventReceivingLoop. We shouldn't run these; // only synchronously.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp:38,safe,safety,38,interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/DirectoryWatcher/linux/DirectoryWatcher-linux.cpp,1,['safe'],['safety']
Safety,"// We have reached the end of the block and didn't find anywhere to; // insert! It's not safe to discard any debug instructions; place them; // in front of the first terminator, or in front of end().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:89,safe,safe,89,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['safe'],['safe']
Safety,"// We have the case of an on-file enum or an unknown class, since; // this comes from a file, we also know that the type was valid but; // since we have no information it was either; // a. an enum; // b. a class of type that was never stored; // c. a class with a custom streamer; // We can ""safely"" pretend that it is an enum in all 3 case because; // a. obviously; // b. it will not be used anyway (no object of that type on the file); // c. since we don't know the class we don't have the Streamer and thus can read it anyway; // So let's temporarily pretend it is an enum.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TEmulatedCollectionProxy.cxx:292,safe,safely,292,io/io/src/TEmulatedCollectionProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TEmulatedCollectionProxy.cxx,1,['safe'],['safely']
Safety,"// We have the number for a PHI, or possibly live-through value, to be used; // at this Use. There are a number of things we have to check about it though:; // * Does any PHI use an 'Undef' (like an IMPLICIT_DEF) value? If so, this; // Use was not completely dominated by DBG_PHIs and we should abort.; // * Are the Defs or PHIs clobbered in a block? SSAUpdater isn't aware that; // we've left SSA form. Validate that the inputs to each PHI are the; // expected values.; // * Is a PHI we've created actually a merging of values, or are all the; // predecessor values the same, leading to a non-PHI machine value number?; // (SSAUpdater doesn't know that either). Remap validated PHIs into the; // the ValidatedValues collection below to sort this out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:295,abort,abort,295,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['abort'],['abort']
Safety,// We have the option to use the safe-divisor idiom to avoid predication.; // The cost based decision here will always select safe-divisor for; // scalable vectors as scalarization isn't legal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:33,safe,safe-divisor,33,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,3,"['avoid', 'safe']","['avoid', 'safe-divisor']"
Safety,"// We have the potential to fold the conditions together, but if the; // predecessor branch is predictable, we may not want to merge them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:95,predict,predictable,95,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['predict'],['predictable']
Safety,"// We have to assume the SP is needed in case there are calls in the function,; // which is detected after the function is lowered. If we aren't really going; // to need SP, don't bother reserving it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:92,detect,detected,92,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['detect'],['detected']
Safety,"// We have to detect the correct stream, using the lexical parent; // name, as there is not other obvious way to get the stream.; // Normal function: LF_FUNC_ID (TPI)/(IPI); // LF_PROCEDURE (TPI); // Lambda function: LF_MFUNCTION (TPI); // Member function: LF_MFUNC_ID (TPI)/(IPI)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp:14,detect,detect,14,interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/LogicalView/Readers/LVCodeViewVisitor.cpp,1,['detect'],['detect']
Safety,"// We have to predicate MI ""in place"", i.e. after this function returns,; // MI will need to be transformed into a predicated form. To avoid com-; // plicated manipulations with the operands (handling tied operands,; // etc.), build a new temporary instruction, then overwrite MI with it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp:135,avoid,avoid,135,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// We have to produce a carry out, and there isn't a free SGPR pair; // for it. We can keep the whole computation on the SALU to avoid; // clobbering an additional register at the cost of an extra mov.; // We may have 1 free scratch SGPR even though a carry out is; // unavailable. Only one additional mov is needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:129,avoid,avoid,129,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['avoid'],['avoid']
Safety,"// We have two limits to reduce the complexity:; // 1) AliasedCheckLimit: It's a small limit to reduce calls to; // SLP->isAliased (which is the expensive part in this loop).; // 2) MaxMemDepDistance: It's for very large blocks and it aborts; // the whole loop (even if the loop is fast, it's quadratic).; // It's important for the loop break condition (see below) to; // check this limit even between two read-only instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:235,abort,aborts,235,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['abort'],['aborts']
Safety,"// We have two ways to try to recover from this error: if the code looks; // grammatically ok (i.e. we have a comma coming up) try to continue; // parsing the rest of the initializer. This allows us to emit; // diagnostics for later elements that we find. If we don't see a comma,; // assume there is a parse error, and just skip to recover.; // FIXME: This comment doesn't sound right. If there is a r_brace; // immediately, it can't be an error, since there is no other way of; // leaving this loop except through this if.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp:30,recover,recover,30,interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseInit.cpp,2,['recover'],['recover']
Safety,"// We haven't found anything, and we're not recovering from a; // different kind of error, so look for typos.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:44,recover,recovering,44,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['recover'],['recovering']
Safety,"// We introduce this option since there is a minor compile-time win by avoiding; // addition of TTI attributes (target-features in particular) to inline; // candidates when they are guaranteed to be the same as top level methods in; // some use cases. If we avoid adding the attribute, we need an option to avoid; // checking these attributes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:71,avoid,avoiding,71,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,3,['avoid'],"['avoid', 'avoiding']"
Safety,"// We keep both the raw value and the min tag value's pointer in a union. When; // the minimum tag value is zero, this allows code below to cleanly expose the; // address of the zero-tag pointer instead of just the zero-tag pointer; // itself. This is especially useful when building `ArrayRef`s out of a single; // pointer. However, we have to carefully access the union due to the active; // member potentially changing. When we *store* a new value, we directly; // access the union to allow us to store using the obvious types. However,; // when we *read* a value, we copy the underlying storage out to avoid relying; // on one member or the other being active.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:606,avoid,avoid,606,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,1,['avoid'],['avoid']
Safety,// We keep track of all prior discarded entries so that we can avoid invoking; // the symbolizer for such entries.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp:63,avoid,avoid,63,interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/RawMemProfReader.cpp,1,['avoid'],['avoid']
Safety,"// We know it's safe to put the load at BasePos, but we'd prefer to put; // it at ""Where"". To see if the load is safe to be placed at Where, put; // it there first and then check if it's safe to move it to BasePos.; // If not, then the load needs to be placed at BasePos.; // We can't do this check proactively because we need the load to exist; // in order to check legality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:16,safe,safe,16,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,3,['safe'],['safe']
Safety,"// We know kernels (generally) cannot be called from within the module. Thus,; // for reachability we would need to step back from a kernel which would allow; // us to reach anything anyway. Even if a kernel is invoked from another; // kernel, values like allocas and shared memory are not accessible. We; // implicitly check for this situation to avoid costly lookups.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:348,avoid,avoid,348,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,1,['avoid'],['avoid']
Safety,"// We know loop's backedge-taken count, but what's loop's trip count?; // Note that while NUW is always safe, while NSW is only for bitwidths != 2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:104,safe,safe,104,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['safe'],['safe']
Safety,"// We know that, the MI and DefMI both meet the pattern, and; // the Imm also meet the requirement with the new Imm-form.; // It is safe to do the transformation now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:132,safe,safe,132,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['safe'],['safe']
Safety,// We limit the max depth to track incoming values of PHIs or binary ops; // (e.g. AND) to avoid excessive cost.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:91,avoid,avoid,91,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['avoid'],['avoid']
Safety,"// We look for instructions that write S registers that are then read as; // D/Q registers. These can only be caused by COPY, INSERT_SUBREG and; // REG_SEQUENCE pseudos that insert an SPR value into a DPR register or; // merge two SPR values to form a DPR register. In order avoid false; // positives we make sure that there is an SPR producer so we look past; // COPY and PHI nodes to find it.; //; // The best code pattern for when an SPR producer is going to be used by a; // DPR or QPR consumer depends on whether the other lanes of the; // corresponding DPR/QPR are currently defined.; //; // We can handle these efficiently, depending on the type of; // pseudo-instruction that is producing the pattern; //; // * COPY: * VDUP all lanes and merge the results together; // using VEXTs.; //; // * INSERT_SUBREG: * If the SPR value was originally in another DPR/QPR; // lane, and the other lane(s) of the DPR/QPR register; // that we are inserting in are undefined, use the; // original DPR/QPR value.; // * Otherwise, fall back on the same stategy as COPY.; //; // * REG_SEQUENCE: * If all except one of the input operands are; // IMPLICIT_DEFs, insert the VDUP pattern for just the; // defined input operand; // * Otherwise, fall back on the same stategy as COPY.; //; // First, get all the reads of D-registers done by this instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp:275,avoid,avoid,275,interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/A15SDOptimizer.cpp,1,['avoid'],['avoid']
Safety,// We loop here until a lex function returns a token; this avoids recursion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:59,avoid,avoids,59,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['avoid'],['avoids']
Safety,"// We match the ""full"" 0 or 1 constant here to avoid a potential infinite; // loop with vectors that may have undefined/poison elements.; // select a, false, b -> select !a, b, false",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['avoid'],['avoid']
Safety,// We match the loads and follow the uses to the extend instead of matching; // the extends and following the def to the load. This is because the load; // must remain in the same position for correctness (unless we also add code; // to find a safe place to sink it) whereas the extend is freely movable.; // It also prevents us from duplicating the load for the volatile case or just; // for performance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:244,safe,safe,244,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['safe'],['safe']
Safety,"// We matched a negative constant, so propagating undef is unsafe.; // Clamp undef elements to -1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:59,unsafe,unsafe,59,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['unsafe'],['unsafe']
Safety,"// We matched a non-negative constant, so propagating undef is unsafe.; // Clamp undef elements to 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:63,unsafe,unsafe,63,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['unsafe'],['unsafe']
Safety,"// We may be trying to avoid interference that ends at a deleted instruction,; // so always begin RegIdx 0 early and all others late.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp:23,avoid,avoid,23,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.cpp,1,['avoid'],['avoid']
Safety,"// We may get a post-structured CFG like below:; //; // | P1; // |/; // F1; // |\; // | N; // |/; // F2; // |\; // | P2; // |/; // F3; // |\; // B; //; // B is the block that has a PHI being reconstructed. P1/P2 are predecessors; // of B before structurization. F1/F2/F3 are flow blocks inserted during; // structurization process. Block N is not a predecessor of B before; // structurization, but are placed between the predecessors(P1/P2) of B after; // structurization. This usually means that threads went to N never take the; // path N->F2->F3->B. For example, the threads take the branch F1->N may; // always take the branch F2->P2. So, when we are reconstructing a PHI; // originally in B, we can safely say the incoming value from N is undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:704,safe,safely,704,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,1,['safe'],['safely']
Safety,"// We may have unresolved symbols. Use dyld to resolve the dependent; // libraries and relink.; // FIXME: We will likely have duplicated libraries as we are appending; // FIXME: This likely makes rootcling --lib-list-prefix redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:224,redund,redundant,224,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['redund'],['redundant']
Safety,"// We may ourself contain the 'Mother' branch name.; // To avoid code duplication, we delegate the removal; // of the mother's name to the first sub-branch loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:59,avoid,avoid,59,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,1,['avoid'],['avoid']
Safety,// We may safely transfer the debug info describing the truncate node over; // to the equivalent and operation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,safe,safely,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safely']
Safety,"// We might be able to find a value, but have chosen not to, to avoid; // tracking too much stack information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:64,avoid,avoid,64,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['avoid'],['avoid']
Safety,"// We might be introducing a new use of the post-inc IV that is not poison; // safe, in which case we should drop poison generating flags. Only keep; // those flags for which SCEV has proven that they always hold.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:79,safe,safe,79,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['safe'],['safe']
Safety,"// We mmap the jitdump to create an MMAP RECORD in perf.data file. The mmap; // is captured either live (perf record running when we mmap) or in deferred; // mode, via /proc/PID/maps. The MMAP record is used as a marker of a jitdump; // file for more meta data info about the jitted code. Perf report/annotate; // detect this special filename and process the jitdump file.; //; // Mapping must be PROT_EXEC to ensure it is captured by perf record; // even when not using -d option.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp:314,detect,detect,314,interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Orc/TargetProcess/JITLoaderPerf.cpp,2,['detect'],['detect']
Safety,"// We model unconditional branches as essentially free -- they really; // shouldn't exist at all, but handling them makes the behavior of the; // inliner more regular and predictable. Interestingly, conditional branches; // which will fold away are also free.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:171,predict,predictable,171,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['predict'],['predictable']
Safety,// We must also check if it's safe to fold the matched instructions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp:30,safe,safe,30,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.cpp,1,['safe'],['safe']
Safety,"// We must be careful with atomic accesses, as they may allow another thread; // to touch this location, clobbering it. We are conservative: if the; // QueryInst is not a simple (non-atomic) memory access, we automatically; // return getClobber.; // If it is simple, we know based on the results of; // ""Compiler testing via a theory of sound optimisations in the C11/C++11; // memory model"" in PLDI 2013, that a non-atomic location can only be; // clobbered between a pair of a release and an acquire action, with no; // access to the location in between.; // Here is an example for giving the general intuition behind this rule.; // In the following code:; // store x 0;; // release action; [1]; // acquire action; [4]; // %val = load x;; // It is unsafe to replace %val by 0 because another thread may be running:; // acquire action; [2]; // store x 42;; // release action; [3]; // with synchronization from 1 to 2 and from 3 to 4, resulting in %val; // being 42. A key property of this program however is that if either; // 1 or 4 were missing, there would be a race between the store of 42; // either the store of 0 or the load (making the whole program racy).; // The paper mentioned above shows that the same property is respected; // by every program that can detect any optimization of that kind: either; // it is racy (undefined) or there is a release followed by an acquire; // between the pair of accesses under consideration.; // If the load is invariant, we ""know"" that it doesn't alias *any* write. We; // do want to respect mustalias results since defs are useful for value; // forwarding, but any mayalias write can be assumed to be noalias.; // Arguably, this logic should be pushed inside AliasAnalysis itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:750,unsafe,unsafe,750,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,2,"['detect', 'unsafe']","['detect', 'unsafe']"
Safety,"// We must cleanup newly-inserted instructions, to avoid any potential; // endless combine looping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,1,['avoid'],['avoid']
Safety,"// We must early-exit here to prevent any DPValues from being emitted below,; // as we have just emitted the debug values resulting from assignment; // tracking analysis, making any existing DPValues redundant (and probably; // less correct).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:200,redund,redundant,200,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['redund'],['redundant']
Safety,// We must insert before i. Detect overflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:28,Detect,Detect,28,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['Detect'],['Detect']
Safety,// We must restrict the ordering to avoid generating loads with Release or; // ReleaseAcquire orderings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:36,avoid,avoid,36,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// We must search by the slow case of localUncachedLookup because that is; // working even if there is no LookupPtr for the DC. We could use; // DC::buildLookup() to create the LookupPtr, but that would load external; // decls again, we must avoid that case.; // Also, even if we had the LookupPtr, we must find Decls which are not; // in the LookupPtr, so we need the slow case.; // These cases are handled in ASTImporterLookupTable, but we cannot use; // that with LLDB since that traverses through the AST which initiates the; // load of external decls again via DC::decls(). And again, we must avoid; // loading external decls during the import.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:242,avoid,avoid,242,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,2,['avoid'],['avoid']
Safety,"// We must sink this DBG_VALUE if its operand is sunk. To avoid searching; // for DBG_VALUEs later, record them when they're encountered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:58,avoid,avoid,58,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['avoid'],['avoid']
Safety,"// We need PatItr and PatEnd later for detecting the end of a CHECK-DAG; // group, so we don't use a range-based for loop here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp:39,detect,detecting,39,interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheck.cpp,1,['detect'],['detecting']
Safety,// We need a detected GCC installation on Linux to provide libstdc++'s; // headers in odd Linuxish places.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:13,detect,detected,13,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,2,['detect'],['detected']
Safety,// We need a detected GCC installation on Solaris (similar to Linux); // to provide libstdc++'s headers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:13,detect,detected,13,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,1,['detect'],['detected']
Safety,"// We need all of the Frame Indices to meet these conditions.; // If they do not, abort the whole operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:82,abort,abort,82,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['abort'],['abort']
Safety,"// We need permanent storage for the string we are about to create. Just; // append it to the vector containing translations. This should only happen; // during MachO symbol table translation, thus there should be no risk on; // exponential growth.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/SymbolMap.cpp:217,risk,risk,217,interpreter/llvm-project/llvm/tools/dsymutil/SymbolMap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/SymbolMap.cpp,1,['risk'],['risk']
Safety,"// We need this to safely RAUW and delete call or invoke return values that; // may themselves be live over a statepoint. For details, please see usage in; // makeStatepointExplicitImpl.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:19,safe,safely,19,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safely']
Safety,// We need to abort on a user we don't understand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:14,abort,abort,14,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['abort'],['abort']
Safety,// We need to avoid a situation in which the value from a VRRC register is; // spilled using an Altivec instruction and reloaded into a VSRC register; // using a VSX instruction. The issue with this is that the VSX; // load/store instructions swap the doublewords in the vector and the Altivec; // ones don't. The register classes on the spill/reload may be different if; // the register is defined using an Altivec instruction and is then used by a; // VSX instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,2,['avoid'],['avoid']
Safety,"// We need to avoid to pass -1 as end entry to the SetCacheEntryRange method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx:14,avoid,avoid,14,tree/treeplayer/src/TTreeReader.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReader.cxx,1,['avoid'],['avoid']
Safety,// We need to avoid touching EFLAGS so shift out all but the least; // significant bit using the instruction that doesn't update flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['avoid'],['avoid']
Safety,"// We need to be a bit careful here. We can only peek through the bitcast; // if the scalar size of elements in the operand are smaller than and a; // multiple of the size they are casting too. Take three cases:; //; // 1) Unsafe:; // bitcast <2 x i16> %NonZero to <4 x i8>; //; // %NonZero can have 2 non-zero i16 elements, but isKnownNonZero on a; // <4 x i8> requires that all 4 i8 elements be non-zero which isn't; // guranteed (imagine just sign bit set in the 2 i16 elements).; //; // 2) Unsafe:; // bitcast <4 x i3> %NonZero to <3 x i4>; //; // Even though the scalar size of the src (`i3`) is smaller than the; // scalar size of the dst `i4`, because `i3` is not a multiple of `i4`; // its possible for the `3 x i4` elements to be zero because there are; // some elements in the destination that don't contain any full src; // element.; //; // 3) Safe:; // bitcast <4 x i8> %NonZero to <2 x i16>; //; // This is always safe as non-zero in the 4 i8 elements implies; // non-zero in the combination of any two adjacent ones. Since i8 is a; // multiple of i16, each i16 is guranteed to have 2 full i8 elements.; // This all implies the 2 i16 elements are non-zero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:223,Unsafe,Unsafe,223,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,4,"['Safe', 'Unsafe', 'safe']","['Safe', 'Unsafe', 'safe']"
Safety,"// We need to change the name of the function to avoid problems when we load more packages",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx:49,avoid,avoid,49,proof/proof/src/TPackMgr.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TPackMgr.cxx,1,['avoid'],['avoid']
Safety,"// We need to change to a wider element type that we have support for.; // For 8 element vectors this is easy, we either extend to v8i32 or v8i64.; // For 16 element vectors we extend to v16i32 unless we are explicitly; // trying to avoid 512-bit vectors. If we are avoiding 512-bit vectors; // we need to split into two 8 element vectors which we can extend to v8i32,; // truncate and concat the results. There's an additional complication if; // the original type is v16i8. In that case we can't split the v16i8; // directly, so we need to shuffle high elements to low and use; // sign_extend_vector_inreg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:233,avoid,avoid,233,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,['avoid'],"['avoid', 'avoiding']"
Safety,// We need to clear the mutability bit in case we are; // destroying the node as part of a sweep in ImutAVLFactory::recoverNodes().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h:116,recover,recoverNodes,116,interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h,1,['recover'],['recoverNodes']
Safety,"// We need to compute an access strategy for this bit-field. We are given the; // offset to the first byte in the bit-field, the sub-byte offset is taken; // from the original layout. We reuse the normal bit-field access strategy by; // treating this as an access to a struct where the bit-field is in byte 0,; // and adjust the containing type size as appropriate.; //; // FIXME: Note that currently we make a very conservative estimate of the; // alignment of the bit-field, because (a) it is not clear what guarantees the; // runtime makes us, and (b) we don't have a way to specify that the struct is; // at an alignment plus offset.; //; // Note, there is a subtle invariant here: we can only call this routine on; // non-synthesized ivars but we may be called for synthesized ivars. However,; // a synthesized ivar can never be a bit-field, so this is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp:858,safe,safe,858,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.cpp,1,['safe'],['safe']
Safety,"// We need to copy NodeExtraInfo to all _new_ nodes that are being introduced; // through the replacement of From with To. Otherwise, replacements of a node; // (From) with more complex nodes (To and its operands) may result in lost; // extra info where the root node (To) is insignificant in further propagating; // and using extra info when further lowering to MIR.; //; // In the first step pre-populate the visited set with the nodes reachable; // from the old From node. This avoids copying NodeExtraInfo to parts of the; // DAG that is not new and should be left untouched.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:481,avoid,avoids,481,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['avoid'],['avoids']
Safety,// We need to copy the TypeLoc because TemplateArgumentLocs store a; // TypeSourceInfo.; // FIXME: Find some way to avoid the copy?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp:116,avoid,avoid,116,interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateVariadic.cpp,1,['avoid'],['avoid']
Safety,// We need to create a local symbol to avoid relocations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp:39,avoid,avoid,39,interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCObjectStreamer.cpp,1,['avoid'],['avoid']
Safety,"// We need to detect various ways of spelling a rotation:; // [11, 12, 13, 14, 15, 0, 1, 2]; // [-1, 12, 13, 14, -1, -1, 1, -1]; // [-1, -1, -1, -1, -1, -1, 1, 2]; // [ 3, 4, 5, 6, 7, 8, 9, 10]; // [-1, 4, 5, 6, -1, -1, 9, -1]; // [-1, 4, 5, 6, -1, -1, -1, -1]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:14,detect,detect,14,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,2,['detect'],['detect']
Safety,"// We need to ensure a safepoint poll occurs before any 'real' call. The; // easiest way to ensure finite execution between safepoints in the face of; // recursive and mutually recursive functions is to enforce that each take; // a safepoint. Additionally, we need to ensure a poll before any call; // which can grow the stack by an unbounded amount. This isn't required; // for GC semantics per se, but is a common requirement for languages; // which detect stack overflow via guard pages and then throw exceptions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:23,safe,safepoint,23,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,4,"['detect', 'safe']","['detect', 'safepoint', 'safepoints']"
Safety,// We need to ensure that argument promotion does not attempt to promote; // pointers to fixed-length vector types larger than 128 bits like; // <8 x float> (and pointers to aggregate types which have such fixed-length; // vector type members) into the values of the pointees. Such vector types; // are used for SVE VLS but there is no ABI for SVE VLS arguments and the; // backend cannot lower such value arguments. The 128-bit fixed-length SVE; // types can be safely treated as 128-bit NEON types and they cannot be; // distinguished in IR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:463,safe,safely,463,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['safe'],['safely']
Safety,"// We need to establish an ordering of constructor and conversion function; // names, and they don't have an intrinsic ordering.; // First we try the easy case by forming the current context's constructor; // name and adding that name first. This is a very useful optimization to; // avoid walking the lexical declarations in many cases, and it also; // handles the only case where a constructor name can come from some other; // lexical context -- when that name is an implicit constructor merged from; // another declaration in the redecl chain. Any non-implicit constructor or; // conversion function which doesn't occur in all the lexical contexts; // would be an ODR violation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp:284,avoid,avoid,284,interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTWriter.cpp,1,['avoid'],['avoid']
Safety,"// We need to follow common pointer manipulation uses to the accesses they; // feed into. We can try to be smart to avoid looking through things we do not; // like for now, e.g., non-inbounds GEPs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:116,avoid,avoid,116,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,1,['avoid'],['avoid']
Safety,"// We need to keep the references to the stack protector slot through frame; // index operands so that it gets resolved by PEI rather than this pass.; // This avoids accesses to the stack protector though virtual base; // registers, and forces PEI to address it using fp/sp/bp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:159,avoid,avoids,159,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,1,['avoid'],['avoids']
Safety,"// We need to make sure probability list is either empty or has the same size; // of successor list. When this function is called, we can safely delete all; // probability in the list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp:138,safe,safely,138,interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBasicBlock.cpp,1,['safe'],['safely']
Safety,"// We need to make sure that it is safe to move the release from its; // current position to the store. This implies proving that any; // instruction in between Store and the Release conservatively can not use; // the RCIdentityRoot of Release. If we can prove we can ignore Inst, so; // continue...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:35,safe,safe,35,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,1,['safe'],['safe']
Safety,"// We need to not do lazy parsing when we need thread safety as; // DWARFUnitVector, in lazy mode, will slowly add things to itself and; // will cause problems in a multi-threaded environment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp:54,safe,safety,54,interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/DWARF/DWARFContext.cpp,1,['safe'],['safety']
Safety,"// We need to over-write the stack slot with something (here, a def at; // this instruction) to ensure no values are preserved in this stack slot; // after the spill. It also prevents TTracker from trying to recover the; // location and re-installing it in the same place.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:208,recover,recover,208,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['recover'],['recover']
Safety,// We need to propagate an invalidation call to all but the newly current SCC; // because the outer pass manager won't do that for us after splitting them.; // FIXME: We should accept a PreservedAnalysis from the CG updater so that if; // there are preserved analysis we can avoid invalidating them here for; // split-off SCCs.; // We know however that this will preserve any FAM proxy so go ahead and mark; // that.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp:275,avoid,avoid,275,interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CGSCCPassManager.cpp,1,['avoid'],['avoid']
Safety,"// We need to reduce the strength of any inlined tail calls. For; // musttail, we have to avoid introducing potential unbounded stack; // growth. For example, if functions 'f' and 'g' are mutually recursive; // with musttail, we can inline 'g' into 'f' so long as we preserve; // musttail on the cloned call to 'f'. If either the inlined call site; // or the cloned call site is *not* musttail, the program already has; // one frame of stack growth, so it's safe to remove musttail. Here is; // a table of example transformations:; //; // f -> musttail g -> musttail f ==> f -> musttail f; // f -> musttail g -> tail f ==> f -> tail f; // f -> g -> musttail f ==> f -> f; // f -> g -> tail f ==> f -> f; //; // Inlined notail calls should remain notail calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:90,avoid,avoid,90,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"// We need to retain the copied value for __strong direct captures.; // If it's a block pointer, we have to copy the block and assign that to; // the destination pointer, so we might as well use _Block_object_assign.; // Otherwise we can avoid that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:238,avoid,avoid,238,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['avoid'],['avoid']
Safety,"// We need to return a negative value to avoid a circular list of friends; // to think that there is always an entry somewhere in the list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:41,avoid,avoid,41,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['avoid'],['avoid']
Safety,// We need to sink a callsite to a unique funclet. Avoid sinking if the; // phi use is too muddled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:51,Avoid,Avoid,51,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['Avoid'],['Avoid']
Safety,// We need to skip the first CompoundStmt to avoid situation when guardian is; // defined in the same scope as guarded variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp:45,avoid,avoid,45,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/UncountedLocalVarsChecker.cpp,1,['avoid'],['avoid']
Safety,"// We need to specifically handle i64 mul here to avoid unnecessary conversion; // instructions. If we only match on the legalized i64 mul expansion,; // SimplifyDemandedBits will be unable to remove them because there will be; // multiple uses due to the separate mul + mulh[su].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp:50,avoid,avoid,50,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelLowering.cpp,1,['avoid'],['avoid']
Safety,"// We need to split vselect into individual per-element operations Because we; // use BFE/BFI instruction for byte extraction/insertion, we do end up with; // 32-bit values, so we may as well do comparison as i32 to avoid conversions; // to/from i16 normally used for i8 values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp:216,avoid,avoid,216,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXISelLowering.cpp,1,['avoid'],['avoid']
Safety,// We need use 32-bit subregister to avoid mismatch register class in 64-bit; // mode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:37,avoid,avoid,37,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// We need valid source locations to avoid assert(InitList.isExplicit()...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:37,avoid,avoid,37,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['avoid'],['avoid']
Safety,"// We never want to inline functions that contain an indirectbr. This is; // incorrect because all the blockaddress's (in static global initializers; // for example) would be referring to the original function, and this indirect; // jump would jump from the inlined copy of the function into the original; // function which is extremely undefined behavior.; // FIXME: This logic isn't really right; we can safely inline functions; // with indirectbr's as long as no other function or global references the; // blockaddress of a block within the current function. And as a QOI issue,; // if someone is using a blockaddress without an indirectbr, and that; // reference somehow ends up in another function or global, we probably; // don't want to inline this function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp:406,safe,safely,406,interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CodeMetrics.cpp,1,['safe'],['safely']
Safety,"// We never want to inline functions that contain an indirectbr. This is; // incorrect because all the blockaddress's (in static global initializers; // for example) would be referring to the original function, and this; // indirect jump would jump from the inlined copy of the function into the; // original function which is extremely undefined behavior.; // FIXME: This logic isn't really right; we can safely inline functions with; // indirectbr's as long as no other function or global references the; // blockaddress of a block within the current function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:406,safe,safely,406,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,1,['safe'],['safely']
Safety,"// We note the locations of these intrinsic calls so that we can; // delete them later if the optimization succeeds, this is safe; // since both llvm.lifetime.start and llvm.lifetime.end intrinsics; // practically fill all the bytes of the alloca with an undefined; // value, although conceptually marked as alive/dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:125,safe,safe,125,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['safe'],['safe']
Safety,"// We now have all the information we need to decide if the use of a heap; // reference is legal or not, given our safepoint semantics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:115,safe,safepoint,115,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['safe'],['safepoint']
Safety,// We only allow whole-alloca splittable loads and stores; // for a large alloca to avoid creating too large BitVector.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:84,avoid,avoid,84,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['avoid'],['avoid']
Safety,"// We only attempt to scalarize instructions forming a single-use chain; // from the original predicated block that would otherwise be vectorized.; // Although not strictly necessary, we give up on instructions we know will; // already be scalar to avoid traversing chains that are unlikely to be; // beneficial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:249,avoid,avoid,249,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avoid'],['avoid']
Safety,"// We only checks for named modules here. The header like modules is skipped.; // FIXME: This is not right if we import the header like modules in the module; // purview.; //; // For example, assuming ""header.h"" provides definition for `D`.; // ```C++; // //--- M.cppm; // export module M;; // import ""header.h""; // or #include ""header.h"" but import it by clang modules; // actually.; //; // //--- Use.cpp; // import M;; // import ""header.h""; // or uses clang modules.; // ```; //; // In this case, `D` has multiple definitions in multiple TU (M.cppm and; // Use.cpp) and `D` is attached to a named module `M`. The compiler should; // reject it. But the current implementation couldn't detect the case since we; // don't record the information about the importee modules.; //; // But this might not be painful in practice. Since the design of C++20 Named; // Modules suggests us to use headers in global module fragment instead of; // module purview.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:686,detect,detect,686,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['detect'],['detect']
Safety,"// We only have a post-order SCC traversal (because SCCs are inherently; // discovered in post-order), so we accumulate them in a vector and then walk; // it in reverse. This is simpler than using the RPO iterator infrastructure; // because we need to combine SCC detection and the PO walk of the call; // graph. We can also cheat egregiously because we're primarily interested in; // synthesizing norecurse and so we can only save the singular SCCs as SCCs; // with multiple functions in them will clearly be recursive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:264,detect,detection,264,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,1,['detect'],['detection']
Safety,// We only infer things using the prototype and the name; we don't need; // definitions. This ensures libfuncs are annotated and also allows our; // CGSCC inference to avoid needing to duplicate the inference from other; // attribute logic on all calls to declarations (as declarations aren't; // explicitly visited by CGSCC passes in the new pass manager.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp:168,avoid,avoid,168,interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp,1,['avoid'],['avoid']
Safety,"// We only need to do this matching if we have template parameters; // or a scope specifier, which also conveniently avoids this work; // for non-C++ cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:117,avoid,avoids,117,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['avoid'],['avoids']
Safety,// We only need to use thread-safe statics for local non-TLS variables and; // inline variables; other global initialization is always single-threaded; // or (through lazy dynamic loading in multiple threads) unsequenced.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp:30,safe,safe,30,interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ItaniumCXXABI.cpp,1,['safe'],['safe']
Safety,"// We only saw whitespace, so just try again with this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:106,avoid,avoid,106,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['avoid'],['avoid']
Safety,// We only support a set of vector types with a consistent maximum fixed size; // across all supported vector element types to avoid legalization issues.; // Therefore -- since the largest is v1024i8/v512i16/etc -- the largest; // fixed-length vector type we support is 1024 bytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:127,avoid,avoid,127,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['avoid'],['avoid']
Safety,// We only try merging comparisons if the target wants to expand memcmp later.; // The rationale is to avoid turning small chains into memcmp calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp:103,avoid,avoid,103,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MergeICmps.cpp,1,['avoid'],['avoid']
Safety,"// We only try to build a recovery expr at this level if we can preserve; // the return type, otherwise we return ExprError() and let the caller; // recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:26,recover,recovery,26,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,2,['recover'],"['recover', 'recovery']"
Safety,// We only want the *_WIDTH macro for the signed types to avoid too many; // predefined macros (the unsigned width and the signed width are identical.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp:58,avoid,avoid,58,interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/InitPreprocessor.cpp,2,['avoid'],['avoid']
Safety,"// We only want to handle cases which are easy to predict at static time, e.g.; // C++ throw statement, that is very likely not taken, or calling never; // returned function, e.g. stdlib exit(). So we set Threshold to filter; // unwanted cases.; //; // Below is LLVM branch weight table, we only want to handle case 1, 2; //; // Case Taken:Nontaken Example; // 1. Unreachable 1048575:1 C++ throw, stdlib exit(),; // 2. Invoke-terminating 1:1048575; // 3. Coldblock 4:64 __builtin_expect; // 4. Loop Branch 124:4 For loop; // 5. PH/ZH/FPH 20:12",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:50,predict,predict,50,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['predict'],['predict']
Safety,"// We pass by reference to avoid expensive copies; // It can't be const reference in general, as users might want/need to call non-const methods on the values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:27,avoid,avoid,27,tree/dataframe/src/RDFInterfaceUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx,1,['avoid'],['avoid']
Safety,"// We pre-populate the deduced value of the partially-substituted; // pack with the specified value. This is not entirely correct: the; // value is supposed to have been substituted, not deduced, but the; // cases where this is observable require an exact type match anyway.; //; // FIXME: If we could represent a ""depth i, index j, pack elem k""; // parameter, we could substitute the partially-substituted pack; // everywhere and avoid this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp:431,avoid,avoid,431,interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateDeduction.cpp,1,['avoid'],['avoid']
Safety,"// We probe the function map twice to try and avoid creating a value handle; // around the function in common cases. This makes insertion a bit slower,; // but if we have to insert we're going to scan the whole function so that; // shouldn't matter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp:46,avoid,avoid,46,interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/AssumptionCache.cpp,1,['avoid'],['avoid']
Safety,"// We provide our own way of handling the entire #include ""file.c+""; // After we have saved the token reset the current one to; // something which is safe (semi colon usually means empty decl)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:150,safe,safe,150,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['safe'],['safe']
Safety,"// We push 'Function' either when a label is parsed or a .functype; // directive is parsed. The reason it is not easy to do this uniformly; // in a single place is,; // 1. We can't do this at label parsing time only because there are; // cases we don't have .functype directive before a function label,; // in which case we don't know if the label is a function at the time; // of parsing.; // 2. We can't do this at .functype parsing time only because we want to; // detect a function started with a label and not ended correctly; // without encountering a .functype directive after the label.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp:468,detect,detect,468,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,1,['detect'],['detect']
Safety,// We record each overload check line before emitting because subsequent Inst; // definitions may extend the number of permitted types (i.e. augment the; // Mask). Use std::map to avoid sorting the table by hash number.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:180,avoid,avoid,180,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,1,['avoid'],['avoid']
Safety,// We recurse into all record fields to detect incomplete and dependent types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp:40,detect,detect,40,interpreter/llvm-project/clang/tools/libclang/CXType.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CXType.cpp,1,['detect'],['detect']
Safety,"// We relax the restriction on use of incomplete types and non-object; // types with the type-based extension of _Generic. Allowing incomplete; // objects means those can be used as ""tags"" for a type-safe way to map; // to a value. Similarly, matching on function types rather than; // function pointer types can be useful. However, the restriction on VM; // types makes sense to retain as there are open questions about how; // the selection can be made at compile time.; //; // C11 6.5.1.1p2 ""The type name in a generic association shall specify a; // complete object type other than a variably modified type.""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:200,safe,safe,200,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['safe'],['safe']
Safety,"// We reorder declarations in RecordDecls because they may have another order; // in the ""to"" context than they have in the ""from"" context. This may happen; // e.g when we import a class like this:; // struct declToImport {; // int a = c + b;; // int b = 1;; // int c = 2;; // };; // During the import of `a` we import first the dependencies in sequence,; // thus the order would be `c`, `b`, `a`. We will get the normal order by; // first removing the already imported members and then adding them in the; // order as they appear in the ""from"" context.; //; // Keeping field order is vital because it determines structure layout.; //; // Here and below, we cannot call field_begin() method and its callers on; // ToDC if it has an external storage. Calling field_begin() will; // automatically load all the fields by calling; // LoadFieldsFromExternalStorage(). LoadFieldsFromExternalStorage() would; // call ASTImporter::Import(). This is because the ExternalASTSource; // interface in LLDB is implemented by the means of the ASTImporter. However,; // calling an import at this point would result in an uncontrolled import, we; // must avoid that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp:1138,avoid,avoid,1138,interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTImporter.cpp,1,['avoid'],['avoid']
Safety,// We reserved the last registers for this. Shift it down to the end of those; // which were actually used.; //; // FIXME: It might be safer to use a pseudoregister before replacement.; // FIXME: We should be able to eliminate unused input registers. We only; // cannot do this for the resources required for scratch access. For now we; // skip over user SGPRs and may leave unused holes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:135,safe,safer,135,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['safe'],['safer']
Safety,"// We return an invalid parameter as opposed to null to avoid having bogus; // diagnostics about an empty template parameter list.; // FIXME: Fix ParseTemplateParameterList to better handle nullptr results; // from here.; // Return a NTTP as if there was an error in a scope specifier, the user; // probably meant to write the type of a NTTP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp:56,avoid,avoid,56,interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseTemplate.cpp,1,['avoid'],['avoid']
Safety,// We save the actual erasing to avoid invalidating memory; // dependencies until we are done with everything.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:33,avoid,avoid,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,1,['avoid'],['avoid']
Safety,"// We say ""the nullability type invariant is violated"" when a location with a; // non-null type contains NULL or a function with a non-null return type returns; // NULL. Violations of the nullability type invariant can be detected either; // directly (for example, when NULL is passed as an argument to a nonnull; // parameter) or indirectly (for example, when, inside a function, the; // programmer defensively checks whether a nonnull parameter contains NULL and; // finds that it does).; //; // As a matter of policy, the nullability checker typically warns on direct; // violations of the nullability invariant (although it uses various; // heuristics to suppress warnings in some cases) but will not warn if the; // invariant has already been violated along the path (either directly or; // indirectly). As a practical matter, this prevents the analyzer from; // (1) warning on defensive code paths where a nullability precondition is; // determined to have been violated, (2) warning additional times after an; // initial direct violation has been discovered, and (3) warning after a direct; // violation that has been implicitly or explicitly suppressed (for; // example, with a cast of NULL to _Nonnull). In essence, once an invariant; // violation is detected on a path, this checker will be essentially turned off; // for the rest of the analysis; //; // The analyzer takes this approach (rather than generating a sink node) to; // ensure coverage of defensive paths, which may be important for backwards; // compatibility in codebases that were developed without nullability in mind.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:222,detect,detected,222,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,2,['detect'],['detected']
Safety,"// We scanned the old callgraph node, removing invalidated call sites and; // then added back newly found call sites. One thing that can happen is; // that an old indirect call site was deleted and replaced with a new direct; // call. In this case, we have devirtualized a call, and CGSCCPM would like; // to iteratively optimize the new code. Unfortunately, we don't really; // have a great way to detect when this happens. As an approximation, we; // just look at whether the number of indirect calls is reduced and the; // number of direct calls is increased. There are tons of ways to fool this; // (e.g. DCE'ing an indirect call and duplicating an unrelated block with a; // direct call) but this is close enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp:399,detect,detect,399,interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CallGraphSCCPass.cpp,1,['detect'],['detect']
Safety,"// We should *never* see a nested full-expression here, because if; // we fail to emit at +1, our caller must not retain after we close; // out the full-expression. This isn't as important in the unsafe; // emitter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:196,unsafe,unsafe,196,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['unsafe'],['unsafe']
Safety,"// We should have avoided introducing a new virtual register, and just; // directly assigned here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp:18,avoid,avoided,18,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CallLowering.cpp,1,['avoid'],['avoided']
Safety,// We should only get a null bound type if processing a dependent; // CFG. Recover by assuming nothing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp:75,Recover,Recover,75,interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/CFG.cpp,1,['Recover'],['Recover']
Safety,// We somehow specified dependent template arguments in an explicit; // instantiation. This should probably only happen during error; // recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:137,recover,recovery,137,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recovery']
Safety,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:443,avoid,avoid,443,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,1,['avoid'],['avoid']
Safety,// We special case the first iteration which we can detect due to the; // empty `ToSimplify` set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp:52,detect,detect,52,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInstSimplify.cpp,1,['detect'],['detect']
Safety,// We support 64-bit ANDs with immediates with 32-bits of leading zeroes; // by using a 32-bit operation with implicit zero extension. Detect such; // immediates here as the normal path expects bit 31 to be sign extended.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp:135,Detect,Detect,135,interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86TargetTransformInfo.cpp,1,['Detect'],['Detect']
Safety,"// We support any array type as ""consecutive"" block in the parameter; // save area. The element type defines the alignment requirement and; // whether the argument should go in GPRs, FPRs, or VRs if available.; //; // Note that clang uses this capability both to implement the ELFv2; // homogeneous float/vector aggregate ABI, and to avoid having to use; // ""byval"" when passing aggregates that might fully fit in registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:334,avoid,avoid,334,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['avoid'],['avoid']
Safety,// We touch up the compare instruction in MBB2 and move it to; // a previous BB to handle partially redundant case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:100,redund,redundant,100,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redund'],['redundant']
Safety,// We track through PHI only once to avoid infinite loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:37,avoid,avoid,37,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['avoid'],['avoid']
Safety,"// We track what is on the current and pending worklist to avoid inserting; // the same thing twice. We could avoid this with a custom priority queue,; // but this is probably not worth it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:59,avoid,avoid,59,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,2,['avoid'],['avoid']
Safety,// We track what is on the pending worklist to avoid inserting the same; // thing twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['avoid'],['avoid']
Safety,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but this; // is probably not worth it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,2,['avoid'],['avoid']
Safety,"// We track what is on the pending worklist to avoid inserting the same; // thing twice. We could avoid this with a custom priority queue, but; // this is probably not worth it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,2,['avoid'],['avoid']
Safety,"// We transform this using the identity:; // (N)(2^-e) == (N)(5^e)(10^-e); // This means we have to multiply N (the significand) by 5^e.; // To avoid overflow, we have to operate on numbers large; // enough to store N * 5^e:; // log2(N * 5^e) == log2(N) + e * log2(5); // <= semantics->precision + e * 137 / 59; // (log_2(5) ~ 2.321928 < 2.322034 ~ 137/59)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:144,avoid,avoid,144,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['avoid'],['avoid']
Safety,// We transitively check superregs. So we can remember this for later; // to avoid compiletime explosion in deep register hierarchies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp:77,avoid,avoid,77,interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TargetRegisterInfo.cpp,1,['avoid'],['avoid']
Safety,// We try to eliminate redundant compare instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:23,redund,redundant,23,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redund'],['redundant']
Safety,"// We use UTF-8 as the internal character encoding. On Windows,; // arguments passed to main() may not be encoded in UTF-8. In order; // to reliably detect encoding of command line arguments, we use an; // Windows API to obtain arguments, convert them to UTF-8, and then; // write them back to the Argv vector.; //; // There's probably other way to do the same thing (e.g. using; // wmain() instead of main()), but this way seems less intrusive; // than that.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp:149,detect,detect,149,interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/InitLLVM.cpp,1,['detect'],['detect']
Safety,"// We use a single common worklist for calls across the entire SCC. We; // process these in-order and append new calls introduced during inlining to; // the end. The PriorityInlineOrder is optional here, in which the smaller; // callee would have a higher priority to inline.; //; // Note that this particular order of processing is actually critical to; // avoid very bad behaviors. Consider *highly connected* call graphs where; // each function contains a small amount of code and a couple of calls to; // other functions. Because the LLVM inliner is fundamentally a bottom-up; // inliner, it can handle gracefully the fact that these all appear to be; // reasonable inlining candidates as it will flatten things until they become; // too big to inline, and then move on and flatten another batch.; //; // However, when processing call edges *within* an SCC we cannot rely on this; // bottom-up behavior. As a consequence, with heavily connected *SCCs* of; // functions we can end up incrementally inlining N calls into each of; // N functions because each incremental inlining decision looks good and we; // don't have a topological ordering to prevent explosions.; //; // To compensate for this, we don't process transitive edges made immediate; // by inlining until we've done one pass of inlining across the entire SCC.; // Large, highly connected SCCs still lead to some amount of code bloat in; // this model, but it is uniformly spread across all the functions in the SCC; // and eventually they all become too large to inline, rather than; // incrementally maknig a single function grow in a super linear fashion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:358,avoid,avoid,358,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,1,['avoid'],['avoid']
Safety,"// We use a stack based implemenation of DFS to avoid recursion.; // Defining DFS data structures:; // A pair (NodeIdx, EdgeIdx) at the top of the Stack denotes that; // - we are currently visiting Nodes[NodeIdx] and; // - the next edge to scan is Edges[NodeIdx][EdgeIdx]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:48,avoid,avoid,48,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,1,['avoid'],['avoid']
Safety,// We use an alternative sequence for SSE1 that extracts as v2f32 and; // then casts to i64. This avoids a 128-bit stack temporary being; // created by type legalization if we were to cast v4f32->v2i64.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:98,avoid,avoids,98,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoids']
Safety,"// We use crash recovery to make some of our APIs more reliable, implicitly; // enable it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:16,recover,recovery,16,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['recover'],['recovery']
Safety,// We use make_early_inc_range to avoid invalidation issues.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:34,avoid,avoid,34,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// We use memoization to avoid running the same matcher on the same; // AST node twice. This struct is the key for looking up match; // result. It consists of an ID of the MatcherInterface (for; // identifying the matcher), a pointer to the AST node and the; // bound nodes before the matcher was executed.; //; // We currently only memoize on nodes whose pointers identify the; // nodes (\c Stmt and \c Decl, but not \c QualType or \c TypeLoc).; // For \c QualType and \c TypeLoc it is possible to implement; // generation of keys for each type.; // FIXME: Benchmark whether memoization of non-pointer typed nodes; // provides enough benefit for the additional amount of code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp:25,avoid,avoid,25,interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/ASTMatchFinder.cpp,1,['avoid'],['avoid']
Safety,// We use the PPC namespace to avoid the need to prefix opcodes with PPC:: in; // the def file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp:31,avoid,avoid,31,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMacroFusion.cpp,1,['avoid'],['avoid']
Safety,"// We use the SSAUpdater to insert PHI nodes for the target addresses of; // indirect branches. We don't actually need the full power of the SSA updater; // in this particular case as we always have immediately available values, but; // this avoids us having to re-implement the PHI construction logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:242,avoid,avoids,242,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['avoid'],['avoids']
Safety,// We use the existence of '/lib/<triple>' as a directory to detect some; // common hurd triples that don't quite match the Clang triple for both; // 32-bit and 64-bit targets. Multiarch fixes its install triples to these; // regardless of what the actual target triple is.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp:61,detect,detect,61,interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Hurd.cpp,1,['detect'],['detect']
Safety,// We use the existence of '/lib/<triple>' as a directory to detect some; // common linux triples that don't quite match the Clang triple for both; // 32-bit and 64-bit targets. Multiarch fixes its install triples to these; // regardless of what the actual target triple is.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:61,detect,detect,61,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,2,['detect'],['detect']
Safety,"// We use uint64_t to avoid double rounding error of the following; // calculation: BP[i] = BP[i] * NewReachableSum / OldReachableSum; // The formula is taken from the private constructor; // BranchProbability(uint32_t Numerator, uint32_t Denominator)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:22,avoid,avoid,22,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,1,['avoid'],['avoid']
Safety,"// We want comparisons to null pointers to not be considered capturing,; // but need to guard against cases like gep(p, -ptrtoint(p2)) == null,; // which are equivalent to p == p2 and would capture the pointer.; //; // A dereferenceable pointer is a case where this is known to be safe,; // because the pointer resulting from such a construction would not be; // dereferenceable.; //; // It is not sufficient to check for inbounds GEP here, because GEP with; // zero offset is always inbounds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp:281,safe,safe,281,interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/CaptureTracking.cpp,1,['safe'],['safe']
Safety,"// We want index gap between two adjacent MI is as same as possible. Given; // total A available indexes, D is number of consecutive unassigned; // instructions, S is the step.; // |<- S-1 -> MI <- S-1 -> MI <- A-S*D ->|; // There're S-1 available indexes between unassigned instruction and its; // predecessor. There're A-S*D available indexes between the last; // unassigned instruction and its successor.; // Ideally, we want; // S-1 = A-S*D; // then; // S = (A+1)/(D+1); // An valid S must be integer greater than zero, so; // S <= (A+1)/(D+1); // =>; // A-S*D >= 0; // That means we can safely use (A+1)/(D+1) as step.; // In previous example, Step is 204, Index of B, C, MI, D is 1228, 1432,; // 1636, 1840.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp:592,safe,safely,592,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocFast.cpp,1,['safe'],['safely']
Safety,"// We want to avoid creating an unnecessary temporary+copy here;; // however, we need one in three cases:; // 1. If the argument is not byval, and we are required to copy the; // source. (This case doesn't occur on any common architecture.); // 2. If the argument is byval, RV is not sufficiently aligned, and; // we cannot force it to be sufficiently aligned.; // 3. If the argument is byval, but RV is not located in default; // or alloca address space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:14,avoid,avoid,14,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['avoid'],['avoid']
Safety,"// We want to avoid creation of any new non-constant SCEV. Since we are; // going to compare the operands to RHS, we should be certain that we don't; // need any size extensions for this. So let's decline all cases when the; // sizes of types of LHS and RHS do not match.; // TODO: Maybe try to get RHS from sext to catch more cases?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,// We want to avoid folding a LOAD into an ICMP node if as a result; // we would be forced to spill the condition code into a GPR.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,// We want to avoid hurting the compile time with analysis of too big trees.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,// We want to avoid matching :upper16: and :lower16: as we want these; // expressions to match in isImm0_65535Expr(),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['avoid'],['avoid']
Safety,"// We want to avoid misleadingly allowing something like ""mov r0, <symbol>""; // especially when we turn it into a movw and the expression <symbol> does; // not have a :lower16: or :upper16 as part of the expression. We don't; // want the behavior of silently truncating, which can be unexpected and; // lead to bugs that are difficult to find since this is an easy mistake; // to make.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/AsmParser/ARMAsmParser.cpp,1,['avoid'],['avoid']
Safety,"// We want to avoid qualified lookups, because they are expensive and; // difficult to construct. This is why we *artificially* push a scope and; // a decl context, where Sema should do the lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx:14,avoid,avoid,14,core/metacling/src/TClingCallbacks.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TClingCallbacks.cxx,1,['avoid'],['avoid']
Safety,"// We want to avoid use-scanning leveraging dominance informations.; // If a block doesn't dominate any of the loop exits, the none of the values; // defined in the loop can be used outside.; // We compute the set of blocks fullfilling the conditions in advance; // walking the dominator tree upwards until we hit a loop header.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,1,['avoid'],['avoid']
Safety,"// We want to avoid useless duplication.; // TODO: This is done automatically for binary operations. As UADDO_CARRY is; // not a binary operation, this is not really possible to leverage this; // existing mechanism for it. However, if more operations require the same; // deduplication logic, then it may be worth generalize.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:14,avoid,avoid,14,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// We want to clone the module in a new context to multi-thread the; // codegen. We do it by serializing partition modules to bitcode; // (while still on the main thread, in order to avoid data races) and; // spinning up new threads which deserialize the partitions into; // separate contexts.; // FIXME: Provide a more direct way to do this in LLVM.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp:183,avoid,avoid,183,interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ParallelCG.cpp,2,['avoid'],['avoid']
Safety,"// We want to collect all dependencies for correctness. Avoiding the real; // system dependencies (e.g. stl from /usr/lib) would probably be a good idea,; // but there is no way to distinguish between those and the ones that can be; // spuriously added by '-isystem' (e.g. to suppress warnings from those; // headers).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp:56,Avoid,Avoiding,56,interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/PrecompiledPreamble.cpp,1,['Avoid'],['Avoiding']
Safety,"// We want to detect if Root is part of a tree which represents a bunch; // of loads being merged into a larger load. We'll try to recognize patterns; // like, for example:; //; // Reg Reg; // \ /; // OR_1 Reg; // \ /; // OR_2; // \ Reg; // .. /; // Root; //; // Reg Reg Reg Reg; // \ / \ /; // OR_1 OR_2; // \ /; // \ /; // ...; // Root; //; // Each ""Reg"" may have been produced by a load + some arithmetic. This; // function will save each of them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp:14,detect,detect,14,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CombinerHelper.cpp,1,['detect'],['detect']
Safety,"// We want to know at compile time whether dynamic_cast or static_cast is; // used. First of all to avoid overhead, but also to avoid a compiler; // error when using dynamic_cast on a non-polymorphic class. In C++17,; // this can be done easily with `if constexpr`, but for the older; // standards we have to use a more verbose alternative. Both ways are; // explicitely implemented for different standards, so that when the; // minimum C++ standard for ROOT is raised to C++17 it's easy to remember; // that we can avoid much boilerplate code in this file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RRangeCast.hxx:100,avoid,avoid,100,core/foundation/inc/ROOT/RRangeCast.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RRangeCast.hxx,3,['avoid'],['avoid']
Safety,// We want to put an LFENCE before any instruction that; // may load or store. This LFENCE is intended to avoid leaking any secret; // data due to a given load or store. This results in closing the cache; // and memory timing side channels. We will treat terminators that load; // or store separately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp:106,avoid,avoid,106,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeExecutionSideEffectSuppression.cpp,1,['avoid'],['avoid']
Safety,"// We want to support three cases here:; // * passing a RooArgSet; // * passing a RooArgList; // * passing an initializer list; // Before, there was only an overload taking a RooArg set, which caused an; // implicit creation of a RooArgSet when a RooArgList was passed. This needs; // to be avoided, because if the passed RooArgList is owning the arguments,; // this information will be lost with the copy. The solution is to have one; // overload that takes a general RooAbsCollection, and one overload for; // RooArgList that is invoked in the case of passing an initializer list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h:291,avoid,avoided,291,roofit/roofitcore/inc/RooAbsArg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h,1,['avoid'],['avoided']
Safety,"// We will change CFG/DT during this traversal, so take precautions to; // avoid problems related to invalidated iterators. In fact, processing; // a child C of B cannot cause another child to be removed, but it can; // cause a new child to be added (which was a child of C before C itself; // was removed. This new child C, however, would have been processed; // prior to processing B, so there is no need to process it again.; // Simply keep a list of children of B, and traverse that list.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp:75,avoid,avoid,75,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonEarlyIfConv.cpp,1,['avoid'],['avoid']
Safety,"// We will detect whether a file changed and return 'Failure' for it, but; // we will also try to fail gracefully by setting up the SLocEntry.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:11,detect,detect,11,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,1,['detect'],['detect']
Safety,"// We will push the add through the select, but we can potentially do better; // if we know there is another add in the sequence and this is pointer math.; // In that case, we can absorb an add into the trailing memory op and avoid; // a 3-operand LEA which is likely slower than a 2-operand LEA.; // TODO: If target has ""slow3OpsLEA"", do this even without the trailing memop?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:226,avoid,avoid,226,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// We won't need DIFilename anymore. Clean it up to avoid its application; // on the next function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp:52,avoid,avoid,52,interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BasicBlockSectionsProfileReader.cpp,1,['avoid'],['avoid']
Safety,"// We would be able to merge only one extension in a load.; // Therefore, if we have more than 1 new extension we heuristically; // cut this search path, because it means we degrade the code quality.; // With exactly 2, the transformation is neutral, because we will merge; // one extension but leave one. However, we optimistically keep going,; // because the new extension may be removed too. Also avoid replacing a; // single free extension with multiple extensions, as this increases the; // number of IR instructions while not providing any savings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:400,avoid,avoid,400,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"// We would like to avoid converting closures which calculare addresses,; // as this should remain in GPRs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp:20,avoid,avoid,20,interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,1,['avoid'],['avoid']
Safety,// We would like to detect if we need to switch to a 64-bit symbol table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp:20,detect,detect,20,interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Object/ArchiveWriter.cpp,1,['detect'],['detect']
Safety,// We would like to restrict this hazard recognizer to only; // post-RA scheduling; we can tell that we're post-RA because we don't; // track VRegLiveness.; // Cortex-M7: TRM indicates that there is a single ITCM bank and two DTCM; // banks banked on bit 2. Assume that TCMs are in use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:34,hazard,hazard,34,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['hazard'],['hazard']
Safety,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:83,detect,detect,83,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,1,['detect'],['detect']
Safety,"// We'd like to avoid creating single-use virtual base registers.; // Because the FrameRefs are in sorted order, and we've already; // processed all FrameRefs before this one, just check whether or not; // the next FrameRef will be able to reuse this new register. If not,; // then don't bother creating it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp:16,avoid,avoid,16,interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LocalStackSlotAllocation.cpp,1,['avoid'],['avoid']
Safety,"// We're about to remove BB from the control flow. Before we do, sink any; // PHINodes into the unwind destination. Doing this before changing the; // control flow avoids some potentially slow checks, since we can currently; // be certain that UnwindDest and BB have no common predecessors (since they; // are both EH pads).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:164,avoid,avoids,164,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoids']
Safety,"// We're about to replace all uses of the FP_ROUND/FP_EXTEND with the; // extload we created. This will cause general havok on the dag because; // anything below the conversion could be folded into other existing nodes.; // To avoid invalidating 'I', back it up to the convert node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp:227,avoid,avoid,227,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelDAGToDAG.cpp,2,['avoid'],['avoid']
Safety,// We're at the point where the parsing of function declarator is finished.; //; // A common error is that users accidently add a virtual specifier; // (e.g. override) in an out-line method definition.; // We attempt to recover by stripping all these specifiers coming after; // the declarator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:220,recover,recover,220,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recover']
Safety,// We're expecting '__identifier' '(' identifier ')'. Try to recover; // if the parens are missing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp:61,recover,recover,61,interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPMacroExpansion.cpp,1,['recover'],['recover']
Safety,"// We're going to widen this vector op to a legal type by padding with undef; // elements. If the wide vector op is eventually going to be expanded to; // scalar libcalls, then unroll into scalar ops now to avoid unnecessary; // libcalls on the undef elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp:207,avoid,avoid,207,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/LegalizeVectorTypes.cpp,1,['avoid'],['avoid']
Safety,"// We're introducing an undef phi def, and need to set undef on any users of; // the previously local def to avoid artifically extending the lifetime; // through the block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:109,avoid,avoid,109,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['avoid'],['avoid']
Safety,"// We're only changing values in this loop, thus safe to keep iterators.; // Since this is computing a fixed point, the order of visit does not; // effect the result. TODO: We could use a worklist here and make this run; // much faster.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:49,safe,safe,49,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safe']
Safety,"// We're pretending the character didn't exist, so just try again with; // this lexer.; // (We manually eliminate the tail call to avoid recursion.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:131,avoid,avoid,131,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['avoid'],['avoid']
Safety,"// We're scaling the LHS to avoid a denormal input, and scale the denominator; // to avoid large values underflowing the result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:28,avoid,avoid,28,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,2,['avoid'],['avoid']
Safety,"// We're scheduling top-down but we're visiting the regions in; // bottom-up order, so we don't know the hazards at the start of a; // region. So assume no hazards (this should usually be ok as most; // blocks are a single region).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:105,hazard,hazards,105,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,2,['hazard'],['hazards']
Safety,"// We're trying to destroy something that is not a region. This may happen; // for a variety of reasons (unknown target region, concrete integer instead; // of target region, etc.). The current code makes an attempt to recover.; // FIXME: We probably don't really need to recover when we're dealing; // with concrete integers specifically.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp:219,recover,recover,219,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/ExprEngineCXX.cpp,2,['recover'],['recover']
Safety,"// We've determined that we are going to sink last ScanIdx instructions,; // and recorded them in InstructionsToSink. Now, some instructions may be; // unprofitable to sink. But that determination depends on the instructions; // that we are going to sink.; // First, forward scan: find the first instruction unprofitable to sink,; // recording all the ones that are profitable to sink.; // FIXME: would it be better, after we detect that not all are profitable.; // to either record the profitable ones, or erase the unprofitable ones?; // Maybe we need to choose (at runtime) the one that will touch least; // instrs?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:426,detect,detect,426,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['detect'],['detect']
Safety,"// We've established mechanical ability and aliasing, it's up to the caller; // to check fault safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:95,safe,safety,95,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safety']
Safety,// We've inserted the location into the map. The map will have coalesced; // adjacent intervals (variable fragments) that describe the same memory; // location. Use this knowledge to insert a debug location that describes; // that coalesced fragment. This may eclipse other locs we've just; // inserted. This is okay as redundant locs will be cleaned up later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:320,redund,redundant,320,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['redund'],['redundant']
Safety,"// We've proven all lanes safe to speculate, fall through.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:26,safe,safe,26,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['safe'],['safe']
Safety,"// We've pushed the return address to the stack, so add 16 to the offset.; // This is safe, since we already checked if it would overflow when we; // checked if this instruction was legal to outline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:86,safe,safe,86,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['safe'],['safe']
Safety,// Weight is added by one to avoid propagation errors introduced by; // 0 weights.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp:29,avoid,avoid,29,interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/SampleProfile.cpp,1,['avoid'],['avoid']
Safety,"// Weights are for internal use only. They are used by heuristics to help to; // estimate edges' probability. Example:; //; // Using ""Loop Branch Heuristics"" we predict weights of edges for the; // block BB2.; // ...; // |; // V; // BB1<-+; // | |; // | | (Weight = 124); // V |; // BB2--+; // |; // | (Weight = 4); // V; // BB3; //; // Probability of the edge BB2->BB1 = 124 / (124 + 4) = 0.96875; // Probability of the edge BB2->BB3 = 4 / (124 + 4) = 0.03125",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:161,predict,predict,161,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,1,['predict'],['predict']
Safety,"// When 'FillDelaySlot' is true, the existing logic will add; // noreorder before instruction and reorder after it. So there; // need exclude this case avoiding two '.set reorder'.; // The format of the first case is:; // .set noreorder; // bnezc; // nop; // .set reorder",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:152,avoid,avoiding,152,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['avoid'],['avoiding']
Safety,"// When -fcf-protection= is used, the inline asm adds an ENDBR. Suppress ENDBR; // for the function to avoid double ENDBR. This is a no-op without; // -fcf-protection=.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:103,avoid,avoid,103,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['avoid'],['avoid']
Safety,"// When -mbranch-protection= is used, the inline asm adds a BTI. Suppress BTI; // for the function to avoid double BTI. This is a no-op without; // -mbranch-protection=.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:102,avoid,avoid,102,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,1,['avoid'],['avoid']
Safety,"// When LSR detects uses of the same base address to access different; // types (e.g. unions), it will assume a conservative type for these; // uses:; // LSR Use: Kind=Address of void in addrspace(4294967295), ...; // The type Ty passed here would then be ""void"". Skip the alignment; // checks, but do not return false right away, since that confuses; // LSR into crashing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:12,detect,detects,12,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['detect'],['detects']
Safety,"// When UnifiedLTO is enabled, use the ThinLTO pre-link pipeline. This; // avoids compile-time performance regressions and keeps the pre-link; // LTO pipeline ""unified"" for both LTO modes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:75,avoid,avoids,75,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,1,['avoid'],['avoids']
Safety,"// When a PHI is used only to be compared with zero, it is safe to replace; // an incoming value proved as known nonzero with any non-zero constant.; // For example, in the code below, the incoming value %v can be replaced; // with any non-zero constant based on the fact that the PHI is only used to; // be compared with zero and %v is a known non-zero value:; // %v = select %cond, 1, 2; // %p = phi [%v, BB] ...; // icmp eq, %p, 0; // FIXME: To be simple, handle only integer type for now.; // This handles a small number of uses to keep the complexity down, and an; // icmp(or(phi)) can equally be replaced with any non-zero constant as the; // ""or"" will only add bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:59,safe,safe,59,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,1,['safe'],['safe']
Safety,"// When a call receives a reference to 'self', [Pre/Post]Call pass; // the SelfFlags from the object 'self' points to before the call to the new; // object after the call. This is to avoid invalidation of 'self' by logging; // functions.; // Another common pattern in classes with multiple initializers is to put the; // subclass's common initialization bits into a static function that receives; // the value of 'self', e.g:; // @code; // if (!(self = [super init])); // return nil;; // if (!(self = _commonInit(self))); // return nil;; // @endcode; // Until we can use inter-procedural analysis, in such a call, transfer the; // SelfFlags to the result of the call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp:183,avoid,avoid,183,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/ObjCSelfInitChecker.cpp,1,['avoid'],['avoid']
Safety,"// When a loop like ""for (int i = 0; i != n; ++i) { /* body */ }"" is rotated,; // we end up with a loop whose backedge-taken count is n - 1. Detect this; // case, and see if we can improve the bound.; //; // Explicitly handling this here is necessary because getUnsignedRange; // isn't context-sensitive; it doesn't know that we only care about the; // range inside the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:141,Detect,Detect,141,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Detect'],['Detect']
Safety,"// When a new class is created, we need to be able to find; // if there are any existing classes that have the same name; // after any typedefs are expanded. (This only really affects; // template arguments.) To avoid having to search through all classes; // in that case, we keep a hash table mapping from the fully; // typedef-expanded names to the original class names.; // An entry is made in the table only if they are actually different.; //; // In these objects, the TObjString base holds the typedef-expanded; // name (the hash key), and fOrigName holds the original class name; // (the value to which the key maps).; //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:212,avoid,avoid,212,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['avoid'],['avoid']
Safety,"// When a scalar epilogue is required, at least one iteration of the scalar; // loop has to execute. Adjust MaxTripCount accordingly to avoid picking a; // max VF that results in a dead vector loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:136,avoid,avoid,136,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avoid'],['avoid']
Safety,"// When a slot is loaded from in a block without being stored to in the; // same block, it is live-on-entry to this block. To avoid CFG analysis,; // consider this slot to be live-on-exit from all blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp:126,avoid,avoid,126,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonFrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// When avoiding a runtime check, the active.lane.mask inside the loop; // uses a modified trip count and the induction variable increment is; // done after the active.lane.mask intrinsic is called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp:8,avoid,avoiding,8,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.cpp,1,['avoid'],['avoiding']
Safety,"// When calling a lambda, both the call operator, and; // the conversion operator to function pointer; // are considered. But when constraint checking; // on the call operator fails, it will also fail on the; // conversion operator as the constraints are always the same.; // As the user probably does not intend to perform a surrogate call,; // we filter them out to produce better error diagnostics, ie to avoid; // showing 2 failed overloads instead of one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:408,avoid,avoid,408,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['avoid'],['avoid']
Safety,// When committing variable values to locations: tell transfer tracker that; // we've clobbered things. It may be able to recover the variable from a; // different location.; // Inform TTracker about any direct clobbers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:122,recover,recover,122,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['recover'],['recover']
Safety,// When compiling for codesize we avoid idiom recognition for a multi-block loop; // unless it is a loop_memset idiom or a memset/memcpy idiom in a nested loop.; //,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:34,avoid,avoid,34,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['avoid'],['avoid']
Safety,"// When converting to single-precision, we actually need to convert; // to double-precision first and then round to single-precision.; // To avoid double-rounding effects during that operation, we have; // to prepare the input operand. Bits that might be truncated when; // converting to double-precision are replaced by a bit that won't; // be lost at this stage, but is below the single-precision rounding; // position.; //; // However, if -enable-unsafe-fp-math is in effect, accept double; // rounding to avoid the extra overhead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:141,avoid,avoid,141,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,3,"['avoid', 'unsafe']","['avoid', 'unsafe-fp-math']"
Safety,"// When current instruction was not CTI, recover reorder state.; // The format of the second case is:; // .set noreoder; // bnezc; // add; // .set reorder",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp:41,recover,recover,41,interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/AsmParser/MipsAsmParser.cpp,1,['recover'],['recover']
Safety,"// When doing parseForModule avoid warning about the user code; // being loaded ... we probably might as well extend this to; // ALL warnings ... but this will suffice for now (working; // around a real bug in QT :().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:29,avoid,avoid,29,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['avoid'],['avoid']
Safety,"// When eliminating a tail call, we modify the values of the arguments.; // Therefore, if the byval parameter has a readonly attribute, we have to; // remove it. It is safe because, from the perspective of a caller, the; // byval parameter is always treated as ""readonly,"" even if the readonly; // attribute is removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:168,safe,safe,168,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,1,['safe'],['safe']
Safety,"// When emitting Stable ABI instrumentation, force outlining calls and avoid; // inlining shadow memory poisoning. While this is a big performance burden; // for now it allows full abstraction from implementation details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp:71,avoid,avoid,71,interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/SanitizerArgs.cpp,1,['avoid'],['avoid']
Safety,"// When encountering a TOC save instruction, call UpdateTOCSaves; // to add it to the TOCSaves map and mark any existing TOC saves; // it dominates as redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp:151,redund,redundant,151,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCMIPeephole.cpp,1,['redund'],['redundant']
Safety,"// When executing in parallel, process largest bitsize modules first to; // improve parallelism, and avoid starving the thread pool near the end.; // This saves about 15 sec on a 36-core machine while link `clang.exe` (out; // of 100 sec).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:101,avoid,avoid,101,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['avoid'],['avoid']
Safety,"// When files are aborted during processing (via TSelector::kAbortFile) the player; // invalidates the element by settign this bit. We need to ask for a new packet",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx:18,abort,aborted,18,proof/proofplayer/src/TEventIter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TEventIter.cxx,2,['abort'],['aborted']
Safety,"// When handling the close parenthesis, we greedily consume them to avoid; // empty strings in the pipeline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp:68,avoid,avoid,68,interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/PassBuilder.cpp,1,['avoid'],['avoid']
Safety,"// When inlining a callee produces new call sites, we want to keep track of; // the fact that they were inlined from the callee. This allows us to avoid; // infinite inlining in some obscure cases. To represent this, we use an; // index into the InlineHistory vector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:147,avoid,avoid,147,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,2,['avoid'],['avoid']
Safety,"// When layout is available, we can generally compute the difference using the; // getSymbolOffset path, which also avoids the possible slow fragment walk.; // However, linker relaxation may cause incorrect fold of A-B if A and B are; // separated by a linker-relaxable instruction. If the section contains; // instructions and InSet is false (not expressions in directive like; // .size/.fill), disable the fast path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:116,avoid,avoids,116,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,1,['avoid'],['avoids']
Safety,"// When merging multiple bit groups, instruction or is used.; // But when rotate is used, rldimi can inert the rotated value into any; // register, so instruction or can be avoided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:173,avoid,avoided,173,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['avoid'],['avoided']
Safety,// When multiple cases share the same code they can be combined during; // optimization. In that case the weights of the branch will be the sum of; // the individual weights. Make sure the combined sum of all neutral cases; // doesn't exceed the value of a single likely attribute.; // The additions both avoid divisions by 0 and make sure the weights of None; // don't exceed the weight of Likely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:305,avoid,avoid,305,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['avoid'],['avoid']
Safety,"// When not adding EH edges from calls, catch clauses; // can otherwise seem dead. Avoid noting them as dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:83,Avoid,Avoid,83,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['Avoid'],['Avoid']
Safety,"// When not using C++ modules, we now have a PCH and we can safely setup; // our callbacks without fearing that they get overwritten by clang code.; // The modules setup is handled above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp:60,safe,safely,60,interpreter/cling/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/Interpreter.cpp,1,['safe'],['safely']
Safety,"// When optimizations are requested, run KCIFPass after InstCombine to; // avoid unnecessary checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp:75,avoid,avoid,75,interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/BackendUtil.cpp,1,['avoid'],['avoid']
Safety,"// When optimizing for size, generate up to 5 extra bytes for a broadcast; // instruction to save 8 or more bytes of constant pool data.; // TODO: If multiple splats are generated to load the same constant,; // it may be detrimental to overall size. There needs to be a way to detect; // that condition to know if this is truly a size win.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:277,detect,detect,277,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,"// When peeking, just return the available data, don't loop. Otherwise,; // we may copy the same chunk of data multiple times into the; // output buffer, for instance when there is no more recent data; // in the socket's internal reception buffers.; // Note that in this case we don't update the counters of data received; // through this socket. They will be updated when the data is actually; // read. This avoids double counting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSSLSocket.cxx:409,avoid,avoids,409,net/net/src/TSSLSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TSSLSocket.cxx,1,['avoid'],['avoids']
Safety,// When possible use a private alias to avoid symbolic relocations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:40,avoid,avoid,40,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['avoid'],['avoid']
Safety,"// When preparing for LTO, avoid rotating loops with calls that could be; // inlined during the LTO stage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['avoid'],['avoid']
Safety,"// When profile data is not available, we need to be conservative in; // estimating the overall savings. Static branch prediction can usually; // guess the branch direction right (taken/non-taken), but the guessed; // branch probability is usually not biased enough. In case when the; // outlined region is predicted to be likely, its probability needs; // to be made higher (more biased) to not under-estimate the cost of; // function outlining. On the other hand, if the outlined region; // is predicted to be less likely, the predicted probablity is usually; // higher than the actual. For instance, the actual probability of the; // less likely target is only 5%, but the guessed probablity can be; // 40%. In the latter case, there is no need for further adjustment.; // FIXME: add an option for this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp:119,predict,prediction,119,interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/PartialInlining.cpp,4,['predict'],"['predicted', 'prediction']"
Safety,"// When rendered geometry doesn't include these attributes but the material does,; // use these default values in WebGL. This avoids errors when buffer data is missing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:126,avoid,avoids,126,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoids']
Safety,"// When returning 'inreg {i32, i32 }', two consecutive i32 arguments can; // reside in the same register in the high and low bits. Reuse the; // CopyFromReg previous node to avoid duplicate copies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp:174,avoid,avoid,174,interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/SparcISelLowering.cpp,2,['avoid'],['avoid']
Safety,"// When the MDNode can be part of the type system, the DIE can be shared; // across CUs.; // Combining type units and cross-CU DIE sharing is lower value (since; // cross-CU DIE sharing is used in LTO and removes type redundancy at that; // level already) but may be implementable for some value in projects; // building multiple independent libraries with LTO and then linking those; // together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp:218,redund,redundancy,218,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.cpp,1,['redund'],['redundancy']
Safety,"// When the instrumented function is a COMDAT function, we cannot use a; // private alias. If we did, we would create reference to a local label in; // this function's section. If this version of the function isn't selected by; // the linker, then the metadata would introduce a reference to a discarded; // section. So, for COMDAT functions, we need to adjust the linkage of the; // alias. Using hidden visibility avoids a dynamic relocation and an entry in; // the dynamic symbol table.; //; // Note that this handles COMDAT functions with visibility other than Hidden,; // since that case is covered in shouldUsePublicSymbol()",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:415,avoid,avoids,415,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,1,['avoid'],['avoids']
Safety,// When the linkage is not internal we must emit an alias for the original; // variable name as it may be accessed from another object. On non-Mach-O; // we can also emit an alias for internal linkage as it's safe to do so.; // It's not safe on Mach-O as the alias (and thus the portion of the; // MergedGlobals variable) may be dead stripped at link time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp:209,safe,safe,209,interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalMerge.cpp,2,['safe'],['safe']
Safety,"// When the map is empty, avoid the overhead of advancing/retreating past; // empty buckets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:26,avoid,avoid,26,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,1,['avoid'],['avoid']
Safety,"// When the region is symbolic and we do not have any information about it,; // assume that this is an array to avoid false positives.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp:112,avoid,avoid,112,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/PointerArithChecker.cpp,1,['avoid'],['avoid']
Safety,"// When the scalar of G_DUP is an s8/s16 gpr, they can't be selected by; // imported patterns. Do it manually here. Avoiding generating s16 gpr is; // difficult because at RBS we may end up pessimizing the fpr case if we; // decided to add an anyextend to fix this. Manual selection is the most; // robust solution for now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:116,Avoid,Avoiding,116,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['Avoid'],['Avoiding']
Safety,"// When the scheduler detects a stall, it will call AdvanceCycle() without; // emitting any instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:22,detect,detects,22,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['detect'],['detects']
Safety,"// When these options are used, the compiler is allowed to apply; // optimizations that may affect the final result. For example; // (x+y)+z is transformed to x+(y+z) but may not give the same; // final result; it's not value safe.; // Another example can be to simplify x/x to 1.0 but x could be 0.0, INF; // or NaN. Final result may then differ. An error is issued when the eval; // method is set with one of these options.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:226,safe,safe,226,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['safe'],['safe']
Safety,"// When we are going to clone an exit, we don't need to clone all the; // instructions in the exit block and we want to ensure we have an easy; // place to merge the CFG, so split the exit first. This is always safe to; // do because there cannot be any non-loop predecessors of a loop exit in; // loop simplified form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:211,safe,safe,211,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,1,['safe'],['safe']
Safety,"// When we are musttail, additional checks have been done and we can safely ignore this check; // At least two cases here: if caller is fastcc then we can't have any; // memory arguments (we'd be expected to clean up the stack afterwards). If; // caller is C then we could potentially use its argument area.; // FIXME: for now we take the most conservative of these in both cases:; // disallow all variadic memory operands.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:69,safe,safely,69,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['safe'],['safely']
Safety,"// When we can emit a TB(N)Z, prefer that.; //; // Handle non-commutative condition codes first.; // Note that we don't want to do this when we have a G_AND because it can; // become a tst. The tst will make the test bit in the TB(N)Z redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:235,redund,redundant,235,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['redund'],['redundant']
Safety,"// When we detect target captures we are looking from inside the; // target region, therefore we need to propagate the capture from the; // enclosing region. Therefore, the capture is not initially nested.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:11,detect,detect,11,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['detect'],['detect']
Safety,"// When we don't have a branch predictor it's always cheaper to not take a; // branch than take it, so we have to take that into account.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:31,predict,predictor,31,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['predict'],['predictor']
Safety,"// When we emulate implicit 'this->' in an unqualified lookup, we might; // end up with an invalid naming class. In that case, we avoid emulating; // 'this->' qualifier to satisfy preconditions of the access checking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:130,avoid,avoid,130,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['avoid'],['avoid']
Safety,// When we enter here we should have already checked that it is safe,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:64,safe,safe,64,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,1,['safe'],['safe']
Safety,"// When we found the lifetime markers refers to a; // subrange of the original alloca, ignore the lifetime; // markers to avoid misleading the analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:122,avoid,avoid,122,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['avoid'],['avoid']
Safety,"// When we haven't passed in Op0, Upper will be a constant. In order to; // prevent folding back to the large immediate in `Or = getNode(...)` we run; // SelectCode first and end up with an opaque machine node. This means that; // we need to use a handle to keep track of Upper in case it gets CSE'd by; // SelectCode.; //; // Note that in the case where Op0 is passed in we could just call; // SelectCode(Upper) later, along with the SelectCode(Or), and avoid needing; // the handle at all, but it's fine to do it here.; //; // TODO: This is a pretty hacky way to do this. Can we do something that; // doesn't require a two paragraph explanation?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp:455,avoid,avoid,455,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// When we know the load's address is loop invariant and the instruction; // in the original scalar loop was unconditionally executed then we; // don't need to mark it as a predicated instruction. Tail folding may; // introduce additional predication, but we're guaranteed to always have; // at least one active lane. We call Legal->blockNeedsPredication here; // because it doesn't query tail-folding. For stores, we need to prove; // both speculation safety (which follows from the same argument as loads),; // but also must prove the value being stored is correct. The easiest; // form of the later is to require that all values stored are the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:453,safe,safety,453,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['safe'],['safety']
Safety,"// When we remap instructions within the same module, we want to avoid; // duplicating inlined DISubprograms, so record all subprograms we find as we; // duplicate instructions and then freeze them in the MD map. We also record; // information about dbg.value and dbg.declare to avoid duplicating the; // types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:65,avoid,avoid,65,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,2,['avoid'],['avoid']
Safety,"// When y<10^-6 avoid W4 algorithm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx:16,avoid,avoid,16,math/mathcore/src/TMath.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/TMath.cxx,1,['avoid'],['avoid']
Safety,"// Where in the prologue we move the CR fields depends on how many scratch; // registers we have, and if we need to save the link register or not. This; // lambda is to avoid duplicating the logic in 2 places.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp:169,avoid,avoid,169,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCFrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// Whether the function contains any irreducible control flow, useful for; // being accurately able to detect loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:103,detect,detect,103,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['detect'],['detect']
Safety,"// Whether these functions overflow depends on the runtime strlen of the; // string, not just the buffer size, so emitting the ""always overflow""; // diagnostic isn't quite right. We should still diagnose passing a buffer; // size larger than the destination buffer though; this is a runtime abort; // in _FORTIFY_SOURCE mode, and is quite suspicious otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:291,abort,abort,291,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['abort'],['abort']
Safety,// Whether to use MAD_64_32 for partial products whose high half is; // discarded. This avoids some ADD instructions but risks false dependency; // stalls on some subtargets in some cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:88,avoid,avoids,88,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,2,"['avoid', 'risk']","['avoids', 'risks']"
Safety,"// Whether we should do DebugCounting at all. DebugCounters aren't; // thread-safe, so this should always be false in multithreaded scenarios.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DebugCounter.h:78,safe,safe,78,interpreter/llvm-project/llvm/include/llvm/Support/DebugCounter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DebugCounter.h,1,['safe'],['safe']
Safety,"// Which typedef to avoid stripping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.h:20,avoid,avoid,20,core/metacling/src/TCling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.h,1,['avoid'],['avoid']
Safety,"// While AVR has different address spaces, they are all represented by; // 16-bit pointers that can be freely casted between (of course, a pointer; // must be cast back to its original address space to be dereferenceable).; // To be safe, also check the pointer size in case we implement __memx; // pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.h:233,safe,safe,233,interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRTargetMachine.h,1,['safe'],['safe']
Safety,"// While some warnings are attached to AST nodes (mostly path-sensitive; // checks), others are simply associated with a plain source location; // or range. Figuring out the node based on locations can be tricky,; // so instead, we traverse the whole body of the declaration and gather; // information on ALL suppressions. After that we can simply check if; // any of those suppressions affect the warning in question.; //; // Traversing AST of a function is not a heavy operation, but for; // large functions with a lot of bugs it can make a dent in performance.; // In order to avoid this scenario, we cache traversal results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp:580,avoid,avoid,580,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugSuppression.cpp,1,['avoid'],['avoid']
Safety,"// While the next two tokens are 'period' 'identifier', repeatedly parse it as; // a field access. We have to avoid consuming assembler directives that look; // like '.' 'else'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:110,avoid,avoid,110,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,1,['avoid'],['avoid']
Safety,"// While volatile access cannot be eliminated, they do not have to clobber; // non-aliasing locations, as normal accesses, for example, can be safely; // reordered with volatile accesses.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp:143,safe,safely,143,interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryDependenceAnalysis.cpp,1,['safe'],['safely']
Safety,// White-list intrinsics that are safe to drop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp:34,safe,safe,34,interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/AsmParser/LLParser.cpp,1,['safe'],['safe']
Safety,"// Windows systems and possibly others don't declare abort() to be noreturn,; // so use the unreachable builtin to avoid a Clang self-host warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp:53,abort,abort,53,interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ErrorHandling.cpp,2,"['abort', 'avoid']","['abort', 'avoid']"
Safety,// With Zbb we can sign extend and let LegalizeDAG use minu/maxu. Using; // sign extend allows overflow of the lower 32 bits to be detected on; // the promoted size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:131,detect,detected,131,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['detect'],['detected']
Safety,"// With a fatal failure in the module loader, we abort parsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:49,abort,abort,49,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,3,['abort'],['abort']
Safety,"// With compilation database, we may open different files; // concurrently or we may write the same file concurrently. So we; // use a map here to allow multiple compile commands to write to the; // same file. Also we need a lock here to avoid data race.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp:238,avoid,avoid,238,interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-scan-deps/ClangScanDeps.cpp,1,['avoid'],['avoid']
Safety,"// With devtoolset on RHEL, we want to add a bin directory that is relative; // to the detected gcc install, because if we are using devtoolset gcc then; // we want to use other tools from devtoolset (e.g. ld) instead of the; // standard system tools.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp:87,detect,detected,87,interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Linux.cpp,1,['detect'],['detected']
Safety,"// With garbage collection, deallocation typically occurs solely at or after; // safepoints. If we're compiling for a collector which uses the; // gc.statepoint infrastructure, safepoints aren't explicitly present; // in the IR until after lowering from abstract to physical machine model.; // The collector could chose to mix explicit deallocation and gc'd objects; // which is why we need the explicit opt in on a per collector basis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp:81,safe,safepoints,81,interpreter/llvm-project/llvm/lib/IR/Value.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Value.cpp,2,['safe'],['safepoints']
Safety,"// With local aliases, we need to provide another externally visible; // symbol __odr_asan_XXX to detect ODR violation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:98,detect,detect,98,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,1,['detect'],['detect']
Safety,"// With the CSE-driven heuristic, we are about to slap two values at the; // beginning of the expression whereas they could live very late in the CFG.; // When using the CSE-local heuristic we avoid creating dependences from; // completely unrelated part of the CFG by limiting the expression; // reordering on the values that live in the first seen basic block.; // The main idea is that we want to avoid forming expressions that would; // become loop dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:193,avoid,avoid,193,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,2,['avoid'],['avoid']
Safety,"// With the incompatible ABI, this will need to be replaced with a direct; // reference to the class symbol. For the compatible nonfragile ABI we are; // still performing this lookup at run time but emitting the symbol for the; // class externally so that we can make the switch later.; //; // Libobjc2 contains an LLVM pass that replaces calls to objc_lookup_class; // with memoized versions or with static references if it's safe to do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:427,safe,safe,427,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['safe'],['safe']
Safety,"// WithMinOffset is the lowest address in the group,; // WithMinOffset.Addr = Base+Start.; // Align instructions for both HVX (V6_valign) and scalar (S2_valignrb); // mask off unnecessary bits, so it's ok to just the original pointer as; // the alignment amount.; // Do an explicit down-alignment of the address to avoid creating an; // aligned instruction with an address that is not really aligned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp:315,avoid,avoid,315,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonVectorCombine.cpp,1,['avoid'],['avoid']
Safety,"// Within the buckets, sort each bucket by memcmp of the symbol's name. It's; // important that we use the same sorting algorithm as is used by the; // reference implementation to ensure that the search for a record within a; // bucket can properly early-out when it detects the record won't be found.; // The algorithm used here corresponds to the function; // caseInsensitiveComparePchPchCchCch in the reference implementation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp:267,detect,detects,267,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/GSIStreamBuilder.cpp,1,['detect'],['detects']
Safety,"// Without this setb optimization, the outer SELECT_CC will be manually; // selected to SELECT_CC_I4/SELECT_CC_I8 Pseudo, then expand-isel-pseudos pass; // transforms pseudo instruction to isel instruction. When there are more than; // one use for result like zext/sext, with current optimization we only see; // isel is replaced by setb but can't see any significant gain. Since; // setb has longer latency than original isel, we should avoid this. Another; // point is that setb requires comparison always kept, it can break the; // opportunity to get the comparison away if we have in future.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp:438,avoid,avoid,438,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,// Workaround for HW data hazard bug observed only in GFX90A. When there; // is a DGEMM instruction in-between a VALU and a VMEM instruction it; // causes the SQ to incorrectly not insert two wait states between the two; // instructions needed to avoid data hazard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:26,hazard,hazard,26,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,3,"['avoid', 'hazard']","['avoid', 'hazard']"
Safety,"// Workaround for https://gcc.gnu.org/bugzilla/show_bug.cgi?id=323; // The same integer must convert to the same double, per the standard.; // However we see 64-vs-80-bit precision comparisons with gcc-7 -O3 -m32.; // So we avoid floating point promotion for exact comparisons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp:224,avoid,avoid,224,interpreter/llvm-project/llvm/lib/Support/JSON.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/JSON.cpp,1,['avoid'],['avoid']
Safety,// Workaround to avoid the crash until upstream issue is fixed:; // https://github.com/llvm/llvm-project/issues/55214,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/DbiModuleList.cpp:17,avoid,avoid,17,interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/DbiModuleList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/PDB/Native/DbiModuleList.cpp,1,['avoid'],['avoid']
Safety,// Workaround to detect a statement thrown out by CFGBuilder:; // case X: {} case Y:; // case X: ; case Y:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:17,detect,detect,17,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['detect'],['detect']
Safety,// Wrap MemorySSA result to ensure address stability of internal MemorySSA; // pointers after construction. Use a wrapper class instead of plain; // unique_ptr<MemorySSA> to avoid build breakage on MSVC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:174,avoid,avoid,174,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,1,['avoid'],['avoid']
Safety,// Wrap double-quotes around a '%s' specifier and limit its maximum; // length. Ideally we'd also somehow escape special characters in the; // contents but printf doesn't support that.; // FIXME: '%s' formatting is not safe in general.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:219,safe,safe,219,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['safe'],['safe']
Safety,"// Wrap return value with a recovery expression of the previous type.; // If no deduction yet, use DependentTy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:28,recover,recovery,28,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['recover'],['recovery']
Safety,// WrappedMemFunction; /**; Template class to wrap any C++ callable object; implementing operator() (const double * x) in a multi-dimensional function interface.; It provides a ROOT::Math::IGenMultiFunction-like signature. Note: If you want to wrap just the reference (to avoid copying) you need to use; Func& or const Func & as template parameter. The former should be used when the; operator() is not a const method of Func. @ingroup GenFunc. */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h:272,avoid,avoid,272,math/mathcore/inc/Math/WrappedFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/WrappedFunction.h,1,['avoid'],['avoid']
Safety,"// Wrapper for getting the safety from the parallel world.; // Takes care of caching mechanics and talking to the Safety function of parallel world.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:27,safe,safety,27,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,2,"['Safe', 'safe']","['Safety', 'safety']"
Safety,"// Wrapper to query additional information for instructions like metadata or; // keywords like nsw, which provides conservative results if those cannot; // be safely used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:159,safe,safely,159,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,1,['safe'],['safely']
Safety,"// Write all bundles along with the start/end markers. If an error was found; // writing the end of the bundle component, abort the bundle writing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/OffloadBundler.cpp:122,abort,abort,122,interpreter/llvm-project/clang/lib/Driver/OffloadBundler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/OffloadBundler.cpp,1,['abort'],['abort']
Safety,"// Write all persistent TClasses.; // Avoid plugins.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/rootpcm/src/rootclingIO.cxx:38,Avoid,Avoid,38,io/rootpcm/src/rootclingIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/rootpcm/src/rootclingIO.cxx,1,['Avoid'],['Avoid']
Safety,"// Write case; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/MainEvent.cxx:175,detect,detector,175,test/MainEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/MainEvent.cxx,1,['detect'],['detector']
Safety,"// Write out the dependency targets, trying to avoid overly long; // lines when possible. We try our best to emit exactly the same; // dependency file as GCC>=10, assuming the included files are the; // same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:47,avoid,avoid,47,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,1,['avoid'],['avoid']
Safety,// Write the result out to stderr avoiding errs() because raw_ostreams can; // call report_fatal_error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/FatalErrorHandler.cpp:34,avoid,avoiding,34,interpreter/llvm-project/clang/tools/libclang/FatalErrorHandler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/FatalErrorHandler.cpp,1,['avoid'],['avoiding']
Safety,// Write to a temporary string to avoid unnecessary flushing on errs().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp:34,avoid,avoid,34,interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/HeaderIncludeGen.cpp,1,['avoid'],['avoid']
Safety,// Write to a temporary to avoid race condition,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/lib/Support/Caching.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Caching.cpp,1,['avoid'],['avoid']
Safety,// WriteIndexesThinBackend should always return 1 to prevent module; // re-ordering and avoid non-determinism in the final link.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp:88,avoid,avoid,88,interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/LTO/LTO.cpp,1,['avoid'],['avoid']
Safety,// Wrong zeros may appear when points sit on a regular grid.; // The following line try to avoid this problem.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:91,avoid,avoid,91,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// Wrong zeros may appear when points sit on a regular grid.; // The following line try to avoid this problem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx:91,avoid,avoid,91,hist/hist/src/TGraphDelaunay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphDelaunay.cxx,1,['avoid'],['avoid']
Safety,"// X % 1.0 (doesn't simplify, but it is safe)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:40,safe,safe,40,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,1,['safe'],['safe']
Safety,"// X is a number from signed range, Y is interpreted as signed.; // Even if Y is SINT_MAX, (X - Y) does not reach SINT_MIN. So the only; // thing we should care about is that we didn't cross SINT_MAX.; // So, if Y is positive, we subtract Y safely.; // Rule 1: Y > 0 ---> Y.; // If 0 <= -Y <= (SINT_MAX - X), we subtract Y safely.; // Rule 2: Y >=s (X - SINT_MAX) ---> Y.; // If 0 <= (SINT_MAX - X) < -Y, we can only subtract (X - SINT_MAX).; // Rule 3: Y <s (X - SINT_MAX) ---> (X - SINT_MAX).; // It gives us smax(Y, X - SINT_MAX) to subtract in all cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:241,safe,safely,241,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,2,['safe'],['safely']
Safety,"// X is a number from unsigned range, Y is interpreted as signed.; // Even if Y is SINT_MIN, (X - Y) does not reach UINT_MAX. So the only; // thing we should care about is that we didn't cross zero.; // So, if Y is negative, we subtract Y safely.; // Rule 1: Y <s 0 ---> Y.; // If 0 <= Y <= X, we subtract Y safely.; // Rule 2: Y <=s X ---> Y.; // If 0 <= X < Y, we should stop at 0 and can only subtract X.; // Rule 3: Y >s X ---> X.; // It gives us smin(X, Y) to subtract in all cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:239,safe,safely,239,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,2,['safe'],['safely']
Safety,"// X sdiv (1 << Y) -> X udiv (1 << Y) ( -> X u>> Y); // Safe because the only negative value (1 << Y) can take on is; // INT_MIN, and X sdiv INT_MIN == X udiv INT_MIN == 0 if X doesn't have; // the sign bit set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:56,Safe,Safe,56,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['Safe'],['Safe']
Safety,// X86 doesn't have an i8 cmov. If both operands are the result of a truncate; // widen the cmov and push the truncate through. This avoids introducing a new; // branch during isel and doesn't add any extensions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:133,avoid,avoids,133,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoids']
Safety,// XXX: cast to int is needed to avoid stupid warning:; // compare with unsigned is always true,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp:33,avoid,avoid,33,interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/Disassembler/AMDGPUDisassembler.cpp,1,['avoid'],['avoid']
Safety,"// XXXX Fix this. It seems we could have flat shading with usage of simple shaders.; // XXXX Also, we could do edge detect on the server for outlines.; // XXXX a) 3d objects - angle between triangles >= 85 degrees (or something);; // XXXX b) 2d objects - segment only has one triangle.; // XXXX Somewhat orthogonal - when we do tesselation, conversion from quads to; // XXXX triangles is trivial, we could do it before invoking the big guns (if they are even needed).; // XXXX Oh, and once triangulated, we really don't need to store 3 as number of verts in a poly each time.; // XXXX Or do we? We might need it for projection stuff.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElements.js:116,detect,detect,116,ui5/eve7/lib/EveElements.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElements.js,2,['detect'],['detect']
Safety,"// Yeah, we have a task, grab it and release the lock on the queue; // We first need to signal that we are active before popping the queue; // in order for wait() to properly detect that even if the queue is; // empty, there is still a task in flight.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp:175,detect,detect,175,interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ThreadPool.cpp,1,['detect'],['detect']
Safety,"// Z / (1.0 / Y) => (Y * Z); //; // This is a special case of Z / (X / Y) => (Y * Z) / X, with X = 1.0. The; // m_OneUse check is avoided because even in the case of the multiple uses; // for 1.0/Y, the number of instructions remain the same and a division is; // replaced by a multiplication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:130,avoid,avoided,130,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['avoid'],['avoided']
Safety,// Z N V; // The instruction uses the V bit or C bit which is not safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:66,safe,safe,66,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,2,['safe'],['safe']
Safety,"// Zap all values, resetting the keys back to non-present (not tombstone),; // which is safe because we're removing all elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:88,safe,safe,88,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,1,['safe'],['safe']
Safety,// Zap the fully redundant load.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:17,redund,redundant,17,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,2,['redund'],['redundant']
Safety,// Zero is either safe or not in the range. The output range is composed by; // the result of countLeadingZero of the two extremes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp:18,safe,safe,18,interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantRange.cpp,1,['safe'],['safe']
Safety,// Zero out now to ease cleanup during crash recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:45,recover,recovery,45,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['recover'],['recovery']
Safety,"// [any flop] C, undef -> NaN; // [any flop] undef, C -> NaN; // We could potentially specialize NaN/Inf constants vs. 'normal'; // constants (possibly differently depending on opcode and operand). This; // would allow returning undef sometimes. But it is always safe to fold to; // NaN because we can choose the undef operand as NaN, and any FP opcode; // with a NaN operand will propagate NaN.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp:263,safe,safe,263,interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/ConstantFold.cpp,1,['safe'],['safe']
Safety,"// \returns true if the subtarget has a hazard requiring an ""s_nop 0""; // instruction before ""s_sendmsg sendmsg(MSG_DEALLOC_VGPRS)"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:40,hazard,hazard,40,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['hazard'],['hazard']
Safety,// __DEVICE__ is a helper macro with common set of attributes for the wrappers; // we implement in this file. We need static in order to avoid emitting unused; // functions and __forceinline__ helps inlining these wrappers at -O1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h:137,avoid,avoid,137,interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_cuda_device_functions.h,2,['avoid'],['avoid']
Safety,"// __HIP_OVERLOAD2 is used to resolve function calls with mixed float/double; // or integer argument to avoid compilation error due to ambibuity. e.g.; // max(5.0f, 6.0) is resolved with max(double, double).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:104,avoid,avoid,104,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,1,['avoid'],['avoid']
Safety,// __declspec(safebuffers) disables stack guards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp:14,safe,safebuffers,14,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.cpp,1,['safe'],['safebuffers']
Safety,"// __unknown_anytype(...) is a special case used by the debugger when; // it has no idea what a function's signature is.; //; // We want to build this call essentially under the K&R; // unprototyped rules, but making a FunctionNoProtoType in C++; // would foul up all sorts of assumptions. However, we cannot; // simply pass all arguments as variadic arguments, nor can we; // portably just call the function under a non-variadic type; see; // the comment on IR-gen's TargetInfo::isNoProtoCallVariadic.; // However, it turns out that in practice it is generally safe to; // call a function declared as ""A foo(B,C,D);"" under the prototype; // ""A foo(B,C,D,...);"". The only known exception is with the; // Windows ABI, where any variadic function is implicitly cdecl; // regardless of its normal CC. Therefore we change the parameter; // types to match the types of the arguments.; //; // This is a hack, but it is far superior to moving the; // corresponding target-specific code from IR-gen to Sema/AST.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:562,safe,safe,562,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['safe'],['safe']
Safety,// `It` is now positioned at the beginning of a range of instructions; // which may be outlinable. Check if each instruction is known to be safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:140,safe,safe,140,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,1,['safe'],['safe']
Safety,"// `MI` is a br_table instruction with a dummy default target argument. This; // function finds and adds the default target argument and removes any redundant; // range check preceding the br_table. Returns the MBB that the br_table is; // moved into so it can be removed from further consideration, or nullptr if the; // br_table cannot be optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp:149,redund,redundant,149,interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/WebAssemblyFixBrTableDefaults.cpp,1,['redund'],['redundant']
Safety,"// `isKnownNonZero` does more analysis than just `!KnownBits.One.isZero()`; // but to avoid unnecessary work, first just if this is an obvious case.; // if X non-zero and NoOverflow(X * Y); // (icmp eq/ne Y)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['avoid'],['avoid']
Safety,"// a structure for safety evaluation (caching) purpose; // to be stored per 3D grid voxel",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:19,safe,safety,19,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['safe'],['safety']
Safety,"// abort",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:3,abort,abort,3,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['abort'],['abort']
Safety,"// abort if out of bounds",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUri.cxx:3,abort,abort,3,core/base/src/TUri.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUri.cxx,3,['abort'],['abort']
Safety,"// abort process button",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TSessionViewer.h:3,abort,abort,3,gui/sessionviewer/inc/TSessionViewer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/inc/TSessionViewer.h,1,['abort'],['abort']
Safety,"// abort request",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rooturlschemehandler.cpp:3,abort,abort,3,gui/qt5webdisplay/rooturlschemehandler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rooturlschemehandler.cpp,1,['abort'],['abort']
Safety,// abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:3,abort,abort,3,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['abort'],['abort']
Safety,"// abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp:3,abort,abort,3,interpreter/cling/lib/Interpreter/DynamicLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.cpp,1,['abort'],['abort']
Safety,"// access member to avoid unnecessarily creating fit result if wasnt needed; // create a new subpad and draw fitResult on it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx:20,avoid,avoid,20,roofit/xroofit/src/xRooHypoSpace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooHypoSpace.cxx,1,['avoid'],['avoid']
Safety,"// adaptStartOfLine will break after lines starting with /** if the comment; // is broken anywhere. Avoid emitting this break twice here.; // Example: in /** longtextcomesherethatbreaks */ (with ColumnLimit 20) will; // insert a break after /**, so this code must not insert the same break.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp:100,Avoid,Avoid,100,interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.cpp,1,['Avoid'],['Avoid']
Safety,"// adc, sbc instructions; // To avoid stack clash, allocation is performed by block and each block is; // probed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,1,['avoid'],['avoid']
Safety,"// add ; to avoid printing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:12,avoid,avoid,12,hist/hist/src/TFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx,1,['avoid'],['avoid']
Safety,"// add a dummy statement to avoid warning for unused input",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_EyeLike.hxx:28,avoid,avoid,28,tmva/sofie/inc/TMVA/ROperator_EyeLike.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_EyeLike.hxx,2,['avoid'],['avoid']
Safety,"// add an eps to avoid failing the search",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stressTF1.cxx:17,avoid,avoid,17,math/mathcore/test/stressTF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stressTF1.cxx,1,['avoid'],['avoid']
Safety,"// add an epsilon to avoid exact vertical lines.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:21,avoid,avoid,21,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,1,['avoid'],['avoid']
Safety,"// add main() to avoid a linking error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx:17,avoid,avoid,17,math/mathcore/test/testGradient.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testGradient.cxx,1,['avoid'],['avoid']
Safety,"// add object to current directory to avoid mem leak",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterPlot.cxx:38,avoid,avoid,38,roofit/roostats/src/HypoTestInverterPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterPlot.cxx,1,['avoid'],['avoid']
Safety,"// add object to top-level directory to avoid mem leak",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterPlot.cxx:40,avoid,avoid,40,roofit/roostats/src/HypoTestInverterPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterPlot.cxx,1,['avoid'],['avoid']
Safety,"// add penalty for effS=0 bin; // to avoid that the minimizer gets stuck in the zero-bin; // force it towards higher efficiency",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCuts.cxx:37,avoid,avoid,37,tmva/tmva/src/MethodCuts.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCuts.cxx,1,['avoid'],['avoid']
Safety,"// add this binning to the var to avoid recalling ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:34,avoid,avoid,34,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['avoid'],['avoid']
Safety,"// add timeout...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressGUI.cxx:7,timeout,timeout,7,test/stressGUI.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressGUI.cxx,4,['timeout'],['timeout']
Safety,"// algorithm thanks to Real-Time Collision Detection by Christer Ericson,; // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,; // under the accompanying license; see chapter 5.1.5 for detailed explanation.; // basically, we're distinguishing which of the voronoi regions of the triangle; // the point lies in with the minimum amount of redundant computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:43,Detect,Detection,43,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['Detect', 'redund']","['Detection', 'redundant']"
Safety,"// all zmq errors not recoverable from here, only at call site",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQSvc.cpp:22,recover,recoverable,22,roofit/roofitZMQ/src/ZeroMQSvc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/src/ZeroMQSvc.cpp,2,['recover'],['recoverable']
Safety,"// also avoid too many nodes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx:8,avoid,avoid,8,geom/webviewer/src/RGeomData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx,2,['avoid'],['avoid']
Safety,"// altname now contains the full name of the class including a possible; // namespace if there has been a using namespace statement.; // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname); // the TClassEdit normalization and the TMetaUtils normalization leads to; // two different space layout. To avoid an infinite recursion, we also; // add the test on (altname != name)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:321,avoid,avoid,321,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['avoid'],['avoid']
Safety,"// always safe, never useful.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:10,safe,safe,10,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,1,['safe'],['safe']
Safety,"// an example of a filter's prolog::; // %0 = call ptr @llvm.eh.recoverfp(@""?fin$0@0@main@@"",..); // %1 = call ptr @llvm.localrecover(@""?fin$0@0@main@@"",..); // %2 = load ptr, ptr %1, align 8; // ==> %2 is the frame-pointer of outermost host function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp:64,recover,recoverfp,64,interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGException.cpp,1,['recover'],['recoverfp']
Safety,"// and finally, to avoid memory leaks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGSpeedo.cxx:19,avoid,avoid,19,gui/gui/src/TGSpeedo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGSpeedo.cxx,2,['avoid'],['avoid']
Safety,// anonymous namespace; //===----------------------------------------------------------------------===//; // -Wthread-safety; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:118,safe,safety,118,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['safe'],['safety']
Safety,"// another sanity check (nsmooth<0 indicated build with KDE)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDF.cxx:11,sanity check,sanity check,11,tmva/tmva/src/PDF.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDF.cxx,1,['sanity check'],['sanity check']
Safety,"// apply cut off to avoid routine to explode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testIntegrationMultiDim.cxx:20,avoid,avoid,20,math/mathcore/test/testIntegrationMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/testIntegrationMultiDim.cxx,1,['avoid'],['avoid']
Safety,"// apply cut off to avoid routine to explode; //unsigned int size = (unsigned int) 1.E8; // apply cut off to avoid routine to explode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testMCIntegration.cxx:20,avoid,avoid,20,math/mathmore/test/testMCIntegration.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testMCIntegration.cxx,2,['avoid'],['avoid']
Safety,"// applying GPU options such as allow_growth=True to avoid allocating all memory on GPU; // that prevents running later TMVA-GPU; // Also new Nvidia RTX cards (e.g. RTX 2070) require this option",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx:53,avoid,avoid,53,tmva/pymva/src/MethodPyKeras.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/src/MethodPyKeras.cxx,1,['avoid'],['avoid']
Safety,// are safe to ignore.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp:7,safe,safe,7,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFlatten.cpp,1,['safe'],['safe']
Safety,"// array of indices for the lines, to avoid duplication of points",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:38,avoid,avoid,38,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// ashr(R, Amt) === sub(xor(lshr(R, Amt), SignMask), SignMask); // SignMask = lshr(SignBit, Amt) - safe to do this with PSRLW.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:99,safe,safe,99,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['safe'],['safe']
Safety,"// assert that the vector time is roughly Vc::double_v::Size times smaller than the scalar time; // allow 25% for 'safety'; // if (std::fabs((best_time_vector * Vc::double_v::Size) - best_time_scalar) > 0.25 * best_time_scalar) {; // ++ret;; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/testGenVectorVc.cxx:115,safe,safety,115,test/testGenVectorVc.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/testGenVectorVc.cxx,1,['safe'],['safety']
Safety,"// assign to the static pointer (NO Thread safety here)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx:43,safe,safety,43,math/fumili/src/TFumiliMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumiliMinimizer.cxx,3,['safe'],['safety']
Safety,"// at the cost of ~10% performance, don't abort the interpreter on any signal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx:42,abort,abort,42,bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,1,['abort'],['abort']
Safety,"// avoid ""to point"" resizing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx:3,avoid,avoid,3,gui/guibuilder/src/TGuiBldDragManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx,2,['avoid'],['avoid']
Safety,"// avoid (infinity and nan ) in the chi2 sum; // eventually add possibility of excluding some points (like singularity)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:3,avoid,avoid,3,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['avoid'],['avoid']
Safety,"// avoid Modified() signal from SetName",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx:3,avoid,avoid,3,graf2d/gpad/src/TCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx,4,['avoid'],['avoid']
Safety,// avoid X udiv 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:3,avoid,avoid,3,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,1,['avoid'],['avoid']
Safety,"// avoid auto flushing again later; // When we are in one-basket-per-cluster mode, there is no need to optimize basket:; // they will automatically grow to the size needed for an event cluster (with the basket; // shrinking preventing them from growing too much larger than the actually-used space).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:3,avoid,avoid,3,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['avoid'],['avoid']
Safety,"// avoid bins in h2 with zero content",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:3,avoid,avoid,3,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,8,['avoid'],['avoid']
Safety,// avoid black filling by middle-size,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,avoid,avoid,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['avoid'],['avoid']
Safety,"// avoid call of original methods, set members directly; // pad->Range(r.px1, r.py1, r.px2, r.py2);; // pad->RangeAxis(r.ux1, r.uy1, r.ux2, r.uy2);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:3,avoid,avoid,3,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['avoid'],['avoid']
Safety,// avoid calling Fold,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h:3,avoid,avoid,3,interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h,4,['avoid'],['avoid']
Safety,"// avoid calling RemoveFrame(e)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListBox.cxx:3,avoid,avoid,3,gui/gui/src/TGListBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListBox.cxx,3,['avoid'],['avoid']
Safety,"// avoid case alpha or beta = 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressMathMore.cxx:3,avoid,avoid,3,test/stressMathMore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressMathMore.cxx,1,['avoid'],['avoid']
Safety,"// avoid cleaning histogram when running a single test suite",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:3,avoid,avoid,3,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['avoid'],['avoid']
Safety,// avoid confusion due-to :: in the namespace,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,avoid,avoid,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// avoid constructing and destructing the helper TChain here if we don't need to",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSample.cxx:3,avoid,avoid,3,tree/dataframe/src/RSample.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RSample.cxx,1,['avoid'],['avoid']
Safety,"// avoid dangling pointers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx:3,avoid,avoid,3,proof/proofplayer/src/TPacketizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizer.cxx,2,['avoid'],['avoid']
Safety,"// avoid default tolerance to be too small (1. is default in RooMinimizer)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProfileLikelihoodTestStat.h:3,avoid,avoid,3,roofit/roostats/inc/RooStats/ProfileLikelihoodTestStat.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/ProfileLikelihoodTestStat.h,1,['avoid'],['avoid']
Safety,"// avoid difference of too small numbers; //rgnval = 1.0E-30;; //rgnerr = TMath::Max( std::abs(rgnval-rgncmp), TMath::Max(std::abs(rgncmp), std::abs(rgnval) )*4.0E-16 );",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx:3,avoid,avoid,3,math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/AdaptiveIntegratorMultiDim.cxx,1,['avoid'],['avoid']
Safety,"// avoid doing a sqrt for 1 dim",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx:3,avoid,avoid,3,math/mathmore/src/GSLSimAnnealing.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLSimAnnealing.cxx,1,['avoid'],['avoid']
Safety,"// avoid double deletion of objects in trash",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGToolBar.cxx:3,avoid,avoid,3,gui/gui/src/TGToolBar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGToolBar.cxx,1,['avoid'],['avoid']
Safety,"// avoid duplicated plotting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx:3,avoid,avoid,3,tmva/tmvagui/src/likelihoodrefs.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx,1,['avoid'],['avoid']
Safety,"// avoid duplicated printing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx:3,avoid,avoid,3,tmva/tmvagui/src/likelihoodrefs.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmvagui/src/likelihoodrefs.cxx,1,['avoid'],['avoid']
Safety,"// avoid dx <= 0 and not inf",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/DistSampler.cxx:3,avoid,avoid,3,math/mathcore/src/DistSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/DistSampler.cxx,1,['avoid'],['avoid']
Safety,// avoid empty symbol in pad name,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,avoid,avoid,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// avoid executing ~/.rootlogon.C twice",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TRint.cxx:3,avoid,avoid,3,core/rint/src/TRint.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rint/src/TRint.cxx,2,['avoid'],['avoid']
Safety,"// avoid execution of Bar Slots",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TH1Editor.h:3,avoid,avoid,3,gui/ged/inc/TH1Editor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/inc/TH1Editor.h,1,['avoid'],['avoid']
Safety,// avoid extra trailing spaces.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp:3,avoid,avoid,3,interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ExtractAPI/DeclarationFragments.cpp,1,['avoid'],['avoid']
Safety,"// avoid flipping in front view",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloLegoGL.cxx:3,avoid,avoid,3,graf3d/eve/src/TEveCaloLegoGL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloLegoGL.cxx,2,['avoid'],['avoid']
Safety,"// avoid infinities or nan in resval",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:3,avoid,avoid,3,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['avoid'],['avoid']
Safety,"// avoid infinities or nan in rval",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:3,avoid,avoid,3,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['avoid'],['avoid']
Safety,"// avoid infinity or nan in chi2 values due to wrong function values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h:3,avoid,avoid,3,math/mathcore/inc/Fit/FitUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h,2,['avoid'],['avoid']
Safety,"// avoid input events in list tree while connecting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:3,avoid,avoid,3,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['avoid'],['avoid']
Safety,// avoid interspersing output,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:3,avoid,avoid,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,1,['avoid'],['avoid']
Safety,"// avoid jumping more than one line up",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListView.cxx:3,avoid,avoid,3,gui/gui/src/TGListView.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListView.cxx,1,['avoid'],['avoid']
Safety,"// avoid keeping a bad point nest time around",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnFunctionCross.cxx:3,avoid,avoid,3,math/minuit2/src/MnFunctionCross.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnFunctionCross.cxx,1,['avoid'],['avoid']
Safety,"// avoid keeping a very bad point next time around",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:3,avoid,avoid,3,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['avoid'],['avoid']
Safety,"// avoid mis-leading byte count error message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:3,avoid,avoid,3,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,2,['avoid'],['avoid']
Safety,// avoid multiple call of the callback after timeout,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,avoid,avoid,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['avoid', 'timeout']","['avoid', 'timeout']"
Safety,"// avoid nan; // if (std::isnan(xtmp[i])) status = -11;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMinimizer.cxx:3,avoid,avoid,3,math/mathmore/src/GSLMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMinimizer.cxx,1,['avoid'],['avoid']
Safety,"// avoid nans if sigma is 0; // want to evaluate gaussian integral in regions where IncompatFunc = 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/Asymptotics.cxx:3,avoid,avoid,3,roofit/xroofit/src/Asymptotics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/Asymptotics.cxx,1,['avoid'],['avoid']
Safety,"// avoid negative or too small values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:3,avoid,avoid,3,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['avoid'],['avoid']
Safety,"// avoid negative sigma. This NP will be set constant anyway later",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONFactories_HistFactory.cxx:3,avoid,avoid,3,roofit/hs3/src/JSONFactories_HistFactory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/hs3/src/JSONFactories_HistFactory.cxx,1,['avoid'],['avoid']
Safety,"// avoid negative values of valxmin/valxmax",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitInterface.cxx:3,avoid,avoid,3,hist/hist/src/HFitInterface.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitInterface.cxx,1,['avoid'],['avoid']
Safety,"// avoid overflowing the error list, so if there are very many, print; // the oldest one first, and pop it off the list",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:3,avoid,avoid,3,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,1,['avoid'],['avoid']
Safety,// avoid oversized bins,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,avoid,avoid,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['avoid'],['avoid']
Safety,"// avoid plotting of wrong dimensions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx:3,avoid,avoid,3,tmva/tmva/src/PDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx,3,['avoid'],['avoid']
Safety,"// avoid polygon stipling",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloLegoGL.cxx:3,avoid,avoid,3,graf3d/eve/src/TEveCaloLegoGL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveCaloLegoGL.cxx,1,['avoid'],['avoid']
Safety,"// avoid potential crash when drawing a canvas with the same name; // than a canvas already embedded in one of the browser's tab",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFileBrowser.cxx:3,avoid,avoid,3,gui/gui/src/TGFileBrowser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFileBrowser.cxx,1,['avoid'],['avoid']
Safety,"// avoid print Hessian that will invert the matrix",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/VariableMetricBuilder.cxx:3,avoid,avoid,3,math/minuit2/src/VariableMetricBuilder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/VariableMetricBuilder.cxx,1,['avoid'],['avoid']
Safety,"// avoid processing async queries sent during processing in dyn mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:3,avoid,avoid,3,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['avoid'],['avoid']
Safety,// avoid projection handling until area is created,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,avoid,avoid,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['avoid'],['avoid']
Safety,// avoid promise in return value,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElements.js:3,avoid,avoid,3,ui5/eve7/lib/EveElements.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/lib/EveElements.js,3,['avoid'],['avoid']
Safety,// avoid races with writes,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp:3,avoid,avoid,3,interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/PerfJITEvents/PerfJITEventListener.cpp,1,['avoid'],['avoid']
Safety,"// avoid reaching MAXINT for temporary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:3,avoid,avoid,3,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['avoid'],['avoid']
Safety,// avoid recursing into the suffix of declarator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:3,avoid,avoid,3,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,1,['avoid'],['avoid']
Safety,"// avoid release",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_basics.cxx:3,avoid,avoid,3,tree/ntuple/v7/test/ntuple_basics.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/test/ntuple_basics.cxx,1,['avoid'],['avoid']
Safety,"// avoid rounding error which can make E2 negative when M2 is negative",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h:3,avoid,avoid,3,math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,1,['avoid'],['avoid']
Safety,"// avoid rounding errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:3,avoid,avoid,3,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,4,['avoid'],['avoid']
Safety,"// avoid setting both SumW2 and Asymptotic for uncertainty correction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx:3,avoid,avoid,3,roofit/roofitcore/src/FitHelpers.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/FitHelpers.cxx,1,['avoid'],['avoid']
Safety,"// avoid singularity in the function (infinity and nan ) in the chi2 sum; // eventually add possibility of excluding some points (like singularity)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h:3,avoid,avoid,3,math/mathcore/inc/Fit/FitUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h,2,['avoid'],['avoid']
Safety,"// avoid small value of a",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/testSMatrix.cxx:3,avoid,avoid,3,math/smatrix/test/testSMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/testSMatrix.cxx,1,['avoid'],['avoid']
Safety,"// avoid some extra multiplications at the expense of some clarity",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:3,avoid,avoid,3,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['avoid'],['avoid']
Safety,"// avoid start-up race",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx:3,avoid,avoid,3,graf2d/win32gdk/src/TGWin32.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32.cxx,1,['avoid'],['avoid']
Safety,"// avoid that dfk*dfj are one small and one huge so I get a nan; // to avoid summing infinite and nan later when calculating the Hessian",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliStandardMaximumLikelihoodFCN.cxx:3,avoid,avoid,3,math/minuit2/src/FumiliStandardMaximumLikelihoodFCN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliStandardMaximumLikelihoodFCN.cxx,2,['avoid'],['avoid']
Safety,"// avoid the case where alpha or beta = 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testStress.cxx:3,avoid,avoid,3,math/mathmore/test/testStress.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/testStress.cxx,1,['avoid'],['avoid']
Safety,"// avoid to return errors which makes eff-err < 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:3,avoid,avoid,3,hist/hist/src/TEfficiency.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx,1,['avoid'],['avoid']
Safety,"// avoid too many allocs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGImageMap.cxx:3,avoid,avoid,3,gui/gui/src/TGImageMap.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGImageMap.cxx,1,['avoid'],['avoid']
Safety,"// avoid underflow/overflows in label axis",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:3,avoid,avoid,3,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['avoid'],['avoid']
Safety,"// avoid unused parameter warning (gcc 12.1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx:3,avoid,avoid,3,tree/dataframe/inc/ROOT/RDF/RAction.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RAction.hxx,3,['avoid'],['avoid']
Safety,"// avoid unused parameter warnings (gcc 12.1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:3,avoid,avoid,3,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,4,['avoid'],['avoid']
Safety,"// avoid unused variable warning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/rootcling_stage1/src/rootcling_stage1.cxx:3,avoid,avoid,3,core/rootcling_stage1/src/rootcling_stage1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/rootcling_stage1/src/rootcling_stage1.cxx,2,['avoid'],['avoid']
Safety,"// avoid unused variable warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:3,avoid,avoid,3,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avoid'],['avoid']
Safety,"// avoid unused variable warnings",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RVecDS.hxx:3,avoid,avoid,3,tree/dataframe/inc/ROOT/RVecDS.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RVecDS.hxx,2,['avoid'],['avoid']
Safety,"// avoid unused variable warnings for older compilers such as gcc 4.9",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:3,avoid,avoid,3,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,2,['avoid'],['avoid']
Safety,"// avoid usage of 1 << nbits, while only works up to 32 bits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,avoid,avoid,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// avoid useless redraw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGSpeedo.cxx:3,avoid,avoid,3,gui/gui/src/TGSpeedo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGSpeedo.cxx,3,['avoid'],['avoid']
Safety,"// avoid using 0 that for ROOT means a specific seed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRngROOTWrapper.h:3,avoid,avoid,3,math/mathmore/src/GSLRngROOTWrapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLRngROOTWrapper.h,1,['avoid'],['avoid']
Safety,// avoid vcall in common case,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp:3,avoid,avoid,3,interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCXXABI.cpp,1,['avoid'],['avoid']
Safety,"// avoid warning about unused parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:3,avoid,avoid,3,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['avoid'],['avoid']
Safety,"// avoid warning due to wrong bzero prototype (used by FD_ZERO macro)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/netpar.cxx:3,avoid,avoid,3,net/rpdutils/src/netpar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/netpar.cxx,1,['avoid'],['avoid']
Safety,"// avoid warning; // normally this method would be complex, but here it is simple for debugging",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/DebuggingSampler.h:3,avoid,avoid,3,roofit/roostats/inc/RooStats/DebuggingSampler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/DebuggingSampler.h,1,['avoid'],['avoid']
Safety,// avoid writing fat binary to disk using an in-memory virtual file system,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp:3,avoid,avoid,3,interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/Interpreter.cpp,1,['avoid'],['avoid']
Safety,// avoid zero faces,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,avoid,avoid,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// avoid zero strings",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQObject.cxx:3,avoid,avoid,3,core/base/src/TQObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQObject.cxx,1,['avoid'],['avoid']
Safety,"// avoid zero strings; // if delegation object TQObjSender is used get the real sender class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQObject.cxx:3,avoid,avoid,3,core/base/src/TQObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TQObject.cxx,1,['avoid'],['avoid']
Safety,"// avoid zero width. assume is last layer and give width = output width; // Determine the number of outputs",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:3,avoid,avoid,3,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['avoid'],['avoid']
Safety,"// avoiding control reaches end of non-void function warning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN_Utils.h:3,avoid,avoiding,3,tmva/tmva/inc/TMVA/MethodCFMlpANN_Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodCFMlpANN_Utils.h,1,['avoid'],['avoiding']
Safety,"// avoids calls to LoadClassInfo() if info is already loaded",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:3,avoid,avoids,3,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['avoid'],['avoids']
Safety,"// avoids case of nBins = 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx:3,avoid,avoids,3,roofit/roostats/src/HypoTestInverter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx,1,['avoid'],['avoids']
Safety,// avoids warning for unused variable,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h:3,avoid,avoids,3,interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,1,['avoid'],['avoids']
Safety,// back() is a br instruction with a debug location; // equals to the one from NextAfterFork; // So to avoid to have two debug locs on two blocks just change it,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:103,avoid,avoid,103,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,1,['avoid'],['avoid']
Safety,"// be careful with machine precision and avoid too small edm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/VariableMetricBuilder.cxx:41,avoid,avoid,41,math/minuit2/src/VariableMetricBuilder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/VariableMetricBuilder.cxx,1,['avoid'],['avoid']
Safety,"// begin is not defined here in order to avoid usage of an undefined static; // data member, instead it's instantiated by LLVM_INSTANTIATE_REGISTRY.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Registry.h:41,avoid,avoid,41,interpreter/llvm-project/llvm/include/llvm/Support/Registry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Registry.h,1,['avoid'],['avoid']
Safety,"// beginning to paint the first point at a random distance; // to avoid artefacts when increasing the dots spacing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoord.cxx:66,avoid,avoid,66,tree/treeviewer/src/TParallelCoord.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TParallelCoord.cxx,1,['avoid'],['avoid']
Safety,"// big risk that this lookup will result in a resize, so force it here; // to be able to reset the lookup function; of course, this is nowhere; // near fool-proof, but should cover interactive usage ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx:7,risk,risk,7,bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPyCppyyModule.cxx,1,['risk'],['risk']
Safety,"// bind is on the master process to avoid zombie children to hold on to binds; // start test",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp:36,avoid,avoid,36,roofit/roofitZMQ/test/test_ZMQ.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp,1,['avoid'],['avoid']
Safety,"// bind is on the master process to avoid zombie children to hold on to binds; // start test: send 2 things, receive 1, send 1 more, finish",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp:36,avoid,avoid,36,roofit/roofitZMQ/test/test_ZMQ.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/test/test_ZMQ.cpp,2,['avoid'],['avoid']
Safety,"// br(!x, t, f) -> br(x, f, t); // Avoid doing this optimization when instrumenting a condition for MC/DC.; // LNot is taken as part of the condition for simplicity, and changing its; // sense negatively impacts test vector tracking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp:35,Avoid,Avoid,35,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.cpp,1,['Avoid'],['Avoid']
Safety,"// build out the signature with predictable formal names",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx:32,predict,predictable,32,bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,1,['predict'],['predictable']
Safety,"// build_vector lo, (load ptr) -> load_d16_hi ptr, lo; // build_vector lo, (zextload ptr from i8) -> load_d16_hi_u8 ptr, lo; // build_vector lo, (sextload ptr from i8) -> load_d16_hi_i8 ptr, lo; // Need to check for possible indirect dependencies on the other half of the; // vector to avoid introducing a cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp:286,avoid,avoid,286,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// by default, rendering happens with timeout",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:38,timeout,timeout,38,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['timeout'],['timeout']
Safety,"// bypasses try block (i.e. segfaults will abort)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx:43,abort,abort,43,bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPMethod.cxx,1,['abort'],['abort']
Safety,"// c++ can put code into header files, why cant we? (with the inline declaration, should be safe from duplicate-symbol error)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/mixmax.h:92,safe,safe,92,math/mathcore/src/mixmax.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/mixmax.h,1,['safe'],['safe']
Safety,"// cached vector to avoid re-allocating every time a new one",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiFit.h:20,avoid,avoid,20,math/mathmore/src/GSLMultiFit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/src/GSLMultiFit.h,4,['avoid'],['avoid']
Safety,"// calculate distance to boundary along the Mehrotra; // predictor-corrector step:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx:57,predict,predictor-corrector,57,math/quadp/src/TGondzioSolver.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TGondzioSolver.cxx,1,['predict'],['predictor-corrector']
Safety,"// calculate risk",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:13,risk,risk,13,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,1,['risk'],['risk']
Safety,"// calculate sum over all detector bins; // excluding the overflow bins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:26,detect,detector,26,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['detect'],['detector']
Safety,"// call DoFillN which will not put entries in the buffer as FillN does; // set fBuffer to zero to avoid re-emptying the buffer from functions called; // by DoFillN (e.g Sumw2)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:98,avoid,avoid,98,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['avoid'],['avoid']
Safety,"// call_indirect instructions have a TYPEINDEX operand that we print; // as a signature here, such that the assembler can recover this; // information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp:122,recover,recover,122,interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/MCTargetDesc/WebAssemblyInstPrinter.cpp,1,['recover'],['recover']
Safety,"// called when manager was updated, need only in standalone modes to detect own element id",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/GL.controller.js:69,detect,detect,69,ui5/eve7/controller/GL.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/GL.controller.js,1,['detect'],['detect']
Safety,"// calling fTransform() like here was not thread safe because it was using a cached vector; // return Fcn()( fTransform(v) );; // make a new thread-safe implementation creating a vector each time; // a bit slower few% in stressFit and 10% in Rosenbrock function but it is negligible in big fits; // get first initial values of parameter (in case some one is fixed)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserFcn.cxx:49,safe,safe,49,math/minuit2/src/MnUserFcn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserFcn.cxx,2,['safe'],['safe']
Safety,"// can try to recover nans ... this stopped being possible in 6.27 onwards because NaNPacker made private",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:14,recover,recover,14,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['recover'],['recover']
Safety,"// can we auto detect this?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/inc/ROOT/REveDataTable.hxx:15,detect,detect,15,graf3d/eve7/inc/ROOT/REveDataTable.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/inc/ROOT/REveDataTable.hxx,1,['detect'],['detect']
Safety,"// can't risk passing to ROOT/meta as it may do RTTI",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx:9,risk,risk,9,bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/cppyy-backend/clingwrapper/src/clingwrapper.cxx,1,['risk'],['risk']
Safety,"// case 3: avoid reusing existing one - maintain fgMinuit to zero; // otherwise we will get a double delete if user deletes externally gMinuit; // in this case we will loose gMinuit instance; // fgMinuit = gMinuit;; // fgUsed = true; // need to reset in case other gMinuit instance is later used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:11,avoid,avoid,11,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,1,['avoid'],['avoid']
Safety,"// case AccelerationMode::kLoop : return SafetyLoop(point, safmax);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:41,Safe,SafetyLoop,41,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['Safe'],['SafetyLoop']
Safety,"// case TStreamerInfo::kBits: writeSequence->AddAction( WriteBasicType<BitsMarker>, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; /*case TStreamerInfo::kFloat16: {; if (element->GetFactor() != 0) {; writeSequence->AddAction( WriteBasicType_WithFactor<float>, new TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; } else {; Int_t nbits = (Int_t)element->GetXmin();; if (!nbits) nbits = 12;; writeSequence->AddAction( WriteBasicType_NoFactor<float>, new TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; }; break;; } */; /*case TStreamerInfo::kDouble32: {; if (element->GetFactor() != 0) {; writeSequence->AddAction( WriteBasicType_WithFactor<double>, new TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; } else {; Int_t nbits = (Int_t)element->GetXmin();; if (!nbits) {; writeSequence->AddAction( ConvertBasicType<float,double>, new TConfiguration(this,i,compinfo,compinfo->fOffset) );; } else {; writeSequence->AddAction( WriteBasicType_NoFactor<double>, new TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; }; }; break;; } */; //case TStreamerInfo::kTNamed: writeSequence->AddAction( WriteTNamed, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; // Idea: We should calculate the CanIgnoreTObjectStreamer here and avoid calling the; // Streamer alltogether.; //case TStreamerInfo::kTObject: writeSequence->AddAction( WriteTObject, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; //case TStreamerInfo::kTString: writeSequence->AddAction( WriteTString, new TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; /*case TStreamerInfo::kSTL: {; TClass *newClass = element->GetNewClass();; TClass *oldClass = element->GetClassPointer();; Bool_t isSTLbase = element->IsBase() && element->IsA()!=TStreamerBase::Class();. if (element->GetArrayLength() <= 1) {; if (newClass && newClass != oldClass) {; if (element->GetStreamer()) {; writeSeq",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:1359,avoid,avoid,1359,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['avoid'],['avoid']
Safety,"// case TStreamerInfo::kBits: writeSequence->AddAction( WriteBasicType<BitsMarker>, new; // TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; /*case TStreamerInfo::kFloat16: {; if (element->GetFactor() != 0) {; writeSequence->AddAction( WriteBasicType_WithFactor<float>, new; TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; } else {; Int_t nbits = (Int_t)element->GetXmin();; if (!nbits) nbits = 12;; writeSequence->AddAction( WriteBasicType_NoFactor<float>, new; TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; }; break;; } */; /*case TStreamerInfo::kDouble32: {; if (element->GetFactor() != 0) {; writeSequence->AddAction( WriteBasicType_WithFactor<double>, new; TConfWithFactor(this,i,compinfo,compinfo->fOffset,element->GetFactor(),element->GetXmin()) );; } else {; Int_t nbits = (Int_t)element->GetXmin();; if (!nbits) {; writeSequence->AddAction( ConvertBasicType<float,double>, new; TConfiguration(this,i,compinfo,compinfo->fOffset) );; } else {; writeSequence->AddAction( WriteBasicType_NoFactor<double>, new; TConfNoFactor(this,i,compinfo,compinfo->fOffset,nbits) );; }; }; break;; } */; // case TStreamerInfo::kTNamed: writeSequence->AddAction( WriteTNamed, new; // TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; // Idea: We should calculate the CanIgnoreTObjectStreamer here and avoid calling the; // Streamer alltogether.; // case TStreamerInfo::kTObject: writeSequence->AddAction( WriteTObject, new; // TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; // case TStreamerInfo::kTString: writeSequence->AddAction( WriteTString, new; // TConfiguration(this,i,compinfo,compinfo->fOffset) ); break;; /*case TStreamerInfo::kSTL: {; TClass *newClass = element->GetNewClass();; TClass *oldClass = element->GetClassPointer();; Bool_t isSTLbase = element->IsBase() && element->IsA()!=TStreamerBase::Class();. if (element->GetArrayLength() <= 1) {; if (newClass && newClass != oldClass) {; if (element->Ge",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx:1373,avoid,avoid,1373,io/io/src/TStreamerInfoActions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfoActions.cxx,1,['avoid'],['avoid']
Safety,"// case both histogram have zero bin contents; // (use square of content to avoid numerical errors)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:76,avoid,avoid,76,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['avoid'],['avoid']
Safety,"// case of batch prediction for",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:17,predict,prediction,17,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['predict'],['prediction']
Safety,"// case of remaining events: compute prediction by single event !",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:37,predict,prediction,37,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['predict'],['prediction']
Safety,"// case where label bins are consecutive starting from first bin will work; // calling before a TH1::LabelsDeflate() will avoid this error message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:122,avoid,avoid,122,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['avoid'],['avoid']
Safety,"// cast to void * to avoid a warning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stress/VectorTest.h:21,avoid,avoid,21,math/mathcore/test/stress/VectorTest.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stress/VectorTest.h,1,['avoid'],['avoid']
Safety,"// ceiling the division; // Avoid empty chunks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx:28,Avoid,Avoid,28,core/imt/inc/ROOT/TThreadExecutor.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/TThreadExecutor.hxx,1,['Avoid'],['Avoid']
Safety,"// change connection id to avoid confusion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:27,avoid,avoid,27,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,2,['avoid'],['avoid']
Safety,"// change whitespace to \s to avoid problems in parsing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:30,avoid,avoid,30,hist/hist/src/TFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx,1,['avoid'],['avoid']
Safety,"// check actual distance/safety to object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:25,safe,safety,25,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,2,['safe'],['safety']
Safety,"// check against actual geometry primitive-safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:43,safe,safety,43,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"// check if alpha1 equals to alpha2 (converting to string - to avoid problems with floats)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/src/TGDMLWrite.cxx:63,avoid,avoid,63,geom/gdml/src/TGDMLWrite.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/src/TGDMLWrite.cxx,1,['avoid'],['avoid']
Safety,// check if code already loaded - to avoid duplication,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:37,avoid,avoid,37,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// check if moved too far (out of detector's bouds)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:34,detect,detector,34,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,2,['detect'],['detector']
Safety,"// check risk evolution",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:9,risk,risk,9,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,1,['risk'],['risk']
Safety,"// check whether this is an interior point. Useful as a; // sanity check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TQpVar.h:60,sanity check,sanity check,60,math/quadp/inc/TQpVar.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TQpVar.h,1,['sanity check'],['sanity check']
Safety,// checkArithmeticNull - Detect when a NULL constant is used improperly in an; // expression. These are mainly cases where the null pointer is used as an; // integer instead of a pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:25,Detect,Detect,25,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['Detect'],['Detect']
Safety,"// clang-format off; /**; * \class ROOT::RDataFrame; * \ingroup dataframe; * \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; on their machines completely transparently.<br>; Skip to the [class reference](#reference) or keep reading for the user guide. In a nutshell:; ~~~{.cpp}; ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; ~~~. Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; care of their execution. The implementation automatically puts in place several low level optimisations such as; multi-thread parallelization and caching. \htmlonly; <a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; alt=""DOI""></a>; \endhtmlonly. ## For the impatient user; You can directly see RDataFrame in action in our [tutorials](https://root.cern/doc/master/group__tutorial__dataframe.html), in C++ or Python. ## Table of Contents; - [Cheat sheet](\ref cheatsheet); - [Introduction](\ref introduction); - [Crash course](\ref crash-course); - [Working with collections](\ref collections); - [Transformations: manipulating data](\ref transformations); - [Actions: getting results](\ref actions); - [Distributed execution in Python](\ref distrdf); - [Performance tips and parallel execution](\ref parallel-execution); - [More features](\ref more-features); - [Systematic variations](\ref systematics); - [RDataFrame objects as function arguments and return values](\ref rnode); - [Storing RDataFrame objects in",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx:850,safe,safe,850,tree/dataframe/src/RDataFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDataFrame.cxx,1,['safe'],['safe']
Safety,"// clang-format off; /**; * \class TTreeReaderValue; * \ingroup treeplayer; * \brief An interface for reading values stored in ROOT columnar datasets; *; * The TTreeReaderValue is a type-safe tool to be used in association with a TTreeReader; * to access the values stored in TTree, TNtuple and TChain datasets.; * TTreeReaderValue can be also used to access collections such as `std::vector`s or TClonesArray; * stored in columnar datasets but it is recommended to use TTreeReaderArray instead as it offers; * several advantages.; *; * See the documentation of TTreeReader for more details and examples.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx:187,safe,safe,187,tree/treeplayer/src/TTreeReaderValue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeReaderValue.cxx,1,['safe'],['safe']
Safety,"// clang-format off; /**; \class RDaosHandle; \brief Translates a `daos_handle_t` to a pointer to object and viceversa. A `daos_handle_t` is used by some API functions (in particular, those that work; with pools, containers, or objects) to reference an entity. This type (aka; `uint64_t`) is large enough for a pointer in all architectures. However, an; indirection layer is added in order to detect the use of invalidated handles.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:393,detect,detect,393,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,1,['detect'],['detect']
Safety,"// clang-format off; /**; \class ROOT::Experimental::Detail::RNTupleAtomicCounter; \ingroup NTuple; \brief A thread-safe integral performance counter; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx:116,safe,safe,116,tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,1,['safe'],['safe']
Safety,"// clang-format off; /**; \class ROOT::Experimental::Detail::RNTuplePlainCounter; \ingroup NTuple; \brief A non thread-safe integral performance counter; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx:119,safe,safe,119,tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,1,['safe'],['safe']
Safety,"// clang-format off; /**; \class ROOT::Experimental::Detail::RNTupleTickCounter; \ingroup NTuple; \brief An either thread-safe or non thread safe counter for CPU ticks. On print, the value is converted from ticks to ns.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx:122,safe,safe,122,tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMetrics.hxx,2,['safe'],['safe']
Safety,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPageAllocator; \ingroup NTuple; \brief Abstract interface to allocate and release pages. The page allocator acquires and releases memory for pages. It does not load the page data, the returned pages; are empty but guaranteed to have enough contiguous space for the given number of elements.; The page allocator must be thread-safe.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx:390,safe,safe,390,tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageAllocator.hxx,1,['safe'],['safe']
Safety,"// clang-format off; /**; \class ROOT::Experimental::Internal::RPagePool; \ingroup NTuple; \brief A thread-safe cache of pages loaded from the page source. The page pool is used as a cache for pages loaded from a page source.; In this way, identical page needed at the same time, only need to be loaded once.; Page sources also use the page pool to stage (preload) pages unsealed by IMT tasks.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx:107,safe,safe,107,tree/ntuple/v7/inc/ROOT/RPagePool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPagePool.hxx,1,['safe'],['safe']
Safety,"// clang-format off; /**; \class ROOT::Experimental::RResultBase; \ingroup Base; \brief Common handling of the error case for RResult<T> (T != void) and RResult<void>. RResultBase captures a possible runtime error that might have occured. If the RResultBase leaves the scope unchecked,; it will throw an exception. RResultBase should only be allocated on the stack, which is helped by deleting the; new operator. RResultBase is movable but not copyable to avoid throwing multiple exceptions about the same failure.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx:456,avoid,avoid,456,core/foundation/v7/inc/ROOT/RError.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/v7/inc/ROOT/RError.hxx,1,['avoid'],['avoid']
Safety,"// clang-format off; /**; \class ROOT::RDF::RSqliteDS; \ingroup dataframe; \brief RSqliteDS is an RDF data source implementation for SQL result sets from sqlite3 files. The RSqliteDS is able to feed an RDataFrame with data from a SQlite SELECT query. One can use it like. auto rdf = ROOT::RDF::FromSqlite(""/path/to/file.sqlite"", ""select name from table"");; auto h = rdf.Define(""lName"", ""name.length()"").Histo1D(""lName"");. The data source has to provide column types for all the columns. Determining column types in SQlite is tricky; as it is dynamically typed and in principle each row can have different column types. The following heuristics; is used:. - If a table column is queried as is (""SELECT colname FROM table""), the default/declared column type is taken.; - For expressions (""SELECT 1+1 FROM table""), the type of the first row of the result set determines the column type.; That can result in a column to be of thought of type NULL where subsequent rows actually have meaningful values.; The provided SELECT query can be used to avoid such ambiguities.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RSqliteDS.hxx:1040,avoid,avoid,1040,tree/dataframe/inc/ROOT/RSqliteDS.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RSqliteDS.hxx,1,['avoid'],['avoid']
Safety,"// clang-format off; /*. YAML Format specification. The TBD v1 format only support two level address libraries and is per; definition application extension safe. --- # the tag !tapi-tbd-v1 is optional and; # shouldn't be emitted to support older linker.; archs: [ armv7, armv7s, arm64 ] # the list of architecture slices that are; # supported by this file.; platform: ios # Specifies the platform (macosx, ios, etc); install-name: /u/l/libfoo.dylib #; current-version: 1.2.3 # Optional: defaults to 1.0; compatibility-version: 1.0 # Optional: defaults to 1.0; swift-version: 0 # Optional: defaults to 0; objc-constraint: none # Optional: defaults to none; exports: # List of export sections; ... Each export section is defined as following:. - archs: [ arm64 ] # the list of architecture slices; allowed-clients: [ client ] # Optional: List of clients; re-exports: [ ] # Optional: List of re-exports; symbols: [ _sym ] # Optional: List of symbols; objc-classes: [] # Optional: List of Objective-C classes; objc-ivars: [] # Optional: List of Objective C Instance; # Variables; weak-def-symbols: [] # Optional: List of weak defined symbols; thread-local-symbols: [] # Optional: List of thread local symbols; */; /*. YAML Format specification. --- !tapi-tbd-v2; archs: [ armv7, armv7s, arm64 ] # the list of architecture slices that are; # supported by this file.; uuids: [ armv7:... ] # Optional: List of architecture and UUID pairs.; platform: ios # Specifies the platform (macosx, ios, etc); flags: [] # Optional:; install-name: /u/l/libfoo.dylib #; current-version: 1.2.3 # Optional: defaults to 1.0; compatibility-version: 1.0 # Optional: defaults to 1.0; swift-version: 0 # Optional: defaults to 0; objc-constraint: retain_release # Optional: defaults to retain_release; parent-umbrella: # Optional:; exports: # List of export sections; ...; undefineds: # List of undefineds sections; ... Each export section is defined as following:. - archs: [ arm64 ] # the list of architecture slices; allowed-c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp:156,safe,safe,156,interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/TextAPI/TextStub.cpp,1,['safe'],['safe']
Safety,"// clang-format off; /// Create a graphviz representation of the dataframe computation graph, return it as a string.; /// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; ///; /// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; ///; /// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; /// effectively optimized away from the computation graph.; ///; /// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:616,safe,safe,616,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['safe'],['safe']
Safety,"// clang-format off; /// Create a graphviz representation of the dataframe computation graph, write it to the specified file.; /// \param[in] node any node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to.; /// \param[in] outputFile file where to save the representation.; ///; /// The output can be displayed with a command akin to `dot -Tpng output.dot > output.png && open output.png`.; ///; /// Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are; /// effectively optimized away from the computation graph.; ///; /// Note that SaveGraph is not thread-safe and must not be called concurrently from different threads.; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:691,safe,safe,691,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['safe'],['safe']
Safety,"// clang-format off; /// Thread-safe callback for RDataFrame.; /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the fPrintInterval).; /// \param value Ignored.; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:32,safe,safe,32,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['safe'],['safe']
Safety,"// clang-format off; /// Trigger the event loop of multiple RDataFrames concurrently; /// \param[in] handles A vector of RResultHandles; /// \return The number of distinct computation graphs that have been processed; ///; /// This function triggers the event loop of all computation graphs which relate to the; /// given RResultHandles. The advantage compared to running the event loop implicitly by accessing the; /// RResultPtr is that the event loops will run concurrently. Therefore, the overall; /// computation of all results is generally more efficient.; /// It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ///; /// ~~~{.cpp}; /// ROOT::RDataFrame df1(""tree1"", ""file1.root"");; /// auto r1 = df1.Histo1D(""var1"");; ///; /// ROOT::RDataFrame df2(""tree2"", ""file2.root"");; /// auto r2 = df2.Sum(""var2"");; ///; /// // RResultPtr -> RResultHandle conversion is automatic; /// ROOT::RDF::RunGraphs({r1, r2});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:695,safe,safe,695,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['safe'],['safe']
Safety,"// clang-format off; ////////////////////////////////////////////////////////////////////////////////; /// Enables the global mutex to make ROOT thread safe/aware.; ///; /// The following becomes safe:; /// - concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); /// - concurrent usage of _different_ ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); /// - concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; /// - concurrent calls to the interpreter through gInterpreter; /// - concurrent loading of ROOT plug-ins; ///; /// In addition, gDirectory, gFile and gPad become a thread-local variable.; /// In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents.; /// gFile and gPad default to nullptr, as it is for single-thread programs.; ///; /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; ///; /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx:152,safe,safe,152,core/base/src/TROOT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TROOT.cxx,6,['safe'],"['safe', 'safety']"
Safety,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column that is updated when the input sample changes.; /// \param[in] name The name of the defined column.; /// \param[in] expression A C++ callable that computes the new value of the defined column.; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// The signature of the callable passed as second argument should be `T(unsigned int slot, const ROOT::RDF::RSampleInfo &id)`; /// where:; /// - `T` is the type of the defined column; /// - `slot` is a number in the range [0, nThreads) that is different for each processing thread. This can simplify; /// the definition of thread-safe callables if you are interested in using parallel capabilities of RDataFrame.; /// - `id` is an instance of a ROOT::RDF::RSampleInfo object which contains information about the sample which is; /// being processed (see the class docs for more information).; ///; /// DefinePerSample() is useful to e.g. define a quantity that depends on which TTree in which TFile is being; /// processed or to inject a callback into the event loop that is only called when the processing of a new sample; /// starts rather than at every entry.; ///; /// The callable will be invoked once per input TTree or once per multi-thread task, whichever is more often.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// ROOT::RDataFrame df{""mytree"", {""sample1.root"",""sample2.root""}};; /// df.DefinePerSample(""weightbysample"",; /// [](unsigned int slot, const ROOT::RDF::RSampleInfo &id); /// { return id.Contains(""sample1"") ? 1.0f : 2.0f; });; /// ~~~; // clang-format on; // TODO we could SFINAE on F's signature to provide friendlier compilation errors in case of signature mismatch",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:752,safe,safe,752,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['safe'],['safe']
Safety,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined function on each entry (*instant action*).; /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; /// \param[in] columns Names of the columns/branches in input to the user function.; ///; /// The callable `f` is invoked once per entry. This is an *instant action*:; /// upon invocation, an event loop as well as execution of all scheduled actions; /// is triggered.; /// Users are responsible for the thread-safety of this callable when executing; /// with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT).; ///; /// ### Example usage:; /// ~~~{.cpp}; /// myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:615,safe,safety,615,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['safe'],['safety']
Safety,"// clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Execute a user-defined function requiring a processing slot index on each entry (*instant action*).; /// \param[in] f Function, lambda expression, functor class or any other callable object performing user defined calculations.; /// \param[in] columns Names of the columns/branches in input to the user function.; ///; /// Same as `Foreach`, but the user-defined function takes an extra; /// `unsigned int` as its first parameter, the *processing slot index*.; /// This *slot index* will be assigned a different value, `0` to `poolSize - 1`,; /// for each thread of execution.; /// This is meant as a helper in writing thread-safe `Foreach`; /// actions when using `RDataFrame` after `ROOT::EnableImplicitMT()`.; /// The user-defined processing callable is able to follow different; /// *streams of processing* indexed by the first parameter.; /// `ForeachSlot` works just as well with single-thread execution: in that; /// case `slot` will always be `0`.; ///; /// ### Example usage:; /// ~~~{.cpp}; /// myDf.ForeachSlot([](unsigned int s, int i){ std::cout << ""Slot "" << s << "": ""<< i << std::endl;}, {""myIntColumn""});; /// ~~~; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:736,safe,safe,736,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['safe'],['safe']
Safety,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column with a value dependent on the processing slot and the current entry.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function (excluding slot and entry).; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// This alternative implementation of `Define` is meant as a helper in writing entry-specific, thread-safe custom; /// columns. The expression must be a callable of signature R(unsigned int, ULong64_t, T1, T2, ...) where `T1, T2...`; /// are the types of the columns that the expression takes as input. The first parameter is reserved for an unsigned; /// integer representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1. The second parameter; /// is reserved for a `ULong64_t` representing the current entry being processed by the current thread.; ///; /// The following two `Define`s are equivalent, although `DefineSlotEntry` is slightly more performant:; /// ~~~{.cpp}; /// int function(unsigned int, ULong64_t, double, double);; /// Define(""x"", function, {""rdfslot_"", ""rdfentry_"", ""column1"", ""column2""}); /// DefineSlotEntry(""x"", function, {""column1"", ""column2""}); /// ~~~; ///; /// See Define() for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:780,safe,safe,780,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['safe'],['safe']
Safety,"// clang-format on; // clang-format off; ////////////////////////////////////////////////////////////////////////////; /// \brief Define a new column with a value dependent on the processing slot.; /// \param[in] name The name of the defined column.; /// \param[in] expression Function, lambda expression, functor class or any other callable object producing the defined value. Returns the value that will be assigned to the defined column.; /// \param[in] columns Names of the columns/branches in input to the producer function (excluding the slot number).; /// \return the first node of the computation graph for which the new quantity is defined.; ///; /// This alternative implementation of `Define` is meant as a helper to evaluate new column values in a thread-safe manner.; /// The expression must be a callable of signature R(unsigned int, T1, T2, ...) where `T1, T2...` are the types; /// of the columns that the expression takes as input. The first parameter is reserved for an unsigned integer; /// representing a ""slot number"". RDataFrame guarantees that different threads will invoke the expression with; /// different slot numbers - slot numbers will range from zero to ROOT::GetThreadPoolSize()-1.; ///; /// The following two calls are equivalent, although `DefineSlot` is slightly more performant:; /// ~~~{.cpp}; /// int function(unsigned int, double, double);; /// df.Define(""x"", function, {""rdfslot_"", ""column1"", ""column2""}); /// df.DefineSlot(""x"", function, {""column1"", ""column2""}); /// ~~~; ///; /// See Define() for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:767,safe,safe,767,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['safe'],['safe']
Safety,"// class WebWindowHandle; /** @summary Method used to initialize connection to web window.; * @param {object} arg - arguments; * @param {string} [arg.socket_kind] - kind of connection longpoll|websocket, detected automatically from URL; * @param {number} [arg.credits = 10] - number of packets which can be send to server without acknowledge; * @param {object} arg.receiver - instance of receiver for websocket events, allows to initiate connection immediately; * @param {string} [arg.first_recv] - required prefix in the first message from RWebWindow, remain part of message will be returned in handle.first_msg; * @param {string} [arg.href] - URL to RWebWindow, using window.location.href by default; * @return {Promise} for ready-to-use {@link WebWindowHandle} instance */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:204,detect,detected,204,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['detect'],['detected']
Safety,"// clear now to avoid concurrent destruction of output trees and input tree (which has them listed as fClones)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:16,avoid,avoid,16,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['avoid'],['avoid']
Safety,// clear primitives produced by previous drawing to avoid flicking,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:52,avoid,avoid,52,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// clone the function to avoid later to sample it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/LikelihoodIntervalPlot.cxx:25,avoid,avoid,25,roofit/roostats/src/LikelihoodIntervalPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/LikelihoodIntervalPlot.cxx,1,['avoid'],['avoid']
Safety,"// close connection when unrecognized opcode is detected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TCivetweb.cxx:48,detect,detected,48,net/http/src/TCivetweb.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TCivetweb.cxx,1,['detect'],['detected']
Safety,"// close when normal close is detected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TCivetweb.cxx:30,detect,detected,30,net/http/src/TCivetweb.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TCivetweb.cxx,1,['detect'],['detected']
Safety,"// code should abort if not found",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/WrapperRooPdf.h:15,abort,abort,15,roofit/roofit/test/WrapperRooPdf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/test/WrapperRooPdf.h,1,['abort'],['abort']
Safety,"// commented out code was attempt to speed up things avoid unnecessarily reinitializing things over and over; // if (!fNll->kReuseNLL) {; // // can be faster just by putting back in old nll; // fNll->std::shared_ptr<RooAbsReal>::operator=(fOldNll);; // fNll->fData = fOldData.first;; // fNll->fGlobs = fOldData.second;; // } else {; // fNll->setData(fOldData);; // fNll->get()->SetName(fOldName);; // fNll->get()->setStringAttribute(""fitresultTitle"", (fOldTitle == """") ? nullptr : fOldTitle);; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx:53,avoid,avoid,53,roofit/xroofit/src/xRooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx,1,['avoid'],['avoid']
Safety,"// compute distance to get outside this shape; // return TGeoArb8::DistFromInside(point, dir, iact, step, safe);; // compute distance to plane ipl :; // ipl=0 : points 0,4,1,5; // ipl=1 : points 1,5,2,6; // ipl=2 : points 2,6,3,7; // ipl=3 : points 3,7,0,4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx:106,safe,safe,106,geom/geom/src/TGeoArb8.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx,1,['safe'],['safe']
Safety,"// compute safe distance",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx:11,safe,safe,11,geom/geom/src/TGeoArb8.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx,19,['safe'],['safe']
Safety,"// compute safe radius",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx:11,safe,safe,11,geom/geom/src/TGeoCone.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx,2,['safe'],['safe']
Safety,"// compute safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPara.cxx:11,safe,safety,11,geom/geom/src/TGeoPara.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPara.cxx,1,['safe'],['safety']
Safety,"// compute safety distance (distance to boundary ignored)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx:11,safe,safety,11,geom/geompainter/src/TGeoChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx,1,['safe'],['safety']
Safety,"// configure default html page; // either HTML code can be specified or just name of file after 'file:' prefix; // Detect file location to specify full path to the HTML file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx:115,Detect,Detect,115,tutorials/webgui/ping/ping.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/webgui/ping/ping.cxx,1,['Detect'],['Detect']
Safety,"// console.log('SUMMURY: detect changed', elem.id, elem.path);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/Summary.controller.js:25,detect,detect,25,ui5/eve7/controller/Summary.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/eve7/controller/Summary.controller.js,1,['detect'],['detect']
Safety,"// const_a, const_b, x -> clamp is safe in all cases including signaling; // nans.; // FIXME: Should this be allowing -0.0?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:35,safe,safe,35,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['safe'],['safe']
Safety,"// convergence when F is within TLF of AIM and next prediction; // of AOPT is within TLA of previous value of AOPT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:52,predict,prediction,52,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['predict'],['prediction']
Safety,"// convergence when F is within tlf of aim and next prediction; // of aopt is within tla of previous value of aopt",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnFunctionCross.cxx:52,predict,prediction,52,math/minuit2/src/MnFunctionCross.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnFunctionCross.cxx,1,['predict'],['prediction']
Safety,"// copy TF1 using TClass to avoid slicing in case of derived classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx:28,avoid,avoid,28,hist/hist/src/HFitImpl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitImpl.cxx,1,['avoid'],['avoid']
Safety,"// copy over opts ... need to clone each so can safely delete when _opts destroyed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:48,safe,safely,48,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['safe'],['safely']
Safety,"// could also avoid a function evaluation at maximum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:14,avoid,avoid,14,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['avoid'],['avoid']
Safety,"// could delete the file selname+"".h""; // However this would remove the optimization of avoiding a useless; // recompilation if the user ask for the same thing twice!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx:88,avoid,avoiding,88,tree/treeplayer/src/TTreePlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreePlayer.cxx,1,['avoid'],['avoiding']
Safety,"// cout<<""FK: rangeIdentical Single = ""<<(rangeIdentical ? 'T':'F')<<endl;; // coverity[CONSTANT_EXPRESSION_RESULT]; // LM : avoid making integral ratio if range is the same. Why was not included ??? (same at line 857)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:125,avoid,avoid,125,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['avoid'],['avoid']
Safety,"// coverity [Calling risky function]",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:21,risk,risky,21,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,6,['risk'],['risky']
Safety,"// coverity[past_the_end] Safe on other platforms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollectionProxyInfo.h:26,Safe,Safe,26,core/cont/inc/TCollectionProxyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollectionProxyInfo.h,3,['Safe'],['Safe']
Safety,"// coverity[tainted_data] The OS should already limit the argument size, so we are safe here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx:83,safe,safe,83,core/dictgen/src/rootcling_impl.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/src/rootcling_impl.cxx,1,['safe'],['safe']
Safety,"// create a new scope to avoid name clash",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Pool.hxx:25,avoid,avoid,25,tmva/sofie/inc/TMVA/ROperator_Pool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Pool.hxx,1,['avoid'],['avoid']
Safety,"// create code for parsing model and generate C++ code for inference; // make it in a separate scope to avoid polluting global interpreter space",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RSofieReader.hxx:104,avoid,avoid,104,tmva/tmva/inc/TMVA/RSofieReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RSofieReader.hxx,1,['avoid'],['avoid']
Safety,// create elements with safety margin,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/model/BrowserModel.js:24,safe,safety,24,ui5/browser/model/BrowserModel.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/model/BrowserModel.js,1,['safe'],['safety']
Safety,"// create parent on next line to avoid triggering workspace initialization code in constructor of xRooNode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx:33,avoid,avoid,33,roofit/xroofit/src/xRooNLLVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNLLVar.cxx,1,['avoid'],['avoid']
Safety,"// create pointer to output matrix used for the predictions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:48,predict,predictions,48,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,2,['predict'],['predictions']
Safety,"// create the tooltip with a timeout of 250 ms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootCanvas.cxx:29,timeout,timeout,29,gui/gui/src/TRootCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TRootCanvas.cxx,1,['timeout'],['timeout']
Safety,"// cross-check against the parallel world safety, using fSafety as limit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:42,safe,safety,42,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safety']
Safety,"// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:45,avoid,avoid,45,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// data = data; // avoid warning; // paramsOfInterest = paramsOfInterest; // avoid warning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/DebuggingSampler.h:19,avoid,avoid,19,roofit/roostats/inc/RooStats/DebuggingSampler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/DebuggingSampler.h,2,['avoid'],['avoid']
Safety,"// delete X connection handler (to avoid looping in TSystem::DispatchOneEvent())",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/GX11Gui.cxx:35,avoid,avoid,35,graf2d/x11/src/GX11Gui.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/x11/src/GX11Gui.cxx,1,['avoid'],['avoid']
Safety,// detect if event was triggered by pinching,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,detect,detect,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detect']
Safety,"// detect other operators",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLatex.cxx:3,detect,detect,3,graf2d/graf/src/TLatex.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/graf/src/TLatex.cxx,1,['detect'],['detect']
Safety,// detect same vertices on both Z-layers,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,detect,detect,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detect']
Safety,"// detect the attribute (__global__, __device__ and __host__) of CUDA; // kernels at the beginning of a function definition; // FIXME: should replaced by a generic solution",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:3,detect,detect,3,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['detect'],['detect']
Safety,"// detect variables from array",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariableInfo.cxx:3,detect,detect,3,tmva/tmva/src/VariableInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/VariableInfo.cxx,1,['detect'],['detect']
Safety,"// determines the mininum squared distance of point to a bounding box (""safey square"")",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:72,safe,safey,72,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safey']
Safety,"// disable cache to avoid infinite recursion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:20,avoid,avoid,20,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,1,['avoid'],['avoid']
Safety,"// disregard too small or invalid safeties",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:34,safe,safeties,34,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['safe'],['safeties']
Safety,"// do it in this order to remain exception-safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TBits.cxx:43,safe,safe,43,core/cont/src/TBits.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TBits.cxx,1,['safe'],['safe']
Safety,"// do like this to avoid nan's",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/test/testVectorIO.cxx:19,avoid,avoid,19,math/genvector/test/testVectorIO.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/test/testVectorIO.cxx,1,['avoid'],['avoid']
Safety,"// do not add the histogram to gDirectory; // use local TDirectory::TContect that will set temporarly gDirectory to a nullptr and; // will avoid that histogram is added in the global directory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:139,avoid,avoid,139,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,2,['avoid'],['avoid']
Safety,"// do not cache parameter values (it is not thread safe); //func.SetParameters(p);; // get fit option and check case if using integral of bins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h:51,safe,safe,51,math/mathcore/inc/Fit/FitUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h,2,['safe'],['safe']
Safety,"// do not call stack->GetHistogram() to avoid it auto-creation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/TObjectDrawable.cxx:40,avoid,avoid,40,graf2d/gpadv7/src/TObjectDrawable.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/TObjectDrawable.cxx,1,['avoid'],['avoid']
Safety,"// do not submit immediately, but after short timeout; // if user types very fast - only last selection will be shown",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/controller/Browser.controller.js:46,timeout,timeout,46,ui5/browser/controller/Browser.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/controller/Browser.controller.js,1,['timeout'],['timeout']
Safety,"// do not submit immediately, but after very short timeout; // if user types very fast - only last selection will be shown",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomHierarchy.controller.js:51,timeout,timeout,51,ui5/geom/controller/GeomHierarchy.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/controller/GeomHierarchy.controller.js,1,['timeout'],['timeout']
Safety,"// do not use GSL integrator which is not thread safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:49,safe,safe,49,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,4,['safe'],['safe']
Safety,"// do not use namespace to avoid too long JSON",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/inc/ROOT/RGeomData.hxx:27,avoid,avoid,27,geom/webviewer/inc/ROOT/RGeomData.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/inc/ROOT/RGeomData.hxx,1,['avoid'],['avoid']
Safety,"// do nothing, just cleanup timeout",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:28,timeout,timeout,28,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,"// do we need to support case when there are bins with labels and bins without them ??; // this case should have been detected before when examining the histograms",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx:118,detect,detected,118,hist/hist/src/TH1Merger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1Merger.cxx,1,['detect'],['detected']
Safety,"// doing this to avoid complaints about unused vars",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:17,avoid,avoid,17,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['avoid'],['avoid']
Safety,"// doing this to avoid complaints about unused vars; // TODO: Could consider using a 'filter' node (see filter() method) applied to the dataset instead; // of creating and using a reduced dataset here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:17,avoid,avoid,17,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['avoid'],['avoid']
Safety,"// don't change the user data, to avoid deletion of the; // list tree item by RecursiveRemove(); // it is better to read the object each time anyway,; // as it may have changed in the file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFileBrowser.cxx:34,avoid,avoid,34,gui/gui/src/TGFileBrowser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFileBrowser.cxx,2,['avoid'],['avoid']
Safety,// don't issue warning when protocol method is optional because primary; // class is not required to implement it and it is safe for protocol; // to implement it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp:124,safe,safe,124,interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclObjC.cpp,1,['safe'],['safe']
Safety,"// don't pass filename arg to TRint (avoid processing file)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootIDE/main.cxx:37,avoid,avoid,37,test/RootIDE/main.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootIDE/main.cxx,1,['avoid'],['avoid']
Safety,// double nonblocking detected,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp:22,detect,detected,22,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/MPI-Checker/MPIChecker.cpp,1,['detect'],['detected']
Safety,"// drawing after creating canvas to avoid drawing in default canvas",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/src/TStructViewerGUI.cxx:36,avoid,avoid,36,graf3d/gviz3d/src/TStructViewerGUI.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gviz3d/src/TStructViewerGUI.cxx,1,['avoid'],['avoid']
Safety,// drop predecessors as they can be big and are redundant,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp:48,redund,redundant,48,interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Passes/StandardInstrumentations.cpp,2,['redund'],['redundant']
Safety,"// dummy stack entry to avoid extra checks in the beginning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx:24,avoid,avoid,24,io/io/src/TBufferJSON.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx,1,['avoid'],['avoid']
Safety,// eliminate infinite recursion -- assume that this node is not redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp:64,redund,redundant,64,interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafetyTIL.cpp,1,['redund'],['redundant']
Safety,"// else we can use BP and FP, but the offset from FP won't fit.; // That will make us scavenge registers which we can probably avoid by; // using BP. If it won't fit for BP either, we'll scavenge anyway.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp:127,avoid,avoid,127,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64FrameLowering.cpp,1,['avoid'],['avoid']
Safety,"// emit Timeout() signal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimer.cxx:8,Timeout,Timeout,8,core/base/src/TTimer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimer.cxx,1,['Timeout'],['Timeout']
Safety,"// empty case to avoid compiler warning about unhandled enum values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEntry.cxx:17,avoid,avoid,17,gui/gui/src/TGTextEntry.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEntry.cxx,1,['avoid'],['avoid']
Safety,// enable-unsafe-fp-math; // FADD -> FMA combines:,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:10,unsafe,unsafe-fp-math,10,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['unsafe'],['unsafe-fp-math']
Safety,"// enable/disable parallel world safety caching",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:33,safe,safety,33,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['safe'],['safety']
Safety,"// end anonymous namespace; // FIXME FIXME FIXME: There are number of places in this file where we convert; // what is a 64-bit assembler value used for computation into a value in the; // object file, which may truncate it. We should detect that truncation where; // invalid and report errors back.; /* *** */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp:235,detect,detect,235,interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCAssembler.cpp,1,['detect'],['detect']
Safety,"// end anonymous namespace; /// Create the fragile-ABI read and write hazards based on the current; /// state of the function, which is presumed to be immediately prior; /// to a @try block. These hazards are used to maintain correct; /// semantics in the face of optimization and the fragile ABI's; /// cavalier use of setjmp/longjmp.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:70,hazard,hazards,70,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,2,['hazard'],['hazards']
Safety,"// end anonymous namespace; /// canSpeculateInstrs - Returns true if all the instructions in MBB can safely; /// be speculated. The terminators are not considered.; ///; /// If instructions use any values that are defined in the head basic block,; /// the defining instructions are added to InsertAfter.; ///; /// Any clobbered regunits are added to ClobberedRegUnits.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:101,safe,safely,101,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,1,['safe'],['safely']
Safety,"// end namespace ROOT; // move implementations here to avoid circle dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Cylindrical3D.h:55,avoid,avoid,55,math/genvector/inc/Math/GenVector/Cylindrical3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Cylindrical3D.h,7,['avoid'],['avoid']
Safety,"// end namespace detail; /// A sum type over pointer-like types.; ///; /// This is a normal tagged union across pointer-like types that uses the low; /// bits of the pointers to store the tag.; ///; /// Each member of the sum type is specified by passing a \c; /// PointerSumTypeMember specialization in the variadic member argument list.; /// This allows the user to control the particular tag value associated with; /// a particular type, use the same type for multiple different tags, and; /// customize the pointer-like traits used for a particular member. Note that; /// these *must* be specializations of \c PointerSumTypeMember, no other type; /// will suffice, even if it provides a compatible interface.; ///; /// This type implements all of the comparison operators and even hash table; /// support by comparing the underlying storage of the pointer values. It; /// doesn't support delegating to particular members for comparisons.; ///; /// It also default constructs to a zero tag with a null pointer, whatever that; /// would be. This means that the zero value for the tag type is significant; /// and may be desirable to set to a state that is particularly desirable to; /// default construct.; ///; /// Having a supported zero-valued tag also enables getting the address of a; /// pointer stored with that tag provided it is stored in its natural bit; /// representation. This works because in the case of a zero-valued tag, the; /// pointer's value is directly stored into this object and we can expose the; /// address of that internal storage. This is especially useful when building an; /// `ArrayRef` of a single pointer stored in a sum type.; ///; /// There is no support for constructing or accessing with a dynamic tag as; /// that would fundamentally violate the type safety provided by the sum type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h:1792,safe,safety,1792,interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerSumType.h,1,['safe'],['safety']
Safety,"// end namespace detail; /// Detects if a given trait holds for some set of arguments 'Args'.; /// For example, the given trait could be used to detect if a given type; /// has a copy assignment operator:; /// template<class T>; /// using has_copy_assign_t = decltype(std::declval<T&>(); /// = std::declval<const T&>());; /// bool fooHasCopyAssign = is_detected<has_copy_assign_t, FooClass>::value;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:29,Detect,Detects,29,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,2,"['Detect', 'detect']","['Detects', 'detect']"
Safety,// end namespace safestack,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h:17,safe,safestack,17,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,1,['safe'],['safestack']
Safety,"// ensure that ranges are properly handled, even if the ranges are invalid; // let: start = desired start, end = desired end, last = actually last entry; // possible cases: default: 0 = start < last < end = max (already implicitly tested above); // 0. start < end <= last; // 1. similar to above but test the case the start is after the first tree); // * In MT runs, there is the additional optimization: once the desired end is reached,; // stop processing further trees, i.e. range asked is [1, 3] and the df has 2 trees; // of 5 entries each -> the second tree is not open.; // 2. 0 = start < last < end < max; // 3. 0 < start < last < end < max; // 4. start = end <= last -> enter the RLoopManager and do no work there (no sanity checks); // 5. start = end > last -> enter the RLoopManager and do no work there (no sanity checks); // 6. last = start < end -> error after getting the number of entries; // 7. last + 1 = start < end -> error after getting the number of entries; // 8. last < start < end -> error after getting the number of entries; // start > end -> error in the spec directly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx:727,sanity check,sanity checks,727,tree/dataframe/test/dataframe_datasetspec.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/test/dataframe_datasetspec.cxx,2,['sanity check'],['sanity checks']
Safety,"// evaluate the derivative of the function with respect to the parameters; //IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; // BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; // so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx:144,avoid,avoid,144,hist/hist/src/WrappedTF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/WrappedTF1.cxx,1,['avoid'],['avoid']
Safety,"// evaluate the gradient of the chi2 function; // this function is used when the model function knows how to calculate the derivative and we can; // avoid that the minimizer re-computes them; //; // case of chi2 effective (errors on coordinate) is not supported",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h:149,avoid,avoid,149,math/mathcore/inc/Fit/FitUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h,2,['avoid'],['avoid']
Safety,"// evaluate the gradient of the function with respect to the parameters; //IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; // BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; // so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedMultiTF1.h:142,avoid,avoid,142,hist/hist/inc/Math/WrappedMultiTF1.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/Math/WrappedMultiTF1.h,1,['avoid'],['avoid']
Safety,"// eve7 click handler; // if normal event, set longer timeout waiting if double click not detected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:54,timeout,timeout,54,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['detect', 'timeout']","['detected', 'timeout']"
Safety,"// every time the texture cache key changes, it's necessary to check if an instance of; // WebGLTexture can be deleted in order to avoid a memory leak.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:131,avoid,avoid,131,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,// exit here to avoid conflicts,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:16,avoid,avoid,16,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,6,['avoid'],['avoid']
Safety,"// exp10, exp10f, exp10l is available on Linux (GLIBC) but are extremely; // buggy prior to glibc version 2.18. Until this version is widely deployed; // or we have a reasonable detection strategy, we cannot use exp10 reliably; // on Linux.; //; // Fall through to disable all of them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp:178,detect,detection,178,interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/TargetLibraryInfo.cpp,1,['detect'],['detection']
Safety,"// exponent in Mehrotra's centering parameter, which is usually; // chosen to me (muaff/mu)^tsig, where muaff is the predicted; // complementarity gap obtained from an affine-scaling step, while; // mu is the current complementarity gap",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TGondzioSolver.h:117,predict,predicted,117,math/quadp/inc/TGondzioSolver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TGondzioSolver.h,2,['predict'],['predicted']
Safety,"// fBranch->GetDirectory();; // This mutex prevents multiple TBasket::WriteBuffer invocations from interacting; // with the underlying TFile at once - TFile is assumed to *not* be thread-safe.; //; // The only parallelism we'd like to exploit (right now!) is the compression; // step - everything else should be serialized at the TFile level.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:187,safe,safe,187,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['safe'],['safe']
Safety,"// fFrame is just being deleted (we're here called by TGUndockedFrame's; // destructor) so just set it NULL below to avoid eventual problems in; // TGDockableFrame's destructor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDockableFrame.cxx:117,avoid,avoid,117,gui/gui/src/TGDockableFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDockableFrame.cxx,1,['avoid'],['avoid']
Safety,"// fNStopsReceived < fNChildren is always true at the moment as we don't support event loop early quitting in; // multi-thread runs, but it costs nothing to be safe and future-proof in case we add support for that later.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:160,safe,safe,160,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['safe'],['safe']
Safety,// fake use to avoid build failure when assertions disabled,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:15,avoid,avoid,15,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"// fcmp (fpext X), C -> fcmp X, (fptrunc C) if fptrunc is lossless; // Avoid lossy conversions and denormals.; // Zero is a special case that's OK to convert.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:71,Avoid,Avoid,71,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['Avoid'],['Avoid']
Safety,"// fdot2_f32_f16 always flushes fp32 denormal operand and output to zero,; // regardless of the denorm mode setting. Therefore,; // unsafe-fp-math/fp-contract is sufficient to allow generating fdot2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:132,unsafe,unsafe-fp-math,132,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['unsafe'],['unsafe-fp-math']
Safety,"// fill the input tensor fXInput from the current Event data; // with the correct shape depending on the model used; // The input tensor is used for network prediction after training ; // using a single event. The network batch size must be equal to 1. ; // The architecture specified at compile time in ArchitectureImpl_t; // is used. This should be the CPU architecture",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:157,predict,prediction,157,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['predict'],['prediction']
Safety,"// filling of a histogram is locked to avoid data loss",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/threads.cxx:39,avoid,avoid,39,test/threads.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/threads.cxx,1,['avoid'],['avoid']
Safety,// findBBsToSinkInto is O(BBs.size() * ColdLoopBBs.size()). We cap the max; // BBs.size() to avoid expensive computation.; // FIXME: Handle code size growth for min_size and opt_size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,1,['avoid'],['avoid']
Safety,"// findCopyInsertPoint - Find a safe place in MBB to insert a copy from SrcReg; // when following the CFG edge to SuccMBB. This needs to be after any def of; // SrcReg, but before any subsequent point where control flow might jump out of; // the basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.cpp:32,safe,safe,32,interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.cpp,1,['safe'],['safe']
Safety,"// first delete the data to avoid memory leaks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFileBrowser.cxx:28,avoid,avoid,28,gui/gui/src/TGFileBrowser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFileBrowser.cxx,1,['avoid'],['avoid']
Safety,"// float4 fhi = (float4) hi - (0x1.0p39f + 0x1.0p23f);; // NOTE: By using fsub of a positive constant instead of fadd of a negative; // constant, we avoid reassociation in MachineCombiner when unsafe-fp-math is; // enabled. See PR24512.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:149,avoid,avoid,149,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,2,"['avoid', 'unsafe']","['avoid', 'unsafe-fp-math']"
Safety,"// fold (fshl N0, N0, N2) -> (rotl N0, N2); // fold (fshr N0, N0, N2) -> (rotr N0, N2); // TODO: Investigate flipping this rotate if only one is legal, if funnel shift; // is legal as well we might be better off avoiding non-constant (BW - N2).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:212,avoid,avoiding,212,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoiding']
Safety,"// fold (fsub (fneg (fpext (fmul, x, y))), z); // -> (fneg (fma (fpext x)), (fpext y), z); // Note: This could be removed with appropriate canonicalization of the; // input expression into (fneg (fadd (fpext (fmul, x, y)), z). However, the; // orthogonal flags -fp-contract=fast and -enable-unsafe-fp-math prevent; // from implementing the canonicalization in visitFSUB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:291,unsafe,unsafe-fp-math,291,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['unsafe'],['unsafe-fp-math']
Safety,"// fold (fsub (fpext (fneg (fmul, x, y))), z); // -> (fneg (fma (fpext x), (fpext y), z)); // Note: This could be removed with appropriate canonicalization of the; // input expression into (fneg (fadd (fpext (fmul, x, y)), z). However, the; // orthogonal flags -fp-contract=fast and -enable-unsafe-fp-math prevent; // from implementing the canonicalization in visitFSUB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:291,unsafe,unsafe-fp-math,291,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['unsafe'],['unsafe-fp-math']
Safety,"// fold (select (setcc x, [+-]0.0, *lt), NaN, (fsqrt x)); // The select + setcc is redundant, because fsqrt returns NaN for X < 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:83,redund,redundant,83,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['redund'],['redundant']
Safety,"// fold (shl (zext (srl x, C)), C) -> (zext (shl (srl x, C), C)); // Only fold this if the inner zext has no other uses to avoid increasing; // the total number of instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:123,avoid,avoid,123,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// fold (urem X, -1) -> select(FX == -1, 0, FX); // Freeze the numerator to avoid a miscompile with an undefined value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:76,avoid,avoid,76,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// for (auto * dataMember : fData) {; // //printf(""add data member for class %s - member %s \n"",GetName(), dataMember->GetName() );; // cl->fData->Add(dataMember);; // }; // // set loaded bit to true to avoid re-loading the data members; // cl->fData->SetIsLoaded();*; //cl->fData = (TListOfDataMembers*)fData;; // The TDataMember were passed along.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx:203,avoid,avoid,203,core/meta/src/TProtoClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TProtoClass.cxx,1,['avoid'],['avoid']
Safety,"// for (int iobs = 0; iobs < obsList.size(); ++iobs) {; // RooRealVar * thisObs = dynamic_cast<RooRealVar*> &obsList[i];; // if (thisObs == 0) continue;; // // loop on the bin contents; // for(int ibin=0; ibin<thisObs->numBins(); ++ibin){; // thisObs->setBin(ibin);; // thisNorm=pdftmp->getVal(obstmp)*thisObs->getBinWidth(jj);; // if (thisNorm*expectedEvents <= 0); // {; // cout << ""WARNING::Detected bin with zero expected events! Please check your inputs."" << endl;; // }; // // have a cut off for overflows ??; // obsDataUnbinned->add(*mc->GetObservables(), thisNorm*expectedEvents);; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx:394,Detect,Detected,394,roofit/roostats/src/AsymptoticCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx,1,['Detect'],['Detected']
Safety,"// for a while, this node's parent pointed to something of type Node2!!; // how to fix??? - I fxied it with a new constructor to avoid the shared_ptr<Node2> calling the const; // Node2& constructor via getting wrapped in a Node2(shared_ptr<TObject>) call; // out.back()->fParent = _pdf;; // std::cout << "" type2 = "" << out.back()->fParent->get()->ClassName() << std::endl;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:129,avoid,avoid,129,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['avoid'],['avoid']
Safety,"// for profiles in 2D and 3D avoid problems with bins with zero error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:29,avoid,avoid,29,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['avoid'],['avoid']
Safety,"// for safe log(x)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:7,safe,safe,7,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['safe'],['safe']
Safety,"// for safety force a refresh of the cache (and tracking) in the nll; // DO NOT do a ConfigChange ... this is just a deactivate-reactivate of caching; // but it seems like doing this breaks the const optimization and function is badly behaved; // so once its turned on never turn it off.; // nll.constOptimizeTestStatistic(RooAbsArg::ConfigChange, constOptimize>1 /* do tracking too if >1 */); //; // trigger a re-evaluate of which nodes to cache-and-track; // the next line seems safe to do but wont bother doing it because not bothering with above; // need to understand why turning the cache off and on again breaks it??; // nll.constOptimizeTestStatistic(RooAbsArg::ValueChange, constOptimize>1); // update the cache values -- is; // this needed??",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx:7,safe,safety,7,roofit/xroofit/src/xRooFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooFit.cxx,2,['safe'],"['safe', 'safety']"
Safety,"// for safety, shouldn't normally be the case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:7,safe,safety,7,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['safe'],['safety']
Safety,"// for sanity check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx:7,sanity check,sanity check,7,gui/guibuilder/src/TGuiBldDragManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx,1,['sanity check'],['sanity check']
Safety,"// for simplicity of the example (avoiding getters/setters) we make data members public as well",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Job.cxx:34,avoid,avoiding,34,roofit/multiprocess/test/test_Job.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/test/test_Job.cxx,1,['avoid'],['avoiding']
Safety,"// for the errors use the getters by index to avoid cases when the arrays are zero; // (like in a case of a graph)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitInterface.cxx:46,avoid,avoid,46,hist/hist/src/HFitInterface.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitInterface.cxx,1,['avoid'],['avoid']
Safety,"// formula functions; // if ndim is not 1 set xmin max to zero to avoid error in ctor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:66,avoid,avoid,66,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['avoid'],['avoid']
Safety,"// forward classes are not verifiable, therefore not safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:53,safe,safe,53,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,1,['safe'],['safe']
Safety,// freeze it to be safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:19,safe,safe,19,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['safe'],['safe']
Safety,"// from CPython's instancemethod: Free list for method objects to safe malloc/free overhead; // The fSelf field is used to chain the elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:66,safe,safe,66,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,1,['safe'],['safe']
Safety,// fshl is a rotate; // Avoid converting rotate into funnel shift.; // Only simplify if one operand is constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:24,Avoid,Avoid,24,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['Avoid'],['Avoid']
Safety,"// function to avoid infinities or nan",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx:15,avoid,avoid,15,math/mathcore/src/FitUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/FitUtil.cxx,1,['avoid'],['avoid']
Safety,"// gGeoManager is defined in the Geom libraries and we want to make sure we; // do not load it when autoloading is off. We can only test this in modules; // mode because gGeoManager is not part of the PCH and non-modular ROOT has; // header parsing and autoloading coupled leading to redundant load of; // libGeom at gROOT->GetGlobal time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingDataMemberInfoTests.cxx:284,redund,redundant,284,core/metacling/test/TClingDataMemberInfoTests.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/test/TClingDataMemberInfoTests.cxx,1,['redund'],['redundant']
Safety,"// get Hessian - inverse of covariance matrix; // just invert it; // but need to get the compact form to avoid the zero for the fixed parameters",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:105,avoid,avoid,105,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,1,['avoid'],['avoid']
Safety,"// get parameter name for i; // (need separate scope for avoiding compl error when declaring name)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnHesse.cxx:57,avoid,avoiding,57,math/minuit2/src/MnHesse.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnHesse.cxx,1,['avoid'],['avoiding']
Safety,"// go through pipes, and change flags where we already know without really; // polling - stuff where we don't need poll to wait for its timeout in the; // OS...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:136,timeout,timeout,136,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['timeout'],['timeout']
Safety,"// guarantee that all emitted copies are; // stuck together, avoiding something bad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp:61,avoid,avoiding,61,interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARC/ARCISelLowering.cpp,2,['avoid'],['avoiding']
Safety,"// hack to detect the case where the user pressed the; // Cancel button",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGInputDialog.cxx:11,detect,detect,11,gui/gui/src/TGInputDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGInputDialog.cxx,1,['detect'],['detect']
Safety,"// handle ${foo}bar as $foo by detecting whether the character following; // the dollar sign is a curly brace. If so, advance VarEnd and DollarPos; // so the variable name does not contain the leading curly brace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterInst.cpp:31,detect,detecting,31,interpreter/llvm-project/llvm/utils/TableGen/AsmWriterInst.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterInst.cpp,1,['detect'],['detecting']
Safety,"// hasFP only knows about stack objects that already exist. We're now; // determining the stack slots that will be created, so we have to predict; // them. Stack objects force FP usage with calls.; //; // Note a new VGPR CSR may be introduced if one is used for the spill, but we; // don't want to report it here.; //; // FIXME: Is this really hasReservedCallFrame?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp:138,predict,predict,138,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIFrameLowering.cpp,1,['predict'],['predict']
Safety,"// helper functions related to local safety caching (3D voxel grid); // Given a 3D point, returns the; // a) the min radius R such that there is at least one leaf bounding box fully enclosed; // in the sphere of radius R around point; // b) the set of leaf bounding boxes who partially lie within radius + margin; // ... using BVH",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:37,safe,safety,37,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['safe'],['safety']
Safety,"// helper to verify expected safety of moving an instance into C++",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/API.h:29,safe,safety,29,bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/API.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/include/CPyCppyy/API.h,1,['safe'],['safety']
Safety,// iOS is always safe to use 'weak'.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:17,safe,safe,17,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,1,['safe'],['safe']
Safety,// id/NSObject is not safe for weak.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp:22,safe,safe,22,interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/Transforms.cpp,1,['safe'],['safe']
Safety,"// if (!leaf->InheritsFrom(TLeafObject::Class()) ) {; // If the leaf that we found so far is not a TLeafObject then there is; // nothing we would be able to do.; // Error(""DefinedVariable"",""Need a TLeafObject to call a function!"");; // return -1;; //}; // We need to recover the info not used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:267,recover,recover,267,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['recover'],['recover']
Safety,"// if (!nastyprint) {; // printf(""Found nasty Hbook case!! You had an Hbook error message\n"");; // printf("" when creating the file (too many records)\n"");; // printf("" Hbook file should have been created with a bigger LRECL\n"");; // printf("" ROOT will try to recover\n"");; // nastyprint = 1;; // }; // nastycase = 1;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/src/h2root.cxx:259,recover,recover,259,main/src/h2root.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/src/h2root.cxx,1,['recover'],['recover']
Safety,"// if (!original_prefix); // move qualifiers on the outer type (avoid 'std::const string'!)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp:64,avoid,avoid,64,interpreter/cling/lib/Utils/AST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp,1,['avoid'],['avoid']
Safety,"// if (PreCond) {; // for (IV in 0..LastIteration) BODY;; // <Final counter/linear vars updates>;; // }; //; // Emit: if (PreCond) - begin.; // If the condition constant folds and can be elided, avoid emitting the; // whole loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp:195,avoid,avoid,195,interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmtOpenMP.cpp,1,['avoid'],['avoid']
Safety,"// if (_ul->getVal()<1){; // RooStats::LikelihoodIntervalPlot plotpll((RooStats::LikelihoodInterval*) pllint);; // TCanvas c1;; // plotpll.Draw();; // c1.Print(""test.ps"");; // std::cout<<"" UL<1 whats going on here?""<<std::endl;; // abort();; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/UpperLimitMCSModule.cxx:232,abort,abort,232,roofit/roostats/src/UpperLimitMCSModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/UpperLimitMCSModule.cxx,1,['abort'],['abort']
Safety,"// if > 0, timeout in sec",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:11,timeout,timeout,11,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['timeout'],['timeout']
Safety,// if AttributesCloner.getOutOffset() == 0 then we need to add; // 1 to avoid assertion for zero size. We will subtract it back later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp:72,avoid,avoid,72,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.cpp,1,['avoid'],['avoid']
Safety,"// if Op (Op N00, N1), N01 already exist; // we need to stop reassciate to avoid dead loop",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:75,avoid,avoid,75,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// if Op (Op N01, N1), N00 already exist; // we need to stop reassciate to avoid dead loop",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:75,avoid,avoid,75,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// if action is 1 we delete the buffer; // this will avoid infinite recursion",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:53,avoid,avoid,53,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['avoid'],['avoid']
Safety,"// if an error happens, it usually means the decl has already been; // imported or the decl is a result of a failed import. But in our; // case, every import is fresh each time code completion is; // triggered. So Import usually doesn't fail. If it does, it just means; // the related decl can't be used in code completion and we can safely; // drop it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp:334,safe,safely,334,interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/CodeCompletion.cpp,1,['safe'],['safely']
Safety,"// if attribute was found, skip the token and use the function; // detection later",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp:67,detect,detection,67,interpreter/cling/lib/Utils/SourceNormalization.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/SourceNormalization.cpp,1,['detect'],['detection']
Safety,// if canonical add to template's set.; // The template that contains the specializations set. It's not safe to; // use getCanonicalDecl on Template since it may still be initializing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:104,safe,safe,104,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['safe'],['safe']
Safety,"// if close to minimum stop to avoid oscillations around minimum value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliBuilder.cxx:31,avoid,avoid,31,math/minuit2/src/FumiliBuilder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliBuilder.cxx,1,['avoid'],['avoid']
Safety,"// if closing happens too early (e.g. timeout) the underlying; // socket may still be open",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx:38,timeout,timeout,38,net/net/src/TPSocket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TPSocket.cxx,1,['timeout'],['timeout']
Safety,// if detect of coordinates fails - ignore,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:6,detect,detect,6,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detect']
Safety,"// if it is a call to gVirtualX and comes from a secondary thread,; // delay it and process it via the main thread (to avoid deadlocks).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32ProxyBase.cxx:119,avoid,avoid,119,graf2d/win32gdk/src/TGWin32ProxyBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/win32gdk/src/TGWin32ProxyBase.cxx,1,['avoid'],['avoid']
Safety,"// if jsrootsys location not detected, try to guess it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:29,detect,detected,29,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detected']
Safety,"// if number of entries is consistent with buffer - set it negative to avoid; // refilling the histogram every time BufferEmpty(0) is called; // In case it is not consistent, by setting fBuffer[0]=0 is like resetting the buffer; // (it will not be used anymore the next time BufferEmpty is called)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:71,avoid,avoid,71,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['avoid'],['avoid']
Safety,"// if object exists in gROOT remove it to avoid a memory leak",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:42,avoid,avoid,42,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,1,['avoid'],['avoid']
Safety,"// if pdf has no floor, will evaluate it as a function to allow it to be negative - evaluation should; // also be faster (no integral); // exception is if RooRealSumPdf is embedded in a RooAddPdf (detected by presence of coefs) ... then it must be; // evaluated as a pdf technically should check parent is a RooAddPdf, because if was inside a RooRealSumPdf then; // would be evaluated as a function!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:197,detect,detected,197,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['detect'],['detected']
Safety,"// if the basket is not yet on file but already has event in it; // we must continue to avoid dropping the basket (and thus losing data)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:88,avoid,avoid,88,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['avoid'],['avoid']
Safety,// if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid; // extremely large values,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:87,avoid,avoid,87,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:85,avoid,avoid,85,hist/hist/src/TH3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx,1,['avoid'],['avoid']
Safety,"// if the variable is neither in the variables nor in the spectators, we abort",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCategory.cxx:73,abort,abort,73,tmva/tmva/src/MethodCategory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCategory.cxx,1,['abort'],['abort']
Safety,"// if there are too many input variables, the creation of correlations plots blows up; // memory and basically kills the TMVA execution; // --> avoid above critical number (which can be user defined)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/TransformationHandler.cxx:144,avoid,avoid,144,tmva/tmva/src/TransformationHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/TransformationHandler.cxx,1,['avoid'],['avoid']
Safety,// if this is a line comment we can drop it safely,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:44,safe,safely,44,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,2,['safe'],['safely']
Safety,"// if tooltips were visible before, try to reconstruct them after short timeout",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:72,timeout,timeout,72,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,"// if true, the population will make copies of the first individuals; // avoid for speed performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/GeneticAlgorithm.h:73,avoid,avoid,73,tmva/tmva/inc/TMVA/GeneticAlgorithm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/GeneticAlgorithm.h,1,['avoid'],['avoid']
Safety,// if vector input detect NaNs and fill mask,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp:19,detect,detect,19,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/Execution.cpp,1,['detect'],['detect']
Safety,"// if we have a fully initialized TypeDecl, we can safely read its type now.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp:51,safe,safely,51,interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReaderDecl.cpp,1,['safe'],['safely']
Safety,"// ignore browsing during TBrowser constructor, avoid gROOT adding",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/src/TObjectElement.cxx:48,avoid,avoid,48,gui/browsable/src/TObjectElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browsable/src/TObjectElement.cxx,1,['avoid'],['avoid']
Safety,"// implement filling of projected histogram; // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; // inbin is the axis being integrated. Loop is done only on the selected bins; // if the out axis has labels and is extendable, temporary make it non-extendable to avoid adding extra bins",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:309,avoid,avoid,309,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['avoid'],['avoid']
Safety,"// in case level will abort we will not come here...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx:22,abort,abort,22,tree/treeviewer/src/TTreeViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTreeViewer.cxx,1,['abort'],['abort']
Safety,"// in case of failure or implausible value, use a safe default: 4k; // page size, and do not try to mmap",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:50,safe,safe,50,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['safe'],['safe']
Safety,"// in case parameter needs to be propagated to user function use trick to set parameters by calling one time the function; // this will be done in sequential mode and parameters can be set in a thread safe manner",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h:201,safe,safe,201,math/mathcore/inc/Fit/FitUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/FitUtil.h,2,['safe'],['safe']
Safety,"// in case when server does not support segments, let chance to recover",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx:64,recover,recover,64,net/net/src/TWebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TWebFile.cxx,1,['recover'],['recover']
Safety,"// inadequate space is detected. fIPessimism is for array ""fIw"",; // fRPessimism is for the array ""fact"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TDecompSparse.h:23,detect,detected,23,math/matrix/inc/TDecompSparse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/matrix/inc/TDecompSparse.h,1,['detect'],['detected']
Safety,"// include a separate scope to avoid defining unique operator temp variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Conv.hxx:31,avoid,avoid,31,tmva/sofie/inc/TMVA/ROperator_Conv.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Conv.hxx,2,['avoid'],['avoid']
Safety,"// increment session Id to avoid clash in session variable name",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/test/TestSofieModels.cxx:27,avoid,avoid,27,tmva/sofie/test/TestSofieModels.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/test/TestSofieModels.cxx,1,['avoid'],['avoid']
Safety,"// initialize the array with the expected standard colors:; // (from http://frexx.de/xterm-256-notes); // this is not what I see, though it's supposedly the default:; // rgb[0][0] = 0; rgb[0][1] = 0; rgb[0][1] = 0;; // use this instead, just to be on the safe side:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplayUnix.cpp:255,safe,safe,255,core/textinput/src/textinput/TerminalDisplayUnix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplayUnix.cpp,1,['safe'],['safe']
Safety,"// inode to TFileSysDir map, to detect softlinks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/html/inc/THtml.h:32,detect,detect,32,html/inc/THtml.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/html/inc/THtml.h,1,['detect'],['detect']
Safety,"// install custom X11 error handler to avoid application exit in case of X11 failure",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/gui_handler_linux.cxx:39,avoid,avoid,39,gui/cefdisplay/src/gui_handler_linux.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/gui_handler_linux.cxx,1,['avoid'],['avoid']
Safety,"// integer, optional (default=1); //The number of jobs to run in parallel for both `fit` and `predict`.; //If -1, then the number of jobs is set to the number of cores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyRandomForest.h:94,predict,predict,94,tmva/pymva/inc/TMVA/MethodPyRandomForest.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyRandomForest.h,1,['predict'],['predict']
Safety,"// introduce large timeout",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:19,timeout,timeout,19,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['timeout'],['timeout']
Safety,"// inttoptr only works for integral pointers. For non-integral pointers, we; // can create a GEP on null with the integral value as index. Note that; // it is safe to use GEP of null instead of inttoptr here, because only; // expressions already based on a GEP of null should be converted to pointers; // during expansion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:159,safe,safe,159,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['safe'],['safe']
Safety,"// inverse Fermi function; // sanity check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodLikelihood.cxx:30,sanity check,sanity check,30,tmva/tmva/src/MethodLikelihood.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodLikelihood.cxx,1,['sanity check'],['sanity check']
Safety,"// invoke signal outside locked mutex to avoid any locking",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx:41,avoid,avoid,41,geom/webviewer/src/RGeomData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx,1,['avoid'],['avoid']
Safety,// is a timeout pending?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:8,timeout,timeout,8,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,"// is is highly recommended to set directory to nullptr to avoid ownership conflicts",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/tobject.cxx:59,avoid,avoid,59,tutorials/rcanvas/tobject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/rcanvas/tobject.cxx,1,['avoid'],['avoid']
Safety,// isNullValue() always returns false when called on a ConstantExpr.; // Skip constant expressions to avoid propagating incorrect information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:102,avoid,avoid,102,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,1,['avoid'],['avoid']
Safety,"// isProfitable() is structured to avoid endless loop interchange.; // If loop cache analysis could decide the profitability then,; // profitability check will stop and return the analysis result.; // If cache analysis failed to analyze the loopnest (e.g.,; // due to delinearization issues) then only check whether it is; // profitable for InstrOrderCost. Likewise, if InstrOrderCost failed to; // analysis the profitability then only, isProfitableForVectorization; // will decide.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp:35,avoid,avoid,35,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopInterchange.cpp,1,['avoid'],['avoid']
Safety,"// isRedundantFlagInstr - check whether the first instruction, whose only; // purpose is to update flags, can be made redundant.; // * SFSUB_F_RR can be made redundant by SUB_RI if the operands are the same.; // * SFSUB_F_RI can be made redundant by SUB_I if the operands are the same.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp:118,redund,redundant,118,interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Lanai/LanaiInstrInfo.cpp,3,['redund'],['redundant']
Safety,"// isTruncateOf - If N is a truncate of some other value, return true, record; // the value being truncated in Op and which of Op's bits are zero/one in Known.; // This function computes KnownBits to avoid a duplicated call to; // computeKnownBits in the caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:200,avoid,avoid,200,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"// iterativelySimplifyCFG can (rarely) make some loops dead. If this happens,; // removeUnreachableBlocks is needed to nuke them, which means we should; // iterate between the two optimizations. We structure the code like this to; // avoid rerunning iterativelySimplifyCFG if the second pass of; // removeUnreachableBlocks doesn't do anything.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:234,avoid,avoid,234,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,1,['avoid'],['avoid']
Safety,"// just safety computed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPgon.cxx:8,safe,safety,8,geom/geom/src/TGeoPgon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPgon.cxx,1,['safe'],['safety']
Safety,"// just to avoid compiler warnings",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RAttrMap.cxx:11,avoid,avoid,11,graf2d/gpadv7/src/RAttrMap.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/src/RAttrMap.cxx,1,['avoid'],['avoid']
Safety,// just to avoid hide,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:11,avoid,avoid,11,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['avoid'],['avoid']
Safety,"// just to avoid warning on CC compiler",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTVLVContainer.cxx:11,avoid,avoid,11,tree/treeviewer/src/TTVLVContainer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeviewer/src/TTVLVContainer.cxx,1,['avoid'],['avoid']
Safety,"// kernel function pointer must be set to null before calling SetKernelFunction to avoid memory leaks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx:83,avoid,avoid,83,hist/hist/src/TKDE.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TKDE.cxx,1,['avoid'],['avoid']
Safety,"// last sanity check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx:8,sanity check,sanity check,8,tmva/tmva/src/MethodPDERS.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDERS.cxx,1,['sanity check'],['sanity check']
Safety,// layering violation required for safe SemaConsumer,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTConsumer.h:35,safe,safe,35,interpreter/llvm-project/clang/include/clang/AST/ASTConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTConsumer.h,1,['safe'],['safe']
Safety,// ld64 version 262 and above runs the deduplicate pass by default.; // FIXME: lld doesn't dedup by default. Should we pass `--icf=safe`; // if `!shouldLinkerNotDedup()` if LinkerIsLLD here?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp:131,safe,safe,131,interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Darwin.cpp,1,['safe'],['safe']
Safety,"// ldexp(ldexp(x, a), b) -> ldexp(x, a + b); //; // The danger is if the first ldexp would overflow to infinity or underflow; // to zero, but the combined exponent avoids it. We ignore this with; // reassoc.; //; // It's also safe to fold if we know both exponents are >= 0 or <= 0 since; // it would just double down on the overflow/underflow which would occur; // anyway.; //; // TODO: Could do better if we had range tracking for the input value; // exponent. Also could broaden sign check to cover == 0 case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:164,avoid,avoids,164,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,2,"['avoid', 'safe']","['avoids', 'safe']"
Safety,"// let box2 = new THREE.Box3().makeEmpty();; // box2.expandByObject(this._toplevel, true);; // console.log('min,max', box.min.x, box.max.x, box.min.y, box.max.y, box.min.z, box.max.z );; // if detect of coordinates fails - ignore",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:193,detect,detect,193,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detect']
Safety,// let submit new request after timeout,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:32,timeout,timeout,32,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,"// libpthread has been folded into libc since Solaris 10, no need to do; // anything for pthreads. Claim argument to avoid warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp:117,avoid,avoid,117,interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Solaris.cpp,1,['avoid'],['avoid']
Safety,"// libstdc++4.6 marks the vector default constructor as explicit in; // _GLIBCXX_DEBUG mode, so recover using the C++03 logic in that case.; // stlport does so too. Look for std::__debug for libstdc++, and for; // std:: for stlport. This is effectively a compiler-side implementation of; // LWG2193.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp:96,recover,recover,96,interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaInit.cpp,1,['recover'],['recover']
Safety,"// likelihood of prediction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:17,predict,prediction,17,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['predict'],['prediction']
Safety,"// limit nbits to less than 30 to avoid error converting from double to uint and also cannot deal with too many combinations",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx:34,avoid,avoid,34,tmva/tmva/src/Factory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Factory.cxx,1,['avoid'],['avoid']
Safety,// line_iterator only detects comments starting in column 1.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SymbolRemappingReader.cpp:22,detect,detects,22,interpreter/llvm-project/llvm/lib/ProfileData/SymbolRemappingReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ProfileData/SymbolRemappingReader.cpp,1,['detect'],['detects']
Safety,// llvm-config is designed to support being run both from a development tree; // and from an installed path. We try and auto-detect which case we are in so; // that we can report the correct information when run from a development; // tree.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp:125,detect,detect,125,interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-config/llvm-config.cpp,1,['detect'],['detect']
Safety,// llvm.gcroot is safe because it doesn't do anything at runtime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:18,safe,safe,18,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,1,['safe'],['safe']
Safety,"// locking avoids data loss",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/threads.cxx:11,avoid,avoids,11,test/threads.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/threads.cxx,1,['avoid'],['avoids']
Safety,"// main interface for Safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:22,Safe,Safety,22,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['Safe'],['Safety']
Safety,// make copy to avoid changes in argument,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/model/BrowserModel.js:16,avoid,avoid,16,ui5/browser/model/BrowserModel.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/browser/model/BrowserModel.js,2,['avoid'],['avoid']
Safety,"// make the prediction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:12,predict,prediction,12,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['predict'],['prediction']
Safety,"// map's [] operator returns reference.; // to avoid ugly UB casts like static_cast<SomeType * &>(voidPtrLValue); // I have this helper class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/inc/TGDMLParse.h:47,avoid,avoid,47,geom/gdml/inc/TGDMLParse.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/gdml/inc/TGDMLParse.h,1,['avoid'],['avoid']
Safety,"// mark canvas as batch - avoid gVirtualX in many places",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx:26,avoid,avoid,26,graf2d/gpad/src/TCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx,1,['avoid'],['avoid']
Safety,"// maximum number of workers per filenode (Long_t to avoid; // warnings from backward compatibility support)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizer.h:53,avoid,avoid,53,proof/proofplayer/inc/TPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/inc/TPacketizer.h,2,['avoid'],['avoid']
Safety,// memory; // Try to match ADDRri since reg+imm style is safe for all VE instructions; // with a memory operand.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp:57,safe,safe,57,interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/VE/VEISelDAGToDAG.cpp,1,['safe'],['safe']
Safety,"// memset_chk writes at most Len bytes, memcpy_chk reads/writes at most; // Len bytes. They may read/write less, if Len exceeds the specified max; // size and aborts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryLocation.cpp:159,abort,aborts,159,interpreter/llvm-project/llvm/lib/Analysis/MemoryLocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryLocation.cpp,1,['abort'],['aborts']
Safety,"// min error; // Double_t riskMin=0; // risk",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:26,risk,riskMin,26,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,2,['risk'],"['risk', 'riskMin']"
Safety,"// minimal timeout to reduce load, generate dummy only if client not submit new request immediately",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:11,timeout,timeout,11,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['timeout'],['timeout']
Safety,"// minimize Stein's unbiased risk estimator using successive calls to DoUnfold at various tau. Optionally, the contributions to SURE (DF and Chi2A) or the L-curve are saved",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h:29,risk,risk,29,hist/unfold/inc/TUnfold.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfold.h,1,['risk'],['risk']
Safety,"// missing information, avoid infinite loop; // by doing nothing ....",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:24,avoid,avoid,24,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,2,['avoid'],['avoid']
Safety,"// mmap may leave the buffer without null terminator if the file size changed; // by the time the last page is mapped in, so avoid it if the file size is; // likely to change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp:125,avoid,avoid,125,interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/MemoryBuffer.cpp,1,['avoid'],['avoid']
Safety,"// more sanity checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListTree.cxx:8,sanity check,sanity checks,8,gui/gui/src/TGListTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListTree.cxx,1,['sanity check'],['sanity checks']
Safety,"// move implementations here to avoid circle dependencies",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PxPyPzE4D.h:32,avoid,avoid,32,math/genvector/inc/Math/GenVector/PxPyPzE4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PxPyPzE4D.h,1,['avoid'],['avoid']
Safety,// move the camera down the pointer ray; // this method avoids floating point error,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:56,avoid,avoids,56,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoids']
Safety,"// move the qualifiers on the outer type (avoid 'std::const string'!)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp:42,avoid,avoid,42,interpreter/cling/lib/Utils/AST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Utils/AST.cpp,1,['avoid'],['avoid']
Safety,"// must reallocate; // Destroy old elements: useless work for trivial types, but in case the element type's constructor; // allocates memory we need to release it here to avoid memleaks (e.g. if this is an RVec<RVec<int>>)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx:171,avoid,avoid,171,tree/ntuple/v7/src/RField.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RField.cxx,1,['avoid'],['avoid']
Safety,"// namespace Detail; // clang-format off; /**; \class ROOT::Experimental::RFieldBase; \ingroup NTuple; \brief A field translates read and write calls from/to underlying columns to/from tree values. A field is a serializable C++ type or a container for a collection of sub fields. The RFieldBase and its; type-safe descendants provide the object to column mapper. They map C++ objects to primitive columns. The; mapping is trivial for simple types such as 'double'. Complex types resolve to multiple primitive columns.; The field knows based on its type and the field name the type(s) and name(s) of the columns. Note: the class hierarchy starting at RFieldBase is not meant to be extended by user-provided child classes.; This is and can only be partially enforced through C++.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx:309,safe,safe,309,tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RFieldBase.hxx,1,['safe'],['safe']
Safety,"// namespace Internal; /// Wraps any collection that can be used in range-based loops and applies; /// `static_cast<T>` or `dynamic_cast<T>` to each element.; /// \tparam T The new type to convert to.; /// \tparam isDynamic If `true`, `dynamic_cast` is used, otherwise `static_cast` is used.; /// \tparam Range_t The type of the input range, which should be usually a reference type to avoid copying.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RRangeCast.hxx:386,avoid,avoid,386,core/foundation/inc/ROOT/RRangeCast.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/inc/ROOT/RRangeCast.hxx,1,['avoid'],['avoid']
Safety,"// namespace ROOT; // clang-format off; /**; * \class TTreeReaderArray; * \ingroup treeplayer; * \brief An interface for reading collections stored in ROOT columnar datasets; *; * The TTreeReaderArray is a type-safe tool to be used in association with a TTreeReader; * to access the collections stored in TTree, TNtuple and TChain datasets.; * In order to access values which are not collections, the TTreeReaderValue class can; * be used.; *; * See the documentation of TTreeReader for more details and examples.; */; // clang-format on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderArray.h:211,safe,safe,211,tree/treeplayer/inc/TTreeReaderArray.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TTreeReaderArray.h,1,['safe'],['safe']
Safety,// namespace __hip; // __HIP_OVERLOAD1 is used to resolve function calls with integer argument to; // avoid compilation error due to ambibuity. e.g. floor(5) is resolved with; // floor(double).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h:102,avoid,avoid,102,interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/__clang_hip_cmath.h,1,['avoid'],['avoid']
Safety,"// namespace clang; // operator new and delete aren't allowed inside namespaces.; /// Placement new for using the ASTContext's allocator.; ///; /// This placement form of operator new uses the ASTContext's allocator for; /// obtaining memory.; ///; /// IMPORTANT: These are also declared in clang/AST/ASTContextAllocate.h!; /// Any changes here need to also be made there.; ///; /// We intentionally avoid using a nothrow specification here so that the calls; /// to this operator will not perform a null check on the result -- the; /// underlying allocator never returns null pointers.; ///; /// Usage looks like this (assuming there's an ASTContext 'Context' in scope):; /// @code; /// // Default alignment (8); /// IntegerLiteral *Ex = new (Context) IntegerLiteral(arguments);; /// // Specific alignment; /// IntegerLiteral *Ex2 = new (Context, 4) IntegerLiteral(arguments);; /// @endcode; /// Memory allocated through this placement new operator does not need to be; /// explicitly freed, as ASTContext will free all of this memory when it gets; /// destroyed. Please note that you cannot use delete on the pointer.; ///; /// @param Bytes The number of bytes to allocate. Calculated by the compiler.; /// @param C The ASTContext that provides the allocator.; /// @param Alignment The alignment of the allocated memory (if the underlying; /// allocator supports it).; /// @return The allocated memory. Could be nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:400,avoid,avoid,400,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['avoid'],['avoid']
Safety,// namespace clang; //===----------------------------------------------------------------------===//; // Unsafe buffer usage analysis.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp:105,Unsafe,Unsafe,105,interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/AnalysisBasedWarnings.cpp,1,['Unsafe'],['Unsafe']
Safety,"// namespace detail; // The UniqueID of in-memory files is derived from path and content.; // This avoids difficulties in creating exactly equivalent in-memory FSes,; // as often needed in multithreaded programs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp:99,avoid,avoids,99,interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/VirtualFileSystem.cpp,1,['avoid'],['avoids']
Safety,// namespace detail; /// Detects when type `T` is incomplete. This is true for forward declarations; /// and false for types with a full definition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:25,Detect,Detects,25,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['Detect'],['Detects']
Safety,"// namespace llvm; /// Fully generic combining of x86 shuffle instructions.; ///; /// This should be the last combine run over the x86 shuffle instructions. Once; /// they have been fully optimized, this will recursively consider all chains; /// of single-use shuffle instructions, build a generic model of the cumulative; /// shuffle operation, and check for simpler instructions which implement this; /// operation. We use this primarily for two purposes:; ///; /// 1) Collapse generic shuffles to specialized single instructions when; /// equivalent. In most cases, this is just an encoding size win, but; /// sometimes we will collapse multiple generic shuffles into a single; /// special-purpose shuffle.; /// 2) Look for sequences of shuffle instructions with 3 or more total; /// instructions, and replace them with the slightly more expensive SSSE3; /// PSHUFB instruction if available. We do this as the last combining step; /// to ensure we avoid using PSHUFB if we can implement the shuffle with; /// a suitable short sequence of other instructions. The PSHUFB will either; /// use a register or have to read from memory and so is slightly (but only; /// slightly) more expensive than the other shuffle instructions.; ///; /// Because this is inherently a quadratic operation (for each shuffle in; /// a chain, we recurse up the chain), the depth is limited to 8 instructions.; /// This should never be an issue in practice as the shuffle lowering doesn't; /// produce sequences of more than 8 instructions.; ///; /// FIXME: We will currently miss some cases where the redundant shuffling; /// would simplify under the threshold for PSHUFB formation because of; /// combine-ordering. To fix this, we should do the redundant instruction; /// combining in this recursive walk.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:951,avoid,avoid,951,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,3,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,// namespace llvm; /// Use __safestack_pointer_address even if the platform has a faster way of; /// access safe stack pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:108,safe,safe,108,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['safe'],['safe']
Safety,"// namespace tok; /// Annotates a diagnostic with some code that should be; /// inserted, removed, or replaced to fix the problem.; ///; /// This kind of hint should be used when we are certain that the; /// introduction, removal, or modification of a particular (small!); /// amount of code will correct a compilation error. The compiler; /// should also provide full recovery from such errors, such that; /// suppressing the diagnostic output can still result in successful; /// compilation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:369,recover,recovery,369,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['recover'],['recovery']
Safety,"// namespace; ////////////////////////////////////////////////////////////////////////////////////////; /// Method to find potentially relevant candidate bounding boxes for safety calculation; /// given a point. Uses trivial algorithm to do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:173,safe,safety,173,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"// need do find minimum of log-likelihood in the range to shift function; // to avoid numerical errors when we compute the likelihood (overflows in the exponent); // N.B.: this works for only 1 parameter of interest otherwise Minuit should be used for finding the minimum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:80,avoid,avoid,80,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['avoid'],['avoid']
Safety,"// need to clone to avoid temporary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/DistSampler.h:20,avoid,avoid,20,math/mathcore/inc/Math/DistSampler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/DistSampler.h,1,['avoid'],['avoid']
Safety,"// need to do that to avoid gradient calculation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/fit/testFit.cxx:22,avoid,avoid,22,math/mathcore/test/fit/testFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/fit/testFit.cxx,3,['avoid'],['avoid']
Safety,"// need to have a static copy of the function; //NOTE: This is NOT thread safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/inc/TFumiliMinimizer.h:74,safe,safe,74,math/fumili/inc/TFumiliMinimizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/inc/TFumiliMinimizer.h,1,['safe'],['safe']
Safety,// need to implement assignment operator to avoid using the templated one; /**; Assignment operator; */,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Rotation3D.h:44,avoid,avoid,44,math/genvector/inc/Math/GenVector/Rotation3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Rotation3D.h,1,['avoid'],['avoid']
Safety,"// no captureStr has the string to display; // inject line breaks to avoid msgbox being too wide",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:69,avoid,avoid,69,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['avoid'],['avoid']
Safety,"// no need for Float32Array, plain Array is 10% faster; // reserve more places to avoid complex boundary checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:82,avoid,avoid,82,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// no need to call for every single editor Layout of TGMainFrame; // ((TGMainFrame*)GetMainFrame())->Layout();; // to avoid that the user changes options on a deactivated Tab",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/src/TGeoGedFrame.cxx:118,avoid,avoid,118,geom/geombuilder/src/TGeoGedFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geombuilder/src/TGeoGedFrame.cxx,1,['avoid'],['avoid']
Safety,"// no need to set parameters used a non-parametric wrapper to avoid allocating; // an array with parameter values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:62,avoid,avoid,62,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,3,['avoid'],['avoid']
Safety,// non-computable results can be safely cached,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp:33,safe,safely,33,interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/MemoryBuiltins.cpp,1,['safe'],['safely']
Safety,"// not needed - but to avoid a wrongly reported compiler warning (see ROOT-6496)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:23,avoid,avoid,23,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,2,['avoid'],['avoid']
Safety,"// not recoverable from here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h:7,recover,recoverable,7,roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h,1,['recover'],['recoverable']
Safety,"// note, if zero pointers given, use internal pdf; // sanity check first",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:54,sanity check,sanity check,54,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,3,['sanity check'],['sanity check']
Safety,"// note: so far this method is inconsistent with the BuildHistogram in ways:; // no projection over other variables; // July2023: made RooRealSumPdf evaluate as a function if doesn't have a floor; // but this method will still evaluate it as a pdf (uses PdfWrapper); // but can get away with it while added NaN recovery to getSimplePropagatedError to pickup raw values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:311,recover,recovery,311,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['recover'],['recovery']
Safety,"// now instantiate the 3D voxel grid for caching the safety candidates; // (note that the structure is merely reserved ... actual filling will happen on-the-fly later on)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:53,safe,safety,53,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"// now unmap the source window (still to avoid flickering)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGSplitFrame.cxx:41,avoid,avoid,41,gui/gui/src/TGSplitFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGSplitFrame.cxx,1,['avoid'],['avoid']
Safety,"// now view can be safely destroyed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rootqt5.cpp:19,safe,safely,19,gui/qt5webdisplay/rootqt5.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rootqt5.cpp,2,['safe'],['safely']
Safety,"// number of events in the real data for bin 'i'; // Cache the weighted fractions and the number of observed MC events; // Sanity check: none of the fractions should be == 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:123,Sanity check,Sanity check,123,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['Sanity check'],['Sanity check']
Safety,"// number of points where risk(i+1)>risk(i)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:26,risk,risk,26,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,2,['risk'],['risk']
Safety,"// objc-receiver:; // expression; // Make sure any typos in the receiver are corrected or diagnosed, so that; // proper recovery can happen. FIXME: Perhaps filter the corrected expr to; // only the things that are valid ObjC receivers?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:120,recover,recovery,120,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['recover'],['recovery']
Safety,"// old-style refs, coded into string like ""$ref12""; // AppendOutput(TString::Format(""\""$ref:%u\"""", iter->second));; // new-style refs, coded into extra object {""$ref"":12}, auto-detected by JSROOT 4.8 and higher",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx:177,detect,detected,177,io/io/src/TBufferJSON.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx,1,['detect'],['detected']
Safety,"// one per column per slot; // This must be a deque to avoid the specialisation vector<bool>. This would not; // work given that the pointer to the boolean in that case cannot be taken",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RCsvDS.hxx:55,avoid,avoid,55,tree/dataframe/inc/ROOT/RCsvDS.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RCsvDS.hxx,1,['avoid'],['avoid']
Safety,// only after timeout user function will be called,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:14,timeout,timeout,14,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,"// only for binary data master version is important; // it allows to detect if streamer info was modified",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx:69,detect,detect,69,net/http/src/THttpServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx,1,['detect'],['detect']
Safety,"// only recoverable error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h:8,recover,recoverable,8,roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitZMQ/res/RooFit_ZMQ/ZeroMQSvc.h,2,['recover'],['recoverable']
Safety,"// only split cells if gain>0 (this also avoids splitting at cell boundary)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx:41,avoid,avoids,41,tmva/tmva/src/PDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx,1,['avoid'],['avoids']
Safety,// op'; // Disable the use of undef because it's not safe to distribute undef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,safe,safe,53,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,2,['safe'],['safe']
Safety,"// or return a reasonable cache estimate for safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:45,safe,safety,45,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['safe'],['safety']
Safety,"// order by length - first the longer ones to avoid replacing wrong functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TFormula.h:46,avoid,avoid,46,hist/hist/inc/TFormula.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/inc/TFormula.h,1,['avoid'],['avoid']
Safety,"// other sanity checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFDA.cxx:9,sanity check,sanity checks,9,tmva/tmva/src/MethodFDA.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFDA.cxx,1,['sanity check'],['sanity checks']
Safety,"// otherwise we need to evaluate it and update the cache; // we evaluate this with saf_max = infinity to get the best; // possible safety value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:131,safe,safety,131,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safety']
Safety,"// output prediction matrix of fNet",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodDL.h:10,predict,prediction,10,tmva/tmva/inc/TMVA/MethodDL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodDL.h,1,['predict'],['prediction']
Safety,"// pass it by const value to help detect common mistakes such as if(x = 3)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx:34,detect,detect,34,tree/dataframe/src/RDFInterfaceUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDFInterfaceUtils.cxx,1,['detect'],['detect']
Safety,"// perform the network prediction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:23,predict,prediction,23,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['predict'],['prediction']
Safety,"// perform the prediction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:15,predict,prediction,15,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,1,['predict'],['prediction']
Safety,"// pictures might already have been deleted above, so avoid access; // to these objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGToolBar.cxx:54,avoid,avoid,54,gui/gui/src/TGToolBar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGToolBar.cxx,1,['avoid'],['avoid']
Safety,"// point inside current (safe) node -> search downwards",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:25,safe,safe,25,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safe']
Safety,"// point on radius-changing plane; // check increasing iplanes; /*; iplane = ipl+1;; saftmp = 0.;; while ((iplane<fNz-1) && saftmp<1E10) {; saftmp = TMath::Abs(SafetyToSegment(point,iplane,kFALSE,safmin));; if (saftmp<safmin) safmin=saftmp;; iplane++;; }; // now decreasing nplanes; iplane = ipl-1;; saftmp = 0.;; while ((iplane>=0) && saftmp<1E10) {; saftmp = TMath::Abs(SafetyToSegment(point,iplane,kFALSE,safmin));; if (saftmp<safmin) safmin=saftmp;; iplane--;; }; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPcon.cxx:160,Safe,SafetyToSegment,160,geom/geom/src/TGeoPcon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPcon.cxx,2,['Safe'],['SafetyToSegment']
Safety,"// points above i can be not initialized; // set zero up to i-th point to avoid redefinition; // of this method in descendant classes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:74,avoid,avoid,74,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['avoid'],['avoid']
Safety,"// poll, wait until status change (infinite timeout)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:44,timeout,timeout,44,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['timeout'],['timeout']
Safety,"// poll: wait until status change (-1: infinite timeout)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx:48,timeout,timeout,48,roofit/multiprocess/src/Messenger.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Messenger.cxx,1,['timeout'],['timeout']
Safety,// pool of Matrix objects to avoid permanent creation,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:29,avoid,avoid,29,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,// popcontext; // pushcontext; // .safeseh; // Procedure directives,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/COFFMasmParser.cpp:35,safe,safeseh,35,interpreter/llvm-project/llvm/lib/MC/MCParser/COFFMasmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/COFFMasmParser.cpp,1,['safe'],['safeseh']
Safety,"// postfix-expression: p-e '[' expression ']'; // If we have a array postfix expression that starts on a new line and; // Objective-C is enabled, it is highly likely that the user forgot a; // semicolon after the base expression and that the array postfix-expr is; // actually another message send. In this case, do some look-ahead to see; // if the contents of the square brackets are obviously not a valid; // expression and recover by pretending there is no suffix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp:427,recover,recover,427,interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExpr.cpp,1,['recover'],['recover']
Safety,"// predicted output and labels",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.h:3,predict,predicted,3,tmva/tmva/test/DNN/RNN/TestFullRNN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestFullRNN.h,1,['predict'],['predicted']
Safety,"// previous risk; // parameters set at point with min error",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:12,risk,risk,12,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,1,['risk'],['risk']
Safety,"// print after parallel processing to avoid synchronization issues",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Numerical2PGradientCalculator.cxx:38,avoid,avoid,38,math/minuit2/src/Numerical2PGradientCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/Numerical2PGradientCalculator.cxx,1,['avoid'],['avoid']
Safety,"// printf(""== segment %d: (%f, %f) - (%f, %f) safe=%f\n"", isegment,; // fX[isegment],fY[isegment],fX[(isegment+1)%fNvert],fY[(isegment+1)%fNvert],safe);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPolygon.cxx:46,safe,safe,46,geom/geom/src/TGeoPolygon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPolygon.cxx,2,['safe'],['safe']
Safety,"// process of timeout, request animation frame",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:14,timeout,timeout,14,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,// promote v4f16 to v4f32 when that is known to be safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp:51,safe,safe,51,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp,1,['safe'],['safe']
Safety,"// put a cloned copy of scanned variable to set in the interval; // to avoid I/O problem of the Result class -; // make the set owning the cloned copy (use clone instead of Clone to not copying all links)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx:71,avoid,avoid,71,roofit/roostats/src/HypoTestInverterResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverterResult.cxx,1,['avoid'],['avoid']
Safety,// quick optimization to avoid having to intern strings that are already; // stored reliably elsewhere,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp:25,avoid,avoid,25,interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGDebugInfo.cpp,1,['avoid'],['avoid']
Safety,"// rand and random are not thread safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx:34,safe,safe,34,core/base/src/TUUID.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUUID.cxx,1,['safe'],['safe']
Safety,"// rather than using the weighted average of the tree respones in the forest; // H.Decker(1997) proposed to use the ""weighted median""; // sort all individual tree responses according to the prediction value; // (keep the association to their tree weight); // the sum up all the associated weights (starting from the one whose tree; // yielded the smalles response) up to the tree ""t"" at which you've; // added enough tree weights to have more than half of the sum of all tree weights.; // choose as response of the forest that one which belongs to this ""t""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:190,predict,prediction,190,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,1,['predict'],['prediction']
Safety,"// re-use gMinuit as static instance of TMinuit; // which can be accessed by the user after minimization; // check if fgMinuit is different than gMinuit; // case 1: fgMinuit not zero but fgMinuit has been deleted (not in gROOT): set to zero; // case 2: fgMinuit not zero and exists in global list : set fgMinuit to gMinuit; // case 3: fgMinuit zero - and gMinuit not zero: create a new instance locally to avoid conflict",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx:406,avoid,avoid,406,math/minuit/src/TMinuitMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuitMinimizer.cxx,1,['avoid'],['avoid']
Safety,// record states ( avoid data race ),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:19,avoid,avoid,19,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['avoid'],['avoid']
Safety,"// recover numbers",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx:3,recover,recover,3,geom/webviewer/src/RGeomData.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/webviewer/src/RGeomData.cxx,1,['recover'],['recover']
Safety,// recover the bind-time world matrices,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:3,recover,recover,3,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['recover'],['recover']
Safety,"// redundant (already present in the header), but Windows needs it",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDefineBase.cxx:3,redund,redundant,3,tree/dataframe/src/RDefineBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RDefineBase.cxx,1,['redund'],['redundant']
Safety,"// remove any trace of identity transform - if given (avoid to apply it twice)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Envelope.cxx:54,avoid,avoid,54,tmva/tmva/src/Envelope.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Envelope.cxx,2,['avoid'],['avoid']
Safety,// remove handle - allow to trigger new timeout,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:40,timeout,timeout,40,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,"// remove target image file - we use it as detection when chrome is ready",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebDisplayHandle.cxx:43,detect,detection,43,gui/webdisplay/src/RWebDisplayHandle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebDisplayHandle.cxx,1,['detect'],['detection']
Safety,"// repeat loop to avoid calling isConstant for nothing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/RooStatsUtils.h:18,avoid,avoid,18,roofit/roostats/inc/RooStats/RooStatsUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/inc/RooStats/RooStatsUtils.h,1,['avoid'],['avoid']
Safety,"// reset callback to release associated with lambda resources; // reset before invoking callback to avoid multiple calls",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RFileDialog.cxx:100,avoid,avoid,100,gui/browserv7/src/RFileDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RFileDialog.cxx,1,['avoid'],['avoid']
Safety,"// reset flags of the new method, as there is a self (which may or may not have; // come in through direct call syntax, but that's now impossible to know, so this; // is the safer choice)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx:174,safe,safer,174,bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CPPOverload.cxx,1,['safe'],['safer']
Safety,"// reset stamps, after timeout connection wll be removed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:23,timeout,timeout,23,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,2,['timeout'],['timeout']
Safety,"// reset the existing histogram and set always the new binning for the axis; // This avoid problems when the histogram already exists and the histograms is rebinned or its range has changed; // (see https://savannah.cern.ch/bugs/?94101 or https://savannah.cern.ch/bugs/?95808 )",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:85,avoid,avoid,85,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,2,['avoid'],['avoid']
Safety,"// restrict the value of negative mass to avoid unphysical negative E2 values; // M2 must be less than P2 for the tachionic particles - otherwise use positive values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h:42,avoid,avoid,42,math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/PtEtaPhiM4D.h,2,['avoid'],['avoid']
Safety,// return *some value* to avoid compiler warning,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp:26,avoid,avoid,26,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonNewValueJump.cpp,1,['avoid'],['avoid']
Safety,"// returning false will abort the in-depth traversal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/AutoSynthesizer.cpp:24,abort,abort,24,interpreter/cling/lib/Interpreter/AutoSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/AutoSynthesizer.cpp,1,['abort'],['abort']
Safety,"// returns a tuple containing first the poll result and second a boolean flag that tells the caller whether it should; // abort the enclosing loop",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/util.cxx:122,abort,abort,122,roofit/multiprocess/src/util.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/util.cxx,1,['abort'],['abort']
Safety,"// riskMin = fNTRisk;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:3,risk,riskMin,3,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,2,['risk'],['riskMin']
Safety,"// run some sanity checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx:12,sanity check,sanity checks,12,roofit/roostats/src/BayesianCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/BayesianCalculator.cxx,1,['sanity check'],['sanity checks']
Safety,"// runOnFunction - To run this pass, first we calculate the alloca; // instructions that are safe for promotion, then we promote each one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:93,safe,safe,93,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,1,['safe'],['safe']
Safety,// s_waitcnt_depctr sa_sdst(0) mitigates hazard.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp:41,hazard,hazard,41,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNHazardRecognizer.cpp,1,['hazard'],['hazard']
Safety,"// safe = TMath::Sqrt(safe);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx:3,safe,safe,3,geom/geom/src/TGeoArb8.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx,2,['safe'],['safe']
Safety,// safe allocas are not interesting,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,safe,safe,3,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,2,['safe'],['safe']
Safety,// safe because there are no fixups,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp:3,safe,safe,3,interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCleanup.cpp,1,['safe'],['safe']
Safety,"// safe bet: assume the typical 64 bytes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:3,safe,safe,3,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,2,['safe'],['safe']
Safety,"// safe constructor using std::vector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserCovariance.h:3,safe,safe,3,math/minuit2/inc/Minuit2/MnUserCovariance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserCovariance.h,1,['safe'],['safe']
Safety,// safe replacement with equal value,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringSaver.cpp:3,safe,safe,3,interpreter/llvm-project/llvm/lib/Support/StringSaver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/StringSaver.cpp,1,['safe'],['safe']
Safety,"// safe, as destructor always returns void",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx:3,safe,safe,3,bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Dispatcher.cxx,1,['safe'],['safe']
Safety,"// safeMetaCast is called by OSDynamicCast.; // We assume that OSDynamicCast is either an identity (cast is OK,; // the input was non-zero),; // or that it returns zero (when the cast failed, or the input; // was zero).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp:3,safe,safeMetaCast,3,interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/RetainSummaryManager.cpp,1,['safe'],['safeMetaCast']
Safety,"// safety check for maxlen < 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEntry.cxx:3,safe,safety,3,gui/gui/src/TGTextEntry.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEntry.cxx,1,['safe'],['safety']
Safety,// safety check for repeated points,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:3,safe,safety,3,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['safe'],['safety']
Safety,"// safety check...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEntry.cxx:3,safe,safety,3,gui/gui/src/TGTextEntry.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTextEntry.cxx,1,['safe'],['safety']
Safety,"// safety checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx:3,safe,safety,3,roofit/roostats/src/HypoTestInverter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx,1,['safe'],['safety']
Safety,"// safety for public functions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/ConfigParser.cxx:3,safe,safety,3,roofit/histfactory/src/ConfigParser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/ConfigParser.cxx,1,['safe'],['safety']
Safety,"// safety from parallel world",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:3,safe,safety,3,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safety']
Safety,"// safety mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPgon.cxx:3,safe,safety,3,geom/geom/src/TGeoPgon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPgon.cxx,1,['safe'],['safety']
Safety,// sanity check,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp:3,sanity check,sanity check,3,interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AVR/AVRISelLowering.cpp,1,['sanity check'],['sanity check']
Safety,"// sanity check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx:3,sanity check,sanity check,3,gui/guibuilder/src/TGuiBldDragManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx,41,['sanity check'],['sanity check']
Safety,"// sanity check (for previous code lines)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodLikelihood.cxx:3,sanity check,sanity check,3,tmva/tmva/src/MethodLikelihood.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodLikelihood.cxx,1,['sanity check'],['sanity check']
Safety,"// sanity check - should never happen",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h:3,sanity check,sanity check,3,roofit/roostats/test/stressRooStats_tests.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/test/stressRooStats_tests.h,2,['sanity check'],['sanity check']
Safety,"// sanity check ... should never happen as otherwise there is apparently; // something odd with the assignment of the leaf nodes (rem: you use the training; // events for this determination of the error rate)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx:3,sanity check,sanity check,3,tmva/tmva/src/MethodBDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBDT.cxx,2,['sanity check'],['sanity check']
Safety,"// sanity check fit result",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx:3,sanity check,sanity check,3,roofit/roostats/src/HypoTestInverter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestInverter.cxx,1,['sanity check'],['sanity check']
Safety,"// sanity check of PDF quality (after smoothing): comparison with; // original histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDF.h:3,sanity check,sanity check,3,tmva/tmva/inc/TMVA/PDF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/PDF.h,1,['sanity check'],['sanity check']
Safety,"// sanity check, there should be no ""(i)"", with 'i' a number anymore",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFDA.cxx:3,sanity check,sanity check,3,tmva/tmva/src/MethodFDA.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFDA.cxx,1,['sanity check'],['sanity check']
Safety,"// sanity check, there should be no ""xi"", with 'i' a number anymore",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFDA.cxx:3,sanity check,sanity check,3,tmva/tmva/src/MethodFDA.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodFDA.cxx,1,['sanity check'],['sanity check']
Safety,"// sanity check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx:3,sanity check,sanity check,3,io/io/src/TStreamerInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TStreamerInfo.cxx,2,['sanity check'],['sanity check']
Safety,"// sanity check...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx:3,sanity check,sanity check,3,roofit/roofit/src/RooNonCPEigenDecay.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofit/src/RooNonCPEigenDecay.cxx,1,['sanity check'],['sanity check']
Safety,"// sanity check:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/BinarySearchTree.cxx:3,sanity check,sanity check,3,tmva/tmva/src/BinarySearchTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/BinarySearchTree.cxx,2,['sanity check'],['sanity check']
Safety,"// sanity check: matrix must be diagonal and positive definit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx:3,sanity check,sanity check,3,tmva/tmva/src/Tools.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx,1,['sanity check'],['sanity check']
Safety,"// sanity check: matrix must be quadratic",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx:3,sanity check,sanity check,3,tmva/tmva/src/Tools.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx,2,['sanity check'],['sanity check']
Safety,"// sanity check: number of targets > 1 and MultiTargetRegression=F; // makes no sense --> set MultiTargetRegression=T",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx:3,sanity check,sanity check,3,tmva/tmva/src/MethodPDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodPDEFoam.cxx,1,['sanity check'],['sanity check']
Safety,"// sanity check:; // (1) sub-matrix swapped[0]..swapped[iDiagonal]; // must not contain off-diagonals; // (2) sub-matrix swapped[0]..swapped[iBlock-1] must be diagonal",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx:3,sanity check,sanity check,3,hist/unfold/src/TUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/src/TUnfold.cxx,1,['sanity check'],['sanity check']
Safety,"// sanity checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGCanvas.cxx:3,sanity check,sanity checks,3,gui/gui/src/TGCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGCanvas.cxx,15,['sanity check'],['sanity checks']
Safety,"// sanity checks: tree must exist, and theVar must be in tree",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:3,sanity check,sanity checks,3,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['sanity check'],['sanity checks']
Safety,"// sanity checks; // signal and background histograms must have same number of bins and; // same limits",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx:3,sanity check,sanity checks,3,tmva/tmva/src/Tools.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/Tools.cxx,1,['sanity check'],['sanity checks']
Safety,"// scale tolerance with Up(); // avoid tolerance too smalls (than limits)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/ModularFunctionMinimizer.cxx:33,avoid,avoid,33,math/minuit2/src/ModularFunctionMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/ModularFunctionMinimizer.cxx,1,['avoid'],['avoid']
Safety,"// scan all values from 0.05 to 0.95 to avoid problem at the border of definitions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/StatFunction.cxx:40,avoid,avoid,40,math/mathmore/test/StatFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/StatFunction.cxx,2,['avoid'],['avoid']
Safety,"// search for fnkNN+2 nearest neighbors, pad with two; // events to avoid Monte-Carlo events with zero distance; // most of CPU time is spent in this recursive function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodKNN.cxx:68,avoid,avoid,68,tmva/tmva/src/MethodKNN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodKNN.cxx,2,['avoid'],['avoid']
Safety,"// see https://bitbucket.org/chromiumembedded/cef-project/src/master/examples/resource_manager/?at=master for demo; // one probably can avoid to use scheme handler and just redirect requests",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/gui_handler.cxx:136,avoid,avoid,136,gui/cefdisplay/src/gui_handler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/cefdisplay/src/gui_handler.cxx,1,['avoid'],['avoid']
Safety,"// see if the precalculated (mid-point) safety value can be used",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:40,safe,safety,40,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"// select (CMPZ X, #-C) -> (CMPZ (ADDS X, #C), #0); // This allows us to avoid materializing the expensive negative constant.; // The CMPZ #0 is useless and will be peepholed away but we need to keep it; // for its glue output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:73,avoid,avoid,73,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['avoid'],['avoid']
Safety,"// set fBuffer to zero to avoid calling BufferEmpty in Reset",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:26,avoid,avoid,26,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['avoid'],['avoid']
Safety,"// set flag to compute Minos error to false in FitConfig to avoid that; // following minimizaiton calls perform unwanted Minos error calculations; /// fConfig.SetMinosErrors(false);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx:60,avoid,avoid,60,math/mathcore/src/Fitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx,1,['avoid'],['avoid']
Safety,// set font size directly to element to avoid complex control,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:40,avoid,avoid,40,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,// set larger timeout for geometry processing,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:14,timeout,timeout,14,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,"// set members directly to avoid redrawing of the client again",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx:27,avoid,avoid,27,gui/webgui6/src/TWebCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webgui6/src/TWebCanvas.cxx,1,['avoid'],['avoid']
Safety,"// set strategy (0 to avoid MnHesse",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/testNdimFit.cxx:22,avoid,avoid,22,math/minuit2/test/testNdimFit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/test/testNdimFit.cxx,2,['avoid'],['avoid']
Safety,"// set the initial prediction for all events to the median",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx:19,predict,prediction,19,tmva/tmva/src/LossFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/LossFunction.cxx,3,['predict'],['prediction']
Safety,// set timeout to avoid menu hanging,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:7,timeout,timeout,7,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,"['avoid', 'timeout']","['avoid', 'timeout']"
Safety,// set timeout to be able draw other points,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:7,timeout,timeout,7,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,"// set zero entries to 1 in the vector to avoid /0 later on",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Plane3D.h:42,avoid,avoid,42,math/genvector/inc/Math/GenVector/Plane3D.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/Plane3D.h,1,['avoid'],['avoid']
Safety,"// setName doesn't do extra work if the name does not change.; // Note: this does not create collisions - if setName is asked to set the; // name to something that already exists, it adds a proper postfix to; // avoid collisions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp:212,avoid,avoid,212,interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/NVPTX/NVPTXAssignValidGlobalNames.cpp,1,['avoid'],['avoid']
Safety,"// shift X, C >= bitwidth(X) --> undef; // All vector elements must be too big (or undef) to avoid partial undefs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['avoid'],['avoid']
Safety,"// should not be necessary, but just to be safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:43,safe,safe,43,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['safe'],['safe']
Safety,"// should use DBL_MIN; // put a cut off to avoid zero on diagonals",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliErrorUpdator.cxx:43,avoid,avoid,43,math/minuit2/src/FumiliErrorUpdator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliErrorUpdator.cxx,1,['avoid'],['avoid']
Safety,"// signal policy: don't abort interpreter in interactive mode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/PyROOTModule.cxx:24,abort,abort,24,bindings/pyroot/pythonizations/src/PyROOTModule.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/PyROOTModule.cxx,1,['abort'],['abort']
Safety,"// signal safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CallContext.h:10,safe,safety,10,bindings/pyroot/cppyy/CPyCppyy/src/CallContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/CallContext.h,1,['safe'],['safety']
Safety,"// signal worker idle timeout in MarkBad",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h:22,timeout,timeout,22,proof/proof/inc/TProof.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/inc/TProof.h,1,['timeout'],['timeout']
Safety,"// single shot timer cleaner; // gSingleShotCleaner will delete singleShotTimer a; // short period after Timeout() signal is emitted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimer.cxx:105,Timeout,Timeout,105,core/base/src/TTimer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimer.cxx,1,['Timeout'],['Timeout']
Safety,"// skip floppy drives, to avoid accessing them each time...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx:26,avoid,avoid,26,core/winnt/src/TWinNTSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/winnt/src/TWinNTSystem.cxx,1,['avoid'],['avoid']
Safety,"// solves the system for a given set of residuals.; // Assembles the right-hand side appropriate to the; // matrix factored in factor, solves the system using; // the factorization produced there, partitions the; // solution vector into step components, then recovers; // the step components eliminated during the block; // elimination that produced the augmented system form",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TQpLinSolverBase.h:259,recover,recovers,259,math/quadp/inc/TQpLinSolverBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/inc/TQpLinSolverBase.h,1,['recover'],['recovers']
Safety,"// special mode when window communication performed in THttpServer::ProcessRequests; // used only with python which create special thread - but is has to be ignored!!!; // therefore use main thread id to detect callbacks which are invoked only from that main thread",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx:204,detect,detect,204,gui/webdisplay/src/RWebWindowsManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindowsManager.cxx,1,['detect'],['detect']
Safety,"// special workaround for local displays like qt5/qt6; // they are not disconnected regularly when page reload is invoked; // therefore try to detect if new key is applied",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:143,detect,detect,143,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['detect'],['detect']
Safety,"// special workaround to avoid POST request, use base64 coding",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:25,avoid,avoid,25,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,1,['avoid'],['avoid']
Safety,"// start from higher number to avoid overlap",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:31,avoid,avoid,31,hist/hist/src/TFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx,1,['avoid'],['avoid']
Safety,"// starting root is always on the left to avoid to go negative; // it is very sensible at the starting point",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/StatFunction.cxx:42,avoid,avoid,42,math/mathmore/test/StatFunction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathmore/test/StatFunction.cxx,2,['avoid'],['avoid']
Safety,"// statistics can be preserved only in case of positive coefficients; // otherwise with negative c1 (histogram subtraction) one risks to get negative variances",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:128,risk,risks,128,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,2,['risk'],['risks']
Safety,"// std::cout << "" Still within cached safety ... remaining safety would be "" << ls_eval - std::sqrt(r) << ""\n"";",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:38,safe,safety,38,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,2,['safe'],['safety']
Safety,"// std::cout << ""3D Safety GRID cache: Determined N to be "" << N << ""\n"";",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:20,Safe,Safety,20,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['Safe'],['Safety']
Safety,"// std::vector<bool> cannot be used in a MT context safely",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterBase.hxx:52,safe,safely,52,tree/dataframe/inc/ROOT/RDF/RFilterBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RFilterBase.hxx,1,['safe'],['safely']
Safety,"// std::vector<bool> is thread-unsafe for our purposes (and generally evil)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx:31,unsafe,unsafe,31,tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RLoopManager.hxx,1,['unsafe'],['unsafe']
Safety,"// step 2: detect instructions corresponding to ""x.next = x >> 1 or x << 1""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:11,detect,detect,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['detect'],['detect']
Safety,"// step 2: detect instructions corresponding to ""x2 = x1 & (x1 - 1)""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:11,detect,detect,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['detect'],['detect']
Safety,"// step 4: Find the instruction which count the CTLZ: cnt.next = cnt + 1; // or cnt.next = cnt + -1.; // TODO: We can skip the step. If loop trip count is known (CTLZ),; // then all uses of ""cnt.next"" could be optimized to the trip count; // plus ""cnt0"". Currently it is not optimized.; // This step could be used to detect POPCNT instruction:; // cnt.next = cnt + (x.next & 1)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:317,detect,detect,317,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['detect'],['detect']
Safety,"// sterilize first so that cache elements don't appear in the client list; // safety net in case sterilizing one client deletes another one of our clients; // monitor for change in clients list size; // found this was only case in 6.26 (valgrind shows invalid read), in 6.28 these went away; // might be in 6.28 the client list iterator became able to handle in-loop edits but didn't see; // in test case that client count changed so just resterilizing if that's the case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:78,safe,safety,78,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['safe'],['safety']
Safety,"// str <undef> could probably be eliminated entirely, but for now we just want; // to avoid making a mess of it.; // FIXME: Use str <undef> as a wildcard to enable better stm folding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMLoadStoreOptimizer.cpp,1,['avoid'],['avoid']
Safety,"// strange, but avoid misleading",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:16,avoid,avoid,16,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,// strerror_r is thread-safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Errno.cpp:24,safe,safe,24,interpreter/llvm-project/llvm/lib/Support/Errno.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/Errno.cpp,1,['safe'],['safe']
Safety,"// strip pdfs of constraints (which cancel out in the ratio) to avoid unnecessary computations and computational errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/SimpleLikelihoodRatioTestStat.cxx:64,avoid,avoid,64,roofit/roostats/src/SimpleLikelihoodRatioTestStat.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/SimpleLikelihoodRatioTestStat.cxx,1,['avoid'],['avoid']
Safety,"// subtlety: because we know this was a non-local dependency, we know; // it's safe to materialize anywhere between the instruction within; // DepInfo and the end of it's block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp:79,safe,safe,79,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GVN.cpp,1,['safe'],['safe']
Safety,// suppress simple click handler if double click detected,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:49,detect,detected,49,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detected']
Safety,"// take back detector dimensions for selection geometry",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.cxx:13,detect,detector,13,test/RootShower/RootShower.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/RootShower.cxx,1,['detect'],['detector']
Safety,"// temporary workspace for proof to avoid messing with TRef",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx:36,avoid,avoid,36,roofit/roostats/src/ToyMCSampler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ToyMCSampler.cxx,1,['avoid'],['avoid']
Safety,"// terminate through default handler; // No need to recover our state; there will be no ""next time"":; // the signal raised above will cause the program to quit.; //signal(signum, TerminalConfigUnix__handleSignal);; //sSignalHandlerActive = false;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalConfigUnix.cpp:52,recover,recover,52,core/textinput/src/textinput/TerminalConfigUnix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalConfigUnix.cpp,1,['recover'],['recover']
Safety,"// test operation involving 2 expressions; // (check bug 35076); // reset initial matrices to avoid numerical problems",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/testSMatrix.cxx:94,avoid,avoid,94,math/smatrix/test/testSMatrix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/test/testSMatrix.cxx,1,['avoid'],['avoid']
Safety,"// test quality (use cdf to avoid zero bins)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranDiscrete.cxx:28,avoid,avoid,28,math/unuran/test/unuranDiscrete.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/unuran/test/unuranDiscrete.cxx,3,['avoid'],['avoid']
Safety,"// the 'if' part is that surrounded by the debug code.; // Intentionally accessing the deleted memory to check whether it has been changed as; // a consequence (side effect) of executing operator delete. If there no change, we; // can guess this is always the case and we can rely on the changes to fBits made; // by ~TObject to detect use-after-delete error (and print a message rather than; // stop the program with a segmentation fault)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx:329,detect,detect,329,core/base/src/TObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx,1,['detect'],['detect']
Safety,"// the minimum safety from the mid-point of this voxel to any leaf bounding box",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:15,safe,safety,15,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['safe'],['safety']
Safety,"// the next value could be before the string but; // that's okay because the next operation is ++; // (this is to avoid (?) a if statement at the end of the; // loop)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:114,avoid,avoid,114,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['avoid'],['avoid']
Safety,"// the shortest garbage collector in the world - one long line of PERL - unlinks files only,; // if there is a symbolic link with '.ROOT.cachefile' for safety ;-)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:152,safe,safety,152,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['safe'],['safety']
Safety,"// the test for 0x1100 is here to avoid the function call in the Latin case",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h:34,avoid,avoid,34,core/dictgen/res/OptionParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/dictgen/res/OptionParser.h,2,['avoid'],['avoid']
Safety,"// the x axis will be full labels while the y axis will be numeric; // avoid underflow-overflow in x; // Inflate Y axis to new limits for y axis of h2 but not h3",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:71,avoid,avoid,71,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['avoid'],['avoid']
Safety,"// the x axis will be full labels while the y axis will be numeric; // avoid underflow-overflow in x; // should the merge not use labels if underflow-overflows are presents ?; // when merging with labels underflow/overflow are ignored and; //NB when axis are extended underflow/overflow are set to zero",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:71,avoid,avoid,71,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,2,['avoid'],['avoid']
Safety,"// the x axis will be full labels while the y axis will be numeric; // avoid underflow-overflow in x; // should the merge not use labels if underflow-overflows are presents ?; // when merging with labels underflow/overflow are ignored and; //NB when axis are extended underflow/overflow are set to zero; // profile3d has not yet filling with labels implemented.; // test filling with x but be careful in filling reference histogram h4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:71,avoid,avoid,71,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['avoid'],['avoid']
Safety,"// the x axis will be full labels while the y axis will be numeric; // avoid underflow-overflow in x; // should the merge not use labels if underflow-overflows are presents ?; // when merging with labels underflow/overflow are ignored and; //NB when axis are extended underflow/overflow are set to zero; // profile3d has not yet filling with labels implemented.; // test filling with x but be careful in filling reference histogram p4",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:71,avoid,avoid,71,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['avoid'],['avoid']
Safety,"// then scale the relevant bin ... if the relevant bin is a ""1"" then just drop in our factor (inside a; // RooProduct though, to avoid it getting modified by subsequent multiplies)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:129,avoid,avoid,129,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['avoid'],['avoid']
Safety,"// then the button itself, with its own color; // decrease a bit the highlight, to avoid bad effects...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLOverlayButton.cxx:83,avoid,avoid,83,graf3d/gl/src/TGLOverlayButton.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLOverlayButton.cxx,1,['avoid'],['avoid']
Safety,"// these are related to the various q^2 values;; // choose the largest to avoid dividing two small numbers and losing accuracy.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/src/3DConversions.cxx:74,avoid,avoid,74,math/genvector/src/3DConversions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/src/3DConversions.cxx,1,['avoid'],['avoid']
Safety,// these variables need to be fixed in one step; // Group Connected Components for Unsafe Vars; // (Dependencies based on pointer assignments),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:83,Unsafe,Unsafe,83,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['Unsafe'],['Unsafe']
Safety,"// this avoids the binding of the hists in PDF to the current ROOT file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx:8,avoid,avoids,8,tmva/tmva/src/MethodBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodBase.cxx,1,['avoid'],['avoids']
Safety,"// this avoids the binding of the hists in TMVA::PDF to the current ROOT file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodLikelihood.cxx:8,avoid,avoids,8,tmva/tmva/src/MethodLikelihood.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodLikelihood.cxx,4,['avoid'],['avoids']
Safety,"// this exists to avoid calling update excessively because it slows down x11 ... but still; // need to call update twice if have a legend drawn in order to relocate it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:18,avoid,avoid,18,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['avoid'],['avoid']
Safety,"// this function modifies cache state ---> make writing thread-safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:63,safe,safe,63,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safe']
Safety,"// this if xmin == xmax == 0; // safety margin for values equal to the maximum within the histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/TransformationHandler.cxx:33,safe,safety,33,tmva/tmva/src/TransformationHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/TransformationHandler.cxx,1,['safe'],['safety']
Safety,"// this is commented out only to try to prevent false positive detection; // from several anti-virus engines on Windows, and multiproc is not; // supported on Windows anyway",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/main/src/hadd.cxx:63,detect,detection,63,main/src/hadd.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/main/src/hadd.cxx,1,['detect'],['detection']
Safety,"// this is not thread safe ...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TCollection.cxx:22,safe,safe,22,core/cont/src/TCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TCollection.cxx,2,['safe'],['safe']
Safety,"// this is not what I see, though it's supposedly the default:; // rgb256[ 8][0] = 127; rgb256[ 8][1] = 127; rgb256[ 8][1] = 127;; // use this instead, just to be on the safe side:",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplayUnix.cpp:170,safe,safe,170,core/textinput/src/textinput/TerminalDisplayUnix.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/textinput/src/textinput/TerminalDisplayUnix.cpp,1,['safe'],['safe']
Safety,"// this is redundant only with libNew",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TBits.cxx:11,redund,redundant,11,core/cont/src/TBits.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TBits.cxx,1,['redund'],['redundant']
Safety,// this is the easiest way to avoid needing to maintain state,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/base/jspdf.mjs:30,avoid,avoid,30,js/modules/base/jspdf.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/base/jspdf.mjs,1,['avoid'],['avoid']
Safety,"// this is to avoid sending XdndPosition messages over and over; // if the target is not responding",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx:14,avoid,avoid,14,gui/gui/src/TGDNDManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx,1,['avoid'],['avoid']
Safety,"// this is workaround to detect ROOT shutdown",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rootqt5.cpp:25,detect,detect,25,gui/qt5webdisplay/rootqt5.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rootqt5.cpp,1,['detect'],['detect']
Safety,"// this line required to avoid strict-aliasing rules warning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveBoxSet.cxx:25,avoid,avoid,25,graf3d/eve7/src/REveBoxSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveBoxSet.cxx,1,['avoid'],['avoid']
Safety,"// this next thing happens if the par has errors but the covariance matrix is empty; // this only happens if the fit was dodgy, so perhaps best to not even try to recover from this; // screwup ... hence I've commented out this fixup here and will let the errors be nan; // if(errVal==0) {; // Warning(""getPropagatedError"",""Missing variance for %s"",rrv.GetName());; // errVal = rrv.getError();; // V(ivar,ivar) = errVal*errVal;; // }; // Make Plus variation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:163,recover,recover,163,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['recover'],['recover']
Safety,"// this tolerance is used to avoid having negative qmu due to numerical errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx:29,avoid,avoid,29,roofit/roostats/src/AsymptoticCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx,1,['avoid'],['avoid']
Safety,// thisMBB:; // xbegin fallMBB; // # fallthrough to mainMBB; // # abortion to fallMBB,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:66,abort,abortion,66,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['abort'],['abortion']
Safety,"// three checks are required to ensure safety:; // . Offset >= 0 (since the offset is given from the base ptr); // . Size >= Offset (unsigned); // . Size - Offset >= NeededSize (unsigned); //; // optimization: if Size >= 0 (signed), skip 1st check; // FIXME: add NSW/NUW here? -- we dont care if the subtraction overflows",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:39,safe,safety,39,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,1,['safe'],['safety']
Safety,"// time is not important - timeout handle before; // if (tm > 100) return -3;; // continue waiting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/canvaspainter/src/RCanvasPainter.cxx:27,timeout,timeout,27,gui/canvaspainter/src/RCanvasPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/canvaspainter/src/RCanvasPainter.cxx,1,['timeout'],['timeout']
Safety,"// time is not important - timeout handle before; // if (tm > 100.) return -3;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/canvaspainter/src/RCanvasPainter.cxx:27,timeout,timeout,27,gui/canvaspainter/src/RCanvasPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/canvaspainter/src/RCanvasPainter.cxx,1,['timeout'],['timeout']
Safety,"// time per risk evaluation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:12,risk,risk,12,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,1,['risk'],['risk']
Safety,"// timeout flag",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h:3,timeout,timeout,3,net/auth/inc/TAuthenticate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/inc/TAuthenticate.h,1,['timeout'],['timeout']
Safety,"// times or values may be shared with other tracks, so overwriting is unsafe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs:70,unsafe,unsafe,70,js/modules/three.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/three.mjs,1,['unsafe'],['unsafe']
Safety,"// to avoid Nan",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h:6,avoid,avoid,6,math/genvector/inc/Math/GenVector/LorentzVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/genvector/inc/Math/GenVector/LorentzVector.h,1,['avoid'],['avoid']
Safety,// to avoid a nan from log(0)*0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:6,avoid,avoid,6,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,4,['avoid'],['avoid']
Safety,"// to avoid a nan from log(0)*0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/PdfFuncMathCore.h:6,avoid,avoid,6,math/mathcore/inc/Math/PdfFuncMathCore.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/PdfFuncMathCore.h,2,['avoid'],['avoid']
Safety,"// to avoid adding fHistogram to gDirectory",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:6,avoid,avoid,6,hist/hist/src/TGraph2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx,1,['avoid'],['avoid']
Safety,"// to avoid binwidth = 0 set arbitrarly to 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitInterface.cxx:6,avoid,avoid,6,hist/hist/src/HFitInterface.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitInterface.cxx,1,['avoid'],['avoid']
Safety,"// to avoid binwidthx = 0 set arbitrarly to 1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitInterface.cxx:6,avoid,avoid,6,hist/hist/src/HFitInterface.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/HFitInterface.cxx,1,['avoid'],['avoid']
Safety,"// to avoid calling SetDrawoption after every change",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx:6,avoid,avoid,6,gui/ged/src/TH1Editor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx,1,['avoid'],['avoid']
Safety,"// to avoid case 0/0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx:6,avoid,avoid,6,roofit/roostats/src/AsymptoticCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/AsymptoticCalculator.cxx,1,['avoid'],['avoid']
Safety,"// to avoid cases in chi2-test of profiles when error is zero",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx:6,avoid,avoid,6,test/stressHistogram.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressHistogram.cxx,1,['avoid'],['avoid']
Safety,"// to avoid compiler warnings",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx:6,avoid,avoid,6,graf2d/asimage/src/TASImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx,4,['avoid'],['avoid']
Safety,// to avoid cross-dependency between modules,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:6,avoid,avoid,6,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// to avoid dependency from TF1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx:6,avoid,avoid,6,gui/fitpanelv7/src/RFitPanel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx,1,['avoid'],['avoid']
Safety,"// to avoid dependency from TF1; // if TF1 object deleted before - prevent second delete",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx:6,avoid,avoid,6,gui/fitpanelv7/src/RFitPanel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx,1,['avoid'],['avoid']
Safety,"// to avoid getting infinity and nan's",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliStandardMaximumLikelihoodFCN.cxx:6,avoid,avoid,6,math/minuit2/src/FumiliStandardMaximumLikelihoodFCN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliStandardMaximumLikelihoodFCN.cxx,1,['avoid'],['avoid']
Safety,"// to avoid infinite loop",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:6,avoid,avoid,6,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['avoid'],['avoid']
Safety,"// to avoid infinite looping",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx:6,avoid,avoid,6,math/mathcore/src/Fitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/Fitter.cxx,2,['avoid'],['avoid']
Safety,"// to avoid infinite recursion Fill->BufferFill->Fill",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:6,avoid,avoid,6,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['avoid'],['avoid']
Safety,"// to avoid jumping from DoAddBar to DoAddB and vice versa",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx:6,avoid,avoid,6,gui/ged/src/TH1Editor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TH1Editor.cxx,1,['avoid'],['avoid']
Safety,"// to avoid memory leak; // t.b.f. "" RooProfileLL should keep and provide possibility to query on global minimum; // set POI to fit value (this will speed up profileLL calculation of global minimum)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodCalculator.cxx:6,avoid,avoid,6,roofit/roostats/src/ProfileLikelihoodCalculator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/ProfileLikelihoodCalculator.cxx,1,['avoid'],['avoid']
Safety,"// to avoid numerical rounding",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:6,avoid,avoid,6,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,5,['avoid'],['avoid']
Safety,"// to avoid problem with subsequents draws",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/LikelihoodIntervalPlot.cxx:6,avoid,avoid,6,roofit/roostats/src/LikelihoodIntervalPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/LikelihoodIntervalPlot.cxx,1,['avoid'],['avoid']
Safety,"// to avoid recursive calls",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:6,avoid,avoid,6,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,2,['avoid'],['avoid']
Safety,"// to avoid segv. stop editting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx:6,avoid,avoid,6,gui/guibuilder/src/TGuiBldDragManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/guibuilder/src/TGuiBldDragManager.cxx,1,['avoid'],['avoid']
Safety,"// to avoid some annoying warnings in case of vectors (D2 = 0)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Expression.h:6,avoid,avoid,6,math/smatrix/inc/Math/Expression.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/smatrix/inc/Math/Expression.h,1,['avoid'],['avoid']
Safety,"// to avoid summing infinite and nan later when calculating the Hessian",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliStandardMaximumLikelihoodFCN.cxx:6,avoid,avoid,6,math/minuit2/src/FumiliStandardMaximumLikelihoodFCN.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/FumiliStandardMaximumLikelihoodFCN.cxx,1,['avoid'],['avoid']
Safety,"// to avoid that following minimization computes automatically the Minos errors",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx:6,avoid,avoid,6,roofit/roofitcore/src/RooMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx,1,['avoid'],['avoid']
Safety,"// to avoid the warning for un-used variables",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stressTMath.cxx:6,avoid,avoid,6,math/mathcore/test/stressTMath.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/test/stressTMath.cxx,1,['avoid'],['avoid']
Safety,"// to detect deletions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx:6,detect,detect,6,bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Converters.cxx,1,['detect'],['detect']
Safety,"// training interface - called from MethodCFMlpANN class object; // sanity checks",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCFMlpANN_Utils.cxx:68,sanity check,sanity checks,68,tmva/tmva/src/MethodCFMlpANN_Utils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodCFMlpANN_Utils.cxx,1,['sanity check'],['sanity checks']
Safety,// transaction safe,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h:15,safe,safe,15,interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Demangle/ItaniumDemangle.h,1,['safe'],['safe']
Safety,"// trick to avoid mouse move events between the mouse click; // and the unmapping...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListBox.cxx:12,avoid,avoid,12,gui/gui/src/TGListBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGListBox.cxx,1,['avoid'],['avoid']
Safety,"// try recompiling the formula. We need to lock because this is not anymore thread safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:83,safe,safe,83,hist/hist/src/TFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx,2,['safe'],['safe']
Safety,"// try recovering the type_info of this type, no problem if we fail (as long as no one calls GetTypeId)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx:7,recover,recovering,7,tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RJittedDefine.hxx,1,['recover'],['recovering']
Safety,// try to avoid browser caching by adding stamp parameter to URL,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:10,avoid,avoid,10,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// try to avoid caching on the browser",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx:10,avoid,avoid,10,net/http/src/THttpServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx,1,['avoid'],['avoid']
Safety,// try to detect if code includes import and must be treated as module,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:10,detect,detect,10,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['detect'],['detect']
Safety,"// try to mprotect the other bits of the pool with no access...; // we'd really like a version of mremap here that can unmap all the; // other pages in the chunk, but that does not exist, so we protect; // the other pages in this chunk such that they may neither be read,; // written nor executed, only the pages we're interested in for; // communications stay readable and writable; //; // if an OS does not support changing the protection of a part of an; // mmapped area, the mprotect calls below should just fail and not; // change any protection, so we're a little less safe against; // corruption, but everything should still work",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx:575,safe,safe,575,roofit/roofitcore/src/BidirMMapPipe.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/BidirMMapPipe.cxx,1,['safe'],['safe']
Safety,"// udiv is an expensive operation in the general case. If this ends up being; // a hot spot, one of the options proposed in; // https://reviews.llvm.org/D28535#650071 could be used to avoid this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp:184,avoid,avoid,184,interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BlockFrequencyInfo.cpp,1,['avoid'],['avoid']
Safety,"// uncomment the next few lines to avoid (forbid) any mouse interaction; // gVirtualX->GrabPointer(gClient->GetDefaultRoot()->GetId(), kButtonPressMask |; // kButtonReleaseMask | kPointerMotionMask, kNone,; // gVirtualX->CreateCursor(kWatch), kTRUE, kFALSE);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/stressGUI.cxx:35,avoid,avoid,35,test/stressGUI.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/stressGUI.cxx,1,['avoid'],['avoid']
Safety,"// unmap the window (to avoid flickering)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGSplitFrame.cxx:24,avoid,avoid,24,gui/gui/src/TGSplitFrame.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGSplitFrame.cxx,1,['avoid'],['avoid']
Safety,"// unsafe constructor using just a pointer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserCovariance.h:3,unsafe,unsafe,3,math/minuit2/inc/Minuit2/MnUserCovariance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserCovariance.h,1,['unsafe'],['unsafe']
Safety,"// update length since Clobber clamps to MaxSize (if Fatal does not abort)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:68,abort,abort,68,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,1,['abort'],['abort']
Safety,"// update statistics (do here to avoid changes by SetBinContent)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:33,avoid,avoid,33,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,2,['avoid'],['avoid']
Safety,"// update statistics (do here to avoid changes by SetBinContent) FIXME remove???",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:33,avoid,avoid,33,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['avoid'],['avoid']
Safety,"// use Kahan's algorithm to sum up weights to avoid loss of precision",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx:46,avoid,avoid,46,roofit/roofitcore/src/RooVectorDataStore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooVectorDataStore.cxx,1,['avoid'],['avoid']
Safety,// use a temporary variable to avoid a use-after-free if the map's storage is; // reallocated,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:31,avoid,avoid,31,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,1,['avoid'],['avoid']
Safety,// use additional time stamp parameter for file name to avoid browser caching problem,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:56,avoid,avoid,56,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// use an independent instance of a random generator; // instead of gRandom to avoid conflicts and; // to get same random numbers when drawing the same histogram",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx:79,avoid,avoid,79,hist/histpainter/src/THistPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/THistPainter.cxx,2,['avoid'],['avoid']
Safety,"// use callback to release pointer, actually not needed but just to avoid compiler warning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RFileDialog.cxx:68,avoid,avoid,68,gui/browserv7/src/RFileDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RFileDialog.cxx,1,['avoid'],['avoid']
Safety,"// use expm1 function to avoid errors at small x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/ProbFuncMathCore.cxx:25,avoid,avoid,25,math/mathcore/src/ProbFuncMathCore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/ProbFuncMathCore.cxx,1,['avoid'],['avoid']
Safety,"// use functionality of SetHierPart; // in order to avoid duplicate code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUri.cxx:52,avoid,avoid,52,core/base/src/TUri.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUri.cxx,1,['avoid'],['avoid']
Safety,"// use functionality of SetRelativePart; // in order to avoid duplicate code",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUri.cxx:56,avoid,avoid,56,core/base/src/TUri.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TUri.cxx,1,['avoid'],['avoid']
Safety,"// use log1p for avoid errors at small z",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/QuantFuncMathCore.cxx:17,avoid,avoid,17,math/mathcore/src/QuantFuncMathCore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/QuantFuncMathCore.cxx,1,['avoid'],['avoid']
Safety,"// use mask to avoid warning",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx:15,avoid,avoid,15,core/unix/src/TUnixSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/unix/src/TUnixSystem.cxx,1,['avoid'],['avoid']
Safety,// use minimal timeout in batch mode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:15,timeout,timeout,15,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,// use of Promise should avoid large call-stack depth when many primitives are drawn,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:25,avoid,avoid,25,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// use safe numerically implementation by subtracting max of tensor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Softmax.hxx:7,safe,safe,7,tmva/sofie/inc/TMVA/ROperator_Softmax.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/sofie/inc/TMVA/ROperator_Softmax.hxx,1,['safe'],['safe']
Safety,"// use std::list to avoid calling of Block_t copy constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RStyle.hxx:20,avoid,avoid,20,graf2d/gpadv7/inc/ROOT/RStyle.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RStyle.hxx,1,['avoid'],['avoid']
Safety,"// use this order for safety on library loading",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx:22,safe,safety,22,roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/histfactory/src/HistoToWorkspaceFactoryFast.cxx,1,['safe'],['safety']
Safety,// use timeout,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/Panel.controller.js:7,timeout,timeout,7,ui5/canv/controller/Panel.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/Panel.controller.js,2,['timeout'],['timeout']
Safety,// use timeout to avoid conflict with mouse click and automatic menu close,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:7,timeout,timeout,7,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,8,"['avoid', 'timeout']","['avoid', 'timeout']"
Safety,// use timeout to avoid too deep call stack,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs:7,timeout,timeout,7,js/modules/webwindow.mjs,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/modules/webwindow.mjs,2,"['avoid', 'timeout']","['avoid', 'timeout']"
Safety,// use translate and then rotate to avoid complex sign calculations,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:36,avoid,avoid,36,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['avoid'],['avoid']
Safety,"// using for training same scalar type defined for the prediction",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx:55,predict,prediction,55,tmva/tmva/src/MethodDL.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDL.cxx,2,['predict'],['prediction']
Safety,"// v128.{load,store}{8,16,32,64}_lane has both a memarg and a lane; // index. We need to avoid parsing an extra alignment operand for the; // lane index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp:89,avoid,avoid,89,interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/WebAssembly/AsmParser/WebAssemblyAsmParser.cpp,1,['avoid'],['avoid']
Safety,"// v_rcp_f32 and v_rsq_f32 do not support denormals, and according to; // the CI documentation has a worst case error of 1 ulp.; // OpenCL requires <= 2.5 ulp for 1.0 / x, so it should always be OK to; // use it as long as we aren't trying to use denormals.; //; // v_rcp_f16 and v_rsq_f16 DO support denormals and 0.51ulp.; // 1.0 / sqrt(x) -> rsq(x); // XXX - Is UnsafeFPMath sufficient to do this for f64? The maximum ULP; // error seems really high at 2^29 ULP.; // 1.0 / x -> rcp(x)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:365,Unsafe,UnsafeFPMath,365,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Unsafe'],['UnsafeFPMath']
Safety,"// various implementations for Safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:31,Safe,Safety,31,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['Safe'],['Safety']
Safety,"// vector_shuffle <0,1,6,7> lhs, rhs; // -> concat_vectors (extract_subvector lhs, 0), (extract_subvector rhs, 2); //; // vector_shuffle <6,7,2,3> lhs, rhs; // -> concat_vectors (extract_subvector rhs, 2), (extract_subvector lhs, 2); //; // vector_shuffle <6,7,0,1> lhs, rhs; // -> concat_vectors (extract_subvector rhs, 2), (extract_subvector lhs, 0); // Avoid scalarizing when both halves are reading from consecutive elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp:356,Avoid,Avoid,356,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIISelLowering.cpp,1,['Avoid'],['Avoid']
Safety,// void abort(void),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp:8,abort,abort,8,interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/Interpreter/ExternalFunctions.cpp,1,['abort'],['abort']
Safety,"// volume to which a safety sphere node was added",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/inc/TGeoChecker.h:21,safe,safety,21,geom/geompainter/inc/TGeoChecker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/inc/TGeoChecker.h,1,['safe'],['safety']
Safety,"// want to avoid zero value",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestCalculatorGeneric.cxx:11,avoid,avoid,11,roofit/roostats/src/HypoTestCalculatorGeneric.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/HypoTestCalculatorGeneric.cxx,1,['avoid'],['avoid']
Safety,"// wasm-ld understands a finite set of symbol types. This flag allows the; // compiler to avoid emitting symbol table entries that would confuse the; // linker, unless the user specifically requests the feature.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbolWasm.h:90,avoid,avoid,90,interpreter/llvm-project/llvm/include/llvm/MC/MCSymbolWasm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbolWasm.h,1,['avoid'],['avoid']
Safety,"// watch for zmq_error from ppoll caused by SIGTERM from master; // poll: wait until status change (-1: infinite timeout)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Queue.cxx:113,timeout,timeout,113,roofit/multiprocess/src/Queue.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/multiprocess/src/Queue.cxx,1,['timeout'],['timeout']
Safety,"// we abort on the first found candidate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/AutoSynthesizer.cpp:6,abort,abort,6,interpreter/cling/lib/Interpreter/AutoSynthesizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/AutoSynthesizer.cpp,1,['abort'],['abort']
Safety,"// we are now in the container, check safety to all candidates",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:38,safe,safety,38,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safety']
Safety,// we have illegal '<' try to recover,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:30,recover,recover,30,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,2,['recover'],['recover']
Safety,"// we need a file because in-memory trees are not supported; // (and are detected at TTreeProcessorMT construction time)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/test/treeprocs/treeprocessors.cxx:73,detect,detected,73,tree/treeplayer/test/treeprocs/treeprocessors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/test/treeprocs/treeprocessors.cxx,2,['detect'],['detected']
Safety,"// we need this in order to avoid border blinking when switching tabs...",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTab.cxx:28,avoid,avoid,28,gui/gui/src/TGTab.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTab.cxx,1,['avoid'],['avoid']
Safety,"// we need to be a bit careful: A returned safety value of TGeoShape::Big(); // is not the actual safety and should not be cached",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:43,safe,safety,43,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,2,['safe'],['safety']
Safety,"// we need to try to avoid this copy",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TClassEdit.cxx:21,avoid,avoid,21,core/foundation/src/TClassEdit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TClassEdit.cxx,2,['avoid'],['avoid']
Safety,"// well we should not have to make the root of the file system!; // (and this avoid infinite recursions!)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:78,avoid,avoid,78,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,2,['avoid'],['avoid']
Safety,"// when reading we initialize the formula later to avoid problem of recursive Jitting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx:51,avoid,avoid,51,hist/hist/src/TFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFormula.cxx,1,['avoid'],['avoid']
Safety,"// when timeout configured, object is prepared for rendering",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js:8,timeout,timeout,8,js/build/jsroot.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/js/build/jsroot.js,2,['timeout'],['timeout']
Safety,"// while(1) is common, avoid extra exit blocks. Be sure; // to correctly handle break/continue though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:23,avoid,avoid,23,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['avoid'],['avoid']
Safety,"// will be a +0 value; // If we can't safely assume the sub-expression will produce a; // block-copied value, emit the sub-expression at +0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:38,safe,safely,38,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['safe'],['safely']
Safety,// winsock2.h must be included before afunix.h. Briefly turn off clang-format to; // avoid error.; // clang-format off,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_socket_stream.cpp:85,avoid,avoid,85,interpreter/llvm-project/llvm/lib/Support/raw_socket_stream.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/raw_socket_stream.cpp,1,['avoid'],['avoid']
Safety,"// with a dense layer (also use not too large batch size or input size to avoid numerical errors)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx:74,avoid,avoid,74,tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/test/DNN/RNN/TestRecurrentBackpropagationCudnn.cxx,1,['avoid'],['avoid']
Safety,"// with gcc on unix machines and on x86_64, we can gain by hand-coding; // exp(z) for the x87 coprocessor; other platforms have the default; // routines as fallback implementation, and compilers other than gcc on; // x86_64 generate better code with the default routines; also avoid; // the inline assembly code when the compiler is not optimising code, or; // is optimising for code size; // (we insist on __unix__ here, since the assemblers on other OSs; // typically do not speak AT&T syntax as gas does...)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooHeterogeneousMath.h:277,avoid,avoid,277,roofit/batchcompute/res/RooHeterogeneousMath.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooHeterogeneousMath.h,1,['avoid'],['avoid']
Safety,// word to byte only under BWI. Otherwise we have to promoted to v16i32; // and then truncate that. But we should only do that if we haven't been; // asked to avoid 512-bit vectors. The actual promotion to v16i32 will be; // handled by isel patterns.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:159,avoid,avoid,159,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,// workaround for openui5 problem - called before actual dimension of HTML element is assigned; // issue longer resize timeout; // normall ui5 resize event with short timeout should follow very fast; // only then one can check size of element and perform rendering,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/CanvasPanel.controller.js:119,timeout,timeout,119,ui5/canv/controller/CanvasPanel.controller.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/canv/controller/CanvasPanel.controller.js,2,['timeout'],['timeout']
Safety,"// workaround, done for nodes drawing to avoid deletion of 3D objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/lib/GeomDrawing.js:41,avoid,avoid,41,ui5/geom/lib/GeomDrawing.js,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/ui5/geom/lib/GeomDrawing.js,1,['avoid'],['avoid']
Safety,"// write first in "".<file>"" then rename to recover from crash during writing",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx:43,recover,recover,43,proof/proof/src/TDataSetManagerFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDataSetManagerFile.cxx,1,['recover'],['recover']
Safety,"// writing to gPrefixFilter is not thread-safe, should be done only from main thread",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx:42,safe,safe,42,math/minuit2/src/MnPrint.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnPrint.cxx,1,['safe'],['safe']
Safety,"// wve adjust for variable bin sizes; ////////////////////////////////////////////////////////////////////////////////; /// Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim'; /// at current value 'xval'; /// \param[in] iDim Index of the histogram dimension along which to interpolate.; /// \param[in] xval Value of histogram variable at dimension `iDim` for which; /// we want to interpolate the histogram weight.; /// \param[in] centralIdx Index of the bin that the point at which we; /// interpolate the histogram weight falls into; /// (can be obtained with `RooDataHist::calcTreeIndex`).; /// \param[in] intOrder Interpolation order, i.e. how many neighbouring bins are; /// used for the interpolation.; /// \param[in] correctForBinSize Enable the inverse bin volume correction factor.; /// \param[in] cdfBoundaries Enable the special boundary condition for a cdf:; /// underflow bins are assumed to have weight zero and; /// overflow bins have weight one. Otherwise, the; /// histogram is mirrored at the boundaries for the; /// interpolation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:141,safe,safe,141,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['safe'],['safe']
Safety,// x / y -> x * (1.0 / y); // TODO: Could avoid denormal scaling and use raw rcp if we knew the output; // will never underflow.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,// zz = q + c + (a - (q + z)) + aa + cc;; // Compute a - (q + z) as -((q + z) - a) to avoid temporary copies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APFloat.cpp,1,['avoid'],['avoid']
Safety,"// {'deviance', 'exponential'}, optional (default='deviance'); //loss function to be optimized. 'deviance' refers to; //deviance (= logistic regression) for classification; //with probabilistic outputs. For loss 'exponential' gradient; //boosting recovers the AdaBoost algorithm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyGTB.h:247,recover,recovers,247,tmva/pymva/inc/TMVA/MethodPyGTB.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/pymva/inc/TMVA/MethodPyGTB.h,1,['recover'],['recovers']
Safety,"// {X,+,N}/C --> {X/C,+,N/C} if safe and N/C can be folded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:32,safe,safe,32,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['safe'],['safe']
Safety,"// |Line| + 1 is needed to avoid underflow when, e.g |Line| = 0 and LCol = 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp:27,avoid,avoid,27,interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/SourceCoverageViewHTML.cpp,1,['avoid'],['avoid']
Safety,"// } else {else if(_bin->get<RooProduct>()) {; // // multiply the element which will just add it as a factor in the rooproduct; // return _bin->Multiply(child,opt);; // } else {; // // not a rooproduct in this bin yet ... so need to replace with a rooproduct and; // multiply that; // // this avoids the undesired behaviour of shared binFactors getting all impacted by; // mulitplies RooArgList all; auto new_p =; // acquireNew<RooProduct>(TString::Format(""%s_bin%d"",binFactors->get()->GetName(),fBinNumber),TString::Format(""binFactors; // of bin %d"",fBinNumber),RooArgList(*_bin->get<RooAbsArg>()));; // new_p->setStringAttribute(""alias"",""""); // for (int i = 0; i < phf->_paramSet.size(); i++) {; // if (i != fBinNumber - 1) all.add(*phf->_paramSet.at(i));; // else all.add(*new_p);; // }; // phf->_paramSet.removeAll();; // phf->_paramSet.add(all);; // // now multiply that bin having converted it to RooProduct; // return binFactors->bins().at(fBinNumber - 1)->Multiply(child,opt);; // }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:293,avoid,avoids,293,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,1,['avoid'],['avoids']
Safety,"//! A regular 3D cache layer for fast point-based safety lookups",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:50,safe,safety,50,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['safe'],['safety']
Safety,"//! BVH helper structure for safety and navigation",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:29,safe,safety,29,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,1,['safe'],['safety']
Safety,"//! Special 'lock' to detect multiple access to a collection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h:22,detect,detect,22,core/cont/inc/TCollection.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/inc/TCollection.h,1,['detect'],['detect']
Safety,"//! cache of the list of proxies. Avoids type casting.; // Debug stuff",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h:34,Avoid,Avoids,34,roofit/roofitcore/inc/RooAbsArg.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsArg.h,1,['Avoid'],['Avoids']
Safety,"//! flag a safe start for point classification",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:11,safe,safe,11,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['safe'],['safe']
Safety,"//! global mode is caching enabled for parallel world safety calls",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:54,safe,safety,54,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['safe'],['safety']
Safety,"//! last computed safety radius",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:18,safe,safety,18,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['safe'],['safety']
Safety,"//! last point for which parallel world safety was ""evaluated""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:40,safe,safety,40,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['safe'],['safety']
Safety,"//! last point for which safety was computed",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:25,safe,safety,25,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['safe'],['safety']
Safety,"//! last safety returned from parallel world (negative if invalid)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:9,safe,safety,9,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['safe'],['safety']
Safety,"//! safety radius from current point",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h:4,safe,safety,4,geom/geom/inc/TGeoNavigator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoNavigator.h,1,['safe'],['safety']
Safety,"//! stores bounding boxes serving a quick safety candidates (to be; //! used with the VoxelGrid and SafetyVoxelInfo)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h:42,safe,safety,42,geom/geom/inc/TGeoParallelWorld.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/TGeoParallelWorld.h,2,"['Safe', 'safe']","['SafetyVoxelInfo', 'safety']"
Safety,"//#else // not thread safe; // const std::vector<double>& operator()(const MnAlgebraicVector&) const;; //#endif; // Index = internal Parameter",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserTransformation.h:22,safe,safe,22,math/minuit2/inc/Minuit2/MnUserTransformation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserTransformation.h,1,['safe'],['safe']
Safety,"//#ifdef MINUIT2_THREAD_SAFE; // this if a thread-safe implementation needed if want to share transformation object between the threads",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserTransformation.cxx:50,safe,safe,50,math/minuit2/src/MnUserTransformation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/src/MnUserTransformation.cxx,1,['safe'],['safe']
Safety,"//#ifdef MINUIT2_THREAD_SAFE; // thread-safe version (do not use cache)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserTransformation.h:40,safe,safe,40,math/minuit2/inc/Minuit2/MnUserTransformation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/MnUserTransformation.h,1,['safe'],['safe']
Safety,"//#ifdef _GLIBCXX_PARALLEL; // #pragma omp parallel; // #pragma omp for; //#endif; // The range methods are not thread safe!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticPopulation.cxx:119,safe,safe,119,tmva/tmva/src/GeneticPopulation.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/GeneticPopulation.cxx,1,['safe'],['safe']
Safety,"//******************************************************************************; ////////////////////////////////////////////////////////////////////////////////; /// Set visualization-parameter model element.; /// Calling of this function from outside of EVE should in principle; /// be avoided as it can lead to dis-synchronization of viz-tag and; /// viz-model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx:289,avoid,avoided,289,graf3d/eve/src/TEveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx,1,['avoid'],['avoided']
Safety,"//*****************************************************************************; //**** DetectRoundChange pass; //*****************************************************************************; // To prevent any explicit change of the default rounding mode, this pass; // detects any call of the fesetround function.; // A warning is generated to ensure the user knows this has happened.; //; // Detects an erratum in UT699 LEON 3 processor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp:88,Detect,DetectRoundChange,88,interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Sparc/LeonPasses.cpp,3,"['Detect', 'detect']","['DetectRoundChange', 'Detects', 'detects']"
Safety,"//*-* -------------Check if, in case of inconsistencies, we are requested to; //*-* -------------attempt recovering the file",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:105,recover,recovering,105,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['recover'],['recovering']
Safety,"//- safe indexing for STL-like vector w/o iterator dictionaries ---------------; /* replaced by indexiterobject iteration, but may still have some future use ...; PyObject* CheckedGetItem(PyObject* self, PyObject* obj); {; // Implement a generic python __getitem__ for STL-like classes that are missing the; // reflection info for their iterators. This is then used for iteration by means of; // consecutive indices, it such index is of integer type.; Py_ssize_t size = PySequence_Size(self);; Py_ssize_t idx = PyInt_AsSsize_t(obj);; if ((size == (Py_ssize_t)-1 || idx == (Py_ssize_t)-1) && PyErr_Occurred()) {; // argument conversion problem: let method itself resolve anew and report; PyErr_Clear();; return PyObject_CallMethodOneArg(self, PyStrings::gGetNoCheck, obj);; }. bool inbounds = false;; if (idx < 0) idx += size;; if (0 <= idx && 0 <= size && idx < size); inbounds = true;. if (inbounds); return PyObject_CallMethodOneArg(self, PyStrings::gGetNoCheck, obj);; else; PyErr_SetString( PyExc_IndexError, ""index out of range"" );. return nullptr;; }*/; //- pair as sequence to allow tuple unpacking --------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx:4,safe,safe,4,bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/cppyy/CPyCppyy/src/Pythonize.cxx,1,['safe'],['safe']
Safety,"//-- slows down x11 so trying to avoid",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx:33,avoid,avoid,33,roofit/xroofit/src/xRooNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/xroofit/src/xRooNode.cxx,2,['avoid'],['avoid']
Safety,"//--- Compute safety first",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd1.cxx:14,safe,safety,14,geom/geom/src/TGeoTrd1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd1.cxx,2,['safe'],['safety']
Safety,"//--- Compute safety first; // check Z facettes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd1.cxx:14,safe,safety,14,geom/geom/src/TGeoTrd1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd1.cxx,2,['safe'],['safety']
Safety,"//---- ClassDefT macros for templates with one template argument ---------------; // ClassDefT corresponds to ClassDef; // ClassDefT2 goes in the same header as ClassDefT but must be; // outside the class scope; // ClassImpT corresponds to ClassImp; /// This ClassDefT is strictly redundant and is kept only for; /// backward compatibility. \deprecated",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Rtypes.h:281,redund,redundant,281,core/base/inc/Rtypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/Rtypes.h,1,['redund'],['redundant']
Safety,"//---- Timeout timer -----------------------------------------------------------; //; // This utility class is only used via TMonitor::Select(Int_t timeout); //",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx:7,Timeout,Timeout,7,net/net/src/TMonitor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx,2,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"//--------------------------------------------------------------------; //; // paintHist(); //; // Draws a histo in the canvas cA in case of the user defined display layout.; // The latest display layout has the highest priority. If an overlap; // with existing pads is detected, they are deleted from cA.; // Algorithm virtually divides cA into subpads with the matrix layout (4x4).; // A real pad in which histo will be drawn is constructed from virtual subpads.; // The number of virtual subpads for the real pad can change in the range 1-16.; // Arrays histInd[16] and pads[16] keep the ""id"" of the histo and the; // address of the real pad; //; // -----------------; // | | | | |; // | 1 | 2 | 3 | 4 |; // |---|---|---|---|; // | | | | |; // | 5 | 6 | 7 | 8 |; // |---|---|---|---|; // | | | | |; // | 9 | 10| 11| 12|; // |---|---|---|---|; // | | | | |; // | 13| 14| 15| 16|; // -----------------; //; //; // If a histo with id=20 must be drawn in a pad which embraces virtual subpads; // 1,2,5,6 then; // histInd[0] = 20 pads[0] = address of the real pad; // histInd[1] = 20 pads[1] = NULL; // histInd[4] = 20 pads[4] = NULL; // histInd[5] = 20 pads[5] = NULL; //; // To search for the pads to be deleted the algorithm uses only array; // histInd[].; // Only one of the virtual subpads of the real pad keeps the address; // to avoid double deleting of the same object.; // If there is an overlap between the pads which contain the histo with; // the same ""id"", then only the latest version is drawn.; // All the other pads with this histo (even non overlapping with the current; // one) will be deleted from the canvas.; // To have several versions of the same histo drawn in the canvas one has; // to avoid pads overlapping when setting display layout.; //--------------------------------------------------------------------",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx:270,detect,detected,270,test/histviewer/histaction.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/histviewer/histaction.cxx,3,"['avoid', 'detect']","['avoid', 'detected']"
Safety,"//---> Check against the parallel geometry safety; // cross-check against the parallel world safety, using fSafety as limit",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:43,safe,safety,43,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,2,['safe'],['safety']
Safety,"//---> check fast unsafe voxels",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:18,unsafe,unsafe,18,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,2,['unsafe'],['unsafe']
Safety,"//---> compute safety for lateral planes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx:15,safe,safety,15,geom/geom/src/TGeoArb8.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx,1,['safe'],['safety']
Safety,"//---> compute safety to current node",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:15,safe,safety,15,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safety']
Safety,"//---> if we were just entering, return this safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:45,safe,safety,45,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safety']
Safety,"//---> if we were just exiting, return this safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:44,safe,safety,44,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safety']
Safety,"/// ""\#pragma execution_character_set(...)"". MSVC supports this pragma only; /// for ""UTF-8"". We parse it and ignore it if UTF-8 is provided and warn; /// otherwise to avoid -Wunknown-pragma warnings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:168,avoid,avoid,168,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['avoid'],['avoid']
Safety,"/// ""\#pragma managed""; /// ""\#pragma managed(...)""; /// ""\#pragma unmanaged""; /// MSVC ignores this pragma when not compiling using /clr, which clang doesn't; /// support. We parse it and ignore it to avoid -Wunknown-pragma warnings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:202,avoid,avoid,202,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['avoid'],['avoid']
Safety,"/// ""\#pragma warning(...)"". MSVC's diagnostics do not map cleanly to clang's; /// diagnostics, so we don't really implement this pragma. We parse it and; /// ignore it to avoid -Wunknown-pragma warnings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp:172,avoid,avoid,172,interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Pragma.cpp,1,['avoid'],['avoid']
Safety,"/// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// BCC 76, %5, <%bb.2>; CRRC:%5; /// Successors according to CFG: %bb.1(?%) %bb.2(?%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.2(?%); ///; /// %bb.2: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.3(?%) %bb.4(?%); ///; /// %bb.3: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2; /// Successors according to CFG: %bb.4(?%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.2 %bb.3; /// %13 = PHI %12, <%bb.3>, %2, <%bb.2>;; /// F8RC:%13,%12,%2; /// <SNIP3>; /// BLR8 implicit %lr8, implicit %rm, implicit %f1; ///; /// When this pattern is detected, branch coalescing will try to collapse; /// it by moving code in %bb.2 to %bb.0 and/or %bb.4 and removing %bb.3.; ///; /// If all conditions are meet, IR should collapse to:; ///; /// %bb.0: derived from LLVM BB %entry; /// liveins: %f1 %f3 %x6; /// <SNIP1>; /// %0 = COPY %f1; F8RC:%0; /// %5 = CMPLWI killed %4, 0; CRRC:%5 GPRC:%4; /// %8 = LXSDX %zero8, killed %7, implicit %rm;; /// mem:LD8[ConstantPool] F8RC:%8 G8RC:%7; /// <SNIP2>; /// BCC 76, %5, <%bb.4>; CRRC:%5; /// Successors according to CFG: %bb.1(0x2aaaaaaa / 0x80000000 = 33.33%); /// %bb.4(0x55555554 / 0x80000000 = 66.67%); ///; /// %bb.1: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0; /// Successors according to CFG: %bb.4(0x40000000 / 0x80000000 = 50.00%); ///; /// %bb.4: derived from LLVM BB %entry; /// Predecessors according to CFG: %bb.0 %bb.1; /// %9 = PHI %8, <%bb.1>, %0, <%bb.0>;; /// F8RC:%9,%8,%0; /// %13 = PHI %12, <%bb.1>, %2, <%bb.0>;; /// F8RC:%13,%12,%2; /",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp:2046,detect,detected,2046,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCBranchCoalescing.cpp,1,['detect'],['detected']
Safety,/// 'HASH' magic value to detect endianness.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp:26,detect,detect,26,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AccelTable.cpp,1,['detect'],['detect']
Safety,"/// '[classname]' - Type of record values that have zero or more superclasses.; ///; /// The list of superclasses is non-redundant, i.e. only contains classes that; /// are not the superclass of some other listed class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h:121,redund,redundant,121,interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h,1,['redund'],['redundant']
Safety,/// (Re-)Initialize this bottom up pointer returning true if we detected a; /// pointer with nested releases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h:64,detect,detected,64,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/PtrState.h,2,['detect'],['detected']
Safety,"/// @brief Check if the TObject's memory has been deleted.; /// @warning This should be only used for error mitigation as the answer is only; /// sometimes correct. It actually just checks whether the object has been; /// deleted, so this will falsely return true for an object that has; /// been destructed but its memory has not been deleted. This will return an; /// undefined value if the memory is re-used between the deletion and the check.; /// i.e. This is useful to prevent a segmentation fault in case where the problem; /// can be detected when the deletion and the usage are 'close-by'; /// @warning In enviroment where delete taints (changes) the memory, this function; /// always returns false as the marker left by ~TObject will be overwritten.; /// @param obj The memory to check; /// @return true if the object has been destructed and it can be inferred that it has been deleted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TObject.h:542,detect,detected,542,core/base/inc/TObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TObject.h,1,['detect'],['detected']
Safety,"/// @brief Close the file object. This should be used instead of ::close for; /// portability. On error, the caller should assume the file is closed, as is; /// the case for Process::SafelyCloseFileDescriptor; ///; /// @param F On input, this is the file to close. On output, the file is; /// set to kInvalidFile.; ///; /// @returns An error code if closing the file failed. Typically, an error here; /// means that the filesystem may have failed to perform some buffered writes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:183,Safe,SafelyCloseFileDescriptor,183,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['Safe'],['SafelyCloseFileDescriptor']
Safety,"/// @}; /// @name Materialization; /// @{; /// Sets the GVMaterializer to GVM. This module must not yet have a; /// Materializer. To reset the materializer for a module that already has one,; /// call materializeAll first. Destroying this module will destroy; /// its materializer without materializing any more GlobalValues. Without; /// destroying the Module, there is no way to detach or destroy a materializer; /// without materializing all the GVs it controls, to avoid leaving orphan; /// unmaterialized GVs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:469,avoid,avoid,469,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['avoid'],['avoid']
Safety,"/// @}; /// Check for null.; ///; /// Check for null in a way that is safe with broken debug info. Unlike; /// the conversion to \c DILocation, this doesn't require that \c Loc is of; /// the right type. Important for cases like \a llvm::StripDebugInfo() and; /// \a Instruction::hasMetadata().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h:70,safe,safe,70,interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h,1,['safe'],['safe']
Safety,"/// @}; /// Create a compiler invocation from a list of input options.; /// \returns true on success.; ///; /// \returns false if an error was encountered while parsing the arguments; /// and attempts to recover and continue parsing the rest of the arguments.; /// The recovery is best-effort and only guarantees that \p Res will end up in; /// one of the vaild-to-access (albeit arbitrary) states.; ///; /// \param [out] Res - The resulting invocation.; /// \param [in] CommandLineArgs - Array of argument strings, this must not; /// contain ""-cc1"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h:204,recover,recover,204,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInvocation.h,2,['recover'],"['recover', 'recovery']"
Safety,"/// A CallbackVH to notify PhiValues when a value is deleted or replaced, so; /// that the cached information for that value can be cleared to avoid; /// dangling pointers to invalid values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:143,avoid,avoid,143,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,1,['avoid'],['avoid']
Safety,"/// A Chain is a sequence of instructions that are linked together by; /// an accumulation operand. For example:; ///; /// fmul def d0, ?; /// fmla def d1, ?, ?, killed d0; /// fmla def d2, ?, ?, killed d1; ///; /// There may be other instructions interleaved in the sequence that; /// do not belong to the chain. These other instructions must not use; /// the ""chain"" register at any point.; ///; /// We currently only support chains where the ""chain"" operand is killed; /// at each link in the chain for simplicity.; /// A chain has three important instructions - Start, Last and Kill.; /// * The start instruction is the first instruction in the chain.; /// * Last is the final instruction in the chain.; /// * Kill may or may not be defined. If defined, Kill is the instruction; /// where the outgoing value of the Last instruction is killed.; /// This information is important as if we know the outgoing value is; /// killed with no intervening uses, we can safely change its register.; ///; /// Without a kill instruction, we must assume the outgoing value escapes; /// beyond our model and either must not change its register or must; /// create a fixup FMOV to keep the old register value consistent.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp:963,safe,safely,963,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64A57FPLoadBalancing.cpp,1,['safe'],['safely']
Safety,"/// A Clang configuration for end-to-end tests that can be converted to; /// command line arguments for the driver.; ///; /// The configuration is represented as typed, named values, making it easier; /// and safer to work with compared to an array of string command line flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h:209,safe,safer,209,interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Testing/TestClangConfig.h,1,['safe'],['safer']
Safety,/// A Counter expression builder is used to construct the counter expressions.; /// It avoids unnecessary duplication and simplifies algebraic expressions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h:87,avoid,avoids,87,interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,1,['avoid'],['avoids']
Safety,"/// A GCStrategy for the CoreCLR Runtime. The strategy is similar to; /// Statepoint-example GC, but differs from it in certain aspects, such as:; /// 1) Base-pointers need not be explicitly tracked and reported for; /// interior pointers; /// 2) Uses a different format for encoding stack-maps; /// 3) Location of Safe-point polls: polls are only needed before loop-back; /// edges and before tail-calls (not needed at function-entry); ///; /// The above differences in behavior are to be implemented in upcoming; /// checkins.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp:315,Safe,Safe-point,315,interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/BuiltinGCs.cpp,1,['Safe'],['Safe-point']
Safety,/// A Lookup helper functions.; ///; /// Used during the InlineInfo::lookup() call to quickly only parse an; /// InlineInfo object if the address falls within this object. This avoids; /// allocations by not appending child InlineInfo objects to the; /// InlineInfo::Children array and also skips any InlineInfo objects that do; /// not contain the address we are looking up.; ///; /// \param Data The binary stream to read the data from.; ///; /// \param Offset The byte offset within \a Data.; ///; /// \param BaseAddr The address that the relative address range offsets are; /// relative to.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp:177,avoid,avoids,177,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp,1,['avoid'],['avoids']
Safety,"/// A MLModelRunner that asks for advice from an external agent, or host. It; /// uses 2 files - ideally named pipes - one to send data to that agent, and; /// one to receive advice.; /// The data exchange uses the training logger (Utils/TrainingLogger.h) format.; /// Specifically, the compiler will send the log header, set the context, and; /// send observations; the host is expected to reply with a tensor value after; /// each observation as a binary buffer that's conforming to the shape of the; /// advice. Interleaved, the data closely resembles the training log for a; /// log where we don't capture the reward signal.; ///; /// Note that the correctness of the received data is the responsibility of the; /// host. In particular, if insufficient data were sent, the compiler will block; /// when waiting for an advice.; ///; /// Note that the host can either open the pipes RW, or open first the pipe to; /// the compiler - i.e. the ""Inbound"" - and then the ""Outbound"", to avoid; /// deadlock. This is because the compiler first tries to open the inbound; /// (which will hang until there's a writer on the other end).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h:984,avoid,avoid,984,interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,1,['avoid'],['avoid']
Safety,/// A RecoveryExpr record.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:6,Recover,RecoveryExpr,6,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['Recover'],['RecoveryExpr']
Safety,"/// A ThreadPool for asynchronous parallel execution on a defined number of; /// threads.; ///; /// The pool keeps a vector of threads alive, waiting on a condition variable; /// for some work to become available.; ///; /// It is possible to reuse one thread pool for different groups of tasks; /// by grouping tasks using ThreadPoolTaskGroup. All tasks are processed using; /// the same queue, but it is possible to wait only for a specific group of; /// tasks to finish.; ///; /// It is also possible for worker threads to submit new tasks and wait for; /// them. Note that this may result in a deadlock in cases such as when a task; /// (directly or indirectly) tries to wait for its own completion, or when all; /// available threads are used up by tasks waiting for a task that has no thread; /// left to run on (this includes waiting on the returned future). It should be; /// generally safe to wait() for a group as long as groups do not form a cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h:893,safe,safe,893,interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadPool.h,1,['safe'],['safe']
Safety,/// A bit that indicates whether it's possible to avoid coying this block to; /// the heap when it initializes or is assigned to a local variable with; /// automatic storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:50,avoid,avoid,50,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['avoid'],['avoid']
Safety,"/// A bitvector that, under the hood, relies on an IntervalMap to coalesce; /// elements into intervals. Good for representing sets which predominantly; /// contain contiguous ranges. Bad for representing sets with lots of gaps; /// between elements.; ///; /// Compared to SparseBitVector, CoalescingBitVector offers more predictable; /// performance for non-sequential find() operations.; ///; /// \tparam IndexT - The type of the index into the bitvector.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:322,predict,predictable,322,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,1,['predict'],['predictable']
Safety,"/// A boolean indicator for each slot listed in the FunctionInfo as to; /// whether it has been used in the current statepoint. Since we try to; /// preserve stack slots across safepoints, there can be gaps in which; /// slots have been allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h:177,safe,safepoints,177,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h,1,['safe'],['safepoints']
Safety,"/// A combined index hook is called after all per-module indexes have been; /// combined (ThinLTO-specific). It can be used to implement -save-temps for; /// the combined index.; ///; /// If this function returns false, any further processing for ThinLTO tasks; /// is aborted.; ///; /// It is called regardless of whether the backend is in-process, although it; /// is not called from individual backend processes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:269,abort,aborted,269,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,1,['abort'],['aborted']
Safety,"/// A debug info location.; ///; /// This class is a wrapper around a tracking reference to an \a DILocation; /// pointer.; ///; /// To avoid extra includes, \a DebugLoc doubles the \a DILocation API with a; /// one based on relatively opaque \a MDNode pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h:136,avoid,avoid,136,interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugLoc.h,1,['avoid'],['avoid']
Safety,/// A decrement of a pointer-type value is unsafe as it may run the pointer; /// out of bounds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:43,unsafe,unsafe,43,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['unsafe'],['unsafe']
Safety,"/// A discriminated union of two or more pointer types, with the discriminator; /// in the low bit of the pointer.; ///; /// This implementation is extremely efficient in space due to leveraging the; /// low bits of the pointer, while exposing a natural and type-safe API.; ///; /// Common use patterns would be something like this:; /// PointerUnion<int*, float*> P;; /// P = (int*)0;; /// printf(""%d %d"", P.is<int*>(), P.is<float*>()); // prints ""1 0""; /// X = P.get<int*>(); // ok.; /// Y = P.get<float*>(); // runtime assertion failure.; /// Z = P.get<double*>(); // compile time failure.; /// P = (float*)0;; /// Y = P.get<float*>(); // ok.; /// X = P.get<int*>(); // runtime assertion failure.; /// PointerUnion<int*, int*> Q; // compile time failure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h:263,safe,safe,263,interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/PointerUnion.h,1,['safe'],['safe']
Safety,"/// A distance of a path for a given jump.; /// In order to incite the path to use blocks/jumps with large positive flow,; /// and avoid changing branch probability of outgoing edges drastically,; /// set the jump distance so as:; /// - to minimize the number of unlikely jumps used and subject to that,; /// - to minimize the number of Flow == 0 jumps used and subject to that,; /// - minimizes total multiplicative Flow increase for the remaining edges.; /// To capture this objective with integer distances, we round off fractional; /// parts to a multiple of 1 / BaseDistance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:131,avoid,avoid,131,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,1,['avoid'],['avoid']
Safety,"/// A downcast may loose specialization information. E. g.:; /// MutableMap<T, U> : Map; /// The downcast to MutableMap looses the information about the types of the; /// Map (due to the type parameters are not being forwarded to Map), and in; /// general there is no way to recover that information from the; /// declaration. In order to have to most information, lets find the most; /// derived type that has all the type parameters forwarded.; ///; /// Get the a subclass of \p From (which has a lower bound \p To) that do not; /// loose information about type parameters. \p To has to be a subclass of; /// \p From. From has to be specialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp:275,recover,recover,275,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/DynamicTypePropagation.cpp,1,['recover'],['recover']
Safety,"/// A dynamically typed AST node container.; ///; /// Stores an AST node in a type safe way. This allows writing code that; /// works with different kinds of AST nodes, despite the fact that they don't; /// have a common base class.; ///; /// Use \c create(Node) to create a \c DynTypedNode from an AST node,; /// and \c get<T>() to retrieve the node as type T if the types match.; ///; /// See \c ASTNodeKind for which node base types are currently supported;; /// You can create DynTypedNodes for all nodes in the inheritance hierarchy of; /// the supported base types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTTypeTraits.h:83,safe,safe,83,interpreter/llvm-project/clang/include/clang/AST/ASTTypeTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTTypeTraits.h,1,['safe'],['safe']
Safety,/// A form of SubstType intended specifically for instantiating the; /// type of a FunctionDecl. Its purpose is solely to force the; /// instantiation of default-argument expressions and to avoid; /// instantiating an exception-specification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp:190,avoid,avoid,190,interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplateInstantiate.cpp,1,['avoid'],['avoid']
Safety,"/// A function pass for tsan instrumentation.; ///; /// Instruments functions to detect race conditions reads. This function pass; /// inserts calls to runtime library functions. If the functions aren't declared; /// yet, the pass inserts the declarations. Otherwise the existing globals are",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/ThreadSanitizer.h:81,detect,detect,81,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/ThreadSanitizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/ThreadSanitizer.h,1,['detect'],['detect']
Safety,/// A function pointer that converts an opaque diagnostic; /// argument to a strings.; ///; /// This takes the modifiers and argument that was present in the diagnostic.; ///; /// The PrevArgs array indicates the previous arguments formatted for this; /// diagnostic. Implementations of this function can use this information to; /// avoid redundancy across arguments.; ///; /// This is a hack to avoid a layering violation between libbasic and libsema.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:334,avoid,avoid,334,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,3,"['avoid', 'redund']","['avoid', 'redundancy']"
Safety,"/// A hacky area where the inliner can retain history about inlining; /// decisions that mutated the call graph's SCC structure in order to avoid; /// infinite inlining. See the comments in the inliner's CG update logic.; ///; /// FIXME: Keeping this here seems like a big layering issue, we should look; /// for a better technique.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:140,avoid,avoid,140,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['avoid'],['avoid']
Safety,/// A handler for state updates occurring while an HTTPRequest is performed.; /// Can trigger the client to abort the request by returning an Error from any; /// of its methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h:108,abort,abort,108,interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,1,['abort'],['abort']
Safety,/// A helper class that allows the use of isa/cast/dyncast; /// to detect TagType objects of enums.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:67,detect,detect,67,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['detect'],['detect']
Safety,/// A helper class that allows the use of isa/cast/dyncast; /// to detect TagType objects of structs/unions/classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:67,detect,detect,67,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['detect'],['detect']
Safety,"/// A helper class that handles instrumentation of VarArg; /// functions on a particular platform.; ///; /// Implementations are expected to insert the instrumentation; /// necessary to propagate argument shadow through VarArg function; /// calls. Visit* methods are called during an InstVisitor pass over; /// the function, and should avoid creating new basic blocks. A new; /// instance of this class is created for each instrumented function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:336,avoid,avoid,336,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['avoid'],['avoid']
Safety,"/// A linked-list with a custom, local allocator.; ///; /// Expose a std::list-like interface that owns and uses a custom LLVM-style; /// allocator (e.g., BumpPtrAllocator), leveraging \a simple_ilist for the; /// implementation details.; ///; /// Because this list owns the allocator, calling \a splice() with a different; /// list isn't generally safe. As such, \a splice has been left out of the; /// interface entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h:349,safe,safe,349,interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/AllocatorList.h,1,['safe'],['safe']
Safety,"/// A map containing the hash of the lookup buffer. This allows us to avoid; /// allocating memory for parsing when we know nothing has changed. Used by; /// StartParsingRAII.; // We do not want to include ""clang/Basic/SourceLocation.h"" because it makes; // the use of this header at runtime significantly slower.; // We really need llvm::hash_code->clang::FileID mapping but we put opaque; // source location as unsigned to compute the FileID when needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/LookupHelper.h:70,avoid,avoid,70,interpreter/cling/include/cling/Interpreter/LookupHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/LookupHelper.h,1,['avoid'],['avoid']
Safety,/// A mapping from string table offset to the index; /// of the Table. It is used to avoid putting; /// duplicated strings in the table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h:85,avoid,avoid,85,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.h,1,['avoid'],['avoid']
Safety,"/// A mock class satisfying the interface expected by ReleaseModeModelRunner for; /// its `TGen` parameter. Useful to avoid conditional compilation complexity, as; /// a compile-time replacement for a real AOT-ed model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:118,avoid,avoid,118,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,1,['avoid'],['avoid']
Safety,"/// A module pass for msan instrumentation.; ///; /// Instruments functions to detect unitialized reads. This function pass; /// inserts calls to runtime library functions. If the functions aren't declared; /// yet, the pass inserts the declarations. Otherwise the existing globals are; /// used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemorySanitizer.h:79,detect,detect,79,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemorySanitizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/MemorySanitizer.h,1,['detect'],['detect']
Safety,"/// A node of symbolizer markup.; ///; /// If only the Text field is set, this represents a region of text outside a; /// markup element. ANSI SGR control codes are also reported this way; if; /// detected, then the control code will be the entirety of the Text field, and; /// any surrounding text will be reported as preceding and following nodes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Markup.h:197,detect,detected,197,interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Markup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/Symbolize/Markup.h,1,['detect'],['detected']
Safety,/// A processor register file.; ///; /// This class describes a processor register file. Register file information is; /// currently consumed by external tools like llvm-mca to predict dispatch; /// stalls due to register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h:177,predict,predict,177,interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenSchedule.h,1,['predict'],['predict']
Safety,"/// A rewriter to build the SCEVs for each of the VF lanes in the expected; /// vectorized loop, which can then be compared to detect their uniformity. This; /// is done by replacing the AddRec SCEVs of the original scalar loop (TheLoop); /// with new AddRecs where the step is multiplied by StepMultiplier and Offset *; /// Step is added. Also checks if all sub-expressions are analyzable w.r.t.; /// uniformity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:127,detect,detect,127,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['detect'],['detect']
Safety,"/// A scoped hash table of the current values of previously encountered; /// memory locations.; ///; /// This allows us to get efficient access to dominating loads or stores when; /// we have a fully redundant load. In addition to the most recent load, we; /// keep track of a generation count of the read, which is compared against; /// the current generation count. The current generation count is incremented; /// after every possibly writing memory operation, which ensures that we only; /// CSE loads with other loads that have no intervening store. Ordering; /// events (such as fences or atomic instructions) increment the generation; /// count as well; essentially, we model these as writes to all possible; /// locations. Note that atomic and/or volatile loads and stores can be; /// present the table; it is the responsibility of the consumer to inspect; /// the atomicity/volatility if needed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp:200,redund,redundant,200,interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/EarlyCSE.cpp,1,['redund'],['redundant']
Safety,"/// A sequence of code fragments, references to parameters and code-generation; /// operations that together can be evaluated to (a fragment of) source code or; /// a diagnostic message, given a match result.; ///; /// We use a `shared_ptr` to allow for easy and cheap copying of stencils.; /// Since `StencilInterface` is an immutable interface, the sharing doesn't; /// impose any risks. Otherwise, we would have to add a virtual `copy` method to; /// the API and implement it for all derived classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h:383,risk,risks,383,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/Stencil.h,1,['risk'],['risks']
Safety,"/// A set of CapabilityExpr objects, which are compiled from thread safety; /// attributes on a function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:68,safe,safety,68,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,1,['safe'],['safety']
Safety,"/// A set of deallocations that should be performed when the; /// ASTContext is destroyed.; // FIXME: We really should have a better mechanism in the ASTContext to; // manage running destructors for types which do variable sized allocation; // within the AST. In some places we thread the AST bump pointer allocator; // into the datastructures which avoids this mess during deallocation but is; // wasteful of memory, and here we require a lot of error prone book keeping; // in order to track and run destructors while we're tearing things down.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:350,avoid,avoids,350,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['avoid'],['avoids']
Safety,"/// A set of selectors, which is used to avoid introducing multiple; /// completions with the same selector into the result set.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:41,avoid,avoid,41,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,1,['avoid'],['avoid']
Safety,"/// A set of symbols to look up, each associated with a SymbolLookupFlags; /// value.; ///; /// This class is backed by a vector and optimized for fast insertion,; /// deletion and iteration. It does not guarantee a stable order between; /// operations, and will not automatically detect duplicate elements (they; /// can be manually checked by calling the validate method).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:281,detect,detect,281,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['detect'],['detect']
Safety,"/// A simple and fast domtree-based CSE pass.; ///; /// This pass does a simple depth-first walk over the dominator tree,; /// eliminating trivially redundant instructions and using instsimplify to; /// canonicalize things as it goes. It is intended to be fast and catch obvious; /// cases so that instcombine and other passes are more effective. It is; /// expected that a later pass of GVN will catch the interesting/hard cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h:149,redund,redundant,149,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/EarlyCSE.h,3,['redund'],['redundant']
Safety,/// A simple binary serialization of an offloading file. We use this format to; /// embed the offloading image into the host executable so it can be extracted; /// and used by the linker.; ///; /// Many of these could be stored in the same section by the time the linker; /// sees it so we mark this information with a header. The version is used to; /// detect ABI stability and the size is used to find other offloading entries; /// that may exist in the same section. All offsets are given as absolute byte; /// offsets from the beginning of the file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/OffloadBinary.h:355,detect,detect,355,interpreter/llvm-project/llvm/include/llvm/Object/OffloadBinary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/OffloadBinary.h,1,['detect'],['detect']
Safety,/// A state machine that detects the \#ifndef-wrapping a file; /// idiom for the multiple-include optimization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorLexer.h:25,detect,detects,25,interpreter/llvm-project/clang/include/clang/Lex/PreprocessorLexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessorLexer.h,1,['detect'],['detects']
Safety,/// A templated base class for \c SmallPtrSet which provides the; /// typesafe interface that is common across all small sizes.; ///; /// This is particularly useful for passing around between interface boundaries; /// to avoid encoding a particular small size in the interface boundary.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h:222,avoid,avoid,222,interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallPtrSet.h,1,['avoid'],['avoid']
Safety,/// A thin wrapper to store two values that we matched as div-rem pair.; /// We want this extra indirection to avoid dealing with RAUW'ing the map keys.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:111,avoid,avoid,111,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,1,['avoid'],['avoid']
Safety,"/// A thread-safe stack of N indexes (0 to size - 1).; /// RSlotStack can be used to safely assign a ""processing slot"" number to; /// each thread in multi-thread applications.; /// In release builds, pop and push operations are unchecked, potentially; /// resulting in undefined behavior if more slot numbers than available are; /// requested.; /// An important design assumption is that a slot will almost always be available; /// when a thread asks for it, and if it is not available it will be very soon,; /// therefore a spinlock is used for synchronization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/RSlotStack.hxx:13,safe,safe,13,core/imt/inc/ROOT/RSlotStack.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/inc/ROOT/RSlotStack.hxx,2,['safe'],"['safe', 'safely']"
Safety,/// A thread-safe version of SimpleCompiler.; ///; /// This class creates a new TargetMachine and SimpleCompiler instance for each; /// compile.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/CompileUtils.h:13,safe,safe,13,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/CompileUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/CompileUtils.h,1,['safe'],['safe']
Safety,/// A thread-safe version of \c RefCountedBase.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h:13,safe,safe,13,interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntrusiveRefCntPtr.h,1,['safe'],['safe']
Safety,"/// A type-erased variant of the above invalidate method with the same core; /// API other than passing an analysis ID rather than an analysis type; /// parameter.; ///; /// This is sadly less efficient than the above routine, which leverages; /// the type parameter to avoid the type erasure overhead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:270,avoid,avoid,270,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['avoid'],['avoid']
Safety,/// A value of ``false`` means that any of the affected ranges were not; /// formatted due to a non-recoverable syntax error.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:100,recover,recoverable,100,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['recover'],['recoverable']
Safety,/// A vector select of 2 constant vectors can be simplified to math/logic to; /// avoid a variable select instruction and possibly avoid constant loads.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:82,avoid,avoid,82,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,2,['avoid'],['avoid']
Safety,"/// A very simple error handler that is usually replaced by the TROOT default error handler.; /// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; /// can get scrambled; /// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TError.cxx:235,abort,abort,235,core/foundation/src/TError.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/foundation/src/TError.cxx,1,['abort'],['abort']
Safety,/// A virtual file system optimized for the dependency discovery.; ///; /// It is primarily designed to work with source files whose contents was; /// preprocessed to remove any tokens that are unlikely to affect the dependency; /// computation.; ///; /// This is not a thread safe VFS. A single instance is meant to be used only in; /// one thread. Multiple instances are allowed to service multiple threads; /// running in parallel.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:277,safe,safe,277,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['safe'],['safe']
Safety,/// A worklist of PHIs to speculate prior to promoting allocas.; ///; /// All of these PHIs have been checked for the safety of speculation and by; /// being speculated will allow promoting allocas currently in the promotable; /// queue.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:118,safe,safety,118,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['safe'],['safety']
Safety,/// A wrapper around AnalysisUsage for the purpose of uniqueing. The wrapper; /// is used to avoid needing to make AnalysisUsage itself a folding set node.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h:93,avoid,avoid,93,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManagers.h,1,['avoid'],['avoid']
Safety,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:269,avoid,avoid,269,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['avoid'],['avoid']
Safety,"/// A wrapper around a string literal that serves as a proxy for constructing; /// global tables of StringRefs with the length computed at compile time.; /// In order to avoid the invocation of a global constructor, StringLiteral; /// should *only* be used in a constexpr context, as such:; ///; /// constexpr StringLiteral S(""test"");; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:170,avoid,avoid,170,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,1,['avoid'],['avoid']
Safety,/// A wrapper around three concatenated vectors (chains) of nodes; it is used; /// to avoid extra instantiation of the vectors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,1,['avoid'],['avoid']
Safety,"/// A wrapper class for fallible iterators.; ///; /// The fallible_iterator template wraps an underlying iterator-like class; /// whose increment and decrement operations are replaced with fallible versions; /// like:; ///; /// @code{.cpp}; /// Error inc();; /// Error dec();; /// @endcode; ///; /// It produces an interface that is (mostly) compatible with a traditional; /// c++ iterator, including ++ and -- operators that do not fail.; ///; /// Instances of the wrapper are constructed with an instance of the; /// underlying iterator and (for non-end iterators) a reference to an Error; /// instance. If the underlying increment/decrement operations fail, the Error; /// is returned via this reference, and the resulting iterator value set to an; /// end-of-range sentinel value. This enables the following loop idiom:; ///; /// @code{.cpp}; /// class Archive { // E.g. Potentially malformed on-disk archive; /// public:; /// fallible_iterator<ArchiveChildItr> children_begin(Error &Err);; /// fallible_iterator<ArchiveChildItr> children_end();; /// iterator_range<fallible_iterator<ArchiveChildItr>>; /// children(Error &Err) {; /// return make_range(children_begin(Err), children_end());; /// //...; /// };; ///; /// void walk(Archive &A) {; /// Error Err = Error::success();; /// for (auto &C : A.children(Err)) {; /// // Loop body only entered when increment succeeds.; /// }; /// if (Err) {; /// // handle error.; /// }; /// }; /// @endcode; ///; /// The wrapper marks the referenced Error as unchecked after each increment; /// and/or decrement operation, and clears the unchecked flag when a non-end; /// value is compared against end (since, by the increment invariant, not being; /// an end value proves that there was no error, and is equivalent to checking; /// that the Error is success). This allows early exits from the loop body; /// without requiring redundant error checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:1872,redund,redundant,1872,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,1,['redund'],['redundant']
Safety,"/// API to communicate dependencies between analyses during invalidation.; ///; /// When an analysis result embeds handles to other analysis results, it; /// needs to be invalidated both when its own information isn't preserved and; /// when any of its embedded analysis results end up invalidated. We pass an; /// \c Invalidator object as an argument to \c invalidate() in order to let; /// the analysis results themselves define the dependency graph on the fly.; /// This lets us avoid building an explicit representation of the; /// dependencies between analysis results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:482,avoid,avoid,482,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['avoid'],['avoid']
Safety,"/// Abstract base class of cleanup handlers.; ///; /// Derived classes override method recoverResources, which makes actual work on; /// resource recovery.; ///; /// Cleanup handlers are stored in a double list, which is owned and managed by; /// a crash recovery context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:87,recover,recoverResources,87,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,3,['recover'],"['recoverResources', 'recovery']"
Safety,"/// AbstractLatticeFunction - This class is implemented by the dataflow instance; /// to specify what the lattice values are and how they handle merges etc. This; /// gives the client the power to compute lattice values from instructions,; /// constants, etc. The current requirement is that lattice values must be; /// copyable. At the moment, nothing tries to avoid copying. Additionally,; /// lattice keys must be able to be used as keys of a mapping data structure.; /// Internally, the generic solver currently uses a DenseMap to map lattice keys; /// to lattice values. If the lattice key is a non-standard type, a; /// specialization of DenseMapInfo must be provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:362,avoid,avoid,362,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,1,['avoid'],['avoid']
Safety,"/// Access - Used by C++ decls for the access specifier.; // NOTE: VC++ treats enums as signed, avoid using the AccessSpecifier enum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:96,avoid,avoid,96,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['avoid'],['avoid']
Safety,"/// Access a particular processing slot.; ///; /// This method is thread-safe as long as concurrent calls request different slots (i.e. pass a different; /// argument) and no thread accesses slot `i` via the arrow operator, so mixing usage of GetAtSlot; /// with usage of the arrow operator can be dangerous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:73,safe,safe,73,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['safe'],['safe']
Safety,/// Accessor to the directive tokens that's atomic to avoid data races.; /// \p CachedFileContents has ownership of the pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h:54,avoid,avoid,54,interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/DependencyScanning/DependencyScanningFilesystem.h,1,['avoid'],['avoid']
Safety,"/// Account for a location \p mloc being clobbered. Examine the variable; /// locations that will be terminated: and try to recover them by using; /// another location. Optionally, given \p MakeUndef, emit a DBG_VALUE to; /// explicitly terminate a location if it can't be recovered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:124,recover,recover,124,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,2,['recover'],"['recover', 'recovered']"
Safety,/// Adaptor that maps from a SCC to its functions.; ///; /// Designed to allow composition of a FunctionPass(Manager) and; /// a CGSCCPassManager. Note that if this pass is constructed with a pointer; /// to a \c CGSCCAnalysisManager it will run the; /// \c FunctionAnalysisManagerCGSCCProxy analysis prior to running the function; /// pass over the SCC to enable a \c FunctionAnalysisManager to be used; /// within this run safely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:425,safe,safely,425,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['safe'],['safely']
Safety,"/// Adaptor that maps from a function to its loops.; ///; /// Designed to allow composition of a LoopPass(Manager) and a; /// FunctionPassManager. Note that if this pass is constructed with a \c; /// FunctionAnalysisManager it will run the \c LoopAnalysisManagerFunctionProxy; /// analysis prior to running the loop passes over the function to enable a \c; /// LoopAnalysisManager to be used within this run safely.; ///; /// The adaptor comes with two modes: the loop mode and the loop-nest mode, and; /// the worklist updater lived inside will be in the same mode as the adaptor; /// (refer to the documentation of \c LPMUpdater for more detailed explanation).; /// Specifically, in loop mode, all loops in the function will be pushed into; /// the worklist and processed by \p Pass, while only top-level loops are; /// processed in loop-nest mode. Please refer to the various specializations of; /// \fn createLoopFunctionToLoopPassAdaptor to see when loop mode and loop-nest; /// mode are used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h:408,safe,safely,408,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/LoopPassManager.h,1,['safe'],['safely']
Safety,/// Add a function to be called when an abort/kill signal is delivered to the; /// process. The handler can have a cookie passed to it to identify what; /// instance of the handler it is.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Signals.h:40,abort,abort,40,interpreter/llvm-project/llvm/include/llvm/Support/Signals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Signals.h,1,['abort'],['abort']
Safety,"/// Add a node bypassing the cost allocator.; /// @param Costs Cost vector ptr for the new node (must be convertible to; /// VectorPtr).; /// @return Node iterator for the added node.; ///; /// This method allows for fast addition of a node whose costs don't need; /// to be passed through the cost allocator. The most common use case for; /// this is when duplicating costs from an existing node (when using a; /// pooling allocator). These have already been uniqued, so we can avoid; /// re-constructing and re-uniquing them by attaching them directly to the; /// new node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h:479,avoid,avoid,479,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,1,['avoid'],['avoid']
Safety,/// Add a node to the Registry: this is the interface between the plugin and; /// the executable.; ///; /// This function is exported by the executable and called by the plugin to; /// add a node to the executable's registry. Therefore it's not defined here; /// to avoid it being instantiated in the plugin and is instead defined in; /// the executable (see LLVM_INSTANTIATE_REGISTRY below).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Registry.h:266,avoid,avoid,266,interpreter/llvm-project/llvm/include/llvm/Support/Registry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Registry.h,1,['avoid'],['avoid']
Safety,"/// Add a pass to the queue of passes to run. This passes ownership of; /// the Pass to the PassManager. When the PassManager is destroyed, the pass; /// will be destroyed as well, so there is no need to delete the pass. This; /// may even destroy the pass right away if it is found to be redundant. This; /// implies that all passes MUST be allocated with 'new'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h:289,redund,redundant,289,interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/LegacyPassManager.h,1,['redund'],['redundant']
Safety,/// Add a small namespace to avoid name clashes with the classes used in; /// the streaming interface. We want these to be short for better; /// write/readability.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:29,avoid,avoid,29,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,1,['avoid'],['avoid']
Safety,"/// Add a stack map intrinsic call's live variable operands to a stackmap; /// or patchpoint target node's operand list.; ///; /// Constants are converted to TargetConstants purely as an optimization to; /// avoid constant materialization and register allocation.; ///; /// FrameIndex operands are converted to TargetFrameIndex so that ISEL does not; /// generate addess computation nodes, and so FinalizeISel can convert the; /// TargetFrameIndex into a DirectMemRefOp StackMap location. This avoids; /// address materialization and register allocation, but may also be required; /// for correctness. If a StackMap (or PatchPoint) intrinsic directly uses an; /// alloca in the entry block, then the runtime may assume that the alloca's; /// StackMap location can be read immediately after compilation and that the; /// location is valid at any point during execution (this is similar to the; /// assumption made by the llvm.gcroot intrinsic). If the alloca's location were; /// only available in a register, then the runtime would need to trap when; /// execution reaches the StackMap in order to read the alloca's location.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:208,avoid,avoid,208,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,2,['avoid'],"['avoid', 'avoids']"
Safety,/// Add a string attribute data and value.; ///; /// We always emit a reference to the string pool instead of immediate; /// strings so that DIEs have more predictable sizes. In the case of split; /// dwarf we emit an index into another table which gets us the static offset; /// into the string table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h:156,predict,predictable,156,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfUnit.h,1,['predict'],['predictable']
Safety,"/// Add an edge bypassing the cost allocator.; /// @param N1Id First node.; /// @param N2Id Second node.; /// @param Costs Cost matrix for new edge.; /// @return Edge iterator for the added edge.; ///; /// This method allows for fast addition of an edge whose costs don't need; /// to be passed through the cost allocator. The most common use case for; /// this is when duplicating costs from an existing edge (when using a; /// pooling allocator). These have already been uniqued, so we can avoid; /// re-constructing and re-uniquing them by attaching them directly to the; /// new edge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h:492,avoid,avoid,492,interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/PBQP/Graph.h,1,['avoid'],['avoid']
Safety,"/// Add an edge to the distribution.; ///; /// Adds an edge to Succ to Dist. If \c LoopHead.isValid(), then whether the; /// edge is local/exit/backedge is in the context of LoopHead. Otherwise,; /// every edge should be a local edge (since all the loops are packaged up).; ///; /// \return \c true unless aborted due to an irreducible backedge.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:306,abort,aborted,306,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,1,['abort'],['aborted']
Safety,"/// Add called function \p F with samples \p S.; /// Optionally scale sample count \p S by \p Weight.; ///; /// Sample counts accumulate using saturating arithmetic, to avoid wrapping; /// around unsigned integers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:169,avoid,avoid,169,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['avoid'],['avoid']
Safety,"/// Add metadata to simd-ize a loop. If IfCond is not nullptr, the loop; /// is cloned. The metadata which prevents vectorization is added to; /// to the cloned loop. The cloned loop is executed when ifCond is evaluated; /// to false.; ///; /// \param Loop The loop to simd-ize.; /// \param AlignedVars The map which containts pairs of the pointer; /// and its corresponding alignment.; /// \param IfCond The value which corresponds to the if clause; /// condition.; /// \param Order The enum to map order clause.; /// \param Simdlen The Simdlen length to apply to the simd loop.; /// \param Safelen The Safelen length to apply to the simd loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:592,Safe,Safelen,592,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,2,['Safe'],['Safelen']
Safety,"/// AddFastMathRuntimeIfAvailable - If a runtime library exists that sets; /// global flags for unsafe floating point math, add it and return true.; ///; /// This checks for presence of the -Ofast, -ffast-math or -funsafe-math flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:96,unsafe,unsafe,96,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['unsafe'],['unsafe']
Safety,/// Address of block to recover at. Null for a finally handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:24,recover,recover,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['recover'],['recover']
Safety,"/// Adds attributes to \p F according to our \p CodeGenOpts and \p LangOpts, as; /// though we had emitted it ourselves. We remove any attributes on F that; /// conflict with the attributes we add here.; ///; /// This is useful for adding attrs to bitcode modules that you want to link; /// with but don't control, such as CUDA's libdevice. When linking with such; /// a bitcode library, you might want to set e.g. its functions'; /// ""unsafe-fp-math"" attribute to match the attr of the functions you're; /// codegen'ing. Otherwise, LLVM will interpret the bitcode module's lack of; /// unsafe-fp-math attrs as tantamount to unsafe-fp-math=false, and then LLVM; /// will propagate unsafe-fp-math=false up to every transitive caller of a; /// function in the bitcode library!; ///; /// With the exception of fast-math attrs, this will only make the attributes; /// on the function more conservative. But it's unsafe to call this on a; /// function which relies on particular fast-math attributes for correctness.; /// It's up to you to ensure that this is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h:436,unsafe,unsafe-fp-math,436,interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.h,6,"['safe', 'unsafe']","['safe', 'unsafe', 'unsafe-fp-math']"
Safety,"/// Adds synthetic edges from top-level statements to their subexpressions.; ///; /// This avoids a ""swoosh"" effect, where an edge from a top-level statement A; /// points to a sub-expression B.1 that's not at the start of B. In these cases,; /// we'd like to see an edge from A to B, then another one from B to B.1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:91,avoid,avoids,91,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,1,['avoid'],['avoids']
Safety,"/// AdvanceCycle - This callback is invoked whenever the next top-down; /// instruction to be scheduled cannot issue in the current cycle, either; /// because of latency or resource conflicts. This should increment the; /// internal state of the hazard recognizer so that previously ""Hazard""; /// instructions will now not be hazards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:246,hazard,hazard,246,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,3,"['Hazard', 'hazard']","['Hazard', 'hazard', 'hazards']"
Safety,"/// After backtracking, the hazard checker needs to be restored to a state; /// corresponding the current cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:28,hazard,hazard,28,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['hazard'],['hazard']
Safety,"/// All specializations that that have already been loaded, ie avoiding; /// deserialization of lazily registered specializations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h:63,avoid,avoiding,63,interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,3,['avoid'],['avoiding']
Safety,"/// All the delegating constructors seen so far in the file, used for; /// cycle detection at the end of the TU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:81,detect,detection,81,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['detect'],['detection']
Safety,"/// All the function redeclarations seen during a class definition that had; /// their exception spec checks delayed, plus the prior declaration they; /// should be checked against. Except during error recovery, the new decl; /// should always be a friend declaration, as that's the only valid way to; /// redeclare a special member before its class is complete.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:202,recover,recovery,202,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['recover'],['recovery']
Safety,/// Allocate and return a hazard recognizer to use for by non-scheduling; /// passes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:26,hazard,hazard,26,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['hazard'],['hazard']
Safety,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions after register allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:26,hazard,hazard,26,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,['hazard'],['hazard']
Safety,/// Allocate and return a hazard recognizer to use for this target when; /// scheduling the machine instructions before register allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:26,hazard,hazard,26,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,['hazard'],['hazard']
Safety,"/// Allocate space for all static allocas in \p StaticAllocas,; /// replace allocas with pointers into the unsafe stack.; ///; /// \returns A pointer to the top of the unsafe stack after all unsafe static; /// allocas are allocated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:107,unsafe,unsafe,107,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,3,['unsafe'],['unsafe']
Safety,/// Allocator object used for creating machine code objects.; ///; /// We use a bump pointer allocator to avoid the need to track all allocated; /// objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h:106,avoid,avoid,106,interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCContext.h,1,['avoid'],['avoid']
Safety,"/// Allow DirectoryEntryRef to degrade into 'const DirectoryEntry*' to; /// facilitate incremental adoption.; ///; /// The goal is to avoid code churn due to dances like the following:; /// \code; /// // Old code.; /// lvalue = rvalue;; ///; /// // Temporary code from an incremental patch.; /// lvalue = &rvalue.getDirectoryEntry();; ///; /// // Final code.; /// lvalue = rvalue;; /// \endcode; ///; /// FIXME: Once DirectoryEntryRef is ""everywhere"" and DirectoryEntry::getName; /// has been deleted, delete this implicit conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DirectoryEntry.h:134,avoid,avoid,134,interpreter/llvm-project/clang/include/clang/Basic/DirectoryEntry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DirectoryEntry.h,1,['avoid'],['avoid']
Safety,"/// Allow FileEntryRef to degrade into 'const FileEntry*' to facilitate; /// incremental adoption.; ///; /// The goal is to avoid code churn due to dances like the following:; /// \code; /// // Old code.; /// lvalue = rvalue;; ///; /// // Temporary code from an incremental patch.; /// lvalue = &rvalue.getFileEntry();; ///; /// // Final code.; /// lvalue = rvalue;; /// \endcode; ///; /// FIXME: Once FileEntryRef is ""everywhere"" and FileEntry::LastRef and; /// FileEntry::getName have been deleted, delete this implicit conversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileEntry.h:124,avoid,avoid,124,interpreter/llvm-project/clang/include/clang/Basic/FileEntry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileEntry.h,1,['avoid'],['avoid']
Safety,"/// Allows for iterating over the elements of a proxied collection. RCollectionIterableOnce avoids an additional; /// iterator copy (see `TVirtualCollectionProxy::GetFunctionCopyIterator`) and thus can only be iterated once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx:92,avoid,avoids,92,tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RField/RFieldProxiedCollection.hxx,1,['avoid'],['avoids']
Safety,"/// An ELF note.; ///; /// Wraps a note header, providing methods for accessing the name and; /// descriptor safely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h:109,safe,safely,109,interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Object/ELFTypes.h,1,['safe'],['safely']
Safety,"/// An Instruction Converter which ignores the given instruction.; /// For example, PHI instructions can be safely ignored since only the registers; /// need to change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp:108,safe,safely,108,interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86DomainReassignment.cpp,1,['safe'],['safely']
Safety,/// An abstract base class for all helper classes used in building the; // copy/move operators. These classes serve as factory functions and help us; // avoid using the same Expr* in the AST twice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:153,avoid,avoid,153,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['avoid'],['avoid']
Safety,/// An analysis pass whose purpose is to identify each of the backedges in; /// the function which require a safepoint poll to be inserted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:109,safe,safepoint,109,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,/// An increment of a pointer-type value is unsafe as it may run the pointer; /// out of bounds.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:44,unsafe,unsafe,44,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['unsafe'],['unsafe']
Safety,/// An instrumentation pass implementing detection of addressability bugs; /// using tagged pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:41,detect,detection,41,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,1,['detect'],['detection']
Safety,"/// An intrusive list with ownership and callbacks specified/controlled by; /// ilist_traits, only with API safe for polymorphic types.; ///; /// The \p Options parameters are the same as those for \a simple_ilist. See; /// there for a description of what's available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:108,safe,safe,108,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,1,['safe'],['safe']
Safety,"/// An opaque object representing a hash code.; ///; /// This object represents the result of hashing some entity. It is intended to; /// be used to implement hashtables or other hashing-based data structures.; /// While it wraps and exposes a numeric value, this value should not be; /// trusted to be stable or predictable across processes or executions.; ///; /// In order to obtain the hash_code for an object 'x':; /// \code; /// using llvm::hash_value;; /// llvm::hash_code code = hash_value(x);; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:313,predict,predictable,313,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['predict'],['predictable']
Safety,"/// An optimization pass over PathPieces that removes redundant diagnostics; /// generated by both ConditionBRVisitor and TrackConstraintBRVisitor. Both; /// BugReporterVisitors use different methods to generate diagnostics, with; /// one capable of emitting diagnostics in some cases but not in others. This; /// can lead to redundant diagnostic pieces at the same point in a path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp:54,redund,redundant,54,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/BugReporter.cpp,2,['redund'],['redundant']
Safety,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:871,detect,detect,871,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['detect'],['detect']
Safety,"/// An unknown context, in which we are recovering from a parsing; /// error and don't know which completions we should give.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h:40,recover,recovering,40,interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h,1,['recover'],['recovering']
Safety,"/// An unsafe function to reset the buffer for which this RVec is acting as a view.; ///; /// \note This is a low-level method that _must_ be called on RVecs that are already non-owning:; /// - it does not put the RVec in ""non-owning mode"" (fCapacity == -1); /// - it does not free any owned buffer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:7,unsafe,unsafe,7,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['unsafe'],['unsafe']
Safety,"/// Analyze a basic block for its contribution to the inline cost.; ///; /// This method walks the analyzer over every instruction in the given basic; /// block and accounts for their cost during inlining at this callsite. It; /// aborts early if the threshold has been exceeded or an impossible to inline; /// construct has been detected. It returns false if inlining is no longer; /// viable, and true if inlining remains viable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp:231,abort,aborts,231,interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InlineCost.cpp,2,"['abort', 'detect']","['aborts', 'detected']"
Safety,/// Appends a detect mismatch command to the linker options.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:14,detect,detect,14,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['detect'],['detect']
Safety,"/// Apply the resolver to the name of the record as well as to the; /// initializers of all fields of the record except SkipVal.; ///; /// The resolver should not resolve any of the fields itself, to avoid; /// recursion / infinite loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h:200,avoid,avoid,200,interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h,1,['avoid'],['avoid']
Safety,/// ArgCache - This is a linked list of MacroArgs objects that the; /// Preprocessor owns which we use to avoid thrashing malloc/free.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MacroArgs.h:106,avoid,avoid,106,interpreter/llvm-project/clang/include/clang/Lex/MacroArgs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MacroArgs.h,1,['avoid'],['avoid']
Safety,/// ArgSet is used to describe arguments relevant for taint detection or; /// taint application. A discrete set of argument indexes and a variadic; /// argument list signified by a starting index are supported.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp:60,detect,detection,60,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GenericTaintChecker.cpp,1,['detect'],['detection']
Safety,/// Array subscript expressions on raw pointers as if they're arrays. Unsafe as; /// it doesn't have any bounds checks for the array.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:70,Unsafe,Unsafe,70,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['Unsafe'],['Unsafe']
Safety,"/// ArrayRef - Represent a constant reference to an array (0 or more elements; /// consecutively in memory), i.e. a start pointer and a length. It allows; /// various APIs to take consecutive elements easily and conveniently.; ///; /// This class does not own the underlying data, it is expected to be used in; /// situations where the data resides in some other buffer, whose lifetime; /// extends past that of the ArrayRef. For this reason, it is not in general; /// safe to store an ArrayRef.; ///; /// This is intended to be trivially copyable, so it should be passed by; /// value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:469,safe,safe,469,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,1,['safe'],['safe']
Safety,"/// As part of recovering from missing or changed content, produce a; /// fake content cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:15,recover,recovering,15,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['recover'],['recovering']
Safety,"/// As part of recovering from missing or changed content, produce a; /// fake, non-empty buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp:15,recover,recovering,15,interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/SourceManager.cpp,1,['recover'],['recovering']
Safety,"/// Assign serial numbers to values from left function, and values from; /// right function.; /// Explanation:; /// Being comparing functions we need to compare values we meet at left and; /// right sides.; /// Its easy to sort things out for external values. It just should be; /// the same value at left and right.; /// But for local values (those were introduced inside function body); /// we have to ensure they were introduced at exactly the same place,; /// and plays the same role.; /// Let's assign serial number to each value when we meet it first time.; /// Values that were met at same place will be with same serial numbers.; /// In this case it would be good to explain few points about values assigned; /// to BBs and other ways of implementation (see below).; ///; /// 1. Safety of BB reordering.; /// It's safe to change the order of BasicBlocks in function.; /// Relationship with other functions and serial numbering will not be; /// changed in this case.; /// As follows from FunctionComparator::compare(), we do CFG walk: we start; /// from the entry, and then take each terminator. So it doesn't matter how in; /// fact BBs are ordered in function. And since cmpValues are called during; /// this walk, the numbering depends only on how BBs located inside the CFG.; /// So the answer is - yes. We will get the same numbering.; ///; /// 2. Impossibility to use dominance properties of values.; /// If we compare two instruction operands: first is usage of local; /// variable AL from function FL, and second is usage of local variable AR; /// from FR, we could compare their origins and check whether they are; /// defined at the same place.; /// But, we are still not able to compare operands of PHI nodes, since those; /// could be operands from further BBs we didn't scan yet.; /// So it's impossible to use dominance properties in general.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h:787,Safe,Safety,787,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/FunctionComparator.h,2,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"/// At this point in the translation unit, does it appear that can we; /// rely on the vtable being defined elsewhere in the program?; ///; /// The response is really only definitive when called at the end of; /// the translation unit.; ///; /// The only semantic restriction here is that the object file should; /// not contain a vtable definition when that vtable is defined; /// strongly elsewhere. Otherwise, we'd just like to avoid emitting; /// vtables when unnecessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp:431,avoid,avoid,431,interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGVTables.cpp,1,['avoid'],['avoid']
Safety,"/// Attempt to build or re-use a precompiled preamble when (re-)parsing; /// the source file.; ///; /// This routine will compute the preamble of the main source file. If a; /// non-trivial preamble is found, it will precompile that preamble into a; /// precompiled header so that the precompiled preamble can be used to reduce; /// reparsing time. If a precompiled preamble has already been constructed,; /// this routine will determine if it is still valid and, if so, avoid; /// rebuilding the precompiled preamble.; ///; /// \param AllowRebuild When true (the default), this routine is; /// allowed to rebuild the precompiled preamble if it is found to be; /// out-of-date.; ///; /// \param MaxLines When non-zero, the maximum number of lines that; /// can occur within the preamble.; ///; /// \returns If the precompiled preamble can be used, returns a newly-allocated; /// buffer that should be used in place of the main file when doing so.; /// Otherwise, returns a NULL pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp:471,avoid,avoid,471,interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/ASTUnit.cpp,1,['avoid'],['avoid']
Safety,"/// Attempt to extract the fields of \p LCV and bind them to the struct region; /// \p R.; ///; /// This path is used when it seems advantageous to ""force"" loading the values; /// within a LazyCompoundVal to bind memberwise to the struct region, rather; /// than using a Default binding at the base of the entire region. This is a; /// heuristic attempting to avoid building long chains of LazyCompoundVals.; ///; /// \returns The updated store bindings, or \c std::nullopt if binding; /// non-lazily would be too expensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp:360,avoid,avoid,360,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/RegionStore.cpp,1,['avoid'],['avoid']
Safety,"/// Attempt to merge an objc_release with a store, load, and objc_retain to form; /// an objc_storeStrong. An objc_storeStrong:; ///; /// objc_storeStrong(i8** %old_ptr, i8* new_value); ///; /// is equivalent to the following IR sequence:; ///; /// ; Load old value.; /// %old_value = load i8** %old_ptr (1); ///; /// ; Increment the new value and then release the old value. This must occur; /// ; in order in case old_value releases new_value in its destructor causing; /// ; us to potentially have a dangling ptr.; /// tail call i8* @objc_retain(i8* %new_value) (2); /// tail call void @objc_release(i8* %old_value) (3); ///; /// ; Store the new_value into old_ptr; /// store i8* %new_value, i8** %old_ptr (4); ///; /// The safety of this optimization is based around the following; /// considerations:; ///; /// 1. We are forming the store strong at the store. Thus to perform this; /// optimization it must be safe to move the retain, load, and release to; /// (4).; /// 2. We need to make sure that any re-orderings of (1), (2), (3), (4) are; /// safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp:727,safe,safety,727,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCContract.cpp,3,['safe'],"['safe', 'safety']"
Safety,"/// Attempt to recover from an ill-formed use of a non-dependent name in a; /// template, where the non-dependent name was declared after the template; /// was defined. This is common in code written for a compilers which do not; /// correctly implement two-stage name lookup.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:15,recover,recover,15,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recover']
Safety,"/// Attempt to recover from ill-formed use of a non-dependent operator in a; /// template, where the non-dependent operator was declared after the template; /// was defined.; ///; /// Returns true if a viable candidate was found and a diagnostic was issued.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:15,recover,recover,15,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,1,['recover'],['recover']
Safety,/// Attempts to auto-detect the host page size.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h:21,detect,detect,21,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h,1,['detect'],['detect']
Safety,/// Attempts to detect a user writing into a piece of memory that's impossible; /// to figure out the size of by just using types.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp:16,detect,detect,16,interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExprConstant.cpp,1,['detect'],['detect']
Safety,"/// Attempts to recover from a call where no functions were found.; ///; /// This function will do one of three things:; /// * Diagnose, recover, and return a recovery expression.; /// * Diagnose, fail to recover, and return ExprError().; /// * Do not diagnose, do not recover, and return ExprResult(). The caller is; /// expected to diagnose as appropriate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp:16,recover,recover,16,interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaOverload.cpp,5,['recover'],"['recover', 'recovery']"
Safety,/// Automatic detection based on the input.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:14,detect,detection,14,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['detect'],['detection']
Safety,"/// Avoid bin packing, i.e. multiple parameters/elements on multiple; /// lines, in this context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:4,Avoid,Avoid,4,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,1,['Avoid'],['Avoid']
Safety,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsPrinter is also used as a mixin for avoiding repeated; /// implementation of printer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:4,Avoid,Avoid,4,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,3,"['Avoid', 'avoid']","['Avoid', 'avoid', 'avoiding']"
Safety,"/// Avoid compiler warning ""has virtual functions but non-virtual destructor; /// [-Wnon-virtual-dtor]"" in derived classes.; ///; /// DOTGraphTraitsViewer is also used as a mixin for avoiding repeated; /// implementation of viewer passes, ie there should be no; /// runtime-polymorphisms/downcasting involving this class and hence no; /// virtual destructor needed. Making this dtor protected stops accidental; /// invocation when the derived class destructor should have been called.; /// Those derived classes sould be marked final to avoid the warning.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h:4,Avoid,Avoid,4,interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DOTGraphTraitsPass.h,3,"['Avoid', 'avoid']","['Avoid', 'avoid', 'avoiding']"
Safety,/// Avoid copying the full IRBuilder. Prefer using InsertPointGuard; /// or FastMathFlagGuard instead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h:4,Avoid,Avoid,4,interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IRBuilder.h,1,['Avoid'],['Avoid']
Safety,/// Avoid emitting this entry for pub sections.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h:4,Avoid,Avoid,4,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerUnit.h,1,['Avoid'],['Avoid']
Safety,/// Avoid re-allocating a vector every time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkParser.h:4,Avoid,Avoid,4,interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/BitstreamRemarkParser.h,1,['Avoid'],['Avoid']
Safety,/// Avoid using DW_OP_convert due to consumer incompatibilities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h:4,Avoid,Avoid,4,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/DwarfDebug.h,1,['Avoid'],['Avoid']
Safety,"/// AvoidConcat - If printing PrevTok immediately followed by Tok would cause; /// the two individual tokens to be lexed as a single token, return true; /// (which causes a space to be printed between them). This allows the output; /// of -E mode to be lexed to the same token stream as lexing the input; /// directly would.; ///; /// This code must conservatively return true if it doesn't want to be 100%; /// accurate. This will cause the output to include extra space characters,; /// but the resulting output won't have incorrect concatenations going on.; /// Examples include "".."", which we print with a space between, because we; /// don't want to track enough to tell ""x.."" from ""..."".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:4,Avoid,AvoidConcat,4,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,1,['Avoid'],['AvoidConcat']
Safety,/// Bail out if the expression does not contain an UDiv expression.; /// Uniform values which are not loop invariant require operations to strip; /// out the lowest bits. For now just look for UDivs and use it to avoid; /// re-writing UDIV-free expressions for other lanes to limit compile time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp:213,avoid,avoid,213,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationLegality.cpp,1,['avoid'],['avoid']
Safety,"/// Base class for tokens / ranges of tokens that can allow breaking; /// within the tokens - for example, to avoid whitespace beyond the column; /// limit, or to reflow text.; ///; /// Generally, a breakable token consists of logical lines, addressed by a line; /// index. For example, in a sequence of line comments, each line comment is its; /// own logical line; similarly, for a block comment, each line in the block; /// comment is on its own logical line.; ///; /// There are two methods to compute the layout of the token:; /// - getRangeLength measures the number of columns needed for a range of text; /// within a logical line, and; /// - getContentStartColumn returns the start column at which we want the; /// content of a logical line to start (potentially after introducing a line; /// break).; ///; /// The mechanism to adapt the layout of the breakable token is organised; /// around the concept of a \c Split, which is a whitespace range that signifies; /// a position of the content of a token where a reformatting might be done.; ///; /// Operating with splits is divided into two operations:; /// - getSplit, for finding a split starting at a position,; /// - insertBreak, for executing the split using a whitespace manager.; ///; /// There is a pair of operations that are used to compress a long whitespace; /// range with a single space if that will bring the line length under the; /// column limit:; /// - getLineLengthAfterCompression, for calculating the size in columns of the; /// line after a whitespace range has been compressed, and; /// - compressWhitespace, for executing the whitespace compression using a; /// whitespace manager; note that the compressed whitespace may be in the; /// middle of the original line and of the reformatted line.; ///; /// For tokens where the whitespace before each line needs to be also; /// reformatted, for example for tokens supporting reflow, there are analogous; /// operations that might be executed before the main line breaki",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h:110,avoid,avoid,110,interpreter/llvm-project/clang/lib/Format/BreakableToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/BreakableToken.h,1,['avoid'],['avoid']
Safety,"/// Base class of cleanup handler that controls recovery of resources of the; /// given type.; ///; /// \tparam Derived Class that uses this class as a base.; /// \tparam T Type of controlled resource.; ///; /// This class serves as a base for its template parameter as implied by; /// Curiously Recurring Template Pattern.; ///; /// This class factors out creation of a cleanup handler. The latter requires; /// knowledge of the current recovery context, which is provided by this class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:48,recover,recovery,48,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,2,['recover'],['recovery']
Safety,"/// Before the llvm-mca pipeline dispatches an instruction, it first checks; /// for any register or resource dependencies / hazards. If it doesn't find; /// any, this method will be invoked to determine if there are any custom; /// hazards that the instruction needs to wait for.; /// The return value of this method is the number of cycles that the; /// instruction needs to wait for.; /// It's safe to underestimate the number of cycles to wait for since these; /// checks will be invoked again before the intruction gets dispatched.; /// However, it's not safe (accurate) to overestimate the number of cycles; /// to wait for since the instruction will wait for AT LEAST that number of; /// cycles before attempting to be dispatched again.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h:125,hazard,hazards,125,interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/CustomBehaviour.h,4,"['hazard', 'safe']","['hazards', 'safe']"
Safety,"/// Bit used by CIndex to mark when a translation unit may be in an; /// inconsistent state, and is not safe to free.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:104,safe,safe,104,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['safe'],['safe']
Safety,"/// BitCodeAbbrev - This class represents an abbreviation record. An; /// abbreviation allows a complex record that has redundancy to be stored in a; /// specialized format instead of the fully-general, fully-vbr, format.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h:120,redund,redundancy,120,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h,1,['redund'],['redundancy']
Safety,/// Bits - Vector of all the data bits that make the node unique.; /// Use a SmallVector to avoid a heap allocation in the common case.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h:92,avoid,avoid,92,interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/FoldingSet.h,1,['avoid'],['avoid']
Safety,/// Break after the next comma (or all the commas in this context if; /// \c AvoidBinPacking is \c true).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:77,Avoid,AvoidBinPacking,77,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,1,['Avoid'],['AvoidBinPacking']
Safety,"/// Broken debug info can be ""recovered"" from by stripping the debug info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:30,recover,recovered,30,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['recover'],['recovered']
Safety,/// Build 'safelen' clause.; ///; /// \param Len Expression associated with this clause.; /// \param StartLoc Starting location of the clause.; /// \param EndLoc Ending location of the clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:11,safe,safelen,11,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,1,['safe'],['safelen']
Safety,"/// Build a new OpenMP 'safelen' clause.; ///; /// By default, performs semantic analysis to build the new OpenMP clause.; /// Subclasses may override this routine to provide different behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:24,safe,safelen,24,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['safe'],['safelen']
Safety,"/// Build a new nested-name-specifier for ""identifier::"", as described; /// by ActOnCXXNestedNameSpecifier.; ///; /// \param S Scope in which the nested-name-specifier occurs.; /// \param IdInfo Parser information about an identifier in the; /// nested-name-spec.; /// \param EnteringContext If true, enter the context specified by the; /// nested-name-specifier.; /// \param SS Optional nested name specifier preceding the identifier.; /// \param ScopeLookupResult Provides the result of name lookup within the; /// scope of the nested-name-specifier that was computed at template; /// definition time.; /// \param ErrorRecoveryLookup Specifies if the method is called to improve; /// error recovery and what kind of recovery is performed.; /// \param IsCorrectedToColon If not null, suggestion of replace '::' -> ':'; /// are allowed. The bool value pointed by this parameter is set to; /// 'true' if the identifier is treated as if it was followed by ':',; /// not '::'.; /// \param OnlyNamespace If true, only considers namespaces in lookup.; ///; /// This routine differs only slightly from ActOnCXXNestedNameSpecifier, in; /// that it contains an extra parameter \p ScopeLookupResult, which provides; /// the result of name lookup within the scope of the nested-name-specifier; /// that was computed at template definition time.; ///; /// If ErrorRecoveryLookup is true, then this call is used to improve error; /// recovery. This means that it should not emit diagnostics, it should; /// just return true on failure. It also means it should only return a valid; /// scope if it *knows* that the result is correct. It should not return in a; /// dependent context, for example. Nor will it extend \p SS with the scope; /// specifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:692,recover,recovery,692,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,3,['recover'],['recovery']
Safety,/// Build and return a new assume created from the provided knowledge; /// if the knowledge in the assume is fully redundant this will return nullptr,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h:115,redund,redundant,115,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/AssumeBundleBuilder.h,1,['redund'],['redundant']
Safety,"/// Builds BasicBlockState for each BB of the function.; /// It can traverse function for verification and provides all required; /// information.; ///; /// GC pointer may be in one of three states: relocated, unrelocated and; /// poisoned.; /// Relocated pointer may be used without any restrictions.; /// Unrelocated pointer cannot be dereferenced, passed as argument to any call; /// or returned. Unrelocated pointer may be safely compared against another; /// unrelocated pointer or against a pointer exclusively derived from null.; /// Poisoned pointers are produced when we somehow derive pointer from relocated; /// and unrelocated pointers (e.g. phi, select). This pointers may be safely; /// used in a very limited number of situations. Currently the only way to use; /// it is comparison against constant exclusively derived from null. All; /// limitations arise due to their undefined state: this pointers should be; /// treated as relocated and unrelocated simultaneously.; /// Rules of deriving:; /// R + U = P - that's where the poisoned pointers come from; /// P + X = P; /// U + U = U; /// R + R = R; /// X + C = X; /// Where ""+"" - any operation that somehow derive pointer, U - unrelocated,; /// R - relocated and P - poisoned, C - constant, X - U or R or P or C or; /// nothing (in case when ""+"" is unary operation).; /// Deriving of pointers by itself is always safe.; /// NOTE: when we are making decision on the status of instruction's result:; /// a) for phi we need to check status of each input *at the end of; /// corresponding predecessor BB*.; /// b) for other instructions we need to check status of each input *at the; /// current point*.; ///; /// FIXME: This works fairly well except one case; /// bb1:; /// p = *some GC-ptr def*; /// p1 = gep p, offset; /// / |; /// / |; /// bb2: |; /// safepoint |; /// \ |; /// \ |; /// bb3:; /// p2 = phi [p, bb2] [p1, bb1]; /// p3 = phi [p, bb2] [p, bb1]; /// here p and p1 is unrelocated; /// p2 and p3 is poisoned (though they sh",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:427,safe,safely,427,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,2,['safe'],['safely']
Safety,"/// Builds a canonical type from a QualType.; ///; /// This routine is inherently unsafe, because it requires the user to; /// ensure that the given type is a canonical type with the correct; // (dynamic) type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h:82,unsafe,unsafe,82,interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CanonicalType.h,1,['unsafe'],['unsafe']
Safety,"/// By default, a token never needs to avoid concatenation. Most tokens; /// (e.g. ',', ')', etc) don't cause a problem when concatenated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h:39,avoid,avoid,39,interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,1,['avoid'],['avoid']
Safety,"/// COPYs don't have register class constraints, so if the user instruction; /// is a COPY, we just try to avoid introducing additional cross-class; /// COPYs. For example:; ///; /// RegClassA = COPY RegClassB // Copy parameter; /// ...; /// RegClassB = COPY RegClassA // UseI parameter; ///; /// which after forwarding becomes; ///; /// RegClassA = COPY RegClassB; /// ...; /// RegClassB = COPY RegClassB; ///; /// so we have reduced the number of cross-class COPYs and potentially; /// introduced a nop COPY that can be removed.; // Allow forwarding if src and dst belong to any common class, so long as they; // don't belong to any (possibly smaller) common class that requires copies to; // go via a different class.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:107,avoid,avoid,107,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['avoid'],['avoid']
Safety,/// CVRecord is a fat pointer (base + size pair) to a symbol or type record.; /// Carrying the size separately instead of trusting the size stored in the; /// record prefix provides some extra safety and flexibility.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CVRecord.h:193,safe,safety,193,interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CVRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/CodeView/CVRecord.h,1,['safe'],['safety']
Safety,"/// Cache any ""global"" code-completion results, so that we can avoid; /// recomputing them with each completion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:63,avoid,avoid,63,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['avoid'],['avoid']
Safety,/// Cache of parts of the loop used throughout loop fusion. These should not; /// need to change throughout the analysis and transformation.; /// These parts are cached to avoid repeatedly looking up in the Loop class.; /// Preheader of the loop this candidate represents,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:172,avoid,avoid,172,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['avoid'],['avoid']
Safety,"/// Calculate iterated dominance frontiers; ///; /// This uses the linear-time phi algorithm based on DJ-graphs mentioned in; /// the file-level comment. It performs DF->IDF pruning using the live-in; /// set, to avoid computing the IDF for blocks where an inserted PHI node; /// would be dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericIteratedDominanceFrontier.h:213,avoid,avoid,213,interpreter/llvm-project/llvm/include/llvm/Support/GenericIteratedDominanceFrontier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/GenericIteratedDominanceFrontier.h,1,['avoid'],['avoid']
Safety,"/// Call ReleasePred for each predecessor, then update register live def/gen.; /// Always update LiveRegDefs for a register dependence even if the current SU; /// also defines the register. This effectively create one large live range; /// across a sequence of two-address node. This is important because the; /// entire chain must be scheduled together. Example:; ///; /// flags = (3) add; /// flags = (2) addc flags; /// flags = (1) addc flags; ///; /// results in; ///; /// LiveRegDefs[flags] = 3; /// LiveRegGens[flags] = 1; ///; /// If (2) addc is unscheduled, then (1) addc must also be unscheduled to avoid; /// interference on flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:608,avoid,avoid,608,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avoid'],['avoid']
Safety,"/// Call this to indicate that it's a good point to assess whether locations; /// have been lost. Typically this will be when a logical change has been; /// completed such as the caller has finished replacing some instructions with; /// alternatives. When CheckDebugLocs is true, the locations will be checked; /// to see if any have been lost since the last checkpoint. When; /// CheckDebugLocs is false, it will just reset ready for the next checkpoint; /// without checking anything. This can be helpful to limit the detection to; /// easy-to-fix portions of an algorithm before allowing more difficult ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LostDebugLocObserver.h:520,detect,detection,520,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LostDebugLocObserver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LostDebugLocObserver.h,1,['detect'],['detection']
Safety,"/// Call this when the user attempts to do something unsupported, like; /// returning a double without SSE2 enabled on x86_64. This is not fatal, unlike; /// report_fatal_error, so calling code should attempt to recover without; /// crashing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp:212,recover,recover,212,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLoweringCall.cpp,1,['recover'],['recover']
Safety,"/// Callback for generating the reduction body. The IR produced by this will; /// be used to combine two values in a thread-safe context, e.g., under; /// lock or within the same thread, and therefore need not be atomic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:124,safe,safe,124,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['safe'],['safe']
Safety,"/// Called by JITLink once all defined symbols in the graph have been assigned; /// their final memory locations in the target process. At this point the; /// LinkGraph can be inspected to build a symbol table, however the block; /// content will not generally have been copied to the target location yet.; ///; /// If the client detects an error in the LinkGraph state (e.g. unexpected or; /// missing symbols) they may return an error here. The error will be; /// propagated to notifyFailed and the linker will bail out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:330,detect,detects,330,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['detect'],['detects']
Safety,/// Called on well-formed 'safelen' clause.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:27,safe,safelen,27,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['safe'],['safelen']
Safety,"/// Called when the separate crash-recovery thread was finished, to; /// indicate that we don't need to clear the thread-local CurrentContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp:35,recover,recovery,35,interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/CrashRecoveryContext.cpp,1,['recover'],['recovery']
Safety,/// Called when the uninitialized variable analysis detects the; /// idiom 'int x = x'. All other uses of 'x' within the initializer; /// are handled by handleUseOfUninitVariable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UninitializedValues.h:52,detect,detects,52,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UninitializedValues.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UninitializedValues.h,2,['detect'],['detects']
Safety,"/// Calls remove on all trackers currently associated with this JITDylib.; /// Does not run static deinits.; ///; /// Note that removal happens outside the session lock, so new code may be; /// added concurrently while the clear is underway, and the newly added; /// code will *not* be cleared. Adding new code concurrently with a clear; /// is usually a bug and should be avoided.; ///; /// It is illegal to call this method on a defunct JITDylib and the client; /// is responsible for ensuring that they do not do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:373,avoid,avoided,373,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['avoid'],['avoided']
Safety,"/// Can an out-of-line inline function serve as a key function?; ///; /// This flag is only useful in ABIs where type data (for example,; /// vtables and type_info objects) are emitted only after processing; /// the definition of a special ""key"" virtual function. (This is safe; /// because the ODR requires that every virtual function be defined; /// somewhere in a program.) This usually permits such data to be; /// emitted in only a single object file, as opposed to redundantly; /// in every object file that requires it.; ///; /// One simple and common definition of ""key function"" is the first; /// virtual function in the class definition which is not defined there.; /// This rule works very well when that function has a non-inline; /// definition in some non-header file. Unfortunately, when that; /// function is defined inline, this rule requires the type data; /// to be emitted weakly, as if there were no key function.; ///; /// The ARM ABI observes that the ODR provides an additional guarantee:; /// a virtual function is always ODR-used, so if it is defined inline,; /// that definition must appear in every translation unit that defines; /// the class. Therefore, there is no reason to allow such functions; /// to serve as key functions.; ///; /// Because this changes the rules for emitting type data,; /// it can cause type data to be emitted with both weak and strong; /// linkage, which is not allowed on all platforms. Therefore,; /// exploiting this observation requires an ABI break and cannot be; /// done on a generic Itanium platform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h:273,safe,safe,273,interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetCXXABI.h,2,"['redund', 'safe']","['redundantly', 'safe']"
Safety,/// Can be safely retained or not retained.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:11,safe,safely,11,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['safe'],['safely']
Safety,/// Can we predict that this node will always be called?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:11,predict,predict,11,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,1,['predict'],['predict']
Safety,"/// Capture the given expression as the result of this pseudo-object; /// operation. This routine is safe against expressions which may; /// already be captured.; ///; /// \returns the captured expression, which will be the; /// same as the input if the input was already captured",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp:101,safe,safe,101,interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaPseudoObject.cpp,1,['safe'],['safe']
Safety,"/// Captures loop safety information.; /// It keep information for loop blocks may throw exception or otherwise; /// exit abnormally on any iteration of the loop which might actually execute; /// at runtime. The primary way to consume this information is via; /// isGuaranteedToExecute below, but some callers bailout or fallback to; /// alternate reasoning if a loop contains any implicit control flow.; /// NOTE: LoopSafetyInfo contains cached information regarding loops and their; /// particular blocks. This information is only dropped on invocation of; /// computeLoopSafetyInfo. If the loop or any of its block is deleted, or if; /// any thrower instructions have been added or removed from them, or if the; /// control flow has changed, or in case of other meaningful modifications, the; /// LoopSafetyInfo needs to be recomputed. If a meaningful modifications to the; /// loop were made and the info wasn't recomputed properly, the behavior of all; /// methods except for computeLoopSafetyInfo is undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:18,safe,safety,18,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['safe'],['safety']
Safety,"/// Carefully grab the subprogram from a local scope.; ///; /// This carefully grabs the subprogram from a local scope, avoiding the; /// built-in assertions that would typically fire.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:120,avoid,avoiding,120,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['avoid'],['avoiding']
Safety,"/// Certain SIMD instructions with vector element operand are not efficient.; /// Rewrite them into SIMD instructions with vector operands. This rewrite; /// is driven by the latency of the instructions.; /// The instruction of concerns are for the time being FMLA, FMLS, FMUL,; /// and FMULX and hence they are hardcoded.; ///; /// For example:; /// fmla v0.4s, v1.4s, v2.s[1]; ///; /// Is rewritten into; /// dup v3.4s, v2.s[1] // DUP not necessary if redundant; /// fmla v0.4s, v1.4s, v3.4s; ///; /// Return true if the SIMD instruction is modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp:454,redund,redundant,454,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64SIMDInstrOpt.cpp,1,['redund'],['redundant']
Safety,"/// Change the MachineInstr \p MI into the equivalent 32-bit copy if it is; /// safe to do so. Return the replacement instruction if OK, otherwise return; /// nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:80,safe,safe,80,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['safe'],['safe']
Safety,"/// Change the MachineInstr \p MI into the equivalent extend to 32 bit; /// register if it is safe to do so. Return the replacement instruction if; /// OK, otherwise return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:94,safe,safe,94,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['safe'],['safe']
Safety,"/// Change the MachineInstr \p MI into the equivalent extending load to 32 bit; /// register if it is safe to do so. Return the replacement instruction if; /// OK, otherwise return nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp:102,safe,safe,102,interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86FixupBWInsts.cpp,1,['safe'],['safe']
Safety,/// Change the global auto detection function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h:27,detect,detection,27,interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h,1,['detect'],['detection']
Safety,"/// CharUnits - This is an opaque type for sizes expressed in character units.; /// Instances of this type represent a quantity as a multiple of the size; /// of the standard C type, char, on the target architecture. As an opaque; /// type, CharUnits protects you from accidentally combining operations on; /// quantities in bit units and character units.; ///; /// In both C and C++, an object of type 'char', 'signed char', or 'unsigned; /// char' occupies exactly one byte, so 'character unit' and 'byte' refer to; /// the same quantity of storage. However, we use the term 'character unit'; /// rather than 'byte' to avoid an implication that a character unit is; /// exactly 8 bits.; ///; /// For portability, never assume that a target character is 8 bits wide. Use; /// CharUnit values wherever you calculate sizes, offsets, or alignments; /// in character units.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CharUnits.h:621,avoid,avoid,621,interpreter/llvm-project/clang/include/clang/AST/CharUnits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CharUnits.h,1,['avoid'],['avoid']
Safety,"/// Check a function's CFG for thread-safety violations.; ///; /// We traverse the blocks in the CFG, compute the set of mutexes that are held; /// at the end of each block, and issue warnings for thread safety violations.; /// Each block in the CFG is traversed exactly once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h:38,safe,safety,38,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,6,['safe'],['safety']
Safety,"/// Check a module for errors.; ///; /// If there are no errors, the function returns false. If an error is; /// found, a message describing the error is written to OS (if; /// non-null) and true is returned.; ///; /// \return true if the module is broken. If BrokenDebugInfo is; /// supplied, DebugInfo verification failures won't be considered as; /// error and instead *BrokenDebugInfo will be set to true. Debug; /// info errors can be ""recovered"" from by stripping the debug info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h:441,recover,recovered,441,interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,1,['recover'],['recovered']
Safety,/// Check for operands with placeholder types and complain if found.; /// Returns ExprError() if there was an error and no recovery was possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:123,recover,recovery,123,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recovery']
Safety,"/// Check given CFG for 'called once' parameter violations.; ///; /// It traverses the function and tracks how such parameters are used.; /// It detects two main violations:; /// * parameter is called twice; /// * parameter is not called; ///; /// \param AC -- context.; /// \param Handler -- a handler for found violations.; /// \param CheckConventionalParameters -- true, if we want to check parameters; /// not explicitly marked as 'called once', but having the same requirements; /// according to conventions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/CalledOnceCheck.h:145,detect,detects,145,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/CalledOnceCheck.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/CalledOnceCheck.h,1,['detect'],['detects']
Safety,"/// Check if \c Add is an add that can be safely folded into \c GEP.; ///; /// \c Add can be folded into \c GEP if:; /// - \c Add is an add,; /// - \c Add's size matches \c GEP's,; /// - \c Add is in the same basic block as \c GEP, and; /// - \c Add has a constant operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:42,safe,safely,42,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,1,['safe'],['safely']
Safety,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:77,detect,detect,77,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,2,['detect'],['detect']
Safety,"/// Check if executing a load of this pointer value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do; /// a quick local scan of the basic block containing \c ScanFrom, to determine; /// if the address is already accessed.; ///; /// This uses the pointee type to determine how many bytes need to be safe to; /// load from the pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:187,safe,safe,187,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,3,['safe'],['safe']
Safety,/// Check if given function is safe for not having callee saved registers.; /// This is used when interprocedural register allocation is enabled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:31,safe,safe,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,1,['safe'],['safe']
Safety,/// Check if it's ok to try and recover dot pseudo destructor calls on; /// pointer objects.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp:32,recover,recover,32,interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprCXX.cpp,1,['recover'],['recover']
Safety,/// Check if life time marker nodes can be hoisted/sunk into the outline; /// region.; ///; /// Returns true if it is safe to do the code motion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:118,safe,safe,118,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,1,['safe'],['safe']
Safety,/// Check if the instruction MI can be safely moved over a set of instructions; /// whose side-effects (in terms of register defs and uses) are expressed in; /// the maps Defs and Uses. These maps reflect the conditional defs and uses; /// that depend on the same predicate register to allow moving instructions; /// over instructions predicated on the opposite condition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp:39,safe,safely,39,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonExpandCondsets.cpp,1,['safe'],['safely']
Safety,/// Check if the library is application extension safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h:50,safe,safe,50,interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,1,['safe'],['safe']
Safety,"/// Check if the provided node is save to speculatively executed given its; /// current arguments. So, while `udiv` the opcode is not safe to; /// speculatively execute, a given `udiv` node may be if the denominator is; /// known nonzero.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:134,safe,safe,134,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['safe'],['safe']
Safety,/// Check if the specified operand is safe to fold into the current; /// instruction.; /// - InsnID(ULEB128) - Instruction ID,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h:38,safe,safe,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/GIMatchTableExecutor.h,1,['safe'],['safe']
Safety,/// Check if this mbb is guaranteed to execute. If not then a load from this mbb; /// may not be safe to hoist.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:97,safe,safe,97,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['safe'],['safe']
Safety,/// Check if we can safely rename this Comdat function. Instances of the same; /// comdat function may have different control flows thus can not share the; /// same counter variable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h:20,safe,safely,20,interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/InstrProf.h,1,['safe'],['safely']
Safety,"/// Check loop instructions safe for Loop versioning.; /// It returns true if it's safe else returns false.; /// Consider following:; /// 1) Check all load store in loop body are non atomic & non volatile.; /// 2) Check function call safety, by ensuring its not accessing memory.; /// 3) Loop body shouldn't have any may throw instruction.; /// 4) Loop body shouldn't have any convergent or noduplicate instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp:28,safe,safe,28,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopVersioningLICM.cpp,3,['safe'],"['safe', 'safety']"
Safety,"/// Check supports recovering, runtime has both fatal (noreturn) and; /// non-fatal handlers for this check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:19,recover,recovering,19,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['recover'],['recovering']
Safety,/// Check the header and detect any errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/Header.cpp:25,detect,detect,25,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/Header.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/Header.cpp,1,['detect'],['detect']
Safety,/// Check whether a given allocation must be put on the safe; /// stack or not. The function analyzes all uses of AI and checks whether it is; /// only accessed in a memory safe way (as decided statically).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:56,safe,safe,56,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,2,['safe'],['safe']
Safety,"/// Check whether a specialization is well-formed in the current; /// context.; ///; /// This routine determines whether a template specialization can be declared; /// in the current context (C++ [temp.expl.spec]p2).; ///; /// \param S the semantic analysis object for which this check is being; /// performed.; ///; /// \param Specialized the entity being specialized or instantiated, which; /// may be a kind of template (class template, function template, etc.) or; /// a member of a class template (member function, static data member,; /// member class).; ///; /// \param PrevDecl the previous declaration of this entity, if any.; ///; /// \param Loc the location of the explicit specialization or instantiation of; /// this entity.; ///; /// \param IsPartialSpecialization whether this is a partial specialization of; /// a class template.; ///; /// \returns true if there was an error that we cannot recover from, false; /// otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp:907,recover,recover,907,interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaTemplate.cpp,1,['recover'],['recover']
Safety,"/// Check whether an OutlinableRegion is incompatible with code already; /// outlined. OutlinableRegions are incomptaible when there are overlapping; /// instructions, or code that has not been recorded has been added to the; /// instructions.; ///; /// \param [in] Region - The OutlinableRegion to check for conflicts with; /// already outlined code.; /// \returns whether the region can safely be outlined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h:389,safe,safely,389,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/IROutliner.h,1,['safe'],['safely']
Safety,"/// Check whether it is poison-safe to represent the expression S using the; /// instruction I. If such a replacement is performed, the poison flags of; /// instructions in DropPoisonGeneratingInsts must be dropped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:31,safe,safe,31,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['safe'],['safe']
Safety,/// Check whether it's safe to outline \p BB.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:23,safe,safe,23,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,1,['safe'],['safe']
Safety,"/// Check whether or not GlobalISel should abort on error.; /// When this is disabled, GlobalISel will fall back on SDISel instead of; /// erroring out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:43,abort,abort,43,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,2,['abort'],['abort']
Safety,/// Check whether the data dependence could prevent store-load; /// forwarding.; ///; /// \return false if we shouldn't vectorize at all or avoid larger; /// vectorization factors by limiting MinDepDistBytes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:140,avoid,avoid,140,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['avoid'],['avoid']
Safety,/// Check whether the dependencies between the accesses are safe.; ///; /// Only checks sets with elements in \p CheckDeps.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:60,safe,safe,60,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['safe'],['safe']
Safety,/// Check whether the function is retainRV/unsafeClaimRV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h:43,unsafe,unsafeClaimRV,43,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h,1,['unsafe'],['unsafeClaimRV']
Safety,/// Check whether we detected a valid Cuda install.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:21,detect,detected,21,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,1,['detect'],['detected']
Safety,/// Check whether we detected a valid GCC install.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:21,detect,detected,21,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,1,['detect'],['detected']
Safety,/// Check whether we detected a valid HIP STDPAR Acceleration library.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:21,detect,detected,21,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,1,['detect'],['detected']
Safety,/// Check whether we detected a valid HIP runtime.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:21,detect,detected,21,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,1,['detect'],['detected']
Safety,/// Check whether we detected a valid ROCm device library.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:21,detect,detected,21,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,1,['detect'],['detected']
Safety,"/// Check whether we're allowed to call Callee from the current context.; ///; /// - If the call is never allowed in a semantically-correct program; /// (CFP_Never), emits an error and returns false.; ///; /// - If the call is allowed in semantically-correct programs, but only if; /// it's never codegen'ed (CFP_WrongSide), creates a deferred diagnostic to; /// be emitted if and when the caller is codegen'ed, and returns true.; ///; /// Will only create deferred diagnostics for a given SourceLocation once,; /// so you can safely call this multiple times without generating duplicate; /// deferred errors.; ///; /// - Otherwise, returns true without emitting any diagnostics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:527,safe,safely,527,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['safe'],['safely']
Safety,"/// CheckAggExprForMemSetUse - If the initializer is large and has a lot of; /// zeros in it, emit a memset and avoid storing the individual zeros.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp:112,avoid,avoid,112,interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprAgg.cpp,1,['avoid'],['avoid']
Safety,/// CheckConstructorCall - Check a constructor call for correctness and safety; /// properties not enforced by the C type system.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:72,safe,safety,72,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['safe'],['safety']
Safety,/// CheckFoldableChainNodeMatcher - This checks to see if the current node; /// (which defines a chain operand) is safe to fold into a larger pattern.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.h:115,safe,safe,115,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.h,1,['safe'],['safe']
Safety,/// CheckFunctionCall - Check a direct function call for various correctness; /// and safety properties not strictly enforced by the C type system.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:86,safe,safety,86,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['safe'],['safety']
Safety,"/// Checks if it is safe to call InductionDescriptor::isInductionPHI for \p Phi,; /// and returns true if this Phi is an induction phi in the loop. When; /// isInductionPHI returns true, \p ID will be also be set by isInductionPHI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:20,safe,safe,20,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,1,['safe'],['safe']
Safety,"/// Checks if the vector of instructions can be represented as a shuffle, like:; /// %x0 = extractelement <4 x i8> %x, i32 0; /// %x3 = extractelement <4 x i8> %x, i32 3; /// %y1 = extractelement <4 x i8> %y, i32 1; /// %y2 = extractelement <4 x i8> %y, i32 2; /// %x0x0 = mul i8 %x0, %x0; /// %x3x3 = mul i8 %x3, %x3; /// %y1y1 = mul i8 %y1, %y1; /// %y2y2 = mul i8 %y2, %y2; /// %ins1 = insertelement <4 x i8> poison, i8 %x0x0, i32 0; /// %ins2 = insertelement <4 x i8> %ins1, i8 %x3x3, i32 1; /// %ins3 = insertelement <4 x i8> %ins2, i8 %y1y1, i32 2; /// %ins4 = insertelement <4 x i8> %ins3, i8 %y2y2, i32 3; /// ret <4 x i8> %ins4; /// can be transformed into:; /// %1 = shufflevector <4 x i8> %x, <4 x i8> %y, <4 x i32> <i32 0, i32 3, i32 5,; /// i32 6>; /// %2 = mul <4 x i8> %1, %1; /// ret <4 x i8> %2; /// Mask will return the Shuffle Mask equivalent to the extracted elements.; /// TODO: Can we split off and reuse the shuffle mask detection from; /// ShuffleVectorInst/getShuffleCost?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:944,detect,detection,944,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['detect'],['detection']
Safety,"/// Checks if there is an available slot in the resource buffer.; ///; /// Returns RS_BUFFER_AVAILABLE if this is not a buffered resource, or if; /// there is a slot available.; ///; /// Returns RS_RESERVED if this buffered resource is a dispatch hazard, and it; /// is reserved.; ///; /// Returns RS_BUFFER_UNAVAILABLE if there are no available slots.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h:247,hazard,hazard,247,interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MCA/HardwareUnits/ResourceManager.h,1,['hazard'],['hazard']
Safety,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:639,safe,safety,639,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,5,"['Safe', 'safe']","['Safe', 'safe', 'safety']"
Safety,"/// Class that lazily initialises the runtime function. Avoids inserting the; /// types and the function declaration into a module if they're not used, and; /// avoids constructing the type more than once if it's used more than once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:56,Avoid,Avoids,56,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,"['Avoid', 'avoid']","['Avoids', 'avoids']"
Safety,"/// Class to determine where the safe point to insert the; /// prologue and epilogue are.; /// Unlike the paper from Fred C. Chow, PLDI'88, that introduces the; /// shrink-wrapping term for prologue/epilogue placement, this pass; /// does not rely on expensive data-flow analysis. Instead we use the; /// dominance properties and loop information to decide which point; /// are safe for such insertion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:33,safe,safe,33,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,2,['safe'],['safe']
Safety,/// Class to store bundler options in standard (non-cl::opt) data structures; // Avoid using cl::opt variables after these assignments when possible,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp:81,Avoid,Avoid,81,interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/clang-offload-bundler/ClangOffloadBundler.cpp,1,['Avoid'],['Avoid']
Safety,/// Class which implements the core thread safety analysis routines.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp:43,safe,safety,43,interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/ThreadSafety.cpp,1,['safe'],['safety']
Safety,/// Clean up any erroneous/redundant code in the given \p Ranges in \p; /// Code.; ///; /// Returns the ``Replacements`` that clean up all \p Ranges in \p Code.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:27,redund,redundant,27,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['redund'],['redundant']
Safety,"/// Clear kill flags for any uses in the given set. This will likely; /// conservatively remove more kill flags than are necessary, but removing them; /// is safer than incorrect kill flags remaining on instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp:158,safe,safer,158,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2ITBlockPass.cpp,1,['safe'],['safer']
Safety,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:120,avoid,avoid,120,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,1,['avoid'],['avoid']
Safety,"/// Clears the user interrupt flag (UIF). Its effect takes place immediately: a; /// user interrupt cannot be delivered on the instruction boundary following; /// CLUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of CLI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> CLUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 0; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:382,abort,abort,382,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,2,['abort'],['abort']
Safety,/// Clone another MachineInstr's memory reference descriptor list and replace; /// ours with it.; ///; /// Note that `*this` may be the incoming MI!; ///; /// Prefer this API whenever possible as it can avoid allocations in common; /// cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:203,avoid,avoid,203,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['avoid'],['avoid']
Safety,/// Clone the merge of multiple MachineInstrs' memory reference descriptors; /// list and replace ours with it.; ///; /// Note that `*this` may be one of the incoming MIs!; ///; /// Prefer this API whenever possible as it can avoid allocations in common; /// cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:226,avoid,avoid,226,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['avoid'],['avoid']
Safety,"/// Code completion occurs within the body of a function on a; /// recovery path, where we do not have a specific handle on our position; /// in the grammar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:67,recover,recovery,67,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['recover'],['recovery']
Safety,"/// CodeInjector is an interface which is responsible for injecting AST; /// of function definitions that may not be available in the original source.; ///; /// The getBody function will be called each time the static analyzer examines a; /// function call that has no definition available in the current translation; /// unit. If the returned statement is not a null pointer, it is assumed to be; /// the body of a function which will be used for the analysis. The source of; /// the body can be arbitrary, but it is advised to use memoization to avoid; /// unnecessary reparsing of the external source that provides the body of the; /// functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CodeInjector.h:548,avoid,avoid,548,interpreter/llvm-project/clang/include/clang/Analysis/CodeInjector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/CodeInjector.h,1,['avoid'],['avoid']
Safety,"/// CollectStatementsForCase - Given the body of a 'switch' statement and a; /// constant value that is being switched on, see if we can dead code eliminate; /// the body of the switch to a simple series of statements to emit. Basically,; /// on a switch (5) we want to find these statements:; /// case 5:; /// printf(...); <--; /// ++i; <--; /// break;; ///; /// and add them to the ResultStmts vector. If it is unsafe to do this; /// transformation (for example, one of the elided statements contains a label; /// that might be jumped to), return CSFC_Failure. If we handled it and 'S'; /// should include statements after it (e.g. the printf() line is a substmt of; /// the case) then return CSFC_FallThrough. If we handled it and found a break; /// statement, then return CSFC_Success.; ///; /// If Case is non-null, then we are looking for the specified case, checking; /// that nothing we jump over contains labels. If Case is null, then we found; /// the case and are looking for the break.; ///; /// If the recursive walk actually finds our Case, then we set FoundCase to; /// true.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp:413,unsafe,unsafe,413,interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGStmt.cpp,1,['unsafe'],['unsafe']
Safety,"/// Collects transformations and merges them before applying them with; /// with applyRewrites(). E.g. if the same source range; /// is requested to be removed twice, only one rewriter remove will be invoked.; /// Rewrites happen in ""transactions""; if one rewrite in the transaction cannot; /// be done (e.g. it resides in a macro) all rewrites in the transaction are; /// aborted.; /// FIXME: ""Transactional"" rewrites support should be baked in the Rewriter.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp:373,abort,aborted,373,interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ARCMigrate/TransformActions.cpp,1,['abort'],['aborted']
Safety,"/// ColonIsSacred - When this is false, we aggressively try to recover from; /// code like ""foo : bar"" as if it were a typo for ""foo :: bar"". This is not; /// safe in case statements and a few other things. This is managed by the; /// ColonProtectionRAIIObject RAII object.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:63,recover,recover,63,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,2,"['recover', 'safe']","['recover', 'safe']"
Safety,"/// ColonProtectionRAIIObject - This sets the Parser::ColonIsSacred bool and; /// restores it when destroyed. This says that ""foo:"" should not be; /// considered a possible typo for ""foo::"" for error recovery purposes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h:200,recover,recovery,200,interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/RAIIObjectsForParser.h,1,['recover'],['recovery']
Safety,/// Combine a translation of the SCEV and the IV to create an expression that; /// recovers a location's value.; /// returns true if an expression was created.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:83,recover,recovers,83,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['recover'],['recovers']
Safety,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:869,risk,risky,869,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['risk'],['risky']
Safety,"/// Combine stores to match the type of value being stored.; ///; /// The core idea here is that the memory does not have any intrinsic type and; /// where we can we should match the type of a store to the type of value being; /// stored.; ///; /// However, this routine must never change the width of a store or the number of; /// stores as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows stores to more closely model the types; /// of their incoming values.; ///; /// Currently, we also refuse to change the precise type used for an atomic or; /// volatile store. This is debatable, and might be reasonable to change later.; /// However, it is risky in case some backend or other part of LLVM is relying; /// on the exact type stored to select appropriate atomic operations.; ///; /// \returns true if the store was successfully combined away. This indicates; /// the caller must erase the store instruction. We have to let the caller erase; /// the store instruction as otherwise there is no way to signal whether it was; /// combined or not: IC.EraseInstFromFunction returns a null pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:709,risk,risky,709,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['risk'],['risky']
Safety,/// Commit the accumulated symbols to the module symbol stream. Safe to call; /// in parallel on different DbiModuleDescriptorBuilder objects. Only modifies; /// the pre-allocated stream in question.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleDescriptorBuilder.h:64,Safe,Safe,64,interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleDescriptorBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/PDB/Native/DbiModuleDescriptorBuilder.h,1,['Safe'],['Safe']
Safety,/// Common base class for all memory intrinsics. Simply provides; /// common methods.; /// Written as CRTP to avoid a common base class amongst the; /// three atomicity hierarchies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h:110,avoid,avoid,110,interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/IntrinsicInst.h,1,['avoid'],['avoid']
Safety,"/// Compare fallible iterators for equality.; ///; /// Returns true if both LHS and RHS are end-of-range values, or if both are; /// non-end-of-range values whose underlying iterator values compare equal.; ///; /// If this is a comparison between an end-of-range iterator and a; /// non-end-of-range iterator, then the Error (referenced by the; /// non-end-of-range value) is marked as checked: Since all; /// increment/decrement operations result in an end-of-range value, comparing; /// false against end-of-range is equivalent to checking that the Error value; /// is success. This flag management enables early returns from loop bodies; /// without redundant Error checks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h:653,redund,redundant,653,interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/fallible_iterator.h,1,['redund'],['redundant']
Safety,"/// Compare two values used by the two functions under pair-wise comparison. If; /// this is the first time the values are seen, they're added to the mapping so; /// that we will detect mismatches on next use.; /// See comments in declaration for more details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:179,detect,detect,179,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,1,['detect'],['detect']
Safety,"/// Compile a module in a separate compiler instance and read the AST,; /// returning true if the module compiles without errors, potentially using a; /// lock manager to avoid building the same module in multiple compiler; /// instances.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:171,avoid,avoid,171,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,1,['avoid'],['avoid']
Safety,"/// Compile a module in a separate compiler instance and read the AST,; /// returning true if the module compiles without errors, using a lock manager; /// to avoid building the same module in multiple compiler instances.; ///; /// Uses a lock file manager and exponential backoff to reduce the chances that; /// multiple instances will compete to create the same module. On timeout,; /// deletes the lock file in order to avoid deadlock from crashing processes or; /// bugs in the lock file manager.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp:159,avoid,avoid,159,interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInstance.cpp,3,"['avoid', 'timeout']","['avoid', 'timeout']"
Safety,"/// Compute an abstract ""cost"" of speculating the given instruction,; /// which is assumed to be safe to speculate. TCC_Free means cheap,; /// TCC_Basic means less cheap, and TCC_Expensive means prohibitively; /// expensive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:97,safe,safe,97,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,"/// Compute mass in all loops.; ///; /// For each loop bottom-up, call \a computeMassInLoop().; ///; /// \a computeMassInLoop() aborts (and returns \c false) on loops that; /// contain a irreducible sub-SCCs. Use \a computeIrreducibleMass() and then; /// re-enter \a computeMassInLoop().; ///; /// \post \a computeMassInLoop() has returned \c true for every loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h:128,abort,aborts,128,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfoImpl.h,1,['abort'],['aborts']
Safety,"/// Compute model prediction on a single event.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBDT.hxx:18,predict,prediction,18,tmva/tmva/inc/TMVA/RBDT.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBDT.hxx,1,['predict'],['prediction']
Safety,"/// Compute model prediction on a single event.; ///; /// The method is intended to be used with std::vectors-like containers,; /// for example RVecs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBDT.hxx:18,predict,prediction,18,tmva/tmva/inc/TMVA/RBDT.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RBDT.hxx,1,['predict'],['prediction']
Safety,"/// Compute model prediction on input RTensor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx:18,predict,prediction,18,tmva/tmva/inc/TMVA/RReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx,2,['predict'],['prediction']
Safety,"/// Compute model prediction on input RTensor; /// The shape of the input tensor should be {nevents, nfeatures}; /// and the return shape will be {nevents, noutputs}; /// support for now only a single input",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RSofieReader.hxx:18,predict,prediction,18,tmva/tmva/inc/TMVA/RSofieReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RSofieReader.hxx,1,['predict'],['prediction']
Safety,"/// Compute model prediction on vector",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx:18,predict,prediction,18,tmva/tmva/inc/TMVA/RReader.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/RReader.hxx,2,['predict'],['prediction']
Safety,/// Compute output and input types by applying different config (basic type; /// and LMUL with type transformers). It also record result of type in legal; /// or illegal set to avoid compute the same config again. The result maybe; /// have illegal RVVType.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h:177,avoid,avoid,177,interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Support/RISCVVIntrinsicUtils.h,1,['avoid'],['avoid']
Safety,/// Compute the layout of an unsafe stack frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h:29,unsafe,unsafe,29,interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStackLayout.h,1,['unsafe'],['unsafe']
Safety,/// Compute the number of known offset bits internally to this block.; /// This number should be used to predict worst case padding when; /// splitting the block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBasicBlockInfo.h:105,predict,predict,105,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBasicBlockInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBasicBlockInfo.h,1,['predict'],['predict']
Safety,"/// ComputePosition - Examine the given output buffer and figure out the new; /// position after output. This is safe to call multiple times on the same; /// buffer, as it records the most recently scanned character and resumes from; /// there when the buffer has not been flushed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormattedStream.h:113,safe,safe,113,interpreter/llvm-project/llvm/include/llvm/Support/FormattedStream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FormattedStream.h,1,['safe'],['safe']
Safety,"/// Computes a range for the induction variable (IndVar) in which the range; /// check is redundant and can be constant-folded away. The induction; /// variable is not required to be the canonical {0,+,1} induction variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:90,redund,redundant,90,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['redund'],['redundant']
Safety,"/// Computes and returns a range of values for the induction variable (IndVar); /// in which the range check can be safely elided. If it cannot compute such a; /// range, returns std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp:116,safe,safely,116,interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/InductiveRangeCheckElimination.cpp,1,['safe'],['safely']
Safety,"/// Computes safety information for a loop checks loop body & header for; /// the possibility of may throw exception, it takes LoopSafetyInfo and loop; /// as argument. Updates safety information in LoopSafetyInfo argument.; /// Note: This is defined to clear and reinitialize an already initialized; /// LoopSafetyInfo. Some callers rely on this fact.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:13,safe,safety,13,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,2,['safe'],['safety']
Safety,"/// Computes the label of a using declaration starting at tthe using token; /// \p UsingTok.; /// If \p UsingTok doesn't begin a using declaration, returns the empty string.; /// Note that this detects specifically using declarations, as in:; /// using A::B::C;; /// and not type aliases, as in:; /// using A = B::C;; /// Type aliases are in general not safe to permute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UsingDeclarationsSorter.cpp:194,detect,detects,194,interpreter/llvm-project/clang/lib/Format/UsingDeclarationsSorter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UsingDeclarationsSorter.cpp,2,"['detect', 'safe']","['detects', 'safe']"
Safety,"/// Computes the multiplicative inverse of this APInt for a given modulo. The; /// iterative extended Euclidean algorithm is used to solve for this value,; /// however we simplify it to speed up calculating only the inverse, and take; /// advantage of div+rem calculations. We also use some tricks to avoid copying; /// (potentially large) APInts around.; /// WARNING: a value of '0' may be returned,; /// signifying that no multiplicative inverse exists!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp:301,avoid,avoid,301,interpreter/llvm-project/llvm/lib/Support/APInt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/APInt.cpp,1,['avoid'],['avoid']
Safety,"/// ConcurrentHashTable - is a resizeable concurrent hashtable.; /// The number of resizings limited up to x2^31. This hashtable is; /// useful to have efficient access to aggregate data(like strings,; /// type descriptors...) and to keep only single copy of such; /// an aggregate. The hashtable allows only concurrent insertions:; ///; /// KeyDataTy* = insert ( const KeyTy& );; ///; /// Data structure:; ///; /// Inserted value KeyTy is mapped to 64-bit hash value ->; ///; /// [------- 64-bit Hash value --------]; /// [ StartEntryIndex ][ Bucket Index ]; /// | |; /// points to the points to; /// first probe the bucket.; /// position inside; /// bucket entries; ///; /// After initialization, all buckets have an initial size. During insertions,; /// buckets might be extended to contain more entries. Each bucket can be; /// independently resized and rehashed(no need to lock the whole table).; /// Different buckets may have different sizes. If the single bucket is full; /// then the bucket is resized.; ///; /// BucketsArray keeps all buckets. Each bucket keeps an array of Entries; /// (pointers to KeyDataTy) and another array of entries hashes:; ///; /// BucketsArray[BucketIdx].Hashes[EntryIdx]:; /// BucketsArray[BucketIdx].Entries[EntryIdx]:; ///; /// [Bucket 0].Hashes -> [uint32_t][uint32_t]; /// [Bucket 0].Entries -> [KeyDataTy*][KeyDataTy*]; ///; /// [Bucket 1].Hashes -> [uint32_t][uint32_t][uint32_t][uint32_t]; /// [Bucket 1].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*][KeyDataTy*]; /// .........................; /// [Bucket N].Hashes -> [uint32_t][uint32_t][uint32_t]; /// [Bucket N].Entries -> [KeyDataTy*][KeyDataTy*][KeyDataTy*]; ///; /// ConcurrentHashTableByPtr uses an external thread-safe allocator to allocate; /// KeyDataTy items.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h:1721,safe,safe,1721,interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ConcurrentHashtable.h,1,['safe'],['safe']
Safety,/// Configure the LLJIT instance to use the ORC runtime and the detected; /// native target for the executor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h:64,detect,detected,64,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,1,['detect'],['detected']
Safety,/// ConflictMarkerKind - Kinds of conflict marker which the lexer might be; /// recovering from.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h:80,recover,recovering,80,interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,1,['recover'],['recovering']
Safety,/// Connected with instruction that interprets 'bags of bits' as floating; /// point numbers. Select fprb to avoid cross bank copies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:109,avoid,avoid,109,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,1,['avoid'],['avoid']
Safety,/// Connected with instruction that interprets 'bags of bits' as integers.; /// Select gprb to avoid cross bank copies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:95,avoid,avoid,95,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,1,['avoid'],['avoid']
Safety,"/// Consider the following situation when coalescing the copy between; /// %31 and %45 at 800. (The vertical lines represent live range segments.); ///; /// Main range Subrange 0004 (sub2); /// %31 %45 %31 %45; /// 544 %45 = COPY %28 + +; /// | v1 | v1; /// 560B bb.1: + +; /// 624 = %45.sub2 | v2 | v2; /// 800 %31 = COPY %45 + + + +; /// | v0 | v0; /// 816 %31.sub1 = ... + |; /// 880 %30 = COPY %31 | v1 +; /// 928 %45 = COPY %30 | + +; /// | | v0 | v0 <--+; /// 992B ; backedge -> bb.1 | + + |; /// 1040 = %31.sub0 + |; /// This value must remain; /// live-out!; ///; /// Assuming that %31 is coalesced into %45, the copy at 928 becomes; /// redundant, since it copies the value from %45 back into it. The; /// conflict resolution for the main range determines that %45.v0 is; /// to be erased, which is ok since %31.v1 is identical to it.; /// The problem happens with the subrange for sub2: it has to be live; /// on exit from the block, but since 928 was actually a point of; /// definition of %45.sub2, %45.sub2 was not live immediately prior; /// to that definition. As a result, when 928 was erased, the value v0; /// for %45.sub2 was pruned in pruneSubRegValues. Consequently, an; /// IMPLICIT_DEF was inserted as a ""backedge"" definition for %45.sub2,; /// providing an incorrect value to the use at 624.; ///; /// Since the main-range values %31.v1 and %45.v0 were proved to be; /// identical, the corresponding values in subranges must also be the; /// same. A redundant copy is removed because it's not needed, and not; /// because it copied an undefined value, so any liveness that originated; /// from that copy cannot disappear. When pruning a value that started; /// at the removed copy, the corresponding identical value must be; /// extended to replace it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:646,redund,redundant,646,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,2,['redund'],['redundant']
Safety,/// Construct a new raw_svector_ostream.; ///; /// \param O The vector to write to; this should generally have at least 128; /// bytes free to avoid any extraneous memory overhead.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:143,avoid,avoid,143,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['avoid'],['avoid']
Safety,/// Construct an ArrayRef from a SmallVector. This is templated in order to; /// avoid instantiating SmallVectorTemplateCommon<T> whenever we; /// copy-construct an ArrayRef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:81,avoid,avoid,81,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,1,['avoid'],['avoid']
Safety,/// Construct an ArrayRef<const T*> from a SmallVector<T*>. This is; /// templated in order to avoid instantiating SmallVectorTemplateCommon<T>; /// whenever we copy-construct an ArrayRef.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:95,avoid,avoid,95,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,1,['avoid'],['avoid']
Safety,"/// Construct from an std::string_view by converting it to a pointer and; /// length. This handles string_views on a pure API basis, and avoids; /// storing one (or a pointer to one) inside a Twine, which avoids problems; /// when mixing code compiled under various C++ standards.; /*implicit*/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:137,avoid,avoids,137,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,2,['avoid'],['avoids']
Safety,"/// ConsumeAnyToken - Dispatch to the right Consume* method based on the; /// current token type. This should only be used in cases where the type of; /// the token really isn't known, e.g. in error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:199,recover,recovery,199,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['recover'],['recovery']
Safety,"/// Contains a set of libraries which we gave to the user via ResolveSymbol; /// call and next time we should check if the user loaded them to avoid; /// useless iterations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp:143,avoid,avoid,143,interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLibraryManagerSymbol.cpp,1,['avoid'],['avoid']
Safety,/// Contains a stable numbering of basic blocks to avoid non-determinstic; /// behavior.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['avoid'],['avoid']
Safety,/// Contains all of the variables defined in this lambda that shadow variables; /// that were defined in parent contexts. Used to avoid warnings when the; /// shadowed variables are uncaptured by this lambda.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:130,avoid,avoid,130,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,1,['avoid'],['avoid']
Safety,"/// Convenience assignment operators. This only works if the destination; /// DocNode has an associated Document, i.e. it was not constructed using the; /// default constructor. The string one does not copy, so the string must; /// remain valid for the lifetime of the Document. Use fromString to avoid; /// that restriction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:297,avoid,avoid,297,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,1,['avoid'],['avoid']
Safety,"/// Convert the string \p S to an integer of the specified type using; /// the radix \p Base. If \p Base is 0, auto-detects the radix.; /// Returns true if the number was successfully converted, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringExtras.h:116,detect,detects,116,interpreter/llvm-project/llvm/include/llvm/ADT/StringExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringExtras.h,1,['detect'],['detects']
Safety,"/// Convert vector addition with vector subtraction if that allows to encode; /// constant as an immediate and thus avoid extra 'ldi' instruction.; /// add X, <-1, -1...> --> sub X, <1, 1...>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp:116,avoid,avoid,116,interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsISelDAGToDAG.cpp,2,['avoid'],['avoid']
Safety,"/// Copy the files into the root directory.; ///; /// When StopOnError is true (the default) we abort as soon as one file; /// cannot be copied. This is relatively common, for example when a file was; /// removed after it was added to the mapping.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h:96,abort,abort,96,interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,1,['abort'],['abort']
Safety,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:543,predict,prediction,543,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,2,['predict'],"['prediction', 'predictions']"
Safety,"/// Could be used to move out the matchers added previously, unless finalize(); /// has been already called. If any of the matchers are moved out, the group; /// becomes safe to destroy, but not safe to re-use for anything else.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:170,safe,safe,170,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,2,['safe'],['safe']
Safety,/// CouldBecomeSafePoint - Predicate to conservatively determine whether the; /// instruction could introduce a safe point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:112,safe,safe,112,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,1,['safe'],['safe']
Safety,/// Coverage map for sampling records.; ///; /// This map keeps a record of sampling records that have been matched to; /// an IR instruction. This is used to detect some form of staleness in; /// profiles (see flag -sample-profile-check-coverage).; ///; /// Each entry in the map corresponds to a FunctionSamples instance. This is; /// another map that counts how many times the sample record at the; /// given location has been used.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h:159,detect,detect,159,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileLoaderBaseUtil.h,1,['detect'],['detect']
Safety,"/// Crash recovery helper object.; ///; /// This class implements support for running operations in a safe context so; /// that crashes (memory errors, stack overflow, assertion violations) can be; /// detected and control restored to the crashing thread. Crash detection is; /// purely ""best effort"", the exact set of failures which can be recovered from; /// is platform dependent.; ///; /// Clients make use of this code by first calling; /// CrashRecoveryContext::Enable(), and then executing unsafe operations via a; /// CrashRecoveryContext object. For example:; ///; /// \code; /// void actual_work(void *);; ///; /// void foo() {; /// CrashRecoveryContext CRC;; ///; /// if (!CRC.RunSafely(actual_work, 0)) {; /// ... a crash was detected, report error to user ...; /// }; ///; /// ... no crash was detected ...; /// }; /// \endcode; ///; /// To assist recovery the class allows specifying set of actions that will be; /// executed in any case, whether crash occurs or not. These actions may be used; /// to reclaim resources in the case of crash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:10,recover,recovery,10,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,9,"['detect', 'recover', 'safe', 'unsafe']","['detected', 'detection', 'recovered', 'recovery', 'safe', 'unsafe']"
Safety,"/// Create a HazardRec for MBB, save it in SchedStates and set HazardRec to; /// point to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp:13,Hazard,HazardRec,13,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.cpp,2,['Hazard'],['HazardRec']
Safety,"/// Create a code extractor for a sequence of blocks.; ///; /// Given a sequence of basic blocks where the first block in the sequence; /// dominates the rest, prepare a code extractor object for pulling this; /// sequence out into its new function. When a DominatorTree is also given,; /// extra checking and transformations are enabled. If AllowVarArgs is true,; /// vararg functions can be extracted. This is safe, if all vararg handling; /// code is extracted, including vastart. If AllowAlloca is true, then; /// extraction of blocks containing alloca instructions would be possible,; /// however code extractor won't validate whether extraction is legal.; /// Any new allocations will be placed in the AllocationBlock, unless; /// it is null, in which case it will be placed in the entry block of; /// the function from which the code is being extracted.; /// If ArgsInZeroAddressSpace param is set to true, then the aggregate; /// param pointer of the outlined function is declared in zero address; /// space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h:412,safe,safe,412,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeExtractor.h,1,['safe'],['safe']
Safety,/// Create a location where the value is undefined and not available. This can; /// happen when a register is volatile and can't be recovered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h:132,recover,recovered,132,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,1,['recover'],['recovered']
Safety,"/// Create a new RNTupleFillContext that can be used to fill entries and prepare clusters in parallel. This method is; /// thread-safe and may be called from multiple threads in parallel at any time, also after some data has already; /// been written.; ///; /// Note that all fill contexts must be destroyed before the RNTupleParallelWriter is destructed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx:130,safe,safe,130,tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleParallelWriter.hxx,1,['safe'],['safe']
Safety,"/// Create a new output file and add it to the list of tracked output files.; ///; /// If \p OutputPath is empty, then createOutputFile will derive an output; /// path location as \p BaseInput, with any suffix removed, and \p Extension; /// appended. If \p OutputPath is not stdout and \p UseTemporary; /// is true, createOutputFile will create a new temporary file that must be; /// renamed to \p OutputPath in the end.; ///; /// \param OutputPath - If given, the path to the output file.; /// \param Binary - The mode to open the file in.; /// \param RemoveFileOnSignal - Whether the file should be registered with; /// llvm::sys::RemoveFileOnSignal. Note that this is not safe for; /// multithreaded use, as the underlying signal mechanism is not reentrant; /// \param UseTemporary - Create a new temporary file that must be renamed to; /// OutputPath in the end.; /// \param CreateMissingDirectories - When \p UseTemporary is true, create; /// missing directories in the output path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h:675,safe,safe,675,interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/CompilerInstance.h,1,['safe'],['safe']
Safety,"/// Create a verifier pass.; ///; /// Check a module or function for validity. This is essentially a pass wrapped; /// around the above verifyFunction and verifyModule routines and; /// functionality. When the pass detects a verification error it is always; /// printed to stderr, and by default they are fatal. You can override that by; /// passing \c false to \p FatalErrors.; ///; /// Note that this creates a pass suitable for the legacy pass manager. It has; /// nothing to do with \c VerifierPass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h:215,detect,detects,215,interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Verifier.h,1,['detect'],['detects']
Safety,"/// Create an implicit import of the given module at the given; /// source location, for error recovery, if possible.; ///; /// This routine is typically used when an entity found by name lookup; /// is actually hidden within a module that we know about but the user; /// has forgotten to import.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:95,recover,recovery,95,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['recover'],['recovery']
Safety,/// Create an instance of the safepoint verifier pass which can be added to; /// a pass pipeline to check for relocation bugs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/SafepointIRVerifier.h:30,safe,safepoint,30,interpreter/llvm-project/llvm/include/llvm/IR/SafepointIRVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/SafepointIRVerifier.h,2,['safe'],['safepoint']
Safety,/// Create an unsafe pool entry ref without changing the ref-count.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SymbolStringPool.h:14,unsafe,unsafe,14,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SymbolStringPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SymbolStringPool.h,1,['unsafe'],['unsafe']
Safety,/// Create name for Type. It uses MDString to store new created string to; /// avoid memory leak.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp:79,avoid,avoid,79,interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Coroutines/CoroFrame.cpp,1,['avoid'],['avoid']
Safety,"/// Create the TargetMachine object to query the backend for optimization; /// preferences.; ///; /// Ideally, this would be passed from the front-end to the OpenMPBuilder, but; /// e.g. Clang does not pass it to its CodeGen layer and creates it only when; /// needed for the LLVM pass pipline. We use some default options to avoid; /// having to pass too many settings from the frontend that probably do not; /// matter.; ///; /// Currently, TargetMachine is only used sometimes by the unrollLoopPartial; /// method. If we are going to use TargetMachine for more purposes, especially; /// those that are sensitive to TargetOptions, RelocModel and CodeModel, it; /// might become be worth requiring front-ends to pass on their TargetMachine,; /// or at least cache it between methods. Note that while fontends such as Clang; /// have just a single main TargetMachine per translation unit, ""target-cpu"" and; /// ""target-features"" that determine the TargetMachine are per-function and can; /// be overrided using __attribute__((target(""OPTIONS""))).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp:326,avoid,avoid,326,interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Frontend/OpenMP/OMPIRBuilder.cpp,1,['avoid'],['avoid']
Safety,"/// CreateCoercedLoad - Create a load from \arg SrcPtr interpreted as; /// a pointer to an object of type \arg Ty, known to be aligned to; /// \arg SrcAlign bytes.; ///; /// This safely handles the case when the src type is smaller than the; /// destination type; in this situation the values of bits which not; /// present in the src are undefined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:179,safe,safely,179,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['safe'],['safely']
Safety,"/// CreateCoercedStore - Create a store to \arg DstPtr from \arg Src,; /// where the source and destination may have different types. The; /// destination is known to be aligned to \arg DstAlign bytes.; ///; /// This safely handles the case when the src type is larger than the; /// destination type; the upper bits of the src will be lost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp:217,safe,safely,217,interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGCall.cpp,1,['safe'],['safely']
Safety,"/// CreateIRTemp - Create a temporary IR object of the given type, with; /// appropriate alignment. This routine should only be used when an temporary; /// value needs to be stored into an alloca (for example, to avoid explicit; /// PHI construction), but the type is the IR type, not the type appropriate; /// for storing in memory.; ///; /// That is, this is exactly equivalent to CreateMemTemp, but calling; /// ConvertType instead of ConvertTypeForMem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:213,avoid,avoid,213,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['avoid'],['avoid']
Safety,/// CreateTargetHazardRecognizer - Return the hazard recognizer to use for; /// this target when scheduling the DAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:46,hazard,hazard,46,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['hazard'],['hazard']
Safety,/// CreateTargetPostRAHazardRecognizer - Return the postRA hazard recognizer; /// to use for this target when scheduling the DAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp:59,hazard,hazard,59,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp,1,['hazard'],['hazard']
Safety,"/// Creates a value appropriate for `Type`, if `Type` is supported, otherwise; /// return null.; ///; /// Recursively initializes storage locations and values until it sees a; /// self-referential pointer or reference type. `Visited` is used to track; /// which types appeared in the reference/pointer chain in order to avoid; /// creating a cyclic dependency with self-referential pointers/references.; ///; /// Requirements:; ///; /// `Type` must not be null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h:320,avoid,avoid,320,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/DataflowEnvironment.h,1,['avoid'],['avoid']
Safety,/// Creates cleanup handler.; /// \param x Pointer to the resource recovered by this handler.; /// \return New handler or null if the method was called outside a recovery; /// context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:67,recover,recovered,67,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,2,['recover'],"['recovered', 'recovery']"
Safety,/// Current lookahead token. We can safely assume that all tokens are from; /// a single source file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CommentParser.h:36,safe,safely,36,interpreter/llvm-project/clang/include/clang/AST/CommentParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CommentParser.h,1,['safe'],['safely']
Safety,/// Current safe point found for the epilogue.; /// The epilogue will be inserted before the first terminator instruction; /// in this basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['safe'],['safe']
Safety,/// Current safe point found for the prologue.; /// The prologue will be inserted before the first instruction; /// in this basic block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:12,safe,safe,12,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['safe'],['safe']
Safety,/// Custom lowers floating point to integer conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,avoid,avoid,122,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avoid'],['avoid']
Safety,/// Custom lowers integer to floating point conversions to use; /// the direct move instructions available in ISA 2.07 to avoid the; /// need for load/store combinations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp:122,avoid,avoid,122,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.cpp,1,['avoid'],['avoid']
Safety,"/// DBG_VALUE pointer and flag. The flag is true if this DBG_VALUE is; /// post-dominated by another DBG_VALUE of the same variable location.; /// This is necessary to detect sequences such as:; /// %0 = someinst; /// DBG_VALUE %0, !123, !DIExpression(); /// %1 = anotherinst; /// DBG_VALUE %1, !123, !DIExpression(); /// Where if %0 were to sink, the DBG_VAUE should not sink with it, as that; /// would re-order assignments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:168,detect,detect,168,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,1,['detect'],['detect']
Safety,"/// Data structure to hold cached (LLVM-IR) information.; ///; /// All attributes are given an InformationCache object at creation time to; /// avoid inspection of the IR by all of them individually. This default; /// InformationCache will hold information required by 'default' attributes,; /// thus the ones deduced when Attributor::identifyDefaultAbstractAttributes(..); /// is called.; ///; /// If custom abstract attributes, registered manually through; /// Attributor::registerAA(...), need more information, especially if it is not; /// reusable, it is advised to inherit from the InformationCache and cast the; /// instance down in the abstract attributes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:144,avoid,avoid,144,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['avoid'],['avoid']
Safety,"/// DataLayout for the target: keep ABI type size and alignment.; ///; /// The DataLayout is created based on the string representation provided; /// during construction. It is kept here only to avoid reparsing the string; /// but should not really be used during compilation, because it has an; /// internal cache that is context specific.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h:195,avoid,avoid,195,interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetMachine.h,1,['avoid'],['avoid']
Safety,"/// DeadArgHacking pass - Same as DAE, but delete arguments of external; /// functions as well. This is definitely not safe, and should only be used by; /// bugpoint.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO.h:119,safe,safe,119,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO.h,1,['safe'],['safe']
Safety,"/// Debug value substitutions: a collection of DebugSubstitution objects,; /// recording changes in where a value is defined. For example, when one; /// instruction is substituted for another. Keeping a record allows recovery; /// of variable locations after compilation finishes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:217,recover,recovery,217,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['recover'],['recovery']
Safety,/// Decide whether we should forward the source of \param Copy to its use in; /// \param UseI based on the physical register class constraints of the opcode; /// and avoiding introducing more cross-class COPYs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp:166,avoid,avoiding,166,interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineCopyPropagation.cpp,1,['avoid'],['avoiding']
Safety,/// Declarations for ObjC runtime functions and constants. These are initialized; /// lazily to avoid cluttering up the Module with unused declarations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h:96,avoid,avoid,96,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ARCRuntimeEntryPoints.h,1,['avoid'],['avoid']
Safety,"/// Dedicated, process-wide RDirectory.; ///; /// \note This is *not* thread-safe. You will need to syncronize yourself. In; /// general it's a bad idea to use a global collection in a multi-threaded; /// environment; ROOT itself does not make use of it. It is merely offered for; /// historical, process-wide object registration by name. Instead, pass a; /// pointer to the object where you need to access it - this is also much; /// faster than a lookup by name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RDirectory.hxx:77,safe,safe,77,core/base/v7/inc/ROOT/RDirectory.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/v7/inc/ROOT/RDirectory.hxx,1,['safe'],['safe']
Safety,"/// DefMaxInstsToScan - the default number of maximum instructions; /// to scan in the block, used by FindAvailableLoadedValue().; /// FindAvailableLoadedValue() was introduced in r60148, to improve jump; /// threading in part by eliminating partially redundant loads.; /// At that point, the value of MaxInstsToScan was already set to '6'; /// without documented explanation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp:252,redund,redundant,252,interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/Loads.cpp,1,['redund'],['redundant']
Safety,"/// Default streamer implementation used by ClassDefInline to avoid; /// requirement to include TBuffer.h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx:62,avoid,avoid,62,core/base/src/TBuffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx,1,['avoid'],['avoid']
Safety,"/// Defines hints for detecting supported languages code blocks in raw; /// strings.; ///; /// A raw string with a matching delimiter or a matching enclosing function; /// name will be reformatted assuming the specified language based on the; /// style for that language defined in the .clang-format file. If no style has; /// been defined in the .clang-format file for the specific language, a; /// predefined style given by 'BasedOnStyle' is used. If 'BasedOnStyle' is not; /// found, the formatting is based on llvm style. A matching delimiter takes; /// precedence over a matching enclosing function name for determining the; /// language of the raw string contents.; ///; /// If a canonical delimiter is specified, occurrences of other delimiters for; /// the same language will be updated to the canonical if possible.; ///; /// There should be at most one specification per language and each delimiter; /// and enclosing function should not occur in multiple specifications.; ///; /// To configure this in the .clang-format file, use:; /// \code{.yaml}; /// RawStringFormats:; /// - Language: TextProto; /// Delimiters:; /// - 'pb'; /// - 'proto'; /// EnclosingFunctions:; /// - 'PARSE_TEXT_PROTO'; /// BasedOnStyle: google; /// - Language: Cpp; /// Delimiters:; /// - 'cc'; /// - 'cpp'; /// BasedOnStyle: llvm; /// CanonicalDelimiter: 'cc'; /// \endcode; /// \version 6",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:22,detect,detecting,22,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['detect'],['detecting']
Safety,/// Destroy a Error. Fails with a call to abort() if the error is; /// unchecked.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:42,abort,abort,42,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['abort'],['abort']
Safety,/// Detect 0-sample input profile and report to output stream. This interface; /// should be called after loadProfiles().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:4,Detect,Detect,4,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['Detect'],['Detect']
Safety,/// Detect if \c SizeofExpr is likely to calculate the sizeof an object.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp:4,Detect,Detect,4,interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaChecking.cpp,1,['Detect'],['Detect']
Safety,/// Detect mutually exclusive flags.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp:4,Detect,Detect,4,interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Verifier.cpp,1,['Detect'],['Detect']
Safety,/// Detect opportunities for ldp/stp formation.; ///; /// Only called for LdSt for which getMemOperandWithOffset returns true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp:4,Detect,Detect,4,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp,1,['Detect'],['Detect']
Safety,"/// Detect patterns of truncation with signed saturation:; /// (truncate (smin ((smax (x, signed_min_of_dest_type)),; /// signed_max_of_dest_type)) to dest_type); /// or:; /// (truncate (smax ((smin (x, signed_max_of_dest_type)),; /// signed_min_of_dest_type)) to dest_type).; /// With MatchPackUS, the smax/smin range is [0, unsigned_max_of_dest_type].; /// Return the source value to be truncated or SDValue() if the pattern was not; /// matched.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Detect,Detect,4,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,"/// Detect patterns of truncation with unsigned saturation:; ///; /// 1. (truncate (umin (x, unsigned_max_of_dest_type)) to dest_type).; /// Return the source value x to be truncated or SDValue() if the pattern was; /// not matched.; ///; /// 2. (truncate (smin (smax (x, C1), C2)) to dest_type),; /// where C1 >= 0 and C2 is unsigned max of destination type.; ///; /// (truncate (smax (smin (x, C2), C1)) to dest_type); /// where C1 >= 0, C2 is unsigned max of destination type and C1 <= C2.; ///; /// These two patterns are equivalent to:; /// (truncate (umin (smax(x, C1), unsigned_max_of_dest_type)) to dest_type); /// So return the smax(x, C1) value to be truncated or SDValue() if the; /// pattern was not matched.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Detect,Detect,4,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,"/// Detect the line ending style of the string.; ///; /// If the string contains a line ending, return the line ending character; /// sequence that is detected. Otherwise return '\n' for unix line endings.; ///; /// \return - The line ending character sequence.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:4,Detect,Detect,4,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,2,"['Detect', 'detect']","['Detect', 'detected']"
Safety,"/// Detect vector gather/scatter index generation and convert it from being a; /// bunch of shuffles and extracts into a somewhat faster sequence.; /// For i686, the best sequence is apparently storing the value and loading; /// scalars back, while for x64 we should use 64-bit extracts and shifts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:4,Detect,Detect,4,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['Detect'],['Detect']
Safety,"/// Detect whether a type is an instantiation of vector<T,A>",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:4,Detect,Detect,4,tree/dataframe/inc/ROOT/RDF/Utils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx,1,['Detect'],['Detect']
Safety,/// DetectVirtual - Whether Sema::IsDerivedFrom should abort the search; /// if it finds a path that goes across a virtual base. The virtual class; /// is also recorded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h:4,Detect,DetectVirtual,4,interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h,2,"['Detect', 'abort']","['DetectVirtual', 'abort']"
Safety,/// DetectedVirtual - The base class that is virtual.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h:4,Detect,DetectedVirtual,4,interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h,1,['Detect'],['DetectedVirtual']
Safety,"/// Detects encoding of the Text. If the Text can be decoded using UTF-8,; /// it is considered UTF8, otherwise we treat it as some 8-bit encoding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Encoding.h:4,Detect,Detects,4,interpreter/llvm-project/clang/lib/Format/Encoding.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Encoding.h,1,['Detect'],['Detects']
Safety,/// Detects the distribution using specified VFS.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Distro.h:4,Detect,Detects,4,interpreter/llvm-project/clang/include/clang/Driver/Distro.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Distro.h,1,['Detect'],['Detects']
Safety,/// Determine if all the instructions in MBB can safely; /// be speculated. The terminators are not considered.; ///; /// Only CmpMI is allowed to clobber the flags.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp:49,safe,safely,49,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ConditionalCompares.cpp,1,['safe'],['safely']
Safety,"/// Determine that this argument is safe to promote, and find the argument; /// parts it can be promoted into.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:36,safe,safe,36,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['safe'],['safe']
Safety,/// Determine the length of the longest redundant prefix of the paths in; /// \p Paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,redund,redundant,40,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redund'],['redundant']
Safety,"/// Determine the length of the longest redundant prefix of the substrs starts; /// from \p LCP in \p Paths. \p Paths can't be empty. If there's only one; /// element in \p Paths, the length of the substr is returned. Note this is; /// differnet from the behavior of the function above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:40,redund,redundant,40,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redund'],['redundant']
Safety,"/// Determine whether a suffix is a valid ud-suffix. We avoid treating reserved; /// suffixes as ud-suffixes, because the diagnostic experience is better if we; /// treat it as an invalid suffix.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:56,avoid,avoid,56,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,2,['avoid'],['avoid']
Safety,"/// Determine whether the given expression might be move-eligible or; /// copy-elidable in either a (co_)return statement or throw expression,; /// without considering function return type, if applicable.; ///; /// \param E The expression being returned from the function or block,; /// being thrown, or being co_returned from a coroutine. This expression; /// might be modified by the implementation.; ///; /// \param Mode Overrides detection of current language mode; /// and uses the rules for C++23.; ///; /// \returns An aggregate which contains the Candidate and isMoveEligible; /// and isCopyElidable methods. If Candidate is non-null, it means; /// isMoveEligible() would be true under the most permissive language standard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp:434,detect,detection,434,interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaStmt.cpp,1,['detect'],['detection']
Safety,/// Determine whether the instructions in this range may be safely and cheaply; /// speculated. This is not an important enough situation to develop complex; /// heuristics. We handle a single arithmetic instruction along with any type; /// conversions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:60,safe,safely,60,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,1,['safe'],['safely']
Safety,"/// Determine whether the parser is currently referring to a an; /// Objective-C message send, using a simplified heuristic to avoid overhead.; ///; /// This routine will only return true for a subset of valid message-send; /// expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:127,avoid,avoid,127,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['avoid'],['avoid']
Safety,"/// Determine whether this file is intended to be safe from; /// multiple inclusions, e.g., it has \#pragma once or a controlling; /// macro.; ///; /// This routine does not consider the effect of \#import",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:50,safe,safe,50,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['safe'],['safe']
Safety,"/// Determine whether this variable is an ARC pseudo-__strong variable. A; /// pseudo-__strong variable has a __strong-qualified type but does not; /// actually retain the object written into it. Generally such variables are; /// also 'const' for safety. There are 3 cases where this will be set, 1) if; /// the variable is annotated with the objc_externally_retained attribute, 2); /// if its 'self' in a non-init method, or 3) if its the variable in an for-in; /// loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:247,safe,safety,247,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['safe'],['safety']
Safety,"/// Determine which blocks the value is live in.; ///; /// These are blocks which lead to uses. Knowing this allows us to avoid; /// inserting PHI nodes into blocks which don't lead to uses (thus, the; /// inserted phi nodes would be dead).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:122,avoid,avoid,122,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['avoid'],['avoid']
Safety,/// Determine which objc runtime call instruction class V belongs to.; ///; /// This is similar to GetARCInstKind except that it only detects objc; /// runtime calls. This allows it to be faster.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:134,detect,detects,134,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,1,['detect'],['detects']
Safety,/// Determines if the given type is safe for constant capture in C++.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp:36,safe,safe,36,interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBlocks.cpp,1,['safe'],['safe']
Safety,/// Determines if these qualifiers compatibly include another set.; /// Generally this answers the question of whether an object with the other; /// qualifiers can be safely used as an object with these qualifiers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:167,safe,safely,167,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['safe'],['safely']
Safety,"/// Determines if this names a single result which is not an; /// unresolved value using decl. If so, it is safe to call; /// getFoundDecl().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:108,safe,safe,108,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['safe'],['safe']
Safety,"/// Determines the latest safe point in a block in which we can insert a split,; /// spill or other instruction related with CurLI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:26,safe,safe,26,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,1,['safe'],['safe']
Safety,/// Determining whether a for-range statement could be built. Avoid any; /// unnecessary or irreversible actions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:62,Avoid,Avoid,62,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['Avoid'],['Avoid']
Safety,"/// Diagnose a declaration whose declarator-id has the given; /// nested-name-specifier.; ///; /// \param SS The nested-name-specifier of the declarator-id.; ///; /// \param DC The declaration context to which the nested-name-specifier; /// resolves.; ///; /// \param Name The name of the entity being declared.; ///; /// \param Loc The location of the name of the entity being declared.; ///; /// \param IsTemplateId Whether the name is a (simple-)template-id, and thus; /// we're declaring an explicit / partial specialization / instantiation.; ///; /// \returns true if we cannot safely recover from this error, false otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:583,safe,safely,583,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,2,"['recover', 'safe']","['recover', 'safely']"
Safety,"/// Diagnose a lookup that found results in an enclosing class during error; /// recovery. This usually indicates that the results were found in a dependent; /// base class that could not be searched as part of a template definition.; /// Always issues a diagnostic (though this may be only a warning in MS; /// compatibility mode).; ///; /// Return \c true if the error is unrecoverable, or \c false if the caller; /// should attempt to recover using these lookup results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:81,recover,recovery,81,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,2,['recover'],"['recover', 'recovery']"
Safety,"/// Diagnose a successfully-corrected typo. Separated from the correction; /// itself to allow external validation of the result, etc.; ///; /// \param Correction The result of performing typo correction.; /// \param TypoDiag The diagnostic to produce. This will have the corrected; /// string added to it (and usually also a fixit).; /// \param PrevNote A note to use when indicating the location of the entity to; /// which we are correcting. Will have the correction string added to it.; /// \param ErrorRecovery If \c true (the default), the caller is going to; /// recover from the typo as if the corrected string had been typed.; /// In this case, \c PDiag must be an error, and we will attach a fixit; /// to it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp:570,recover,recover,570,interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLookup.cpp,1,['recover'],['recover']
Safety,/// Diagnose redundant or conflicting nullability information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp:13,redund,redundant,13,interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseObjc.cpp,1,['redund'],['redundant']
Safety,/// Did we abort the visit early?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:11,abort,abort,11,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,1,['abort'],['abort']
Safety,/// DidCallStackSave - Whether llvm.stacksave has been called. Used to avoid; /// calling llvm.stacksave for multiple VLAs in the same scope.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:71,avoid,avoid,71,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['avoid'],['avoid']
Safety,/// Disable crash recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:18,recover,recovery,18,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,1,['recover'],['recovery']
Safety,/// Disable tail call on x86-64. The epilogue code before the tail jump blocks; /// autoreleaseRV/retainRV and autoreleaseRV/unsafeClaimRV optimizations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:125,unsafe,unsafeClaimRV,125,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['unsafe'],['unsafeClaimRV']
Safety,"/// DisableGVCompilation - If called, the JIT will abort if it's asked to; /// allocate space and populate a GlobalVariable that is not internal to; /// the module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:51,abort,abort,51,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['abort'],['abort']
Safety,"/// DisableLazyCompilation - When lazy compilation is off (the default), the; /// JIT will eagerly compile every function reachable from the argument to; /// getPointerToFunction. If lazy compilation is turned on, the JIT will only; /// compile the one function and emit stubs to compile the rest when they're; /// first called. If lazy compilation is turned off again while some lazy; /// stubs are still around, and one of those stubs is called, the program will; /// abort.; ///; /// In order to safely compile lazily in a threaded program, the user must; /// ensure that 1) only one thread at a time can call any particular lazy; /// stub, and 2) any thread modifying LLVM IR must hold the JIT's lock; /// (ExecutionEngine::lock) or otherwise ensure that no other thread calls a; /// lazy stub. See http://llvm.org/PR5184 for details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:470,abort,abort,470,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,2,"['abort', 'safe']","['abort', 'safely']"
Safety,"/// Discriminated union of Pass ID types.; ///; /// The PassConfig API prefers dealing with IDs because they are safer and more; /// efficient. IDs decouple configuration from instantiation. This way, when a; /// pass is overriden, it isn't unnecessarily instantiated. It is also unsafe to; /// refer to a Pass pointer after adding it to a pass manager, which deletes; /// redundant pass instances.; ///; /// However, it is convient to directly instantiate target passes with; /// non-default ctors. These often don't have a registered PassInfo. Rather than; /// force all target passes to implement the pass registry boilerplate, allow; /// the PassConfig API to handle either type.; ///; /// AnalysisID is sadly char*, so PointerIntPair won't work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h:113,safe,safer,113,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetPassConfig.h,3,"['redund', 'safe', 'unsafe']","['redundant', 'safer', 'unsafe']"
Safety,/// Distro - Helper class for detecting and classifying Linux distributions.; ///; /// This class encapsulates the clang Linux distribution detection mechanism; /// as well as helper functions that match the specific (versioned) results; /// into wider distribution classes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Distro.h:30,detect,detecting,30,interpreter/llvm-project/clang/include/clang/Driver/Distro.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Distro.h,2,['detect'],"['detecting', 'detection']"
Safety,"/// Do a breadth first search through the implied hierarchy; /// of branches.; /// To avoid scanning through the list multiple time; /// we also remember the 'depth-first' match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:86,avoid,avoid,86,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['avoid'],['avoid']
Safety,"/// Do last resort, unqualified lookup on a LookupResult that; /// Sema cannot find.; ///; /// \param R a LookupResult that is being recovered.; ///; /// \param S the Scope of the identifier occurrence.; ///; /// \return true to tell Sema to recover using the LookupResult.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h:133,recover,recovered,133,interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,4,['recover'],"['recover', 'recovered']"
Safety,"/// DoPromotion - This method actually performs the promotion of the specified; /// arguments, and returns the new function. At this point, we know that it's; /// safe to do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:163,safe,safe,163,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,1,['safe'],['safe']
Safety,"/// Does an efficient ""scan"" of the sources to detect the presence of; /// preprocessor (or module import) directives and collects the raw lexed tokens; /// for those directives so that the \p Lexer can ""replay"" them when the file is; /// included.; ///; /// Note that the behavior of the raw lexer is affected by the language mode,; /// while at this point we want to do a scan and collect tokens once,; /// irrespective of the language mode that the file will get included in. To; /// compensate for that the \p Lexer, while ""replaying"", will adjust a token; /// where appropriate, when it could affect the preprocessor's state.; /// For example in a directive like; ///; /// \code; /// #if __has_cpp_attribute(clang::fallthrough); /// \endcode; ///; /// The preprocessor needs to see '::' as 'tok::coloncolon' instead of 2; /// 'tok::colon'. The \p Lexer will adjust if it sees consecutive 'tok::colon'; /// while in C++ mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp:47,detect,detect,47,interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/DependencyDirectivesScanner.cpp,1,['detect'],['detect']
Safety,"/// Does the module have any calls to the llvm.experimental.guard intrinsic; /// at all? If this is false, we avoid doing work that will only help if; /// thare are guards present in the IR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:110,avoid,avoid,110,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['avoid'],['avoid']
Safety,"/// Does this SU have a hazard within the current instruction group.; ///; /// The scheduler supports two modes of hazard recognition. The first is the; /// ScheduleHazardRecognizer API. It is a fully general hazard recognizer that; /// supports highly complicated in-order reservation tables; /// (ScoreboardHazardRecognizer) and arbitrary target-specific logic.; ///; /// The second is a streamlined mechanism that checks for hazards based on; /// simple counters that the scheduler itself maintains. It explicitly checks; /// for instruction dispatch limitations, including the number of micro-ops that; /// can dispatch per cycle.; ///; /// TODO: Also check whether the SU must start a new group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:24,hazard,hazard,24,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,8,['hazard'],"['hazard', 'hazards']"
Safety,"/// Does this runtime provide ARC entrypoints that are likely to be faster; /// than an ordinary message send of the appropriate selector?; ///; /// The ARC entrypoints are guaranteed to be equivalent to just sending the; /// corresponding message. If the entrypoint is implemented naively as just a; /// message send, using it is a trade-off: it sacrifices a few cycles of; /// overhead to save a small amount of code. However, it's possible for; /// runtimes to detect and special-case classes that use ""standard""; /// retain/release behavior; if that's dynamically a large proportion of all; /// retained objects, using the entrypoint will also be faster than using a; /// message send.; ///; /// When this method returns true, Clang will turn non-super message sends of; /// certain selectors into calls to the correspond entrypoint:; /// retain => objc_retain; /// release => objc_release; /// autorelease => objc_autorelease",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h:464,detect,detect,464,interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,1,['detect'],['detect']
Safety,"/// Does this runtime provide an objc_terminate function?; ///; /// This is used in handlers for exceptions during the unwind process;; /// without it, abort() must be used in pure ObjC files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h:152,abort,abort,152,interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,1,['abort'],['abort']
Safety,"/// Does this runtime provide entrypoints that are likely to be faster; /// than an ordinary message send of the ""alloc"" selector?; ///; /// The ""alloc"" entrypoint is guaranteed to be equivalent to just sending the; /// corresponding message. If the entrypoint is implemented naively as just a; /// message send, using it is a trade-off: it sacrifices a few cycles of; /// overhead to save a small amount of code. However, it's possible for; /// runtimes to detect and special-case classes that use ""standard""; /// alloc behavior; if that's dynamically a large proportion of all; /// objects, using the entrypoint will also be faster than using a message; /// send.; ///; /// When this method returns true, Clang will turn non-super message sends of; /// certain selectors into calls to the corresponding entrypoint:; /// alloc => objc_alloc; /// allocWithZone:nil => objc_allocWithZone",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h:458,detect,detect,458,interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/ObjCRuntime.h,1,['detect'],['detect']
Safety,/// Drive the analysis of interleaved memory accesses in the loop.; ///; /// Use this class to analyze interleaved accesses only when we can vectorize; /// a loop. Otherwise it's meaningless to do analysis as the vectorization; /// on interleaved accesses is unsafe.; ///; /// The analysis collects interleave groups and records the relationships; /// between the member and the group in a map.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:259,unsafe,unsafe,259,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,1,['unsafe'],['unsafe']
Safety,"/// Dual division/remainder interface.; ///; /// Sometimes it is convenient to divide two APInt values and obtain both the; /// quotient and remainder. This function does both operations in the same; /// computation making it a little more efficient. The pair of input arguments; /// may overlap with the pair of output arguments. It is safe to call; /// udivrem(X, Y, X, Y), for example.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:337,safe,safe,337,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['safe'],['safe']
Safety,"/// During lowering new call nodes can be created (such as memset, etc.).; /// Those will become new roots of the current DAG, but complications arise; /// when they are tail calls. In such cases, the call lowering will update; /// the root, but the builder still needs to know that a tail call has been; /// lowered in order to avoid generating an additional return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp:329,avoid,avoid,329,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp,1,['avoid'],['avoid']
Safety,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in the direction of movement, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:158,hazard,hazards,158,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,2,"['hazard', 'interlock']","['hazards', 'interlocks']"
Safety,"/// Each Scheduling boundary is associated with ready queues. It tracks the; /// current cycle in whichever direction at has moved, and maintains the state; /// of ""hazards"" and other interlocks at the current cycle.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h:165,hazard,hazards,165,interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/VLIWMachineScheduler.h,2,"['hazard', 'interlock']","['hazards', 'interlocks']"
Safety,/// Eliminate redundant type cast between integer and float.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:14,redund,redundant,14,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['redund'],['redundant']
Safety,"/// Eliminates partially redundant \p Load, replacing it with \p; /// AvailableLoads (connected by Phis if needed).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h:25,redund,redundant,25,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/GVN.h,1,['redund'],['redundant']
Safety,/// Emit a write hazard at the current location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:17,hazard,hazard,17,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['hazard'],['hazard']
Safety,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:282,recover,recover,282,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['recover'],['recover']
Safety,"/// Emit read hazards in all the protected blocks, i.e. all the blocks; /// which have been inserted since the beginning of the try.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp:14,hazard,hazards,14,interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp,1,['hazard'],['hazards']
Safety,"/// Emit something like "".long Hi-Lo"" where the size in bytes of the directive; /// is specified by Size and Hi/Lo specify the labels. This implicitly uses; /// .set if it avoids relocations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:172,avoid,avoids,172,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['avoid'],['avoids']
Safety,"/// Emit the result of the given expression as an abstract constant,; /// asserting that it succeeded. This is only safe to do when the; /// expression is known to be a constant expression with either a fairly; /// simple type or a known simple form.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ConstantEmitter.h:116,safe,safe,116,interpreter/llvm-project/clang/lib/CodeGen/ConstantEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/ConstantEmitter.h,1,['safe'],['safe']
Safety,"/// Emit the unified return block, trying to avoid its emission when; /// possible.; /// \return The debug location of the user written return statement if the; /// return block is avoided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:45,avoid,avoid,45,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,2,['avoid'],"['avoid', 'avoided']"
Safety,"/// EmitARCUnsafeUnretainedScalarExpr - Semantically equivalent to; /// immediately releasing the resut of EmitARCRetainScalarExpr, but; /// avoiding any spurious retains, including by performing reclaims; /// with objc_unsafeClaimAutoreleasedReturnValue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:141,avoid,avoiding,141,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['avoid'],['avoiding']
Safety,"/// EmitBranch - Emit a branch to the specified basic block from the current; /// insert block, taking care to avoid creation of branches from dummy; /// blocks. It is legal to call this function even if there is no current; /// insertion point.; ///; /// This function clears the current insertion point. The caller should follow; /// calls to this function with calls to Emit*Block prior to generation new; /// code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:111,avoid,avoid,111,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['avoid'],['avoid']
Safety,"/// EmitInstruction - This callback is invoked when an instruction is; /// emitted, to advance the hazard state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:99,hazard,hazard,99,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['hazard'],['hazard']
Safety,/// EmitIntValue - Special case of EmitValue that avoids the client having to; /// pass in a MCExpr for constant integers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp:50,avoid,avoids,50,interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,1,['avoid'],['avoids']
Safety,/// EmitSLEB128IntValue - Special case of EmitSLEB128Value that avoids the; /// client having to pass in a MCExpr for constant integers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp:64,avoid,avoids,64,interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,1,['avoid'],['avoids']
Safety,/// EmitULEB128IntValue - Special case of EmitULEB128Value that avoids the; /// client having to pass in a MCExpr for constant integers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp:64,avoid,avoids,64,interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCStreamer.cpp,1,['avoid'],['avoids']
Safety,"/// Emits the label used with llvm.eh.recoverfp, which is used by; /// outlined funclets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h:38,recover,recoverfp,38,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/WinException.h,1,['recover'],['recoverfp']
Safety,/// Enable abort calls when global instruction selection fails to lower/select; /// an instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:11,abort,abort,11,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['abort'],['abort']
Safety,/// Enable crash recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:17,recover,recovery,17,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,1,['recover'],['recovery']
Safety,/// Enable spillage copy elimination in MachineCopyPropagation pass. This; /// helps removing redundant copies generated by register allocator when; /// handling complex eviction chains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h:94,redund,redundant,94,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetSubtargetInfo.h,1,['redund'],['redundant']
Safety,/// Enable store-to-load forwarding conflict detection. This option can; /// be disabled for correctness testing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp:45,detect,detection,45,interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LoopAccessAnalysis.cpp,1,['detect'],['detection']
Safety,/// EnableGlobalISelAbort - Control abort behaviour when global instruction; /// selection fails to lower/select an instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:36,abort,abort,36,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,1,['abort'],['abort']
Safety,/// Enables or disables whether ANSI escape sequences are used to output; /// colors. This only has an effect on Windows.; /// Note: Setting this option is not thread-safe and should only be done; /// during initialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:167,safe,safe,167,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,1,['safe'],['safe']
Safety,"/// End part of this FunctionDecl's source range.; ///; /// We could compute the full range in getSourceRange(). However, when we're; /// dealing with a function definition deserialized from a PCH/AST file,; /// we can only compute the full range once the function body has been; /// de-serialized, so it's far better to have the (sometimes-redundant); /// EndRangeLoc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:341,redund,redundant,341,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['redund'],['redundant']
Safety,"/// EnsureInsertPoint - Ensure that an insertion point is defined so that; /// emitted IR has a place to go. Note that by definition, if this function; /// creates a block then that block is unreachable; callers may do better to; /// detect when no insertion point is defined and simply skip IR generation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:234,detect,detect,234,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['detect'],['detect']
Safety,"/// Ensures that the value has the required type, by inserting a bitcast if; /// required. This function lets us avoid inserting bitcasts that are; /// redundant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:113,avoid,avoid,113,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"/// Enumerate reachable metadata in (almost) post-order.; ///; /// Enumerate all the metadata reachable from MD. We want to minimize the; /// cost of reading bitcode records, and so the primary consideration is that; /// operands of uniqued nodes are resolved before the nodes are read. This; /// avoids re-uniquing them on the context and factors away RAUW support.; ///; /// This algorithm guarantees that subgraphs of uniqued nodes are in; /// post-order. Distinct subgraphs reachable only from a single uniqued node; /// will be in post-order.; ///; /// \note The relative order of a distinct and uniqued node is irrelevant.; /// \a organizeMetadata() will later partition distinct nodes ahead of; /// uniqued ones.; ///{",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h:297,avoid,avoids,297,interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Bitcode/Writer/ValueEnumerator.h,2,['avoid'],['avoids']
Safety,/// EnumerationMutationFunction - Return the function that's called by the; /// compiler when a mutation is detected during foreach iteration.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h:108,detect,detected,108,interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCRuntime.h,1,['detect'],['detected']
Safety,/// Erase \p V from \p BB and move \II forward to avoid invalidating; /// iterators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:50,avoid,avoid,50,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['avoid'],['avoid']
Safety,"/// Evaluate the result of an add between (conceptually) two MCValues.; ///; /// This routine conceptually attempts to construct an MCValue:; /// Result = (Result_A - Result_B + Result_Cst); /// from two MCValue's LHS and RHS where; /// Result = LHS + RHS; /// and; /// Result = (LHS_A - LHS_B + LHS_Cst) + (RHS_A - RHS_B + RHS_Cst).; ///; /// This routine attempts to aggressively fold the operands such that the result; /// is representable in an MCValue, but may not always succeed.; ///; /// \returns True on success, false if the result is not representable in an; /// MCValue.; /// NOTE: It is really important to have both the Asm and Layout arguments.; /// They might look redundant, but this function can be used before layout; /// is done (see the object streamer for example) and having the Asm argument; /// lets us avoid relaxations early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp:681,redund,redundant,681,interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCExpr.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"/// EvaluateDirectiveSubExpr - Evaluate the subexpression whose first token is; /// PeekTok, and whose precedence is PeekPrec. This returns the result in LHS.; ///; /// If ValueLive is false, then this value is being evaluated in a context where; /// the result is not used. As such, avoid diagnostics that relate to; /// evaluation, such as division by zero warnings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:284,avoid,avoid,284,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,1,['avoid'],['avoid']
Safety,"/// EvaluateValue - Evaluate the token PeekTok (and any others needed) and; /// return the computed value in Result. Return true if there was an error; /// parsing. This function also returns information about the form of the; /// expression in DT. See above for information on what DT means.; ///; /// If ValueLive is false, then this value is being evaluated in a context where; /// the result is not used. As such, avoid diagnostics that relate to; /// evaluation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp:418,avoid,avoid,418,interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PPExpressions.cpp,1,['avoid'],['avoid']
Safety,"/// Exception safe assignment operator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:14,safe,safe,14,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,1,['safe'],['safe']
Safety,"/// Exception safe swap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h:14,safe,safe,14,tree/treeplayer/inc/TFormLeafInfoReference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/inc/TFormLeafInfoReference.h,1,['safe'],['safe']
Safety,"/// Exchange the two operands to this instruction.; /// This instruction is safe to use on any binary instruction and; /// does not modify the semantics of the instruction. If the instruction; /// cannot be reversed (ie, it's a Div), then return true.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h:76,safe,safe,76,interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/InstrTypes.h,1,['safe'],['safe']
Safety,"/// Execution the given code ""safely"", using crash recovery or safety; /// threads when possible.; ///; /// \return False if a crash was detected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:30,safe,safely,30,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h,4,"['detect', 'recover', 'safe']","['detected', 'recovery', 'safely', 'safety']"
Safety,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:587,avoid,avoid,587,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,2,['avoid'],"['avoid', 'avoiding']"
Safety,"/// Expand pseudo Int-to-FP conversion instructions.; ///; /// For example, the following pseudo instruction; /// PseudoCVT_D32_W D2, A5; /// gets expanded into these two instructions:; /// MTC1 F4, A5; /// CVT_D32_W D2, F4; ///; /// We do this expansion post-RA to avoid inserting a floating point copy; /// instruction between MTC1 and CVT_D32_W.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h:266,avoid,avoid,266,interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsSEInstrInfo.h,1,['avoid'],['avoid']
Safety,"/// Expands raw code, replacing things such as `${foo}` with their; /// substitution in \p CE.; ///; /// \param CE Map of Code Expansions; /// \param Locs SMLocs for the Code Expander, in case it needs to emit; /// diagnostics.; /// \param AddComment Optionally called to emit a comment before the expanded; /// code.; ///; /// \return A CXXPredicateCode object that contains the expanded code. Note; /// that this may or may not insert a new object. All CXXPredicateCode objects; /// are held in a set to avoid emitting duplicate C++ code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/Patterns.h:506,avoid,avoid,506,interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/Patterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISel/Patterns.h,1,['avoid'],['avoid']
Safety,"/// ExpectAndConsume - The parser expects that 'ExpectedTok' is next in the; /// input. If so, it is consumed and false is returned.; ///; /// If a trivial punctuator misspelling is encountered, a FixIt error; /// diagnostic is issued and false is returned after recovery.; ///; /// If the input is malformed, this emits the specified diagnostic and true is; /// returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:263,recover,recovery,263,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['recover'],['recovery']
Safety,"/// Explicitly record a dependence from \p FromAA to \p ToAA, that is if; /// \p FromAA changes \p ToAA should be updated as well.; ///; /// This method should be used in conjunction with the `getAAFor` method and; /// with the DepClass enum passed to the method set to None. This can; /// be beneficial to avoid false dependences but it requires the users of; /// `getAAFor` to explicitly record true dependences through this method.; /// The \p DepClass flag indicates if the dependence is striclty necessary.; /// That means for required dependences, if \p FromAA changes to an invalid; /// state, \p ToAA can be moved to a pessimistic fixpoint because it required; /// information from \p FromAA but none are available anymore.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:307,avoid,avoid,307,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['avoid'],['avoid']
Safety,"/// Explicitly trigger a crash recovery in the current process, and; /// return failure from RunSafely(). This function does not return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:31,recover,recovery,31,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,1,['recover'],['recovery']
Safety,/// Extra wait hazard is needed in some cases before; /// s_cbranch_vccnz/s_cbranch_vccz.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:15,hazard,hazard,15,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['hazard'],['hazard']
Safety,/// FAddCombine is the class for optimizing an unsafe fadd/fsub along; /// with its neighboring at most two instructions.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp:47,unsafe,unsafe,47,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp,1,['unsafe'],['unsafe']
Safety,"/// Fetches any debuginfod artifact using the specified local cache directory,; /// server URLs, and request timeout (in milliseconds). If the artifact is; /// found, uses the UniqueKey for the local cache file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h:109,timeout,timeout,109,interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,1,['timeout'],['timeout']
Safety,"/// Figure out if an expression could be turned into a call.; ///; /// Use this when trying to recover from an error where the programmer may have; /// written just the name of a function instead of actually calling it.; ///; /// \param E - The expression to examine.; /// \param ZeroArgCallReturnTy - If the expression can be turned into a call; /// with no arguments, this parameter is set to the type returned by such a; /// call; otherwise, it is set to an empty QualType.; /// \param OverloadSet - If the expression is an overloaded function; /// name, this parameter is populated with the decls of the various overloads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp:95,recover,recover,95,interpreter/llvm-project/clang/lib/Sema/Sema.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/Sema.cpp,1,['recover'],['recover']
Safety,/// Filled - Indicate whether the buffer has been completely; /// filled. This helps avoid garbage output.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/circular_raw_ostream.h:85,avoid,avoid,85,interpreter/llvm-project/llvm/include/llvm/Support/circular_raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/circular_raw_ostream.h,1,['avoid'],['avoid']
Safety,/// Filter out checks between pointers from the same partition.; ///; /// \p PtrToPartition contains the partition number for pointers. Partition; /// number -1 means that the pointer is used in multiple partitions. In this; /// case we can't safely omit the check.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:243,safe,safely,243,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,1,['safe'],['safely']
Safety,"/// Filter out potentially dead comdat functions where other entries keep the; /// entire comdat group alive.; ///; /// This is designed for cases where functions appear to become dead but remain; /// alive due to other live entries in their comdat group.; ///; /// The \p DeadComdatFunctions container should only have pointers to; /// `Function`s which are members of a comdat group and are believed to be; /// dead.; ///; /// After this routine finishes, the only remaining `Function`s in \p; /// DeadComdatFunctions are those where every member of the comdat is listed; /// and thus removing them is safe (provided *all* are removed).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h:604,safe,safe,604,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ModuleUtils.h,1,['safe'],['safe']
Safety,"/// Find a point at which the widened condition of \p Guard should be inserted.; /// When it is represented as intrinsic call, we can do it right before the call; /// instruction. However, when we are dealing with widenable branch, we must; /// account for the following situation: widening should not turn a; /// loop-invariant condition into a loop-variant. It means that if; /// widenable.condition() call is invariant (w.r.t. any loop), the new wide; /// condition should stay invariant. Otherwise there can be a miscompile, like; /// the one described at https://github.com/llvm/llvm-project/issues/60234. The; /// safest way to do it is to expand the new condition at WC's block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp:620,safe,safest,620,interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/GuardWidening.cpp,1,['safe'],['safest']
Safety,"/// Find a point in code which dominates all given instructions. We can safely; /// assume that, whatever fact we can prove at the found point, this fact is; /// also true for each of the given instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:72,safe,safely,72,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['safe'],['safely']
Safety,/// Find all VK_TLSGD/VK_TLSLD symbol references in expression and replace; /// them by VK_PPC_TLSGD/VK_PPC_TLSLD. This is necessary to avoid having; /// _GLOBAL_OFFSET_TABLE_ created via ELFObjectWriter::RelocNeedsGOT.; /// FIXME: This is a hack.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp:136,avoid,avoid,136,interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/AsmParser/PPCAsmParser.cpp,1,['avoid'],['avoid']
Safety,"/// Find matching pairs of integer div/rem ops (they have the same numerator,; /// denominator, and signedness). If they exist in different basic blocks, bring; /// them together by hoisting or replace the common division operation that is; /// implicit in the remainder:; /// X % Y <--> X - ((X / Y) * Y).; ///; /// We can largely ignore the normal safety and cost constraints on speculation; /// of these ops when we find a matching pair. This is because we are already; /// guaranteed that any exceptions and most cost are already incurred by the; /// first member of the pair.; ///; /// Note: This transform could be an oddball enhancement to EarlyCSE, GVN, or; /// SimplifyCFG, but it's split off on its own because it's different enough; /// that it doesn't quite match the stated objectives of those passes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp:350,safe,safety,350,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DivRemPairs.cpp,1,['safe'],['safety']
Safety,"/// Find the first executable file \p Name in \p Paths.; ///; /// This does not perform hashing as a shell would but instead stats each PATH; /// entry individually so should generally be avoided. Core LLVM library; /// functions and options should instead require fully specified paths.; ///; /// \param Name name of the executable to find. If it contains any system; /// slashes, it will be returned as is.; /// \param Paths optional list of paths to search for \p Name. If empty it; /// will use the system PATH environment instead.; ///; /// \returns The fully qualified path to the first \p Name in \p Paths if it; /// exists. \p Name if \p Name has slashes in it. Otherwise an error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:188,avoid,avoided,188,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['avoid'],['avoided']
Safety,/// Find the minimum FP type we can safely truncate to.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:36,safe,safely,36,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['safe'],['safely']
Safety,/// Find the set of basic blocks that are reachable from \p Start without the; /// basic block \p Avoid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/BlockCoverageInference.h:98,Avoid,Avoid,98,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/BlockCoverageInference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/BlockCoverageInference.h,1,['Avoid'],['Avoid']
Safety,"/// Find the underlying defining instruction / operand for a COPY instruction; /// while in SSA form. Copies do not actually define values -- they move them; /// between registers. Labelling a COPY-like instruction with an instruction; /// number is to be avoided as it makes value numbers non-unique later in; /// compilation. This method follows the definition chain for any sequence of; /// COPY-like instructions to find whatever non-COPY-like instruction defines; /// the copied value; or for parameters, creates a DBG_PHI on entry.; /// May insert instructions into the entry block!; /// \p MI The copy-like instruction to salvage.; /// \p DbgPHICache A container to cache already-solved COPYs.; /// \returns An instruction/operand pair identifying the defining value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:256,avoid,avoided,256,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['avoid'],['avoided']
Safety,"/// FindCallSeqStart - Starting from the (lowered) CALLSEQ_END node, locate; /// the corresponding (lowered) CALLSEQ_BEGIN node.; ///; /// NestLevel and MaxNested are used in recursion to indcate the current level; /// of nesting of CALLSEQ_BEGIN and CALLSEQ_END pairs, as well as the maximum; /// level seen so far.; ///; /// TODO: It would be better to give CALLSEQ_END an explicit operand to point; /// to the corresponding CALLSEQ_BEGIN to avoid needing to search for it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:444,avoid,avoid,444,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['avoid'],['avoid']
Safety,"/// Finds a default timeout for debuginfod HTTP requests. Checks; /// DEBUGINFOD_TIMEOUT environment variable, default is 90 seconds (90000 ms).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h:20,timeout,timeout,20,interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/Debuginfod.h,1,['timeout'],['timeout']
Safety,/// Finds the transitive closure of symbols within the given region.; ///; /// Returns false if the visitor aborted the scan.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/Store.h:108,abort,aborted,108,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/Store.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/Store.h,1,['abort'],['aborted']
Safety,"/// Finish checking all of the structural equivalences.; ///; /// \returns true if the equivalence check failed (non-equivalence detected),; /// false if equivalence was detected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h:129,detect,detected,129,interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTStructuralEquivalence.h,2,['detect'],['detected']
Safety,"/// Fit a parabola, where parameters are set up such that negative function values are obtained.; /// The minimiser needs to recover from that.; /// Test also that when recovery with NaN packing is switched off, the minimiser fails to recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:125,recover,recover,125,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,3,['recover'],"['recover', 'recovery']"
Safety,"/// Fix list of lists before merging (to avoid errors about duplicated objects)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMP.cxx:41,avoid,avoid,41,tree/treeplayer/src/TTreeProcessorMP.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeProcessorMP.cxx,1,['avoid'],['avoid']
Safety,"/// Fixable gadgets correspond to code patterns that aren't always unsafe but need to be; /// properly recognized in order to emit fixes. For example, if a raw pointer-type; /// variable is replaced by a safe C++ container, every use of such variable must be; /// carefully considered and possibly updated.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:67,unsafe,unsafe,67,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"/// Flag indicating if Sema is building a recovery call expression.; ///; /// This flag is used to avoid building recovery call expressions; /// if Sema is already doing so, which would cause infinite recursions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:42,recover,recovery,42,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,3,"['avoid', 'recover']","['avoid', 'recovery']"
Safety,"/// Fold (icmp Pred1 V1, C1) & (icmp Pred2 V2, C2); /// or (icmp Pred1 V1, C1) | (icmp Pred2 V2, C2); /// into a single comparison using range-based reasoning.; /// NOTE: This is also used for logical and/or, must be poison-safe!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:224,safe,safe,224,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safe']
Safety,"/// Fold (icmp eq ctpop(X) 1) | (icmp eq X 0) into (icmp ult ctpop(X) 2) and; /// fold (icmp ne ctpop(X) 1) & (icmp ne X 0) into (icmp ugt ctpop(X) 1).; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:202,safe,safe,202,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safe']
Safety,"/// Fold (icmp)&(icmp) or (icmp)|(icmp) if possible.; /// If IsLogical is true, then the and/or is in select form and the transform; /// must be poison-safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:152,safe,safe,152,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safe']
Safety,/// For \p E referring to a ref-countable/-counted pointer/reference we return; /// whether it's a safe call argument. Examples: function parameter or; /// this-pointer. The logic relies on the set of recursive rules we enforce for; /// WebKit codebase.; ///; /// \returns Whether \p E is a safe call arugment.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:99,safe,safe,99,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,2,['safe'],['safe']
Safety,"/// For a shared lock, wait until the owner releases the lock.; /// Total timeout for the file to appear is ~1.5 minutes.; /// \param MaxSeconds the maximum total wait time in seconds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h:74,timeout,timeout,74,interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h,1,['timeout'],['timeout']
Safety,"/// For all PatFragPatterns, add a new entry in PatternAlternatives for each; /// PatternList it contains. This is multiplicative, so if we have 2; /// PatFrags with 3 alternatives each, we get 2*3 permutations added to; /// PermutationsToEmit. The ""MaxPermutations"" field controls how many; /// permutations are allowed before an error is emitted and this function; /// returns false. This is a simple safeguard to prevent combination of; /// PatFrags from generating enormous amounts of rules.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp:403,safe,safeguard,403,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelCombinerEmitter.cpp,1,['safe'],['safeguard']
Safety,"/// For all of the arithmetic operators provided here any invalid state is; /// perpetuated and cannot be removed. Once a cost becomes invalid it stays; /// invalid, and it also inherits any invalid state from the RHS.; /// Arithmetic work on the actual values is implemented with saturation,; /// to avoid overflow when using more extreme cost values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/InstructionCost.h:301,avoid,avoid,301,interpreter/llvm-project/llvm/include/llvm/Support/InstructionCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/InstructionCost.h,1,['avoid'],['avoid']
Safety,"/// For copy B = A in BB2, if A is defined by A = B in BB0 which is a; /// predecessor of BB2, and if B is not redefined on the way from A = B; /// in BB0 to B = A in BB2, B = A in BB2 is partially redundant if the; /// execution goes through the path from BB0 to BB2. We may move B = A; /// to the predecessor without such reversed copy.; /// So we will transform the program from:; /// BB0:; /// A = B; BB1:; /// ... ...; /// / \ /; /// BB2:; /// ...; /// B = A;; ///; /// to:; ///; /// BB0: BB1:; /// A = B; ...; /// ... B = A;; /// / \ /; /// BB2:; /// ...; ///; /// A special case is when BB0 and BB2 are the same BB which is the only; /// BB in a loop:; /// BB1:; /// ...; /// BB0/BB2: ----; /// B = A; |; /// ... |; /// A = B; |; /// |-------; /// |; /// We may hoist B = A from BB0/BB2 to BB1.; ///; /// The major preconditions for correctness to remove such partial; /// redundancy include:; /// 1. A in B = A in BB2 is defined by a PHI in BB2, and one operand of; /// the PHI is defined by the reversed copy A = B in BB0.; /// 2. No B is referenced from the start of BB2 to B = A.; /// 3. No B is defined from A = B to the end of BB0.; /// 4. BB1 has only one successor.; ///; /// 2 and 4 implicitly ensure B is not live at the end of BB1.; /// 4 guarantees BB2 is hotter than BB1, so we can only move a copy to a; /// colder place, which not only prevent endless loop, but also make sure; /// the movement of copy is beneficial.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:198,redund,redundant,198,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,2,['redund'],"['redundancy', 'redundant']"
Safety,"/// For each memory instruction, this class maintains difference of the; /// number of unsafe dependences that start out from this instruction minus; /// those that end here.; ///; /// By traversing the memory instructions in program order and accumulating this; /// number, we know whether any unsafe dependence crosses over a program point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp:87,unsafe,unsafe,87,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDistribute.cpp,2,['unsafe'],['unsafe']
Safety,"/// For each operand we need (i) the value, and (ii) the opcode that it; /// would be attached to if the expression was in a left-linearized form.; /// This is required to avoid illegal operand reordering.; /// For example:; /// \verbatim; /// 0 Op1; /// |/; /// Op1 Op2 Linearized + Op2; /// \ / ----------> |/; /// - -; ///; /// Op1 - Op2 (0 + Op1) - Op2; /// \endverbatim; ///; /// Value Op1 is attached to a '+' operation, and Op2 to a '-'.; ///; /// Another way to think of this is to track all the operations across the; /// path from the operand all the way to the root of the tree and to; /// calculate the operation that corresponds to this path. For example, the; /// path from Op2 to the root crosses the RHS of the '-', therefore the; /// corresponding operation is a '-' (which matches the one in the; /// linearized tree, as shown above).; ///; /// For lack of a better term, we refer to this operation as Accumulated; /// Path Operation (APO).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:172,avoid,avoid,172,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"/// For every itinerary, an ""action"" to apply to the automaton. This removes; /// the redundancy in actions between itinerary classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:86,redund,redundancy,86,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,1,['redund'],['redundancy']
Safety,"/// For reclaims, perform an unsafeClaim if that's enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:29,unsafe,unsafeClaim,29,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['unsafe'],['unsafeClaim']
Safety,"/// For spills with equal values, remove redundant spills and hoist those left; /// to less hot spots.; ///; /// Spills with equal values will be collected into the same set in; /// MergeableSpills when spill is inserted. These equal spills are originated; /// from the same defining instruction and are dominated by the instruction.; /// Before hoisting all the equal spills, redundant spills inside in the same; /// BB are first marked to be deleted. Then starting from the spills left, walk; /// up on the dominator tree towards the Root node where the define instruction; /// is located, mark the dominated spills to be deleted along the way and; /// collect the BB nodes on the path from non-dominated spills to the define; /// instruction into a WorkSet. The nodes in WorkSet are the candidate places; /// where we are considering to hoist the spills. We iterate the WorkSet in; /// bottom-up order, and for each node, we will decide whether to hoist spills; /// inside its subtree to that node. In this way, we can get benefit locally; /// even if hoisting all the equal spills to one cold place is impossible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:41,redund,redundant,41,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,2,['redund'],['redundant']
Safety,/// For the comparison operators we have chosen to use lexicographical; /// ordering where valid costs are always considered to be less than invalid; /// costs. This avoids having to add asserts to the comparison operators that; /// the states are valid and users can test for validity of the cost; /// explicitly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/InstructionCost.h:166,avoid,avoids,166,interpreter/llvm-project/llvm/include/llvm/Support/InstructionCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/InstructionCost.h,1,['avoid'],['avoids']
Safety,"/// For the given DC, return the DC that is safe to perform lookups on. This is; /// the DC we actually want to work with most of the time.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp:44,safe,safe,44,interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ExternalASTMerger.cpp,1,['safe'],['safe']
Safety,"/// Forbid to convert from Error::success() implicitly, this avoids having; /// Expected<T> foo() { return Error::success(); } which compiles otherwise; /// but triggers the assertion above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:61,avoid,avoids,61,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['avoid'],['avoids']
Safety,/// FormSVEBuiltinResult - Returns the struct of scalable vectors as a wider; /// vector. It extracts the scalable vector from the struct and inserts into; /// the wider vector. This avoids the error when allocating space in llvm; /// for struct of scalable vectors if a function returns struct.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:183,avoid,avoids,183,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['avoid'],['avoids']
Safety,"/// FormattedArgs - Keep track of all of the arguments formatted by; /// ConvertArgToString and pass them into subsequent calls to; /// ConvertArgToString, allowing the implementation to avoid redundancies in; /// obvious cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp:187,avoid,avoid,187,interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Basic/Diagnostic.cpp,2,"['avoid', 'redund']","['avoid', 'redundancies']"
Safety,/// Frames modifying the state as defined in \c wasModifiedBeforeCallExit.; /// This visitor generates a note only if a function does *not* change the; /// state that way. This information is not immediately available; /// by looking at the node associated with the exit from the function; /// (usually the return statement). To avoid recomputing the same information; /// many times (going up the path for each node and checking whether the; /// region was written into) we instead lazily compute the stack frames; /// along the path.; // TODO: Can't we just use a map instead? This is likely not as cheap as it; // makes the code difficult to read.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h:329,avoid,avoid,329,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,1,['avoid'],['avoid']
Safety,"/// Frontend produces RecoveryExprs on semantic errors that prevent creating; /// other well-formed expressions. E.g. when type-checking of a binary operator; /// fails, we cannot produce a BinaryOperator expression. Instead, we can choose; /// to produce a recovery expression storing left and right operands.; ///; /// RecoveryExpr does not have any semantic meaning in C++, it is only useful to; /// preserve expressions in AST that would otherwise be dropped. It captures; /// subexpressions of some expression that we could not construct and source; /// range covered by the expression.; ///; /// By default, RecoveryExpr uses dependence-bits to take advantage of existing; /// machinery to deal with dependent code in C++, e.g. RecoveryExpr is preserved; /// in `decltype(<broken-expr>)` as part of the `DependentDecltypeType`. In; /// addition to that, clang does not report most errors on dependent; /// expressions, so we get rid of bogus errors for free. However, note that; /// unlike other dependent expressions, RecoveryExpr can be produced in; /// non-template contexts.; ///; /// We will preserve the type in RecoveryExpr when the type is known, e.g.; /// preserving the return type for a broken non-overloaded function call, a; /// overloaded call where all candidates have the same return type. In this; /// case, the expression is not type-dependent (unless the known type is itself; /// dependent); ///; /// One can also reliably suppress all bogus errors on expressions containing; /// recovery expressions by examining results of Expr::containsErrors().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:22,Recover,RecoveryExprs,22,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,8,"['Recover', 'recover']","['RecoveryExpr', 'RecoveryExprs', 'recovery']"
Safety,/// Function called if fast enumeration detects that the collection is; /// modified during the update.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:40,detect,detects,40,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['detect'],['detects']
Safety,"/// FunctionDecls and SourceLocations for which CheckCUDACall has emitted a; /// (maybe deferred) ""bad call"" diagnostic. We use this to avoid emitting the; /// same deferred diag twice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:136,avoid,avoid,136,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avoid'],['avoid']
Safety,"/// Functions that attempt to perform the combining. They detect if that is; /// legal, and if so they update the inputs \a Inputs and the offload action; /// that were collapsed in \a CollapsedOffloadAction. A tool that deals with; /// the combined action is returned. If the combining is not legal or if the; /// tool does not exist, null is returned.; /// Currently three kinds of collapsing are supported:; /// - Assemble + Backend + Compile;; /// - Assemble + Backend ;; /// - Backend + Compile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp:58,detect,detect,58,interpreter/llvm-project/clang/lib/Driver/Driver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/Driver.cpp,1,['detect'],['detect']
Safety,"/// Fuse two fusion candidates, creating a new fused loop.; ///; /// This method contains the mechanics of fusing two loops, represented by \p; /// FC0 and \p FC1. It is assumed that \p FC0 dominates \p FC1 and \p FC1; /// postdominates \p FC0 (making them control flow equivalent). It also; /// assumes that the other conditions for fusion have been met: adjacent,; /// identical trip counts, and no negative distance dependencies exist that; /// would prevent fusion. Thus, there is no checking for these conditions in; /// this method.; ///; /// Fusion is performed by rewiring the CFG to update successor blocks of the; /// components of tho loop. Specifically, the following changes are done:; ///; /// 1. The preheader of \p FC1 is removed as it is no longer necessary; /// (because it is currently only a single statement block).; /// 2. The latch of \p FC0 is modified to jump to the header of \p FC1.; /// 3. The latch of \p FC1 i modified to jump to the header of \p FC0.; /// 4. All blocks from \p FC1 are removed from FC1 and added to FC0.; ///; /// All of these modifications are done with dominator tree updates, thus; /// keeping the dominator (and post dominator) information up-to-date.; ///; /// This can be improved in the future by actually merging blocks during; /// fusion. For example, the preheader of \p FC1 can be merged with the; /// preheader of \p FC0. This would allow loops with more than a single; /// statement in the preheader to be fused. Similarly, the latch blocks of the; /// two loops could also be fused into a single block. This will require; /// analysis to prove it is safe to move the contents of the block past; /// existing code, which currently has not been implemented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp:1612,safe,safe,1612,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopFuse.cpp,1,['safe'],['safe']
Safety,"/// GCMachineCodeAnalysis - Target-independent pass to mark safe points; /// in machine code. Must be added very late during code generation, just; /// prior to output, and importantly after all CFG transformations (such as; /// branch folding).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:60,safe,safe,60,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['safe'],['safe']
Safety,/// GCMachineCodeAnalysis - This is a target-independent pass over the machine; /// function representation to identify safe points for the garbage collector; /// in the machine code. It inserts labels at safe points and populates a; /// GCMetadata record for each function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:120,safe,safe,120,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,2,['safe'],['safe']
Safety,/// GCPoint - Metadata for a collector-safe point in machine code.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:39,safe,safe,39,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,1,['safe'],['safe']
Safety,/// Generate (x & ~(y-1)) to align down or ((x+(y-1)) & ~(y-1)) to align up.; /// Note: For pointer types we can avoid ptrtoint/inttoptr pairs by using the; /// llvm.ptrmask intrinsic (with a GEP before in the align_up case).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp:113,avoid,avoid,113,interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGBuiltin.cpp,1,['avoid'],['avoid']
Safety,/// Generate code to restore the stack after all stack restore points; /// in \p StackRestorePoints.; ///; /// \returns A local variable in which to maintain the dynamic top of the; /// unsafe stack if needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:186,unsafe,unsafe,186,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,1,['unsafe'],['unsafe']
Safety,/// Generate the IR code for the vectorized loop captured in VPlan \p BestPlan; /// according to the best selected \p VF and \p UF.; ///; /// TODO: \p IsEpilogueVectorization is needed to avoid issues due to epilogue; /// vectorization re-using plans for both the main and epilogue vector loops.; /// It should be removed once the re-use issue has been fixed.; /// \p ExpandedSCEVs is passed during execution of the plan for epilogue loop; /// to re-use expansion results generated during main plan execution.; ///; /// Returns a mapping of SCEVs to their expanded IR values and a mapping for; /// the reduction resume values. Note that this is a temporary workaround; /// needed due to the current epilogue handling.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:188,avoid,avoid,188,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,1,['avoid'],['avoid']
Safety,/// Generates key/subkey pair for the given value to provide effective sorting; /// of the values and better detection of the vectorizable values sequences. The; /// keys/subkeys can be used for better sorting of the values themselves (keys); /// and in values subgroups (subkeys).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:109,detect,detection,109,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['detect'],['detection']
Safety,"/// Generic lowering of v16i8 shuffles.; ///; /// This is a hybrid strategy to lower v16i8 vectors. It first attempts to; /// detect any complexity reducing interleaving. If that doesn't help, it uses; /// UNPCK to spread the i8 elements across two i16-element vectors, and uses; /// the existing lowering for v8i16 blends on each half, finally PACK-ing them; /// back together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:126,detect,detect,126,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detect']
Safety,"/// Get a canonical UDivExpr for a recurrence.; /// {X,+,N}/C => {Y,+,N}/C where Y=X-(X%N). Safe when C%N=0.; // We can currently only fold X%N if X is constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:92,Safe,Safe,92,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['Safe'],['Safe']
Safety,"/// Get a global palette by name. Returns an empty palette if no palette with that name is known.; /// This function is not thread safe; any concurrent call to global Palette manipulation must be synchronized!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPalette.hxx:131,safe,safe,131,graf2d/gpadv7/inc/ROOT/RPalette.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpadv7/inc/ROOT/RPalette.hxx,1,['safe'],['safe']
Safety,/// Get a pointer to a parsed line table corresponding to a compile unit.; /// Report any recoverable parsing problems using the handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h:90,recover,recoverable,90,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFContext.h,1,['recover'],['recoverable']
Safety,"/// Get a pointer to an object of type T from the underlying stream, as if by; /// memcpy, and store the result into \p Dest. It is up to the caller to; /// ensure that objects of type T can be safely treated in this manner.; /// Updates the stream's offset to point after the newly read object. Whether; /// a copy occurs depends upon the implementation of the underlying; /// stream.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:194,safe,safely,194,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,1,['safe'],['safely']
Safety,"/// Get a reference to a \p NumElements element array of objects of type T; /// from the underlying stream as if by memcpy, and store the resulting array; /// slice into \p array. It is up to the caller to ensure that objects of; /// type T can be safely treated in this manner. Updates the stream's offset; /// to point after the newly read object. Whether a copy occurs depends upon; /// the implementation of the underlying stream.; ///; /// \returns a success error code if the data was successfully read, otherwise; /// returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h:248,safe,safely,248,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamReader.h,1,['safe'],['safely']
Safety,/// Get file creation mode mask of the process.; ///; /// @returns Mask reported by umask(2); /// @note There is no umask on Windows. This function returns 0 always; /// on Windows. This function does not return an error_code because; /// umask(2) never fails. It is not thread safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:278,safe,safe,278,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['safe'],['safe']
Safety,/// Get the GCC triple for the detected install.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:31,detect,detected,31,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,1,['detect'],['detected']
Safety,"/// Get the GsymCreator string table offset for the qualified name for the; /// DIE passed in. This function will avoid making copies of any strings in; /// the GsymCreator when possible. We don't need to copy a string when the; /// string comes from our .debug_str section or is an inlined string in the; /// .debug_info. If we create a qualified name string in this function by; /// combining multiple strings in the DWARF string table or info, we will make; /// a copy of the string when we add it to the string table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp:114,avoid,avoid,114,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp,1,['avoid'],['avoid']
Safety,/// Get the detected Cuda Include path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,1,['detect'],['detected']
Safety,/// Get the detected Cuda device library path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,1,['detect'],['detected']
Safety,/// Get the detected Cuda install's version.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,1,['detect'],['detected']
Safety,/// Get the detected Cuda installation path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,1,['detect'],['detected']
Safety,"/// Get the detected GCC installation path suffix for the multi-arch; /// target variant. Always starts with a '/', unless empty",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Multilib.h:12,detect,detected,12,interpreter/llvm-project/clang/include/clang/Driver/Multilib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Multilib.h,2,['detect'],['detected']
Safety,/// Get the detected GCC installation path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,1,['detect'],['detected']
Safety,/// Get the detected GCC parent lib path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,1,['detect'],['detected']
Safety,/// Get the detected GCC version string.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,1,['detect'],['detected']
Safety,/// Get the detected Multilib,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,1,['detect'],['detected']
Safety,/// Get the detected Rocm device library path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,1,['detect'],['detected']
Safety,/// Get the detected Rocm install's version.; // RocmVersion version() const { return Version; }; /// Get the detected Rocm installation path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,2,['detect'],['detected']
Safety,/// Get the detected Rocm library path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,1,['detect'],['detected']
Safety,"/// Get the detected os path suffix for the multi-arch; /// target variant. Always starts with a '/', unless empty",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Multilib.h:12,detect,detected,12,interpreter/llvm-project/clang/include/clang/Driver/Multilib.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Multilib.h,2,['detect'],['detected']
Safety,/// Get the detected path to Cuda's bin directory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,1,['detect'],['detected']
Safety,/// Get the detected path to Rocm's bin directory.; // StringRef getBinPath() const { return BinPath; }; /// Get the detected Rocm Include path.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:12,detect,detected,12,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,2,['detect'],['detected']
Safety,/// Get the instruction causing the visit to abort.; /// \returns a pointer to the instruction causing the abort if one is; /// available; otherwise returns null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:45,abort,abort,45,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,2,['abort'],['abort']
Safety,"/// Get the next line table from the section. Report any issues via the; /// handlers.; ///; /// \param RecoverableErrorHandler - any issues that don't prevent further; /// parsing of the table will be reported through this handler.; /// \param UnrecoverableErrorHandler - any issues that prevent further; /// parsing of the table will be reported through this handler.; /// \param OS - if not null, the parser will print information about the; /// table as it parses it.; /// \param Verbose - if true, the parser will print verbose information when; /// printing to the output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h:104,Recover,RecoverableErrorHandler,104,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h,1,['Recover'],['RecoverableErrorHandler']
Safety,/// Get the number of redundant path components in each path in \p Paths.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp:22,redund,redundant,22,interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-cov/CoverageReport.cpp,1,['redund'],['redundant']
Safety,"/// Get the process's page size.; /// This may fail if the underlying syscall returns an error. In most cases,; /// page size information is used for optimization, and this error can be; /// safely discarded by calling consumeError, and an estimated page size; /// substituted instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h:191,safe,safely,191,interpreter/llvm-project/llvm/include/llvm/Support/Process.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Process.h,1,['safe'],['safely']
Safety,/// Get the record type with the given non-redundant list of superclasses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h:43,redund,redundant,43,interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Record.h,1,['redund'],['redundant']
Safety,/// Get the spelling of a token into a SmallVector.; ///; /// Note that the returned StringRef may not point to the; /// supplied buffer if a copy can be avoided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:154,avoid,avoided,154,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['avoid'],['avoided']
Safety,"/// Get the spelling of a token into a preallocated buffer, instead; /// of as an std::string.; ///; /// The caller is required to allocate enough space for the token, which is; /// guaranteed to be at least Tok.getLength() bytes long. The length of the; /// actual result is returned.; ///; /// Note that this method may do two possible things: it may either fill in; /// the buffer specified with characters, or it may *change the input pointer*; /// to point to a constant buffer with the data already in it (avoiding a; /// copy). The caller is not allowed to modify the returned buffer pointer; /// if an internal buffer is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:512,avoid,avoiding,512,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['avoid'],['avoiding']
Safety,"/// Get the string for the current token, this includes all characters (for; /// example, the quotes on strings) in the token.; ///; /// The returned StringRef points into the source manager's memory buffer, and; /// is safe to store across calls to Lex().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmMacro.h:220,safe,safe,220,interpreter/llvm-project/llvm/include/llvm/MC/MCAsmMacro.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCAsmMacro.h,1,['safe'],['safe']
Safety,"/// GetFirstChar - Get the first character of the token \arg Tok,; /// avoiding calls to getSpelling where possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp:71,avoid,avoiding,71,interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/TokenConcatenation.cpp,1,['avoid'],['avoiding']
Safety,/// Gets the linker options necessary to detect object file mismatches on; /// this platform.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h:41,detect,detect,41,interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/TargetInfo.h,1,['detect'],['detect']
Safety,"/// Given a SELECT or a SELECT_CC node, where LHS and RHS are the two values; /// being selected between, see if we can simplify the select. Callers of this; /// should assume that TheSelect is deleted if this returns true. As such, they; /// should return the appropriate thing (e.g. the node) back to the top-level of; /// the DAG combiner loop to avoid it being looked at.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:350,avoid,avoid,350,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"/// Given a chain of or (||) or and (&&) comparison of a value against a; /// constant, this will try to recover the information required for a switch; /// structure.; /// It will depth-first traverse the chain of comparison, seeking for patterns; /// like %a == 12 or %a < 4 and combine them to produce a set of integer; /// representing the different cases for the switch.; /// Note that if the chain is composed of '||' it will build the set of elements; /// that matches the comparisons (i.e. any of this value validate the chain); /// while for a chain of '&&' it will build the set elements that make the test; /// fail.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:105,recover,recover,105,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['recover'],['recover']
Safety,"/// Given a linear access function, tries to recover subscripts; /// for each dimension of the array element access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:45,recover,recover,45,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['recover'],['recover']
Safety,"/// Given a loop with an deccreasing induction variable, is it possible to; /// safely calculate the bounds of a new loop using the given Predicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:80,safe,safely,80,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,1,['safe'],['safely']
Safety,"/// Given a loop with an increasing induction variable, is it possible to; /// safely calculate the bounds of a new loop using the given Predicate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:79,safe,safely,79,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,1,['safe'],['safely']
Safety,"/// Given a scalar cast operation that is extracted from a vector, try to; /// vectorize the cast op followed by extraction. This will avoid an expensive; /// round-trip between XMM and GPR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:135,avoid,avoid,135,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"/// Given a scalar cast to FP with a cast to integer operand (almost an ftrunc),; /// try to vectorize the cast ops. This will avoid an expensive round-trip; /// between XMM and GPR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:127,avoid,avoid,127,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"/// Given a template argument that contains an unexpanded parameter pack, but; /// which has already been substituted, attempt to determine the number of; /// elements that will be produced once this argument is fully-expanded.; ///; /// This is intended for use when transforming 'sizeof...(Arg)' in order to; /// avoid actually expanding the pack where possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:315,avoid,avoid,315,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avoid'],['avoid']
Safety,"/// Given a value that is stored to a global but never read, determine whether; /// it's safe to remove the store and the chain of computation that feeds the; /// store.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:89,safe,safe,89,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['safe'],['safe']
Safety,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:849,avoid,avoid,849,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,2,['avoid'],['avoid']
Safety,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:660,avoid,avoid,660,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"/// Given an object of the given canonical type, can we safely copy a; /// value out of it based on its initializer?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:56,safe,safely,56,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['safe'],['safely']
Safety,"/// Given that the given expression is some sort of call (which does; /// not return retained), perform an unsafeClaim following it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:107,unsafe,unsafeClaim,107,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['unsafe'],['unsafeClaim']
Safety,"/// Given that this builder was created by beginning an array or struct; /// component on the given parent builder, finish the array/struct; /// component and add it to the parent.; ///; /// It is an intentional choice that the parent is passed in explicitly; /// despite it being redundant with information already kept in the; /// builder. This aids in readability by making it easier to find the; /// places that add components to a builder, as well as ""bookending""; /// the sub-builder more explicitly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitBuilder.h:281,redund,redundant,281,interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/ConstantInitBuilder.h,1,['redund'],['redundant']
Safety,"/// Given the language and code-generation options that Clang was configured; /// with, set the default LLVM IR attributes for a function definition.; /// The attributes set here are mostly global target-configuration and; /// pipeline-configuration options like the target CPU, variant stack; /// rules, whether to optimize for size, and so on. This is useful for; /// frontends (such as Swift) that generally intend to interoperate with; /// C code and rely on Clang's target configuration logic.; ///; /// As a general rule, this function assumes that meaningful attributes; /// haven't already been added to the builder. It won't intentionally; /// displace any existing attributes, but it also won't check to avoid; /// overwriting them. Callers should generally apply customizations after; /// making this call.; ///; /// This function assumes that the caller is not defining a function that; /// requires special no-builtin treatment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenABITypes.h:714,avoid,avoid,714,interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenABITypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CodeGenABITypes.h,1,['avoid'],['avoid']
Safety,"/// Given the pattern; /// (X & (C l>>/<< Y)) ==/!= 0; /// return true if it should be transformed into:; /// ((X <</l>> Y) & C) ==/!= 0; /// WARNING: if 'X' is a constant, the fold may deadlock!; /// FIXME: we could avoid passing XC, but we can't use isConstOrConstSplat(); /// here because it can end up being not linked in.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:217,avoid,avoid,217,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['avoid'],['avoid']
Safety,/// Global access point for the JIT debugging interface designed for use with a; /// singleton toolbox. Handles thread-safe registration and deregistration of; /// object files that are in executable memory managed by the client of this; /// class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp:119,safe,safe,119,interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/GDBRegistrationListener.cpp,1,['safe'],['safe']
Safety,"/// GsymCreator is used to emit GSYM data to a stand alone file or section; /// within a file.; ///; /// The GsymCreator is designed to be used in 3 stages:; /// - Create FunctionInfo objects and add them; /// - Finalize the GsymCreator object; /// - Save to file or section; ///; /// The first stage involves creating FunctionInfo objects from another source; /// of information like compiler debug info metadata, DWARF or Breakpad files.; /// Any strings in the FunctionInfo or contained information, like InlineInfo; /// or LineTable objects, should get the string table offsets by calling; /// GsymCreator::insertString(...). Any file indexes that are needed should be; /// obtained by calling GsymCreator::insertFile(...). All of the function calls; /// in GsymCreator are thread safe. This allows multiple threads to create and; /// add FunctionInfo objects while parsing debug information.; ///; /// Once all of the FunctionInfo objects have been added, the; /// GsymCreator::finalize(...) must be called prior to saving. This function; /// will sort the FunctionInfo objects, finalize the string table, and do any; /// other passes on the information needed to prepare the information to be; /// saved.; ///; /// Once the object has been finalized, it can be saved to a file or section.; ///; /// ENCODING; ///; /// GSYM files are designed to be memory mapped into a process as shared, read; /// only data, and used as is.; ///; /// The GSYM file format when in a stand alone file consists of:; /// - Header; /// - Address Table; /// - Function Info Offsets; /// - File Table; /// - String Table; /// - Function Info Data; ///; /// HEADER; ///; /// The header is fully described in ""llvm/DebugInfo/GSYM/Header.h"".; ///; /// ADDRESS TABLE; ///; /// The address table immediately follows the header in the file and consists; /// of Header.NumAddresses address offsets. These offsets are sorted and can be; /// binary searched for efficient lookups. Addresses in the address table are; /// stored",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:785,safe,safe,785,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,1,['safe'],['safe']
Safety,/// HACK: 2014-11-14 libstdc++ had a bug where it shadows std::swap with a; /// member swap function then tries to call std::swap unqualified from the; /// exception specification of that function. This function detects whether; /// we're in such a case and turns off delay-parsing of exception; /// specifications. Libstdc++ 6.1 (released 2016-04-27) appears to have; /// resolved it as side-effect of commit ddb63209a8d (2015-06-05).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp:212,detect,detects,212,interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExceptionSpec.cpp,1,['detect'],['detects']
Safety,"/// Handle a change in variable location within a block. Terminate the; /// variables current location, and record the value it now refers to, so; /// that we can detect location transfers later on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:163,detect,detect,163,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['detect'],['detect']
Safety,"/// Handle a disconnection from the underlying transport. No further messages; /// should be sent to handleMessage after this is called.; /// Err may contain an Error value indicating unexpected disconnection. This; /// allows clients to log such errors, but no attempt should be made at; /// recovery (which should be handled inside the transport class, if it is; /// supported at all).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h:293,recover,recovery,293,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Shared/SimpleRemoteEPCUtils.h,1,['recover'],['recovery']
Safety,"/// Handle any DIE (debug info entry) from the DWARF.; ///; /// This function will find all DW_TAG_subprogram DIEs that convert them into; /// GSYM FuntionInfo objects and add them to the GsymCreator supplied during; /// construction. The DIE and all its children will be recursively parsed; /// with calls to this function.; ///; /// \param Strm The thread specific log stream for any non fatal errors and; /// warnings. Once a thread has finished parsing an entire compile unit, all; /// information in this temporary stream will be forwarded to the member; /// variable log. This keeps logging thread safe. If the value is NULL, then; /// don't log.; ///; /// \param CUI The compile unit specific information that contains the DWARF; /// line table, cached file list, and other compile unit specific; /// information.; ///; /// \param Die The DWARF debug info entry to parse.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h:604,safe,safe,604,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/DwarfTransformer.h,1,['safe'],['safe']
Safety,"/// Handle any errors (if present) in an Expected<T>, then try a recovery path.; ///; /// If the incoming value is a success value it is returned unmodified. If it; /// is a failure value then it the contained error is passed to handleErrors.; /// If handleErrors is able to handle the error then the RecoveryPath functor; /// is called to supply the final result. If handleErrors is not able to; /// handle all errors then the unhandled errors are returned.; ///; /// This utility enables the follow pattern:; ///; /// @code{.cpp}; /// enum FooStrategy { Aggressive, Conservative };; /// Expected<Foo> foo(FooStrategy S);; ///; /// auto ResultOrErr =; /// handleExpected(; /// foo(Aggressive),; /// []() { return foo(Conservative); },; /// [](AggressiveStrategyError&) {; /// // Implicitly conusme this - we'll recover by using a conservative; /// // strategy.; /// });; ///; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:65,recover,recovery,65,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,3,"['Recover', 'recover']","['RecoveryPath', 'recover', 'recovery']"
Safety,/// Handle lowering of 2-lane 64-bit floating point shuffles.; ///; /// This is the basis function for the 2-lane 64-bit shuffles as we have full; /// support for floating point shuffles but not integer shuffles. These; /// instructions will incur a domain crossing penalty on some chips though so; /// it is better to avoid lowering through this for integer vectors where; /// possible.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:319,avoid,avoid,319,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"/// Handle the Microsoft \#pragma detect_mismatch extension.; ///; /// The syntax is:; /// \code; /// #pragma detect_mismatch(""name"", ""value""); /// \endcode; /// Where 'name' and 'value' are quoted strings. The values are embedded in; /// the object file and passed along to the linker. If the linker detects a; /// mismatch in the object file's values for the given name, a LNK2038 error; /// is emitted. See MSDN for more details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp:301,detect,detects,301,interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParsePragma.cpp,1,['detect'],['detects']
Safety,"/// Handle the cases when we prefer one instruction over another. Case 1 - we; /// prefer not to generate multiple loads in the packet to avoid a potential; /// bank conflict. Case 2 - if a packet contains a dot cur instruction, then we; /// prefer the instruction that can use the dot cur result. However, if the use; /// is not scheduled in the same packet, then prefer other instructions in the; /// subsequent packet. Case 3 - we prefer a vector store that can be converted; /// to a .new store. The packetizer will not generate the .new store if the; /// store doesn't have resources to fit in the packet (but the .new store may; /// have resources). We attempt to schedule the store as soon as possible to; /// help packetize the two instructions together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp:138,avoid,avoid,138,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.cpp,1,['avoid'],['avoid']
Safety,"/// HandleTopLevelDecl - Handle the specified top-level declaration. This is; /// called by the parser to process every top-level Decl*.; ///; /// \returns true to continue parsing, or false to abort parsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTConsumer.h:194,abort,abort,194,interpreter/llvm-project/clang/include/clang/AST/ASTConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTConsumer.h,1,['abort'],['abort']
Safety,/// Handler class for thread safety warnings.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h:29,safe,safety,29,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafety.h,1,['safe'],['safety']
Safety,/// Handles most opcodes. Split \p MI into same instruction on sub-vectors or; /// scalars with \p NumElts elements (1 for scalar). Supports uneven splits:; /// there can be leftover sub-vector with fewer then \p NumElts or a leftover; /// scalar. To avoid this use moreElements first and set MI number of elements; /// to multiple of \p NumElts. Non-vector operands that should be used on all; /// sub-instructions without split are listed in \p NonVecOpIndices.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h:251,avoid,avoid,251,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,1,['avoid'],['avoid']
Safety,"/// Harden a return instruction.; ///; /// Returns implicitly perform a load which we need to harden. Without hardening; /// this load, an attacker my speculatively write over the return address to; /// steer speculation of the return to an attacker controlled address. This is; /// called Spectre v1.1 or Bounds Check Bypass Store (BCBS) and is described in; /// this paper:; /// https://people.csail.mit.edu/vlk/spectre11.pdf; ///; /// We can harden this by introducing an LFENCE that will delay any load of the; /// return address until prior instructions have retired (and thus are not being; /// speculated), or we can harden the address used by the implicit load: the; /// stack pointer.; ///; /// If we are not using an LFENCE, hardening the stack pointer has an additional; /// benefit: it allows us to pass the predicate state accumulated in this; /// function back to the caller. In the absence of a BCBS attack on the return,; /// the caller will typically be resumed and speculatively executed due to the; /// Return Stack Buffer (RSB) prediction which is very accurate and has a high; /// priority. It is possible that some code from the caller will be executed; /// speculatively even during a BCBS-attacked return until the steering takes; /// effect. Whenever this happens, the caller can recover the (poisoned); /// predicate state from the stack pointer and continue to harden loads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1048,predict,prediction,1048,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,"['predict', 'recover']","['prediction', 'recover']"
Safety,/// Hash a function in order to detect when a function (or more specific) pass; /// has modified it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:32,detect,detect,32,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,1,['detect'],['detect']
Safety,/// Hash a module in order to detect when a module (or more specific) pass has; /// modified it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h:30,detect,detect,30,interpreter/llvm-project/llvm/include/llvm/Pass.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Pass.h,1,['detect'],['detect']
Safety,/// HazardRec - The hazard recognizer to use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp:4,Hazard,HazardRec,4,interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PostRASchedulerList.cpp,6,"['Hazard', 'hazard']","['HazardRec', 'hazard']"
Safety,"/// HazardRecognizer - This determines whether or not an instruction can be; /// issued this cycle, and whether or not a noop needs to be inserted to handle; /// the hazard.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:4,Hazard,HazardRecognizer,4,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,2,"['Hazard', 'hazard']","['HazardRecognizer', 'hazard']"
Safety,"/// Helper class for managing resource cleanups.; ///; /// \tparam T Type of resource been reclaimed.; /// \tparam Cleanup Class that defines how the resource is reclaimed.; ///; /// Clients create objects of this type in the code executed in a crash recovery; /// context to ensure that the resource will be reclaimed even in the case of; /// crash. For example:; ///; /// \code; /// void actual_work(void *) {; /// ...; /// std::unique_ptr<Resource> R(new Resource());; /// CrashRecoveryContextCleanupRegistrar D(R.get());; /// ...; /// }; ///; /// void foo() {; /// CrashRecoveryContext CRC;; ///; /// if (!CRC.RunSafely(actual_work, 0)) {; /// ... a crash was detected, report error to user ...; /// }; /// \endcode; ///; /// If the code of `actual_work` in the example above does not crash, the; /// destructor of CrashRecoveryContextCleanupRegistrar removes cleanup code from; /// the current CrashRecoveryContext and the resource is reclaimed by the; /// destructor of std::unique_ptr. If crash happens, destructors are not called; /// and the resource is reclaimed by cleanup object registered in the recovery; /// context by the constructor of CrashRecoveryContextCleanupRegistrar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:251,recover,recovery,251,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,3,"['detect', 'recover']","['detected', 'recovery']"
Safety,"/// Helper class that detects loops which require us to lower an i1 COPY into; /// bitwise manipulation.; ///; /// Unfortunately, we cannot use LoopInfo because LoopInfo does not distinguish; /// between loops with the same header. Consider this example:; ///; /// A-+-+; /// | | |; /// B-+ |; /// | |; /// C---+; ///; /// A is the header of a loop containing A, B, and C as far as LoopInfo is; /// concerned. However, an i1 COPY in B that is used in C must be lowered to; /// bitwise operations to combine results from different loop iterations when; /// B has a divergent branch (since by default we will compile this code such; /// that threads in a wave are merged at the entry of C).; ///; /// The following rule is implemented to determine whether bitwise operations; /// are required: use the bitwise lowering for a def in block B if a backward; /// edge to B is reachable without going through the nearest common; /// post-dominator of B and all uses of the def.; ///; /// TODO: This rule is conservative because it does not check whether the; /// relevant branches are actually divergent.; ///; /// The class is designed to cache the CFG traversal so that it can be re-used; /// for multiple defs within the same basic block.; ///; /// TODO: We could use region analysis to quickly skip over SESE regions during; /// the traversal.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp:22,detect,detects,22,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SILowerI1Copies.cpp,1,['detect'],['detects']
Safety,/// Helper class to indicate whether a vector index can be safely scalarized and; /// if a freeze needs to be inserted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:59,safe,safely,59,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['safe'],['safely']
Safety,"/// Helper for Errors used as out-parameters.; ///; /// This helper is for use with the Error-as-out-parameter idiom, where an error; /// is passed to a function or method by reference, rather than being returned.; /// In such cases it is helpful to set the checked bit on entry to the function; /// so that the error can be written to (unchecked Errors abort on assignment); /// and clear the checked bit on exit so that clients cannot accidentally forget; /// to check the result. This helper performs these actions automatically using; /// RAII:; ///; /// @code{.cpp}; /// Result foo(Error &Err) {; /// ErrorAsOutParameter ErrAsOutParam(&Err); // 'Checked' flag set; /// // <body of foo>; /// // <- 'Checked' flag auto-cleared when ErrAsOutParam is destructed.; /// }; /// @endcode; ///; /// ErrorAsOutParameter takes an Error* rather than Error& so that it can be; /// used with optional Errors (Error pointers that are allowed to be null). If; /// ErrorAsOutParameter took an Error reference, an instance would have to be; /// created inside every condition that verified that Error was non-null. By; /// taking an Error pointer we can just create one instance at the top of the; /// function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:354,abort,abort,354,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['abort'],['abort']
Safety,"/// Helper for converting an ECError to a std::error_code.; ///; /// This method requires that Err be Error() or an ECError, otherwise it; /// will trigger a call to abort().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:166,abort,abort,166,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['abort'],['abort']
Safety,/// Helper function for mergeConsecutiveStores. Checks if candidate stores; /// have indirect dependency through their operands. RootNode is the; /// predecessor to all stores calculated by getStoreMergeCandidates and is; /// used to prune the dependency check. \return True if safe to merge.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:278,safe,safe,278,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['safe'],['safe']
Safety,"/// Helper function to truncate an optional APInt to a given BitWidth.; /// When solving addrec-related equations, it is preferable to return a value; /// that has the same bit width as the original addrec's coefficients. If the; /// solution fits in the original bit width, truncate it (except for i1).; /// Returning a value of a different bit width may inhibit some optimizations.; ///; /// In general, a solution to a quadratic equation generated from an addrec; /// may require BW+1 bits, where BW is the bit width of the addrec's; /// coefficients. The reason is that the coefficients of the quadratic; /// equation are BW+1 bits wide (to avoid truncation when converting from; /// the addrec to the equation).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:645,avoid,avoid,645,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,"/// Helper functions to select the appropriate marshaller functions.; /// They detect the number of arguments, arguments types and return type.; /// 0-arg overload",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h:79,detect,detect,79,interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/ASTMatchers/Dynamic/Marshallers.h,1,['detect'],['detect']
Safety,"/// Helper method to apply something that is like the default mapping.; /// Basically, that means that \p OpdMapper.getMI() is left untouched; /// aside from the reassignment of the register operand that have been; /// remapped.; ///; /// The type of all the new registers that have been created by the; /// mapper are properly remapped to the type of the original registers; /// they replace. In other words, the semantic of the instruction does; /// not change, only the register banks.; ///; /// If the mapping of one of the operand spans several registers, this; /// method will abort as this is not like a default mapping anymore.; ///; /// \pre For OpIdx in {0..\p OpdMapper.getMI().getNumOperands()); /// the range OpdMapper.getVRegs(OpIdx) is empty or of size 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:583,abort,abort,583,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['abort'],['abort']
Safety,/// Helper struct to parse and store a memory address as base + index + offset.; /// We ignore sign extensions when it is safe to do so.; /// The following two expressions are not equivalent. To differentiate we need; /// to store whether there was a sign extension involved in the index; /// computation.; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (add (i8 load %index); /// (i8 1)))); /// vs; ///; /// (load (i64 add (i64 copyfromreg %c); /// (i64 signextend (i32 add (i32 signextend (i8 load %index)); /// (i32 1))))),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h:122,safe,safe,122,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGAddressAnalysis.h,1,['safe'],['safe']
Safety,/// Helper to avoid creating an AA for IR Attributes that might already be set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:14,avoid,avoid,14,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['avoid'],['avoid']
Safety,"/// Helper to form a PSHUFB-based shuffle+blend, opportunistically avoiding the; /// blend if only one input is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:67,avoid,avoiding,67,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoiding']
Safety,/// Helper to get the language options from the ASTContext.; /// Defined out of line to avoid depending on ASTContext.h.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:88,avoid,avoid,88,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,2,['avoid'],['avoid']
Safety,/// Helper to scan a function for loads vulnerable to misspeculation that we; /// want to harden.; ///; /// We use this to avoid making changes to functions where there is nothing we; /// need to do to harden against misspeculation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:123,avoid,avoid,123,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['avoid'],['avoid']
Safety,"/// Helps avoid false dependencies on undef registers by updating the; /// machine instructions' undef operand to use a register that the instruction; /// is truly dependent on, or use a register with clearance higher than Pref.; /// Returns true if it was able to find a true dependency, thus not requiring; /// a dependency breaking instruction regardless of clearance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp:10,avoid,avoid,10,interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BreakFalseDeps.cpp,1,['avoid'],['avoid']
Safety,"/// Here we can be fairly sure that executing this exit will most likely; /// lead to executing llvm.experimental.deoptimize.; /// This is a profitability heuristic, not a legality constraint.; // If we found a widenable exit condition, do two things:; // 1) fold the widened exit test into the widenable condition; // 2) fold the branch to untaken - avoids infinite looping",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:351,avoid,avoids,351,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['avoid'],['avoids']
Safety,"/// Hides a using shadow declaration. This is required by the current; /// using-decl implementation when a resolvable using declaration in a; /// class is followed by a declaration which would hide or override; /// one or more of the using decl's targets; for example:; ///; /// struct Base { void foo(int); };; /// struct Derived : Base {; /// using Base::foo;; /// void foo(int);; /// };; ///; /// The governing language is C++03 [namespace.udecl]p12:; ///; /// When a using-declaration brings names from a base class into a; /// derived class scope, member functions in the derived class; /// override and/or hide member functions with the same name and; /// parameter types in a base class (rather than conflicting).; ///; /// There are two ways to implement this:; /// (1) optimistically create shadow decls when they're not hidden; /// by existing declarations, or; /// (2) don't create any shadow decls (or at least don't make them; /// visible) until we've fully parsed/instantiated the class.; /// The problem with (1) is that we might have to retroactively remove; /// a shadow decl, which requires several O(n) operations because the; /// decl structures are (very reasonably) not designed for removal.; /// (2) avoids this but is very fiddly and phase-dependent.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp:1224,avoid,avoids,1224,interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDeclCXX.cpp,1,['avoid'],['avoids']
Safety,"/// Hoist back-copies to the complement interval. It tries to hoist all; /// the back-copies to one BB if it is beneficial, or else simply remove; /// redundant backcopies dominated by others.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:151,redund,redundant,151,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,1,['redund'],['redundant']
Safety,"/// Holds all the casts that participate in the update chain of the induction; /// variables, and that have been proven to be redundant (possibly under a; /// runtime guard). These casts can be ignored when creating the vectorized; /// loop body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:126,redund,redundant,126,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['redund'],['redundant']
Safety,/// Holds and updates state information required to vectorize the main loop; /// and its epilogue in two separate passes. This setup helps us avoid; /// regenerating and recomputing runtime safety checks. It also helps us to; /// shorten the iteration-count-check path length for the cases where the; /// iteration count of the loop is so small that the main vector loop is; /// completely skipped.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:142,avoid,avoid,142,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,"['avoid', 'safe']","['avoid', 'safety']"
Safety,/// Holds the information from a dbg_label node through SDISel.; /// We do not use SDValue here to avoid including its header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h:99,avoid,avoid,99,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,1,['avoid'],['avoid']
Safety,/// Holds the information from a dbg_value node through SDISel.; /// We do not use SDValue here to avoid including its header.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h:99,avoid,avoid,99,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SDNodeDbgValue.h,1,['avoid'],['avoid']
Safety,"/// Hooks for building estimates in place of slower divisions and square; /// roots.; /// Return either a square root or its reciprocal estimate value for the input; /// operand.; /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or; /// 'Enabled' as set by a potential default override attribute.; /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson; /// refinement iterations required to generate a sufficient (though not; /// necessarily IEEE-754 compliant) estimate is returned in that parameter.; /// The boolean UseOneConstNR output is used to select a Newton-Raphson; /// algorithm implementation that uses either one or two constants.; /// The boolean Reciprocal is used to select whether the estimate is for the; /// square root of the input operand or the reciprocal of its square root.; /// A target may choose to implement its own refinement within this function.; /// If that's true, then return '0' as the number of RefinementSteps to avoid; /// any further refinement of the estimate.; /// An empty SDValue return means no estimate sequence can be created.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:996,avoid,avoid,996,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['avoid'],['avoid']
Safety,"/// How narrow does the trip count of a loop have to be to have to be considered; /// ""counted""? Counted loops do not get safepoints at backedges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:122,safe,safepoints,122,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoints']
Safety,/// Identifier used when the related instruction mapping instance; /// is generated by target independent code.; /// Make sure not to use that identifier to avoid possible collision.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:157,avoid,avoid,157,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['avoid'],['avoid']
Safety,"/// If \p Op is a stack or frame register return true, otherwise return false.; /// This is used to avoid basing the debug entry values on the registers, since; /// we do not support it at the moment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:100,avoid,avoid,100,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['avoid'],['avoid']
Safety,"/// If ``true``, clang-format detects whether function calls and; /// definitions are formatted with one parameter per line.; ///; /// Each call can be bin-packed, one-per-line or inconclusive. If it is; /// inconclusive, e.g. completely on one line, but a decision needs to be; /// made, clang-format analyzes whether there are other bin-packed cases in; /// the input file and act accordingly.; ///; /// \note; /// This is an experimental flag, that might go away or be renamed. Do; /// not use this in config files, etc. Use at your own risk.; /// \endnote; /// \version 3.7",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:30,detect,detects,30,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,2,"['detect', 'risk']","['detects', 'risk']"
Safety,"/// If a LSRUse has multiple formulae with the same ScaledReg and Scale.; /// Pick the best one and delete the others.; /// This narrowing heuristic is to keep as many formulae with different; /// Scale and ScaledReg pair as possible while narrowing the search space.; /// The benefit is that it is more likely to find out a better solution; /// from a formulae set with more Scale and ScaledReg variations than; /// a formulae set with the same Scale and ScaledReg. The picking winner; /// reg heuristic will often keep the formulae with the same Scale and; /// ScaledReg and filter others, and we want to avoid that if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:607,avoid,avoid,607,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['avoid'],['avoid']
Safety,"/// If a branch or a select condition is skewed in one direction by more than; /// this factor, it is very likely to be predicted correctly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:120,predict,predicted,120,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['predict'],['predicted']
Safety,"/// If a runtime library exists that sets global flags for unsafe floating; /// point math, return true.; ///; /// This checks for presence of the -Ofast, -ffast-math or -funsafe-math flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:59,unsafe,unsafe,59,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['unsafe'],['unsafe']
Safety,"/// If both input operands of a logic op are being cast from floating-point; /// types or FP compares, try to convert this into a floating-point logic node; /// to avoid unnecessary moves from SSE to integer registers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:164,avoid,avoid,164,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"/// If called on unreachable code, the instruction may simplify to itself.; /// Make life easier for users by detecting that case here, and returning a; /// safe value instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:110,detect,detecting,110,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,2,"['detect', 'safe']","['detecting', 'safe']"
Safety,"/// If counting leading or trailing zeros is an expensive operation and a zero; /// input is defined, add a check for zero to avoid calling the intrinsic.; ///; /// We want to transform:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 false); ///; /// into:; /// entry:; /// %cmpz = icmp eq i64 %A, 0; /// br i1 %cmpz, label %cond.end, label %cond.false; /// cond.false:; /// %z = call i64 @llvm.cttz.i64(i64 %A, i1 true); /// br label %cond.end; /// cond.end:; /// %ctz = phi i64 [ 64, %entry ], [ %z, %cond.false ]; ///; /// If the transform is performed, return true and set ModifiedDT to true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:126,avoid,avoid,126,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"/// If enableDetectExceptions is not enabled then must be 0, otherwise must be; /// non-0 and specifies the set of HSAIL exceptions that must have the DETECT; /// policy enabled. If this set is not empty then the generated code may have; /// lower performance than if the set is empty. However, an implementation; /// should endeavour to make the performance impact small. If the kernel being; /// finalized has any enabledetectexceptions control directives, then the; /// values specified by this argument are unioned with the values in these; /// control directives. If any of the functions the kernel calls have an; /// enabledetectexceptions control directive, then they must be equal or a; /// subset of, this union.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:151,DETECT,DETECT,151,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['DETECT'],['DETECT']
Safety,"/// If it is profitable, duplicate TailBB's contents in each; /// of its predecessors.; /// \p IsSimple result of isSimpleBB; /// \p TailBB Block to be duplicated.; /// \p ForcedLayoutPred When non-null, use this block as the layout predecessor; /// instead of the previous block in MF's order.; /// \p TDBBs A vector to keep track of all blocks tail-duplicated; /// into.; /// \p Copies A vector of copy instructions inserted. Used later to; /// walk all the inserted copies and remove redundant ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp:487,redund,redundant,487,interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TailDuplicator.cpp,1,['redund'],['redundant']
Safety,"/// If maxDynamicGroupSize is not enabled then must be 0, and any amount of; /// dynamic group segment can be allocated for a dispatch, otherwise the value; /// specifies the maximum number of bytes of dynamic group segment that can be; /// allocated for a dispatch. If the kernel being finalized has any; /// maxdynamicsize control directives, then the values must be the same, and; /// must be the same as this argument if it is enabled. This value can be used; /// by the finalizer to determine the maximum number of bytes of group memory; /// used by each work-group by adding this value to the group memory required; /// for all group segment variables used by the kernel and all functions it; /// calls, and group memory used to implement other HSAIL features such as; /// fbarriers and the detect exception operations. This can allow the finalizer; /// to determine the expected number of work-groups that can be executed by a; /// compute unit and allow more resources to be allocated to the work-items if; /// it is known that fewer work-groups can be executed due to group memory; /// limitations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h:797,detect,detect,797,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDKernelCodeT.h,1,['detect'],['detect']
Safety,"/// If no error occurs, this returns a valid Remark object.; /// If an error of type EndOfFileError occurs, it is safe to recover from it; /// by stopping the parsing.; /// If any other error occurs, it should be propagated to the user.; /// The pointer should never be null.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkParser.h:114,safe,safe,114,interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkParser.h,2,"['recover', 'safe']","['recover', 'safe']"
Safety,"/// If set, signals that this TTree is the output of the processing of another TTree, and; /// the entries are reshuffled w.r.t. to the original TTree. As a safety measure, a TTree; /// with this bit set cannot add friends nor can be added as a friend. If you know what; /// you are doing, you can manually unset this bit with `ResetBit(EStatusBits::kEntriesReshuffled)`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:157,safe,safety,157,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['safe'],['safety']
Safety,"/// If set, this ObjectLinkingLayer instance will claim responsibility; /// for any symbols provided by a given object file that were not already in; /// the MaterializationResponsibility instance. Setting this flag allows; /// higher-level program representations (e.g. LLVM IR) to be added based on; /// only a subset of the symbols they provide, without having to write; /// intervening layers to scan and add the additional symbols. This trades; /// diagnostic quality for convenience however: If all symbols are enumerated; /// up-front then clashes can be detected and reported early (and usually; /// deterministically). If this option is set, clashes for the additional; /// symbols may not be detected until late, and detection may depend on; /// the flow of control through JIT'd code. Use with care.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h:562,detect,detected,562,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h,3,['detect'],"['detected', 'detection']"
Safety,"/// If set, this RTDyldObjectLinkingLayer instance will claim responsibility; /// for any symbols provided by a given object file that were not already in; /// the MaterializationResponsibility instance. Setting this flag allows; /// higher-level program representations (e.g. LLVM IR) to be added based on; /// only a subset of the symbols they provide, without having to write; /// intervening layers to scan and add the additional symbols. This trades; /// diagnostic quality for convenience however: If all symbols are enumerated; /// up-front then clashes can be detected and reported early (and usually; /// deterministically). If this option is set, clashes for the additional; /// symbols may not be detected until late, and detection may depend on; /// the flow of control through JIT'd code. Use with care.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h:568,detect,detected,568,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h,3,['detect'],"['detected', 'detection']"
Safety,"/// If the previous block ended with a widenable branch, determine if reusing; /// the target block is profitable and legal. This will have the effect of; /// ""widening"" PBI, but doesn't require us to reason about hosting safety.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:222,safe,safety,222,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safety']
Safety,"/// If the specified loop has a predictable backedge-taken count, return it,; /// otherwise return a SCEVCouldNotCompute object. The backedge-taken count is; /// the number of times the loop header will be branched to from within the; /// loop, assuming there are no abnormal exists like exception throws. This is; /// one less than the trip count of the loop, since it doesn't count the first; /// iteration, when the header is branched to from outside the loop.; ///; /// Note that it is not valid to call this method on a loop without a; /// loop-invariant backedge-taken count (see; /// hasLoopInvariantBackedgeTakenCount).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:32,predict,predictable,32,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['predict'],['predictable']
Safety,"/// If the target has a standard location for the unsafe stack pointer,; /// returns the address of that location. Otherwise, returns nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h:50,unsafe,unsafe,50,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64ISelLowering.h,1,['unsafe'],['unsafe']
Safety,"/// If this file is backed by a assembly streamer, this dumps the; /// specified string in the output .s file. This capability is indicated by; /// the hasRawTextSupport() predicate. By default this aborts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:199,abort,aborts,199,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['abort'],['aborts']
Safety,"/// If this flag is set, the remapper ignores missing function-local entries; /// (Argument, Instruction, BasicBlock) that are not in the value map. If it; /// is unset, it aborts if an operand is asked to be remapped which doesn't; /// exist in the mapping.; ///; /// There are no such assertions in MapValue(), whose results are almost; /// unchanged by this flag. This flag mainly changes the assertion behaviour; /// in RemapInstruction().; ///; /// Since an Instruction's metadata operands (even that point to SSA values); /// aren't guaranteed to be dominated by their definitions, MapMetadata will; /// return ""!{}"" instead of ""null"" for \a LocalAsMetadata instances whose SSA; /// values are unmapped when this flag is set. Otherwise, \a MapValue(); /// completely ignores this flag.; ///; /// \a MapMetadata() always ignores this flag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:173,abort,aborts,173,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,1,['abort'],['aborts']
Safety,"/// If this is a generic lambda, and the template parameter; /// list has been created (from the TemplateParams) then store; /// a reference to it (cache it to avoid reconstructing it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:160,avoid,avoid,160,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,1,['avoid'],['avoid']
Safety,"/// If this queue only has one ready candidate, return it. As a side effect,; /// defer any nodes that now hit a hazard, and advance the cycle until at least; /// one node is ready. If multiple instructions are ready, return NULL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:113,hazard,hazard,113,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['hazard'],['hazard']
Safety,/// If we are extracting a subvector produced by a wide binary operator try; /// to use a narrow binary operator and/or avoid concatenation and extraction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:120,avoid,avoid,120,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"/// If we are extracting two 128-bit halves of a vector and shuffling the; /// result, match that to a 256-bit AVX2 vperm* instruction to avoid a; /// multi-shuffle lowering.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:138,avoid,avoid,138,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"/// If we are inverting an PTEST/TESTP operand, attempt to adjust the CC; /// to avoid the inversion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:81,avoid,avoid,81,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"/// If we are using indirect thunks, we need to expand indirectbr to avoid it; /// lowering to an actual indirect jump.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.h:69,avoid,avoid,69,interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86Subtarget.h,1,['avoid'],['avoid']
Safety,"/// If we have a SelectInst that will likely profit from branch prediction,; /// turn it into a branch.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:64,predict,prediction,64,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['predict'],['prediction']
Safety,"/// If we have a Top Down pointer in the S_CanRelease state, make sure that; /// there are no CFG hazards by checking the states of various bottom up; /// pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:98,hazard,hazards,98,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['hazard'],['hazards']
Safety,"/// If we have a global that is only initialized with a fixed size allocation; /// try to transform the program to use global memory instead of heap; /// allocated memory. This eliminates dynamic allocation, avoids an indirection; /// accessing the data, and exposes the resultant global to further GlobalOpt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:208,avoid,avoids,208,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['avoid'],['avoids']
Safety,"/// If we have a select with an equality comparison, then we know the value in; /// one of the arms of the select. See if substituting this value into an arm; /// and simplifying the result yields the same value as the other arm.; ///; /// To make this transform safe, we must drop poison-generating flags; /// (nsw, etc) if we simplified to a binop because the select may be guarding; /// that poison from propagating. If the existing binop already had no; /// poison-generating flags, then this transform can be done by instsimplify.; ///; /// Consider:; /// %cmp = icmp eq i32 %x, 2147483647; /// %add = add nsw i32 %x, 1; /// %sel = select i1 %cmp, i32 -2147483648, i32 %add; ///; /// We can't replace %sel with %add unless we strip away the flags.; /// TODO: Wrapping flags could be preserved in some cases with better analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:263,safe,safe,263,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,1,['safe'],['safe']
Safety,"/// If we have a top down pointer in the S_Use state, make sure that there are; /// no CFG hazards by checking the states of various bottom up pointers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:91,hazard,hazards,91,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['hazard'],['hazards']
Safety,"/// Ignore the stack of \c ParenStates for state comparison.; ///; /// In long and deeply nested unwrapped lines, the current algorithm can; /// be insufficient for finding the best formatting with a reasonable amount; /// of time and memory. Setting this flag will effectively lead to the; /// algorithm not analyzing some combinations. However, these combinations; /// rarely contain the optimal solution: In short, accepting a higher; /// penalty early would need to lead to different values in the \c; /// ParenState stack (in an otherwise identical state) and these different; /// values would need to lead to a significant amount of avoided penalty; /// later.; ///; /// FIXME: Come up with a better algorithm instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h:639,avoid,avoided,639,interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/ContinuationIndenter.h,1,['avoid'],['avoided']
Safety,/// ImmediatelyAfterTopLevelIfndef - This is true when the only tokens; /// processed in the file so far is an #ifndef and an identifier. Used in; /// the detection of header guards in a file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h:155,detect,detection,155,interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,1,['detect'],['detection']
Safety,/// Implement a unique function which doesn't require we sort the input; /// vector. Doing so has the effect of changing the output of a couple of; /// tests in ways which make them less useful in testing fused safepoints.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:211,safe,safepoints,211,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safepoints']
Safety,"/// Implement emitting a version of the operator for many of the calling; /// conventions for MSVC, as described here:; /// https://devblogs.microsoft.com/oldnewthing/20150220-00/?p=44623.; /// Experimentally, we determined that cdecl, stdcall, fastcall, and; /// vectorcall are generated by MSVC when it is supported by the target.; /// Additionally, we are ensuring that the default-free/default-member and; /// call-operator calling convention are generated as well.; /// NOTE: We intentionally generate a 'thiscall' on Win32 implicitly from the; /// 'member default', despite MSVC not doing so. We do this in order to ensure; /// that someone who intentionally places 'thiscall' on the lambda call; /// operator will still get that overload, since we don't have the a way of; /// detecting the attribute by the time we get here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp:784,detect,detecting,784,interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaLambda.cpp,1,['detect'],['detecting']
Safety,"/// Implement hashing for user-defined `struct`s.; ///; /// Any user-define `struct` can participate in hashing via `HashBuilder` by; /// providing a `addHash` templated function.; ///; /// ```; /// template <typename HasherT, llvm::endianness Endianness>; /// void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const UserDefinedStruct &Value);; /// ```; ///; /// For example:; /// ```; /// struct SimpleStruct {; /// char c;; /// int i;; /// };; ///; /// template <typename HasherT, llvm::endianness Endianness>; /// void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const SimpleStruct &Value) {; /// HBuilder.add(Value.c);; /// HBuilder.add(Value.i);; /// }; /// ```; ///; /// To avoid endianness issues, specializations of `addHash` should; /// generally rely on exising `add`, `addRange`, and `addRangeElements`; /// functions. If directly using `update`, an implementation must correctly; /// handle endianness.; ///; /// ```; /// struct __attribute__ ((packed)) StructWithFastHash {; /// int I;; /// char C;; ///; /// // If possible, we want to hash both `I` and `C` in a single; /// // `update` call for performance concerns.; /// template <typename HasherT, llvm::endianness Endianness>; /// friend void addHash(HashBuilder<HasherT, Endianness> &HBuilder,; /// const StructWithFastHash &Value) {; /// if (Endianness == llvm::endianness::native) {; /// HBuilder.update(ArrayRef(; /// reinterpret_cast<const uint8_t *>(&Value), sizeof(Value)));; /// } else {; /// // Rely on existing `add` methods to handle endianness.; /// HBuilder.add(Value.I);; /// HBuilder.add(Value.C);; /// }; /// }; /// };; /// ```; ///; /// To avoid collisions, specialization of `addHash` for variable-size; /// types must take the size into account.; ///; /// For example:; /// ```; /// struct CustomContainer {; /// private:; /// size_t Size;; /// int Elements[100];; ///; /// public:; /// CustomContainer(size_t Size) : Size(Size) {; /// for (size_t I = 0; I != Size; ++I); /// Elements[I] = ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h:705,avoid,avoid,705,interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/HashBuilder.h,1,['avoid'],['avoid']
Safety,"/// Implement the combining of integral values into a hash_code.; ///; /// This overload is selected when the value type of the iterator is integral; /// and when the input iterator is actually a pointer. Rather than computing; /// a hash_code for each object and then combining them, this (as an; /// optimization) directly combines the integers. Also, because the integers; /// are stored in contiguous memory, this routine avoids copying each value; /// and directly reads from the underlying memory.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h:426,avoid,avoids,426,interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Hashing.h,1,['avoid'],['avoids']
Safety,"/// Implementation for an ilist node.; ///; /// Templated on an appropriate \a ilist_detail::node_options, usually computed; /// by \a ilist_detail::compute_node_options.; ///; /// This is a wrapper around \a ilist_node_base whose main purpose is to; /// provide type safety: you can't insert nodes of \a ilist_node_impl into the; /// wrong \a simple_ilist or \a iplist.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h:268,safe,safety,268,interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist_node.h,1,['safe'],['safety']
Safety,/// Implements the naive hardening approach of putting an LFENCE after every; /// potentially mis-predicted control flow construct.; ///; /// We include this as an alternative mostly for the purpose of comparison. The; /// performance impact of this is expected to be extremely severe and not; /// practical for any real-world users.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:98,predict,predicted,98,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['predict'],['predicted']
Safety,"/// Implements the simple state machine that the Lexer class uses to; /// detect files subject to the 'multiple-include' optimization.; ///; /// The public methods in this class are triggered by various; /// events that occur when a file is lexed, and after the entire file is lexed,; /// information about which macro (if any) controls the header is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h:74,detect,detect,74,interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,1,['detect'],['detect']
Safety,"/// In Microsoft mode, if we are inside a template class whose parent class has; /// dependent base classes, and we can't resolve an unqualified identifier, then; /// assume the identifier is a member of a dependent base class. We can only; /// recover successfully in static methods, instance methods, and other contexts; /// where 'this' is available. This doesn't precisely match MSVC's; /// instantiation model, but it's close enough.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:245,recover,recover,245,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['recover'],['recover']
Safety,"/// In dwarf emission, the following sequence; /// 1. dbg.value ... Fragment(0, 64); /// 2. dbg.value ... Fragment(0, 32); /// effectively sets Fragment(32, 32) to undef (each def sets all bits not in; /// the intersection of the fragments to having ""no location""). This makes; /// sense for implicit location values because splitting the computed values; /// could be troublesome, and is probably quite uncommon. When we convert; /// dbg.assigns to dbg.value+deref this kind of thing is common, and describing; /// a location (memory) rather than a value means we don't need to worry about; /// splitting any values, so we try to recover the rest of the fragment; /// location here.; /// This class performs a(nother) dataflow analysis over the function, adding; /// variable locations so that any bits of a variable with a memory location; /// have that location explicitly reinstated at each subsequent variable; /// location definition that that doesn't overwrite those bits. i.e. after a; /// variable location def, insert new defs for the memory location with; /// fragments for the difference of ""all bits currently in memory"" and ""the; /// fragment of the second def"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:631,recover,recover,631,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['recover'],['recover']
Safety,"/// In generating diagnostics, ignore optionals reachable through overloaded; /// `operator*` or `operator->` (other than those of the optional type; /// itself). The analysis does not equate the results of such calls, so it; /// can't identify when their results are used safely (across calls),; /// resulting in false positives in all such cases. Note: this option does not; /// cover access through `operator[]`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.h:273,safe,safely,273,interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/FlowSensitive/Models/UncheckedOptionalAccessModel.h,1,['safe'],['safely']
Safety,"/// In order to avoid unwanted copies, ""delete"" the copy constructor.; /// If a copy is needed, it should be done through `Remark::clone()`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/Remark.h:16,avoid,avoid,16,interpreter/llvm-project/llvm/include/llvm/Remarks/Remark.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/Remark.h,1,['avoid'],['avoid']
Safety,"/// In release builds, this is a no-op. For !NDEBUG builds, the checks are; /// implemented in the .cpp file to avoid circular header deps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h:112,avoid,avoid,112,interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,1,['avoid'],['avoid']
Safety,"/// In the ""DisableDerivedAbiTags"" mode derived ABI tags are not calculated.; /// This mode is used when mangler creates another mangler recursively to; /// calculate ABI tags for the function return value or the variable type.; /// Also it is required to avoid infinite recursion in some cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp:256,avoid,avoid,256,interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ItaniumMangle.cpp,1,['avoid'],['avoid']
Safety,"/// In the case of deeply invalid expressions, `getNextCorrection()` will; /// never be called since the transform never makes progress. If we don't; /// detect this we risk trying to correct typos forever.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h:154,detect,detect,154,interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/SemaInternal.h,2,"['detect', 'risk']","['detect', 'risk']"
Safety,"/// In the process of detecting a reduction, we consider a pair of; /// %ReductionOP, which we refer to as real and imag (or vice versa), and; /// traverse the use-tree to detect complex operations. As this is a reduction; /// operation, it will eventually reach RealPHI and ImagPHI, which corresponds; /// to the %ReductionOPs that we suspect to be complex.; /// RealPHI and ImagPHI are used by the identifyPHINode method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:22,detect,detecting,22,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,2,['detect'],"['detect', 'detecting']"
Safety,"/// Increment the number of samples for this record by \p S.; /// Optionally scale sample count \p S by \p Weight.; ///; /// Sample counts accumulate using saturating arithmetic, to avoid wrapping; /// around unsigned integers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:182,avoid,avoid,182,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['avoid'],['avoid']
Safety,"/// Indicate that it is potentially unsafe to automatically vectorize; /// floating-point operations because the semantics of vector and scalar; /// floating-point semantics may differ. For example, ARM NEON v7 SIMD math; /// does not support IEEE-754 denormal numbers, while depending on the; /// platform, scalar floating-point math does.; /// This applies to floating-point math operations and calls, not memory; /// operations, shuffles, or casts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,unsafe,unsafe,36,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['unsafe'],['unsafe']
Safety,/// Indicate that the specified indexed load does or does not work with the; /// specified type and indicate what to do abort it.; ///; /// NOTE: All indexed mode loads are initialized to Expand in; /// TargetLowering.cpp,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:120,abort,abort,120,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['abort'],['abort']
Safety,/// Indicates that distributed backend should skip compilation of the; /// module. Flag is suppose to be set by distributed ThinLTO indexing; /// when it detected that the module is not needed during the final; /// linking. As result distributed backend should just output a minimal; /// valid object file.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:154,detect,detected,154,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['detect'],['detected']
Safety,"/// Indicates whether it is safe use the Value2VPValue mapping or if the; /// mapping cannot be used any longer, because it is stale.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:28,safe,safe,28,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['safe'],['safe']
Safety,"/// IndirectAliased - Similar to Indirect, but the pointer may be to an; /// object that is otherwise referenced. The object is known to not be; /// modified through any other references for the duration of the call, and; /// the callee must not itself modify the object. Because C allows; /// parameter variables to be modified and guarantees that they have unique; /// addresses, the callee must defensively copy the object into a local; /// variable if it might be modified or its address might be compared.; /// Since those are uncommon, in principle this convention allows programs; /// to avoid copies in more situations. However, it may introduce *extra*; /// copies if the callee fails to prove that a copy is unnecessary and the; /// caller naturally produces an unaliased object for the argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h:595,avoid,avoid,595,interpreter/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/CodeGen/CGFunctionInfo.h,1,['avoid'],['avoid']
Safety,"/// InferPossibleTypes - As we emit the pattern, we end up generating type; /// checks and applying them to the 'PatWithNoTypes' tree. As we do this, we; /// want to propagate implied types as far throughout the tree as possible so; /// that we avoid doing redundant type checks. This does the type propagation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp:245,avoid,avoid,245,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcherGen.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,/// Inform safety info that we are planning to remove the instruction \p Inst; /// from its block. It will make all cache updates to keep it correct after; /// this removal.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:11,safe,safety,11,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['safe'],['safety']
Safety,/// Inform the CoreEngine that a basic block was aborted because; /// it could not be completely analyzed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h:49,abort,aborted,49,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h,1,['abort'],['aborted']
Safety,/// Inform the safety info that we are planning to insert a new instruction; /// \p Inst into the basic block \p BB. It will make all cache updates to keep; /// it correct after this insertion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:15,safe,safety,15,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['safe'],['safety']
Safety,/// Information that allows to avoid completing redundant enumerators.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp:31,avoid,avoid,31,interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCodeComplete.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,/// Initialize ProfOverlap with the sum of samples in base and test; /// profiles. This function also computes and keeps the sum of samples and; /// max sample counts of each function in BaseStats and TestStats for later; /// use to avoid re-computations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp:233,avoid,avoid,233,interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-profdata/llvm-profdata.cpp,1,['avoid'],['avoid']
Safety,/// Initialize the preprocessor to parse a model file; ///; /// To parse model files the preprocessor of the original source is reused to; /// preserver the identifier table. However to avoid some duplicate; /// information in the preprocessor some cleanup is needed before it is used; /// to parse model files. This method does that cleanup.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:186,avoid,avoid,186,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['avoid'],['avoid']
Safety,/// InlineParams - This is a local array used for the first function decl; /// chunk to avoid going to the heap for the common case when we have one; /// function chunk in the declarator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:88,avoid,avoid,88,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,1,['avoid'],['avoid']
Safety,"/// Insert a dependency-breaking instruction; /// before MI to eliminate an unwanted dependency on OpNum.; ///; /// If it wasn't possible to avoid a def in the last N instructions before MI; /// (see getPartialRegUpdateClearance), this hook will be called to break the; /// unwanted dependency.; ///; /// On x86, an xorps instruction can be used as a dependency breaker:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// xorps %xmm0, %xmm0; /// cvtsi2ss %rbx, %xmm0; ///; /// An <imp-kill> operand should be added to MI if an instruction was; /// inserted. This ties the instructions together in the post-ra scheduler.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:141,avoid,avoid,141,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['avoid'],['avoid']
Safety,"/// Insert an architecture-specific instruction to clear a register. If you; /// need to avoid sideeffects (e.g. avoid XOR on x86, which sets EFLAGS), set; /// \p AllowSideEffects to \p false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:89,avoid,avoid,89,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,['avoid'],['avoid']
Safety,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:535,avoid,avoid,535,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['avoid'],['avoid']
Safety,/// Insert nop instruction when hazard condition is found,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h:32,hazard,hazard,32,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.h,1,['hazard'],['hazard']
Safety,"/// Insert the specified binary operator, doing a small amount of work to; /// avoid inserting an obviously redundant operation, and hoisting to an; /// outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:79,avoid,avoid,79,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,3,"['avoid', 'redund', 'safe']","['avoid', 'redundant', 'safe']"
Safety,/// Insert truncates and extends for any truncated recipe. Redundant casts; /// will be folded later.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:59,Redund,Redundant,59,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,1,['Redund'],['Redundant']
Safety,"/// InsertBinop - Insert the specified binary operator, doing a small amount; /// of work to avoid inserting an obviously redundant operation, and hoisting; /// to an outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:93,avoid,avoid,93,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,3,"['avoid', 'redund', 'safe']","['avoid', 'redundant', 'safe']"
Safety,"/// Inserts 'NewPath' into this trie. \c ConsumedLength denotes; /// the number of \c NewPath's trailing characters already consumed during; /// recursion.; ///; /// An insert of a path; /// 'p'starts at the root node and does the following:; /// - If the node is empty, insert 'p' into its storage and abort.; /// - If the node has a path 'p2' but no children, take the last path segment; /// 's' of 'p2', put a new child into the map at 's' an insert the rest of; /// 'p2' there.; /// - Insert a new child for the last segment of 'p' and insert the rest of; /// 'p' there.; ///; /// An insert operation is linear in the number of a path's segments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp:303,abort,abort,303,interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/FileMatchTrie.cpp,1,['abort'],['abort']
Safety,/// Inserts a FileEntry into the file table.; ///; /// This is used to insert a file entry in a thread safe way into this object.; ///; /// \param FE A file entry object that contains valid string table offsets; /// from this object already.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:103,safe,safe,103,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,1,['safe'],['safe']
Safety,"/// Inserts an #include or #import directive of \p Header into the code.; /// If \p IsAngled is true, \p Header will be quoted with <> in the directive;; /// otherwise, it will be quoted with """".; ///; /// When searching for points to insert new header, this ignores #include's; /// after the #include block(s) in the beginning of a file to avoid inserting; /// headers into code sections where new #include's should not be added by; /// default. These code sections include:; /// - raw string literals (containing #include).; /// - #if blocks.; /// - Special #include's among declarations (e.g. functions).; ///; /// Returns a replacement that inserts the new header into a suitable #include; /// block of the same category. This respects the order of the existing; /// #includes in the block; if the existing #includes are not already sorted,; /// this will simply insert the #include in front of the first #include of the; /// same category in the code that should be sorted after \p IncludeName. If; /// \p IncludeName already exists (with exactly the same spelling), this; /// returns std::nullopt.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h:341,avoid,avoid,341,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h,1,['avoid'],['avoid']
Safety,"/// InstallLazyFunctionCreator - If an unknown function is needed, the; /// specified function pointer is invoked to create it. If it returns null,; /// the JIT will abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:166,abort,abort,166,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['abort'],['abort']
Safety,/// Instantiate a wide operation to replace a narrow operation. This only needs; /// to handle operations that can evaluation to SCEVAddRec. It can safely return; /// 0 for any operation we decide not to clone.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:148,safe,safely,148,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['safe'],['safely']
Safety,/// Instantiation or recovery rebuild of a for-range statement. Don't; /// attempt any typo-correction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:21,recover,recovery,21,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['recover'],['recovery']
Safety,"/// InstrInfoQuery provides an interface to query additional information for; /// instructions like metadata or keywords like nsw, which provides conservative; /// results if the users specified it is safe to use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:201,safe,safe,201,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,1,['safe'],['safe']
Safety,/// Instrument functions of a module to detect uninitialized reads.; ///; /// Instantiating MemorySanitizer inserts the msan runtime library API function; /// declarations into the module if they don't exist already. Instantiating; /// ensures the __msan_init function is in the list of global constructors for; /// the module.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:40,detect,detect,40,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,1,['detect'],['detect']
Safety,"/// Instrument memcpy; ///; /// Similar to memmove: avoid copying shadow twice. This is somewhat; /// unfortunate as it may slowdown small constant memcpys.; /// FIXME: consider doing manual inline for small constant sizes and proper; /// alignment.; ///; /// Note: This also handles memcpy.inline, which promises no calls to external; /// functions as an optimization. However, with instrumentation enabled this; /// is difficult to promise; additionally, we know that the MSan runtime; /// exists and provides __msan_memcpy(). Therefore, we assume that with; /// instrumentation it's safe to turn memcpy.inline into a call to; /// __msan_memcpy(). Should this be wrong, such as when implementing memcpy(); /// itself, instrumentation should be disabled with the no_sanitize attribute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:52,avoid,avoid,52,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,/// Interface to access stack safety analysis results for single function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:30,safe,safety,30,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,1,['safe'],['safety']
Safety,"/// Interface to connect the parser with the registry and more.; ///; /// The parser uses the Sema instance passed into; /// parseMatcherExpression() to handle all matcher tokens. The simplest; /// processor implementation would simply call into the registry to create; /// the matchers.; /// However, a more complex processor might decide to intercept the matcher; /// creation and do some extra work. For example, it could apply some; /// transformation to the matcher by adding some id() nodes, or could detect; /// specific matcher nodes for more efficient lookup.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h:507,detect,detect,507,interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/ASTMatchers/Dynamic/Parser.h,1,['detect'],['detect']
Safety,/// InterleavedLoadCombines Pass - This pass identifies interleaved loads and; /// combines them into wide loads detectable by InterleavedAccessPass; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:113,detect,detectable,113,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['detect'],['detectable']
Safety,"/// Invalidates cached information about the specified pointer, because it; /// may be too conservative in memdep.; ///; /// This is an optional call that can be used when the client detects an; /// equivalence between the pointer and some other value and replaces the; /// other value with ptr. This can make Ptr available in more places that; /// cached info does not necessarily keep.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:183,detect,detects,183,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,1,['detect'],['detects']
Safety,/// Invoked when an unsafe operation over raw pointers is found.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UnsafeBufferUsage.h:20,unsafe,unsafe,20,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UnsafeBufferUsage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UnsafeBufferUsage.h,1,['unsafe'],['unsafe']
Safety,"/// Is this instruction potentially interesting for further simplification after; /// widening it's type? In other words, can the extend be safely hoisted out of; /// the loop with SCEV reducing the value to a recurrence on the same loop. If; /// so, return the extended recurrence and the kind of extension used. Otherwise; /// return {nullptr, ExtendKind::Unknown}.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:140,safe,safely,140,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['safe'],['safely']
Safety,/// Is this intrinsic safe for big-endian? or does it need its arguments; /// reversing?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp:22,safe,safe,22,interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/utils/TableGen/NeonEmitter.cpp,1,['safe'],['safe']
Safety,/// Is this value an IMPLICIT_DEF that can be erased?; ///; /// IMPLICIT_DEF values should only exist at the end of a basic block that; /// is a predecessor to a phi-value. These IMPLICIT_DEF instructions can be; /// safely erased if they are overlapping a live value in the other live; /// interval.; ///; /// Weird control flow graphs and incomplete PHI handling in; /// ProcessImplicitDefs can very rarely create IMPLICIT_DEF values with; /// longer live ranges. Such IMPLICIT_DEF values should be treated like; /// normal values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:217,safe,safely,217,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['safe'],['safely']
Safety,"/// IsInvalidUnlessNestedName - This method is used for error recovery; /// purposes to determine whether the specified identifier is only valid as; /// a nested name specifier, for example a namespace name. It is; /// conservatively correct to always return false from this method.; ///; /// The arguments are the same as those passed to ActOnCXXNestedNameSpecifier.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp:62,recover,recovery,62,interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCXXScopeSpec.cpp,1,['recover'],['recovery']
Safety,"/// IsStartOfConflictMarker - If the specified pointer is the start of a version; /// control conflict marker like '<<<<<<<', recognize it as such, emit an error; /// and recover nicely. This returns true if it is a conflict marker and false; /// if not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:171,recover,recover,171,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['recover'],['recover']
Safety,"/// IsUntrackedValue - If the specified LatticeKey is obviously uninteresting; /// to the analysis (i.e., it would always return UntrackedVal), this; /// function can return true to avoid pointless work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:182,avoid,avoid,182,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,1,['avoid'],['avoid']
Safety,"/// It is a visitor for GCPtrTracker::verifyFunction. It decides if the; /// instruction (which uses heap reference) is legal or not, given our safepoint; /// semantics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:144,safe,safepoint,144,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['safe'],['safepoint']
Safety,/// It is never safe to tail call objc_autorelease since by tail calling; /// objc_autorelease: fast autoreleasing causing our object to be potentially; /// reclaimed from the autorelease pool which violates the semantics of; /// __autoreleasing types in ARC.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp:16,safe,safe,16,interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ObjCARCInstKind.cpp,1,['safe'],['safe']
Safety,"/// It is safe to destroy a constant iff it is only used by constants itself.; /// Note that constants cannot be cyclic, so this test is pretty easy to; /// implement recursively.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h:10,safe,safe,10,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/GlobalStatus.h,1,['safe'],['safe']
Safety,"/// It is safe to destroy a constant iff it is only used by constants itself.; /// Note that while constants cannot be cyclic, they can be tree-like, so we; /// should keep a visited set to avoid exponential runtime.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:10,safe,safe,10,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"/// Iterate over an enum type from Begin to End inclusive, even when `EnumT`; /// is not marked as safely iterable by `enum_iteration_traits`.; /// Note: `enum_seq_inclusive` will generate each consecutive value, even if no; /// enumerator with that value exists.; /// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX - 1]; /// for forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX - 1] for reverse; /// iteration).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:99,safe,safely,99,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,1,['safe'],['safely']
Safety,"/// Iterate over an enum type from Begin up to - but not including - End, even; /// when `EnumT` is not marked as safely iterable by `enum_iteration_traits`.; /// Note: `enum_seq` will generate each consecutive value, even if no; /// enumerator with that value exists.; /// Note: Begin and End values have to be within [INTMAX_MIN, INTMAX_MAX] for; /// forward iteration (resp. [INTMAX_MIN + 1, INTMAX_MAX] for reverse; /// iteration).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h:114,safe,safely,114,interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Sequence.h,1,['safe'],['safely']
Safety,/// Iterate over local declarations (locally parsed if this is a parsed; /// source file or the loaded declarations of the primary module if this is an; /// AST file).; /// \returns true if the iteration was complete or false if it was aborted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:236,abort,aborted,236,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['abort'],['aborted']
Safety,"/// Iterate through the sections, searching for the relocation section; /// associated with the unwind index table section specified by; /// IndexSectionIndex. Iterate the associated section searching for the; /// relocation associated with the index table entry specified by; /// IndexTableOffset. The symbol is the section symbol for the exception; /// handling table. Use this symbol to recover the actual exception handling; /// table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h:390,recover,recover,390,interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h,1,['recover'],['recover']
Safety,"/// JumpScopeChecker - This object is used by Sema to diagnose invalid jumps; /// into VLA and other protected scopes. For example, this rejects:; /// goto L;; /// int a[n];; /// L:; ///; /// We also detect jumps out of protected scopes when it's not possible to do; /// cleanups properly. Indirect jumps and ASM jumps can't do cleanups because; /// the target is unknown. Return statements with \c [[clang::musttail]] cannot; /// handle any cleanups due to the nature of a tail call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:200,detect,detect,200,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,1,['detect'],['detect']
Safety,/// Keeps track of function bodies that have already been parsed.; ///; /// Is thread-safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:86,safe,safe,86,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,1,['safe'],['safe']
Safety,/// Keeps track of non-local addresses that have been sunk into a block.; /// This allows us to avoid inserting duplicate code for blocks with; /// multiple load/stores of the same address. The usage of WeakTrackingVH; /// enables SunkAddrs to be treated as a cache whose entries can be; /// invalidated if a sunken address computation has been erased.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:96,avoid,avoid,96,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"/// LLVM RTTI discriminator. This is actually a SymbolKind enumerator, but is; /// unsigned to avoid sign extension and achieve better bitpacking with MSVC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h:95,avoid,avoid,95,interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h,1,['avoid'],['avoid']
Safety,/// LLVM i8 type. Cached here to avoid repeatedly getting it in all of the; /// places where it's used,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:33,avoid,avoid,33,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['avoid'],['avoid']
Safety,/// Lanes with defined values in this register. Other lanes are undef and; /// safe to clobber.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:79,safe,safe,79,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['safe'],['safe']
Safety,"/// LazyFunctionCreator - If an unknown function is needed, this function; /// pointer is invoked to create it. If this returns null, the JIT will; /// abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:152,abort,abort,152,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['abort'],['abort']
Safety,"/// Legal integers and common types are considered desirable. This is used to; /// avoid creating instructions with types that may not be supported well by the; /// the backend.; /// NOTE: This treats i8, i16 and i32 specially because they are common; /// types in frontend languages.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:83,avoid,avoid,83,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['avoid'],['avoid']
Safety,"/// Legalize an instruction by performing the operation on a wider scalar type; /// (for example a 16-bit addition can be safely performed at 32-bits; /// precision, ignoring the unused bits).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h:122,safe,safely,122,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerHelper.h,1,['safe'],['safely']
Safety,"/// Lifts a list of `ASTEdit`s into an `EditGenerator`.; ///; /// The `EditGenerator` will return an empty vector if any of the edits apply to; /// portions of the source that are ineligible for rewriting (certain; /// interactions with macros, for example) and it will fail if any invariants; /// are violated relating to bound nodes in the match. However, it does not; /// fail in the case of conflicting edits -- conflict handling is left to; /// clients. We recommend use of the \c AtomicChange or \c Replacements classes; /// for assistance in detecting such conflicts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h:549,detect,detecting,549,interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Transformer/RewriteRule.h,1,['detect'],['detecting']
Safety,/// Limits the size of scheduling regions in a block.; /// It avoid long compile times for _very_ large blocks where vector; /// instructions are spread over a wide range.; /// This limit is way higher than needed by real-world functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:62,avoid,avoid,62,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"/// List of categories and class extensions defined for this class.; ///; /// Categories are stored as a linked list in the AST, since the categories; /// and class extensions come long after the initial interface declaration,; /// and we avoid dynamically-resized arrays in the AST wherever possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:239,avoid,avoid,239,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['avoid'],['avoid']
Safety,"/// Little struct that can pack a float into the unused bits of the mantissa of a; /// NaN double. This can be used to transport information about violation; /// of function definition ranges, negative PDFs or other computation; /// problems in RooFit.; /// To separate NaNs that contain packed floats from regular NaNs, a tag is; /// written into the upper bits of the mantissa. If this tag is found, a payload; /// can be recovered. Otherwise, the NaN is assumed to originate from other sources; /// than a RooFit class that wants to signal to the minimiser.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooNaNPacker.h:424,recover,recovered,424,roofit/batchcompute/res/RooNaNPacker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/batchcompute/res/RooNaNPacker.h,1,['recover'],['recovered']
Safety,"/// LiveOutPair - A value and the block that defined it. The domtree node is; /// redundant, it can be computed as: MDT[Indexes.getMBBFromIndex(VNI->def)].",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:82,redund,redundant,82,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,1,['redund'],['redundant']
Safety,/// LoadInst specialization to compute vector information.; ///; /// This function also acts as abort condition to the recursion.; ///; /// \param LI LoadInst to operate on; /// \param Result Result of the computation; ///; /// \returns false if no sensible information can be gathered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:96,abort,abort,96,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['abort'],['abort']
Safety,"/// Look for extractelement/insertvalue sequence that acts like a bitcast.; ///; /// \returns underlying value that was ""cast"", or nullptr otherwise.; ///; /// For example, if we have:; ///; /// %E0 = extractelement <2 x double> %U, i32 0; /// %V0 = insertvalue [2 x double] undef, double %E0, 0; /// %E1 = extractelement <2 x double> %U, i32 1; /// %V1 = insertvalue [2 x double] %V0, double %E1, 1; ///; /// and the layout of a <2 x double> is isomorphic to a [2 x double],; /// then %V1 can be safely approximated by a conceptual ""bitcast"" of %U.; /// Note that %U may contain non-undef values where %V1 has undef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:497,safe,safely,497,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,1,['safe'],['safely']
Safety,"/// Lookup a single address within a line table's data.; ///; /// Clients have the option to decode an entire line table using; /// LineTable::decode() or just find a single matching entry using this; /// function. The benefit of using this function is that parsed LineEntry; /// objects that do not match will not be stored in an array. This will avoid; /// memory allocation costs and parsing can stop once a match has been found.; ///; /// \param Data The binary stream to read the data from. This object must; /// have the data for the LineTable object starting at offset zero. The data; /// can contain more data than needed.; ///; /// \param BaseAddr The base address to use when decoding the line table.; /// This will be the FunctionInfo's start address and will be used to; /// initialize the line table row prior to parsing any opcodes.; ///; /// \returns An LineEntry object if a match is found, error otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h:348,avoid,avoid,348,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/LineTable.h,1,['avoid'],['avoid']
Safety,"/// Lookup a single address within the inline info data.; ///; /// Clients have the option to decode an entire InlineInfo object (using; /// InlineInfo::decode() ) or just find the matching inline info using this; /// function. The benefit of using this function is that only the information; /// needed for the lookup will be extracted, other info can be skipped and; /// parsing can stop as soon as the deepest match is found. This allows; /// symbolication tools to be fast and efficient and avoid allocation costs; /// when doing lookups.; ///; /// This function will augment the SourceLocations array \a SrcLocs with any; /// inline information that pertains to \a Addr. If no inline information; /// exists for \a Addr, then \a SrcLocs will be left untouched. If there is; /// inline information for \a Addr, then \a SrcLocs will be modifiied to; /// contain the deepest most inline function's SourceLocation at index zero; /// in the array and proceed up the concrete function source file and; /// line at the end of the array.; ///; /// \param GR The GSYM reader that contains the string and file table that; /// will be used to fill in the source locations.; ///; /// \param Data The binary stream to read the data from. This object must; /// have the data for the LineTable object starting at offset zero. The data; /// can contain more data than needed.; ///; /// \param BaseAddr The base address to use when decoding the line table.; /// This will be the FunctionInfo's start address and will be used to; /// decode the correct addresses for the inline information.; ///; /// \param Addr The address to lookup.; ///; /// \param SrcLocs The inline source locations that matches \a Addr. This; /// array must be initialized with the matching line entry; /// from the line table upon entry. The name of the concrete; /// function must be supplied since it will get pushed to; /// the last SourceLocation entry and the inline information; /// will fill in the source file and line from the inl",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h:495,avoid,avoid,495,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/InlineInfo.h,1,['avoid'],['avoid']
Safety,"/// Lookup an address in the a GSYM.; ///; /// Lookup just the information needed for a specific address \a Addr. This; /// function is faster that calling getFunctionInfo() as it will only return; /// information that pertains to \a Addr and allows the parsing to skip any; /// extra information encoded for other addresses. For example the line table; /// parsing can stop when a matching LineEntry has been fouhnd, and the; /// InlineInfo can stop parsing early once a match has been found and also; /// skip information that doesn't match. This avoids memory allocations and; /// is much faster for lookups.; ///; /// \param Addr A virtual address from the orignal object file to lookup.; /// \returns An expected LookupResult that contains only the information; /// needed for the current address, or an error object that indicates reason; /// for failing to lookup the address.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h:549,avoid,avoids,549,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h,1,['avoid'],['avoids']
Safety,"/// Loop over all of the basic blocks, replacing address; /// calculations in load and store instructions, if it's already; /// been calculated by LEA. Also, remove redundant LEAs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:165,redund,redundant,165,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['redund'],['redundant']
Safety,/// LoopVectorizationCostModel - estimates the expected speedups due to; /// vectorization.; /// In many cases vectorization is not profitable. This can happen because of; /// a number of reasons. In this class we mainly attempt to predict the; /// expected speedup/slowdowns due to the supported instruction set. We use the; /// TargetTransformInfo to query the different backends for the cost of; /// different operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:232,predict,predict,232,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['predict'],['predict']
Safety,"/// Lower a vector shuffle as a zero or any extension.; ///; /// Given a specific number of elements, element bit width, and extension; /// stride, produce either a zero or any extension based on the available; /// features of the subtarget. The extended elements are consecutive and; /// begin and can start from an offsetted element index in the input; to; /// avoid excess shuffling the offset must either being in the bottom lane; /// or at the start of a higher lane. All extended elements must be from; /// the same lane.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:363,avoid,avoid,363,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['avoid'],['avoid']
Safety,"/// Lower barriers out of existence (if the associated GCStrategy hasn't; /// already done so...), and insert initializing stores to roots as a defensive; /// measure. Given we're going to report all roots live at all safepoints, we; /// need to be able to ensure each root has been initialized by the point the; /// first safepoint is reached. This really should have been done by the; /// frontend, but the old API made this non-obvious, so we do a potentially; /// redundant store just in case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp:218,safe,safepoints,218,interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GCRootLowering.cpp,3,"['redund', 'safe']","['redundant', 'safepoint', 'safepoints']"
Safety,"/// Lower deopt state and gc pointer arguments of the statepoint. The actual; /// lowering is described in lowerIncomingStatepointValue. This function is; /// responsible for lowering everything in the right position and playing some; /// tricks to avoid redundant stack manipulation where possible. On; /// completion, 'Ops' will contain ready to use operands for machine code; /// statepoint. The chain nodes will have already been created and the DAG root; /// will be set to the last value spilled (if any were).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:249,avoid,avoid,249,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,/// MachineLateInstrsCleanup - This pass removes redundant identical; /// instructions after register allocation and rematerialization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:49,redund,redundant,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['redund'],['redundant']
Safety,/// Main run interface method. We override here to avoid calling skipSCC().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp:51,avoid,avoid,51,interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,1,['avoid'],['avoid']
Safety,"/// Maintain hazard recognizers for all blocks, so that the scheduler state; /// can be maintained past BB boundaries when appropariate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:13,hazard,hazard,13,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['hazard'],['hazard']
Safety,"/// Make coefficients of RooAddPdf sum to more than 1. Fitter should recover from this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:69,recover,recover,69,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,1,['recover'],['recover']
Safety,"/// Make coefficients of RooRealSumPdf sum to more than 1. Fitter should recover from this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx:73,recover,recover,73,roofit/roofitcore/test/testNaNPacker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testNaNPacker.cxx,1,['recover'],['recover']
Safety,"/// Make sure that for each type in \p Small, there exists a larger type; /// in \p Big. \p SmallIsVT indicates that this is being called for; /// SDTCisVTSmallerThanOp. In that case the TypeSetByHwMode is re-created for; /// each call and needs special consideration in how we detect changes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h:278,detect,detect,278,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.h,1,['detect'],['detect']
Safety,/// Makes sure all subscript pairs share the same integer type by; /// sign-extending as necessary.; /// Sign-extending a subscript is safe because getelementptr assumes the; /// array subscripts are signed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:135,safe,safe,135,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['safe'],['safe']
Safety,"/// Manages TObject-derived objects created in a PyROOT application; ///; /// This class is responsible to keep track of the creation of the objects; /// that need further memory management within ROOT. The `ClearProxiedObjects`; /// function is only called at PyROOT shutdown time. The `CallCppyyRecursiveRemove`; /// is called as part of the global list of cleanups object destruction.; ///; /// This class is intentionally not derived from TObject. See the; /// `PyROOT::RegulatorCleanup` class for more info.; ///; /// \note This class is not thread-safe on its own. We create one thread-local; /// object in PyROOTWrapper.cxx.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TMemoryRegulator.h:554,safe,safe,554,bindings/pyroot/pythonizations/src/TMemoryRegulator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/bindings/pyroot/pythonizations/src/TMemoryRegulator.h,1,['safe'],['safe']
Safety,"/// Many allocas are only used within a single basic block. If this is the; /// case, avoid traversing the CFG and inserting a lot of potentially useless; /// PHI nodes by just performing a single linear pass over the basic block; /// using the Alloca.; ///; /// If we cannot promote this alloca (because it is read before it is written),; /// return false. This is necessary in cases where, due to control flow, the; /// alloca is undefined only on some control flow paths. e.g. code like; /// this is correct in LLVM IR:; /// // A is an alloca with no stores so far; /// for (...) {; /// int t = *A;; /// if (!first_iteration); /// use(t);; /// *A = 42;; /// }",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:86,avoid,avoid,86,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['avoid'],['avoid']
Safety,/// Map for recovering vreg name from vreg number.; /// This map is used by the MIR Printer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:12,recover,recovering,12,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,1,['recover'],['recovering']
Safety,"/// Map from {State, Action} to {NewState, TransitionInfoIdx}.; /// TransitionInfoIdx is used by the DfaTranscriber to analyze the transition.; /// FIXME: This uses a std::map because ActionT can be a pair type including; /// an enum. In particular DenseMapInfo<ActionT> must be defined to use; /// DenseMap here.; /// This is a shared_ptr to allow very quick copy-construction of Automata; this; /// state is immutable after construction so this is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h:450,safe,safe,450,interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Automaton.h,1,['safe'],['safe']
Safety,/// Map of all string variables defined so far. Used at parse time to detect; /// a name conflict between a numeric variable and a string variable when; /// the former is defined on a later line than the latter.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h:70,detect,detect,70,interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/FileCheck/FileCheckImpl.h,1,['detect'],['detect']
Safety,"/// Maps HeaderMap keys to SearchDir indices. When HeaderMaps are used; /// heavily, SearchDirs can start with thousands of HeaderMaps, so this Index; /// lets us avoid scanning them all to find a match.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h:163,avoid,avoid,163,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearch.h,1,['avoid'],['avoid']
Safety,"/// Maps from a start to an end spelling location of transformations; /// performed by the preprocessor. These include:; /// 1. range from '#' to the last token in the line for PP directives,; /// 2. macro name and arguments for macro expansions.; /// Note that we record only top-level macro expansions, intermediate; /// expansions (e.g. inside macro arguments) are ignored.; ///; /// Used to find correct boundaries of macro calls and directives when; /// building mappings from spelled to expanded tokens.; ///; /// Logically, at each point of the preprocessor execution there is a stack of; /// macro expansions being processed and we could use it to recover the; /// location information we need. However, the public preprocessor API only; /// exposes the points when macro expansions start (when we push a macro onto; /// the stack) and not when they end (when we pop a macro from the stack).; /// To workaround this limitation, we rely on source location information; /// stored in this map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h:656,recover,recover,656,interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Syntax/Tokens.h,1,['recover'],['recover']
Safety,"/// Mark MI as dead. If a def of one of MI's operands, DefMI, would also be; /// dead due to MI being killed, then mark DefMI as dead too.; /// Some of the combines (extends(trunc)), try to walk through redundant; /// copies in between the extends and the truncs, and this attempts to collect; /// the in between copies if they're dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h:203,redund,redundant,203,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizationArtifactCombiner.h,1,['redund'],['redundant']
Safety,"/// Mark a variable's reference in a lambda as non-odr using.; ///; /// For generic lambdas, if a variable is named in a potentially evaluated; /// expression, where the enclosing full expression is dependent then we; /// must capture the variable (given a default capture).; /// This is accomplished by recording all references to variables; /// (DeclRefExprs or MemberExprs) within said nested lambda in its array of; /// PotentialCaptures. All such variables have to be captured by that lambda,; /// except for as described below.; /// If that variable is usable as a constant expression and is named in a; /// manner that does not involve its odr-use (e.g. undergoes; /// lvalue-to-rvalue conversion, or discarded) record that it is so. Upon the; /// act of analyzing the enclosing full expression (ActOnFinishFullExpr); /// if we can determine that the full expression is not instantiation-; /// dependent, then we can entirely avoid its capture.; ///; /// const int n = 0;; /// [&] (auto x) {; /// (void)+n + x;; /// };; /// Interestingly, this strategy would involve a capture of n, even though; /// it's obviously not odr-used here, because the full-expression is; /// instantiation-dependent. It could be useful to avoid capturing such; /// variables, even when they are referred to in an instantiation-dependent; /// expression, if we can unambiguously determine that they shall never be; /// odr-used. This would involve removal of the variable-referring-expression; /// from the array of PotentialCaptures during the lvalue-to-rvalue; /// conversions. But per the working draft N3797, (post-chicago 2013) we must; /// capture such variables.; /// Before anyone is tempted to implement a strategy for not-capturing 'n',; /// consider the insightful warning in:; /// /cfe-commits/Week-of-Mon-20131104/092596.html; /// ""The problem is that the set of captures for a lambda is part of the ABI; /// (since lambda layout can be made visible through inline functions and the; /// like), and there",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:933,avoid,avoid,933,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,1,['avoid'],['avoid']
Safety,"/// Mark the plan to indicate that using Value2VPValue is not safe any; /// longer, because it may be stale.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:62,safe,safe,62,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['safe'],['safe']
Safety,"/// Mark the pointer as escaped, and the visit as aborted. Intended; /// for use in a void return.; /// \param I The instruction which both escapes the pointer and aborts the; /// visit, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:50,abort,aborted,50,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,2,['abort'],"['aborted', 'aborts']"
Safety,"/// Mark the visit as aborted. Intended for use in a void return.; /// \param I The instruction which caused the visit to abort, if available.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:22,abort,aborted,22,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,2,['abort'],"['abort', 'aborted']"
Safety,"/// Marks that the current location is not supposed to be reachable.; /// In !NDEBUG builds, prints the message and location info to stderr.; /// In NDEBUG builds, if the platform does not support a builtin unreachable; /// then we call an internal LLVM runtime function. Otherwise the behavior is; /// controlled by the CMake flag; /// -DLLVM_UNREACHABLE_OPTIMIZE; /// * When ""ON"" (default) llvm_unreachable() becomes an optimizer hint; /// that the current location is not supposed to be reachable: the hint; /// turns such code path into undefined behavior. On compilers that don't; /// support such hints, prints a reduced message instead and aborts the; /// program.; /// * When ""OFF"", a builtin_trap is emitted instead of an; // optimizer hint or printing a reduced message.; ///; /// Use this instead of assert(0). It conveys intent more clearly, suppresses; /// diagnostics for unreachable code paths, and allows compilers to omit; /// unnecessary code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:647,abort,aborts,647,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,1,['abort'],['aborts']
Safety,/// Marks the end of an TSX (RTM) suspend load address tracking region. If this; /// intrinsic is used inside a suspend load address tracking region it will; /// end the suspend region and all following load addresses will be added to; /// the transaction read set. If it's used inside an active transaction but; /// not in a suspend region it will cause transaction abort. If it's used; /// outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XRESLDTRK instruction.; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:367,abort,abort,367,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,1,['abort'],['abort']
Safety,"/// Marks the start of an TSX (RTM) suspend load address tracking region. If; /// this intrinsic is used inside a transactional region, subsequent loads; /// are not added to the read set of the transaction. If it's used inside a; /// suspend load address tracking region it will cause transaction abort.; /// If it's used outside of a transactional region it behaves like a NOP.; ///; /// \headerfile <x86intrin.h>; ///; /// This intrinsic corresponds to the \c XSUSLDTRK instruction.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h:298,abort,abort,298,interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/tsxldtrkintrin.h,1,['abort'],['abort']
Safety,/// Match UB-safe variants of the funnel shift intrinsic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:13,safe,safe,13,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safe']
Safety,"/// Materialize and insert \p Res = G_PTR_ADD \p Op0, (G_CONSTANT \p Value); ///; /// G_PTR_ADD adds \p Value bytes to the pointer specified by \p Op0,; /// storing the resulting pointer in \p Res. If \p Value is zero then no; /// G_PTR_ADD or G_CONSTANT will be created and \pre Op0 will be assigned to; /// \p Res.; ///; /// \pre setBasicBlock or setMI must have been called.; /// \pre \p Op0 must be a generic virtual register with pointer type.; /// \pre \p ValueTy must be a scalar type.; /// \pre \p Res must be 0. This is to detect confusion between; /// materializePtrAdd() and buildPtrAdd().; /// \post \p Res will either be a new generic virtual register of the same; /// type as \p Op0 or \p Op0 itself.; ///; /// \return a MachineInstrBuilder for the newly created instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:532,detect,detect,532,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,1,['detect'],['detect']
Safety,"/// Mechanism to add runtime checking of devirtualization decisions, optionally; /// trapping or falling back to indirect call on any that are not correct.; /// Trapping mode is useful for debugging undefined behavior leading to failures; /// with WPD. Fallback mode is useful for ensuring safety when whole program; /// visibility may be compromised.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp:290,safe,safety,290,interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/WholeProgramDevirt.cpp,1,['safe'],['safety']
Safety,/// Memory access instruction may be vectorized in more than one way.; /// Form of instruction after vectorization depends on cost.; /// This function takes cost-based decisions for Load/Store instructions; /// and collects them in a map. This decisions map is used for building; /// the lists of loop-uniform and loop-scalar instructions.; /// The calculated cost is saved with widening decision in order to; /// avoid redundant calculations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:414,avoid,avoid,414,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"/// Merge all the thread private objects. Can be called many times. It; /// does create a new instance of class T to represent the ""Sum"" object.; /// This method is not thread safe: correct or acceptable behaviours; /// depend on the nature of T and of the merging function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:176,safe,safe,176,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['safe'],['safe']
Safety,/// Merge parallel regions when it is safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:38,safe,safe,38,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['safe'],['safe']
Safety,/// Merges the stores in the given vector into a wide store.; /// \p returns true if at least some of the stores were merged.; /// This may decide not to merge stores if heuristics predict it will not be; /// worth it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h:181,predict,predict,181,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,1,['predict'],['predict']
Safety,/// Merging redundant sexts when one is dominating the other.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp:12,redund,redundant,12,interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CodeGenPrepare.cpp,1,['redund'],['redundant']
Safety,"/// Method to try and mark a result as invalid.; ///; /// When the outer analysis manager detects a change in some underlying; /// unit of the IR, it will call this method on all of the results cached.; ///; /// \p PA is a set of preserved analyses which can be used to avoid; /// invalidation because the pass which changed the underlying IR took care; /// to update or preserve the analysis result in some way.; ///; /// \p Inv is typically a \c AnalysisManager::Invalidator object that can be; /// used by a particular analysis result to discover if other analyses; /// results are also invalidated in the event that this result depends on; /// them. See the documentation in the \c AnalysisManager for more details.; ///; /// \returns true if the result is indeed invalid (the default).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:90,detect,detects,90,interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,2,"['avoid', 'detect']","['avoid', 'detects']"
Safety,/// Minimal filter to detect invalid constructs for inlining.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:22,detect,detect,22,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,1,['detect'],['detect']
Safety,"/// Minuit calls (via FcnAdapters etc) DoEval or Gradient with a set of parameters x.; /// This function syncs these values to the proper places in RooFit.; ///; /// The first twist, and reason this function is more complicated than one may imagine, is that Minuit internally uses a; /// transformed parameter space to account for parameter boundaries. Whether we receive these Minuit ""internal""; /// parameter values or ""regular""/untransformed RooFit parameter space values depends on the situation.; /// - The values that arrive here via DoEval are always ""normal"" parameter values, since Minuit transforms these; /// back into regular space before passing to DoEval (see MnUserFcn::operator() which wraps the Fcn(Gradient)Base; /// in ModularFunctionMinimizer::Minimize and is used for direct function calls from that point on in the minimizer).; /// These can thus always be safely synced with this function's RooFit parameters using SetPdfParamVal.; /// - The values that arrive here via Gradient will be in internal coordinates if that is; /// what this class expects, and indeed this is the case for MinuitFcnGrad's current implementation. This is; /// communicated to Minuit via MinuitFcnGrad::returnsInMinuit2ParameterSpace. Inside Minuit, that function determines; /// whether this class's gradient calculator is wrapped inside a AnalyticalGradientCalculator, to which Minuit passes; /// ""external"" parameter values, or as an ExternalInternalGradientCalculator, which gets ""internal"" parameter values.; /// Long story short: when MinuitFcnGrad::returnsInMinuit2ParameterSpace() returns true, Minuit will pass ""internal""; /// values to Gradient. These cannot be synced with this function's RooFit parameters using; /// SetPdfParamVal, unless a manual transformation step is performed in advance. However, they do need to be passed; /// on to the gradient calculator, since indeed we expect values there to be in ""internal"" space. However, this is; /// calculator dependent. Note that in the c",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx:879,safe,safely,879,roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/TestStatistics/MinuitFcnGrad.cxx,1,['safe'],['safely']
Safety,/// Mode of ASan detect stack use after return,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizerOptions.h:17,detect,detect,17,interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Instrumentation/AddressSanitizerOptions.h,1,['detect'],['detect']
Safety,/// Modeling special VFP / NEON fp MLA / MLS hazards.; /// MLxEntryMap - Map fp MLA / MLS to the corresponding entry in the internal; /// MLx table.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:45,hazard,hazards,45,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,1,['hazard'],['hazards']
Safety,"/// MorphNodeTo - This *mutates* the specified node to have the specified; /// return type, opcode, and operands.; ///; /// Note that MorphNodeTo returns the resultant node. If there is already a; /// node of the specified opcode and operands, it returns that node instead of; /// the current one. Note that the SDLoc need not be the same.; ///; /// Using MorphNodeTo is faster than creating a new node and swapping it in; /// with ReplaceAllUsesWith both because it often avoids allocating a new; /// node, and because it doesn't require CSE recalculation for any of; /// the node's users.; ///; /// However, note that MorphNodeTo recursively deletes dead nodes from the DAG.; /// As a consequence it isn't appropriate to use from within the DAG combiner or; /// the legalizer which maintain worklists that would need to be updated when; /// deleting things.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:473,avoid,avoids,473,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['avoid'],['avoids']
Safety,"/// Move instructions, in an order-preserving manner, from \p FromBB to the end; /// of \p ToBB when proven safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h:108,safe,safe,108,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,1,['safe'],['safe']
Safety,"/// Move instructions, in an order-preserving manner, from \p FromBB to the; /// beginning of \p ToBB when proven safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h:114,safe,safe,114,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,1,['safe'],['safe']
Safety,"/// Must not call Write() of all attached objects:; /// some might not be needed to be written or writing might be aborted due to; /// an exception; require explicit Write().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:115,abort,aborted,115,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['abort'],['aborted']
Safety,"/// MutableArrayRef - Represent a mutable reference to an array (0 or more; /// elements consecutively in memory), i.e. a start pointer and a length. It; /// allows various APIs to take and modify consecutive elements easily and; /// conveniently.; ///; /// This class does not own the underlying data, it is expected to be used in; /// situations where the data resides in some other buffer, whose lifetime; /// extends past that of the MutableArrayRef. For this reason, it is not in; /// general safe to store a MutableArrayRef.; ///; /// This is intended to be trivially copyable, so it should be passed by; /// value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:498,safe,safe,498,interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ArrayRef.h,1,['safe'],['safe']
Safety,/// Name suffixes which canonicalization should handle to avoid; /// profile mismatch.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h:58,avoid,avoid,58,interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/SampleProf.h,1,['avoid'],['avoid']
Safety,"/// Note, we assume here that void* is related to raw malloc'ed memory and; /// that malloc returns objects at least 4-byte aligned. However, this may be; /// wrong, or pointers may be from something other than malloc. In this case,; /// you should specify a real typed pointer or avoid this template.; ///; /// All clients should use assertions to do a run-time check to ensure that; /// this is actually true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PointerLikeTypeTraits.h:281,avoid,avoid,281,interpreter/llvm-project/llvm/include/llvm/Support/PointerLikeTypeTraits.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PointerLikeTypeTraits.h,1,['avoid'],['avoid']
Safety,"/// Number of elements (from consecutive iterations) that are safe to; /// operate on simultaneously, multiplied by the size of the element in bits.; /// The size of the element is taken from the memory access that is most; /// restrictive.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:62,safe,safe,62,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['safe'],['safe']
Safety,/// Number of hazard wait states for s_setreg_b32/s_setreg_imm32_b32.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h:14,hazard,hazard,14,interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/GCNSubtarget.h,1,['hazard'],['hazard']
Safety,/// Objective-C string literals can be safely casted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp:39,safe,safely,39,interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExprObjC.cpp,1,['safe'],['safely']
Safety,/// Offset relative to the start of the DECLTYPES_BLOCK block. Keep; /// structure alignment 32-bit and avoid padding gap because undefined; /// value in the padding affects AST hash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h:104,avoid,avoid,104,interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTBitCodes.h,1,['avoid'],['avoid']
Safety,"/// Open timeout constants",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h:9,timeout,timeout,9,io/io/inc/TFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/TFile.h,1,['timeout'],['timeout']
Safety,"/// Opportunistically remove the callee from ReferencesToConsteval if we can.; /// It's OK if this fails; we'll also remove this in; /// HandleImmediateInvocations, but catching it here allows us to avoid; /// walking the AST looking for it in simple cases.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:199,avoid,avoid,199,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,"/// Optimize for fast execution as much as possible.; ///; /// This mode is significantly more aggressive in trading off compile time; /// and code size to get execution time improvements. The core idea is that; /// this mode should include any optimization that helps execution time on; /// balance across a diverse collection of benchmarks, even if it increases; /// code size or compile time for some benchmarks without corresponding; /// improvements to execution time.; ///; /// Despite being willing to trade more compile time off to get improved; /// execution time, this mode still tries to avoid superlinear growth in; /// order to make even significantly slower compile times at least scale; /// reasonably. This does not preclude very substantial constant factor; /// costs though.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:599,avoid,avoid,599,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,1,['avoid'],['avoid']
Safety,"/// Optimize generic copy instructions to avoid cross register bank copy.; /// The optimization looks through a chain of copies and tries to find a source; /// that has a compatible register class.; /// Two register classes are considered to be compatible if they share the same; /// register bank.; /// New copies issued by this optimization are register allocator; /// friendly. This optimization does not remove any copy as it may; /// overconstrain the register allocator, but replaces some operands; /// when possible.; /// \pre isCoalescableCopy(*MI) is true.; /// \return True, when \p MI has been rewritten. False otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:42,avoid,avoid,42,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,1,['avoid'],['avoid']
Safety,"/// Optimize quickly without destroying debuggability.; ///; /// This level is tuned to produce a result from the optimizer as quickly; /// as possible and to avoid destroying debuggability. This tends to result; /// in a very good development mode where the compiled code will be; /// immediately executed as part of testing. As a consequence, where; /// possible, we would like to produce efficient-to-execute code, but not; /// if it significantly slows down compilation or would prevent even basic; /// debugging of the resulting binary.; ///; /// As an example, complex loop transformations such as versioning,; /// vectorization, or fusion don't make sense here due to the degree to; /// which the executed code differs from the source code, and the compile; /// time cost.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h:159,avoid,avoid,159,interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Passes/OptimizationLevel.h,1,['avoid'],['avoid']
Safety,"/// OptimizeVFPBrcond - With -enable-unsafe-fp-math, it's legal to optimize some; /// f32 and even f64 comparisons to integer ones.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:37,unsafe,unsafe-fp-math,37,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['unsafe'],['unsafe-fp-math']
Safety,"/// Optional filters on the arguments which will be match. To avoid a; /// zero-sized array, we store one specifier even if we're asked for none.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h:62,avoid,avoid,62,interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Option/ArgList.h,1,['avoid'],['avoid']
Safety,"/// Optional target hook that returns true if \p MBB is safe to outline from,; /// and returns any target-specific information in \p Flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:56,safe,safe,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['safe'],['safe']
Safety,/// Order may have elements assigned special value (size) which is out of; /// bounds. Such indices only appear on places which correspond to undef values; /// (see canReuseExtract for details) and used in order to avoid undef values; /// have effect on operands ordering.; /// The first loop below simply finds all unused indices and then the next loop; /// nest assigns these indices for undef values positions.; /// As an example below Order has two undef positions and they have assigned; /// values 3 and 7 respectively:; /// before: 6 9 5 4 9 2 1 0; /// after: 6 3 5 4 7 2 1 0,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:215,avoid,avoid,215,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,/// PPCDispatchGroupSBHazardRecognizer - This class implements a scoreboard-based; /// hazard recognizer for PPC ooo processors with dispatch-group hazards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:87,hazard,hazard,87,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,2,['hazard'],"['hazard', 'hazards']"
Safety,"/// PPCHazardRecognizer970 - This class defines a finite state automata that; /// models the dispatch logic on the PowerPC 970 (aka G5) processor. This; /// promotes good dispatch group formation and implements noop insertion to; /// avoid structural hazards that cause significant performance penalties (e.g.; /// setting the CTR register then branching through it within a dispatch group),; /// or storing then loading from the same address within a dispatch group.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h:234,avoid,avoid,234,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.h,2,"['avoid', 'hazard']","['avoid', 'hazards']"
Safety,"/// Packed index data structure. This index can either refer to a range of primitives for a BVH; /// leaf, or to the children of a BVH node. In either case, the index corresponds to a contiguous; /// range, which means that:; ///; /// - For leaves, primitives in a BVH node should be accessed via:; ///; /// size_t begin = index.first_id();; /// size_t end = begin + index.prim_count();; /// for (size_t i = begin; i < end; ++i) {; /// size_t prim_id = bvh.prim_ids[i];; /// // ...; /// }; ///; /// Note that for efficiency, reordering the original data to avoid the indirection via; /// `bvh.prim_ids` is preferable.; ///; /// - For inner nodes, children should be accessed via:; ///; /// auto& left_child = bvh.nodes[index.first_id()];; /// auto& right_child = bvh.nodes[index.first_id() + 1];; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/index.h:557,avoid,avoid,557,geom/geom/inc/bvh/v2/index.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/inc/bvh/v2/index.h,1,['avoid'],['avoid']
Safety,"/// Parallel decompression and unpacking of the pages in the given cluster. The unzipped pages are supposed; /// to be preloaded in a page pool attached to the source. The method is triggered by the cluster pool's; /// unzip thread. It is an optional optimization, the method can safely do nothing. In particular, the; /// actual implementation will only run if a task scheduler is set. In practice, a task scheduler is set; /// if implicit multi-threading is turned on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:280,safe,safely,280,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['safe'],['safely']
Safety,"/// Parse a lambda introducer.; /// \param Intro A LambdaIntroducer filled in with information about the; /// contents of the lambda-introducer.; /// \param Tentative If non-null, we are disambiguating between a; /// lambda-introducer and some other construct. In this mode, we do not; /// produce any diagnostics or take any other irreversible action unless; /// we're sure that this is a lambda-expression.; /// \return \c true if parsing (or disambiguation) failed with a diagnostic and; /// the caller should bail out / recover.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:524,recover,recover,524,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recover']
Safety,"/// Parse the TableGen file defined within the main buffer of the given; /// SourceMgr. On success, populates the provided RecordKeeper with the parsed; /// records and returns false. On failure, returns true.; ///; /// NOTE: TableGen currently relies on global state within a given parser; /// invocation, so this function is not thread-safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Parser.h:338,safe,safe,338,interpreter/llvm-project/llvm/include/llvm/TableGen/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TableGen/Parser.h,1,['safe'],['safe']
Safety,"/// Parse the given string as a type.; ///; /// This is a dangerous utility function currently employed only by API notes.; /// It is not a general entry-point for safely parsing types from strings.; ///; /// \param TypeStr The string to be parsed as a type.; /// \param Context The name of the context in which this string is being; /// parsed, which will be used in diagnostics.; /// \param IncludeLoc The location at which this parse was triggered.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:164,safe,safely,164,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['safe'],['safely']
Safety,"/// ParseAsmOperands - Parse the asm-operands production as used by; /// asm-statement, assuming the leading ':' token was eaten.; ///; /// [GNU] asm-operands:; /// asm-operand; /// asm-operands ',' asm-operand; ///; /// [GNU] asm-operand:; /// asm-string-literal '(' expression ')'; /// '[' identifier ']' asm-string-literal '(' expression ')'; ///; //; // FIXME: Avoid unnecessary std::string trashing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp:365,Avoid,Avoid,365,interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmtAsm.cpp,1,['Avoid'],['Avoid']
Safety,"/// ParseCXXCondition - if/switch/while condition expression.; ///; /// condition:; /// expression; /// type-specifier-seq declarator '=' assignment-expression; /// [C++11] type-specifier-seq declarator '=' initializer-clause; /// [C++11] type-specifier-seq declarator braced-init-list; /// [Clang] type-specifier-seq ref-qualifier[opt] '[' identifier-list ']'; /// brace-or-equal-initializer; /// [GNU] type-specifier-seq declarator simple-asm-expr[opt] attributes[opt]; /// '=' assignment-expression; ///; /// In C++1z, a condition may in some contexts be preceded by an; /// optional init-statement. This function will parse that too.; ///; /// \param InitStmt If non-null, an init-statement is permitted, and if present; /// will be parsed and stored here.; ///; /// \param Loc The location of the start of the statement that requires this; /// condition, e.g., the ""for"" in a for loop.; ///; /// \param MissingOK Whether an empty condition is acceptable here. Otherwise; /// it is considered an error to be recovered from.; ///; /// \param FRI If non-null, a for range declaration is permitted, and if; /// present will be parsed and stored here, and a null result will be returned.; ///; /// \param EnterForConditionScope If true, enter a continue/break scope at the; /// appropriate moment for a 'for' loop.; ///; /// \returns The parsed condition.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp:1012,recover,recovered,1012,interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseExprCXX.cpp,1,['recover'],['recovered']
Safety,"/// ParseCXXMemberInitializer - Parse the brace-or-equal-initializer.; /// Also detect and reject any attempted defaulted/deleted function definition.; /// The location of the '=', if any, will be placed in EqualLoc.; ///; /// This does not check for a pure-specifier; that's handled elsewhere.; ///; /// brace-or-equal-initializer:; /// '=' initializer-expression; /// braced-init-list; ///; /// initializer-clause:; /// assignment-expression; /// braced-init-list; ///; /// defaulted/deleted function-definition:; /// '=' 'default'; /// '=' 'delete'; ///; /// Prior to C++0x, the assignment-expression in an initializer-clause must; /// be a constant-expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp:80,detect,detect,80,interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDeclCXX.cpp,1,['detect'],['detect']
Safety,"/// ParseDecimalOrOctalCommon - This method is called for decimal or octal; /// numbers. It issues an error for illegal digits, and handles floating point; /// parsing. If it detects a floating point number, the radix is set to 10.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp:175,detect,detects,175,interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/LiteralSupport.cpp,1,['detect'],['detects']
Safety,"/// ParseImplicitInt - This method is called when we have an non-typename; /// identifier in a declspec (which normally terminates the decl spec) when; /// the declspec has no type specifier. In this case, the declspec is either; /// malformed or is ""implicit int"" (in K&R and C89).; ///; /// This method handles diagnosing this prettily and returns false if the; /// declspec is done being processed. If it recovers and thinks there may be; /// other pieces of declspec after it, it returns true.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp:408,recover,recovers,408,interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseDecl.cpp,1,['recover'],['recovers']
Safety,"/// ParseOperandName - Parse an operand name like ""$foo"" or ""$foo.bar"",; /// where $foo is a whole operand and $foo.bar refers to a suboperand.; /// This aborts if the name is invalid. If AllowWholeOp is true, references; /// to operands with suboperands are allowed, otherwise not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.h:154,abort,aborts,154,interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.h,1,['abort'],['aborts']
Safety,"/// ParseParenExprOrCondition:; /// [C ] '(' expression ')'; /// [C++] '(' condition ')'; /// [C++1z] '(' init-statement[opt] condition ')'; ///; /// This function parses and performs error recovery on the specified condition; /// or expression (depending on whether we're in C++ or C mode). This function; /// goes out of its way to recover well. It returns true if there was a parser; /// error (the right paren couldn't be found), which indicates that the caller; /// should try to recover harder. It returns false if the condition is; /// successfully parsed. Note that a successful parse can still have semantic; /// errors in the condition.; /// Additionally, it will assign the location of the outer-most '(' and ')',; /// to LParenLoc and RParenLoc, respectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:190,recover,recovery,190,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,3,['recover'],"['recover', 'recovery']"
Safety,/// Parses the command line options into the LinkOptions struct and performs; /// some sanity checking. Returns an error in case the latter fails.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp:87,sanity check,sanity checking,87,interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/dsymutil/dsymutil.cpp,1,['sanity check'],['sanity checking']
Safety,"/// Parsing of OpenMP clauses with single expressions like 'final',; /// 'collapse', 'safelen', 'num_threads', 'simdlen', 'num_teams',; /// 'thread_limit', 'simdlen', 'priority', 'grainsize', 'num_tasks', 'hint' or; /// 'detach'.; ///; /// final-clause:; /// 'final' '(' expression ')'; ///; /// num_threads-clause:; /// 'num_threads' '(' expression ')'; ///; /// safelen-clause:; /// 'safelen' '(' expression ')'; ///; /// simdlen-clause:; /// 'simdlen' '(' expression ')'; ///; /// collapse-clause:; /// 'collapse' '(' expression ')'; ///; /// priority-clause:; /// 'priority' '(' expression ')'; ///; /// grainsize-clause:; /// 'grainsize' '(' expression ')'; ///; /// num_tasks-clause:; /// 'num_tasks' '(' expression ')'; ///; /// hint-clause:; /// 'hint' '(' expression ')'; ///; /// allocator-clause:; /// 'allocator' '(' expression ')'; ///; /// detach-clause:; /// 'detach' '(' event-handler-expression ')'; ///; /// align-clause; /// 'align' '(' positive-integer-constant ')'; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:86,safe,safelen,86,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,3,['safe'],"['safelen', 'safelen-clause']"
Safety,/// Parsing of OpenMP clauses.; ///; /// clause:; /// if-clause | final-clause | num_threads-clause | safelen-clause |; /// default-clause | private-clause | firstprivate-clause | shared-clause; /// | linear-clause | aligned-clause | collapse-clause | bind-clause |; /// lastprivate-clause | reduction-clause | proc_bind-clause |; /// schedule-clause | copyin-clause | copyprivate-clause | untied-clause |; /// mergeable-clause | flush-clause | read-clause | write-clause |; /// update-clause | capture-clause | seq_cst-clause | device-clause |; /// simdlen-clause | threads-clause | simd-clause | num_teams-clause |; /// thread_limit-clause | priority-clause | grainsize-clause |; /// nogroup-clause | num_tasks-clause | hint-clause | to-clause |; /// from-clause | is_device_ptr-clause | task_reduction-clause |; /// in_reduction-clause | allocator-clause | allocate-clause |; /// acq_rel-clause | acquire-clause | release-clause | relaxed-clause |; /// depobj-clause | destroy-clause | detach-clause | inclusive-clause |; /// exclusive-clause | uses_allocators-clause | use_device_addr-clause |; /// has_device_addr; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp:102,safe,safelen-clause,102,interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseOpenMP.cpp,1,['safe'],['safelen-clause']
Safety,/// Parts of a decomposed MSGuidDecl. Factored out to avoid unnecessary; /// dependencies on DeclCXX.h.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:54,avoid,avoid,54,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['avoid'],['avoid']
Safety,"/// Pass the ErrorInfo(s) contained in E to their respective handlers. Any; /// unhandled errors (or Errors returned by handlers) are re-concatenated and; /// returned.; /// Because this function returns an error, its result must also be checked; /// or returned. If you intend to handle all errors use handleAllErrors; /// (which returns void, and will abort() on unhandled errors) instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:354,abort,abort,354,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['abort'],['abort']
Safety,"/// PassRegistry - This class manages the registration and intitialization of; /// the pass subsystem as application startup, and assists the PassManager; /// in resolving pass dependencies.; /// NOTE: PassRegistry is NOT thread-safe. If you want to use LLVM on multiple; /// threads simultaneously, you will need to use a separate PassRegistry on; /// each thread.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassRegistry.h:229,safe,safe,229,interpreter/llvm-project/llvm/include/llvm/PassRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/PassRegistry.h,1,['safe'],['safe']
Safety,"/// Peform pruning using the supplied policy, returns true if pruning; /// occurred, i.e. if Policy.Interval was expired.; ///; /// Check whether cache pruning happens using the supplied policy, adds a; /// ThinLTO warning if cache_size_bytes or cache_size_files is too small for the; /// current link job. The warning recommends the user to consider adjusting; /// --thinlto-cache-policy.; ///; /// As a safeguard against data loss if the user specifies the wrong directory; /// as their cache directory, this function will ignore files not matching the; /// pattern ""llvmcache-*"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:405,safe,safeguard,405,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,1,['safe'],['safeguard']
Safety,"/// PerThreadAllocator is used in conjunction with ThreadPoolExecutor to allow; /// per-thread allocations. It wraps a possibly thread-unsafe allocator,; /// e.g. BumpPtrAllocator. PerThreadAllocator must be used with only main thread; /// or threads created by ThreadPoolExecutor, as it utilizes getThreadIndex,; /// which is set by ThreadPoolExecutor. To work properly, ThreadPoolExecutor; /// should be initialized before PerThreadAllocator is created.; /// TODO: The same approach might be implemented for ThreadPool.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PerThreadBumpPtrAllocator.h:135,unsafe,unsafe,135,interpreter/llvm-project/llvm/include/llvm/Support/PerThreadBumpPtrAllocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PerThreadBumpPtrAllocator.h,1,['unsafe'],['unsafe']
Safety,/// Perform an optional yaml-mapping of an endian-aware type EndianType. The; /// only purpose of this function is to avoid casting the Default value to the; /// endian type;,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp:118,avoid,avoid,118,interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjectYAML/MinidumpYAML.cpp,1,['avoid'],['avoid']
Safety,/// Perform sanity checks on graph when requested.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:12,sanity check,sanity checks,12,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,1,['sanity check'],['sanity checks']
Safety,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:253,safe,safe,253,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['safe'],['safe']
Safety,"/// Perform simple partial redundancy elimination of the VSETVLI instructions; /// we're about to insert by looking for cases where we can PRE from the; /// beginning of one block to the end of one of its predecessors. Specifically,; /// this is geared to catch the common case of a fixed length vsetvl in a single; /// block loop when it could execute once in the preheader instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp:27,redund,redundancy,27,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVInsertVSETVLI.cpp,1,['redund'],['redundancy']
Safety,"/// Perform two related transforms whose purpose is to incrementally recognize; /// an explode_vector followed by scalar reduction as a vector reduction node.; /// This exists to recover from a deficiency in SLP which can't handle; /// forests with multiple roots sharing common nodes. In some cases, one; /// of the trees will be vectorized, and the other will remain (unprofitably); /// scalarized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp:179,recover,recover,179,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVISelLowering.cpp,1,['recover'],['recover']
Safety,"/// Performs the Request, passing response data to the Handler. Returns all; /// errors which occur during the request. Aborts if an error is returned by a; /// Handler method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h:120,Abort,Aborts,120,interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,1,['Abort'],['Aborts']
Safety,"/// Permissive - True when recovering from errors, in which case precautions; /// are taken to handle incomplete scope information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp:27,recover,recovering,27,interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/JumpDiagnostics.cpp,1,['recover'],['recovering']
Safety,"/// Phi instructions will eventually be lowered to copy instructions.; /// If phi is in a loop header, a recurrence may formulated around the source; /// and destination of the phi. For such case commuting operands of the; /// instructions in the recurrence may enable coalescing of the copy instruction; /// generated from the phi. For example, if there is a recurrence of; ///; /// LoopHeader:; /// %1 = phi(%0, %100); /// LoopLatch:; /// %0<def, tied1> = ADD %2<def, tied0>, %1; ///; /// , the fact that %0 and %2 are in the same tied operands set makes; /// the coalescing of copy instruction generated from the phi in; /// LoopHeader(i.e. %1 = COPY %0) impossible, because %1 and; /// %2 have overlapping live range. This introduces additional move; /// instruction to the final assembly. However, if we commute %2 and; /// %1 of ADD instruction, the redundant move instruction can be; /// avoided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp:856,redund,redundant,856,interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PeepholeOptimizer.cpp,2,"['avoid', 'redund']","['avoided', 'redundant']"
Safety,"/// Plan how to best vectorize, return the best VF and its cost, or; /// std::nullopt if vectorization and interleaving should be avoided up front.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h:130,avoid,avoided,130,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorizationPlanner.h,1,['avoid'],['avoided']
Safety,/// Pointer to the HazardRecognizer that tracks the scheduler state for; /// the current region.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:19,Hazard,HazardRecognizer,19,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['Hazard'],['HazardRecognizer']
Safety,"/// Populate the IC worklist from a function, by walking it in reverse; /// post-order and adding all reachable code to the worklist.; ///; /// This has a couple of tricks to make the code faster and more powerful. In; /// particular, we constant fold and DCE instructions as we go, to avoid adding; /// them to the worklist (this significantly speeds up instcombine on code where; /// many instructions are dead or constant). Additionally, if we find a branch; /// whose condition is a known constant, we only visit the reachable successors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:286,avoid,avoid,286,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['avoid'],['avoid']
Safety,"/// Populate the vector of Chains.; ///; /// This decreases ILP at the architecture level. Targets with ample registers,; /// multiple memory ports, and no register renaming probably don't want; /// this. However, such targets should probably disable LSR altogether.; ///; /// The job of LSR is to make a reasonable choice of induction variables across; /// the loop. Subsequent passes can easily ""unchain"" computation exposing more; /// ILP *within the loop* if the target wants it.; ///; /// Finding the best IV chain is potentially a scheduling problem. Since LSR; /// will not reorder memory operations, it will recognize this as a chain, but; /// will generate redundant IV increments. Ideally this would be corrected later; /// by a smart scheduler:; /// = A[i]; /// = A[i+x]; /// A[i] =; /// A[i+x] =; ///; /// TODO: Walk the entire domtree within this loop, not just the path to the; /// loop latch. This will discover chains on side paths, but requires; /// maintaining multiple copies of the Chains state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:666,redund,redundant,666,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['redund'],['redundant']
Safety,/// PostRAHazardRecognizer - This pass runs the post-ra hazard; /// recognizer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:56,hazard,hazard,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['hazard'],['hazard']
Safety,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:920,recover,recover,920,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['recover'],['recover']
Safety,/// Predicate for distinguishing instructions that are hazardous in a load delay; /// slot. Consider inline assembly as unsafe as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:55,hazard,hazardous,55,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,2,"['hazard', 'unsafe']","['hazardous', 'unsafe']"
Safety,/// Predicate for distingushing between control transfer instructions and all; /// other instructions for handling forbidden slots. Consider inline assembly; /// as unsafe as well.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:165,unsafe,unsafe,165,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,1,['unsafe'],['unsafe']
Safety,/// Predicate for the element types that the SLP vectorizer supports.; ///; /// The most important thing to filter here are types which are invalid in LLVM; /// vectors. We also filter target specific types which have absolutely no; /// meaningful vectorization path such as x86_fp80 and ppc_f128. This just; /// avoids spending time checking the cost model and realizing that they will; /// be inevitably scalarized.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:313,avoid,avoids,313,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoids']
Safety,"/// Prepare the action for processing the input file \p Input.; ///; /// This is run after the options and frontend have been initialized,; /// but prior to executing any per-file processing.; ///; /// \param CI - The compiler instance this action is being run from. The; /// action may store and use this object up until the matching EndSourceFile; /// action.; ///; /// \param Input - The input filename and kind. Some input kinds are handled; /// specially, for example AST inputs, since the AST file itself contains; /// several objects which would normally be owned by the; /// CompilerInstance. When processing AST input files, these objects should; /// generally not be initialized in the CompilerInstance -- they will; /// automatically be shared with the AST file in between; /// BeginSourceFile() and EndSourceFile().; ///; /// \return True on success; on failure the compilation of this file should; /// be aborted and neither Execute() nor EndSourceFile() should be called.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:918,abort,aborted,918,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['abort'],['aborted']
Safety,"/// Preserved analyses across SCCs.; ///; /// We specifically want to allow CGSCC passes to mutate ancestor IR; /// (changing both the CG structure and the function IR itself). However,; /// this means we need to take special care to correctly mark what analyses; /// are preserved *across* SCCs. We have to track this out-of-band here; /// because within the main `PassManager` infrastructure we need to mark; /// everything within an SCC as preserved in order to avoid repeatedly; /// invalidating the same analyses as we unnest pass managers and adaptors.; /// So we track the cross-SCC version of the preserved analyses here from any; /// code that does direct invalidation of SCC analyses, and then use it; /// whenever we move forward in the post-order walk of SCCs before running; /// passes over the new SCC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:465,avoid,avoid,465,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['avoid'],['avoid']
Safety,"/// Print T and prefix it with the comment string (normally #) and; /// optionally a tab. This prints the comment immediately, not at the end of; /// the current line. It is basically a safe version of EmitRawText: since it; /// only prints comments, the object streamer ignores it instead of asserting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:186,safe,safe,186,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['safe'],['safe']
Safety,/// Print information about the detected CUDA installation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h:32,detect,detected,32,interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Cuda.h,1,['detect'],['detected']
Safety,/// Print information about the detected GCC installation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:32,detect,detected,32,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,1,['detect'],['detected']
Safety,/// Print information about the detected ROCm installation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h:32,detect,detected,32,interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/ROCm.h,1,['detect'],['detected']
Safety,"/// Print the filename, with escaping or quoting that accommodates the three; /// most likely tools that use dependency files: GNU Make, BSD Make, and; /// NMake/Jom.; ///; /// BSD Make is the simplest case: It does no escaping at all. This means; /// characters that are normally delimiters, i.e. space and # (the comment; /// character) simply aren't supported in filenames.; ///; /// GNU Make does allow space and # in filenames, but to avoid being treated; /// as a delimiter or comment, these must be escaped with a backslash. Because; /// backslash is itself the escape character, if a backslash appears in a; /// filename, it should be escaped as well. (As a special case, $ is escaped; /// as $$, which is the normal Make way to handle the $ character.); /// For compatibility with BSD Make and historical practice, if GNU Make; /// un-escapes characters in a filename but doesn't find a match, it will; /// retry with the unmodified original string.; ///; /// GCC tries to accommodate both Make formats by escaping any space or #; /// characters in the original filename, but not escaping backslashes. The; /// apparent intent is so that filenames with backslashes will be handled; /// correctly by BSD Make, and by GNU Make in its fallback mode of using the; /// unmodified original string; filenames with # or space characters aren't; /// supported by BSD Make at all, but will be handled correctly by GNU Make; /// due to the escaping.; ///; /// A corner case that GCC gets only partly right is when the original filename; /// has a backslash immediately followed by space or #. GNU Make would expect; /// this backslash to be escaped; however GCC escapes the original backslash; /// only when followed by space, not #. It will therefore take a dependency; /// from a directive such as; /// #include ""a\ b\#c.h""; /// and emit it as; /// a\\\ b\\#c.h; /// which GNU Make will interpret as; /// a\ b\; /// followed by a comment. Failing to find this file, it will fall back to the; /// origi",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp:440,avoid,avoid,440,interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/DependencyFile.cpp,1,['avoid'],['avoid']
Safety,"/// Process a single induction variable. First use the SCEVExpander to create a; /// wide induction variable that evaluates to the same recurrence as the; /// original narrow IV. Then use a worklist to forward traverse the narrow IV's; /// def-use chain. After widenIVUse has processed all interesting IV users, the; /// narrow IV will be isolated for removal by DeleteDeadPHIs.; ///; /// It would be simpler to delete uses as they are processed, but we must avoid; /// invalidating SCEV expressions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:459,avoid,avoid,459,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['avoid'],['avoid']
Safety,"/// Process any TypoExprs in the given Expr and its children,; /// generating diagnostics as appropriate and returning a new Expr if there; /// were typos that were all successfully corrected and ExprError if one or; /// more typos could not be corrected.; ///; /// \param E The Expr to check for TypoExprs.; ///; /// \param InitDecl A VarDecl to avoid because the Expr being corrected is its; /// initializer.; ///; /// \param RecoverUncorrectedTypos If true, when typo correction fails, it; /// will rebuild the given Expr with all TypoExprs degraded to RecoveryExprs.; ///; /// \param Filter A function applied to a newly rebuilt Expr to determine if; /// it is an acceptable/usable result from a single combination of typo; /// corrections. As long as the filter returns ExprError, different; /// combinations of corrections will be tried until all are exhausted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:347,avoid,avoid,347,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,3,"['Recover', 'avoid']","['RecoverUncorrectedTypos', 'RecoveryExprs', 'avoid']"
Safety,"/// Process the given Ops list, which is a list of operands to be added under; /// the given scale, update the given map. This is a helper function for; /// getAddRecExpr. As an example of what it does, given a sequence of operands; /// that would form an add expression like this:; ///; /// m + n + 13 + (A * (o + p + (B * (q + m + 29)))) + r + (-1 * r); ///; /// where A and B are constants, update the map with these values:; ///; /// (m, 1+A*B), (n, 1), (o, A), (p, A), (q, A*B), (r, 0); ///; /// and add 13 + A*B*29 to AccumulatedConstant.; /// This will allow getAddRecExpr to produce this:; ///; /// 13+A*B*29 + n + (m * (1+A*B)) + ((o + p) * A) + (q * A*B); ///; /// This form often exposes folding opportunities that are hidden in; /// the original operand list.; ///; /// Return true iff it appears that any interesting folding opportunities; /// may be exposed. This helps getAddRecExpr short-circuit extra work in; /// the common case where no interesting opportunities are present, and; /// is also used as a check to avoid infinite recursion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp:1031,avoid,avoid,1031,interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ScalarEvolution.cpp,1,['avoid'],['avoid']
Safety,/// Produce location ID number for a Register. Provides some small amount of; /// type safety.; /// \param Reg The register we're looking up.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:87,safe,safety,87,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['safe'],['safety']
Safety,"/// Produces a shallow copy of the given template argument list.; ///; /// This operation assumes that the input argument list outlives it.; /// This takes the list as a pointer to avoid looking like a copy; /// constructor, since this really isn't safe to use that way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h:181,avoid,avoid,181,interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"/// PromoteArguments - This method checks the specified function to see if there; /// are any promotable arguments and if it is safe to promote the function (for; /// example, all callers are direct). If safe to promote some arguments, it; /// calls the DoPromotion method.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:128,safe,safe,128,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,2,['safe'],['safe']
Safety,/// Provide a default implementation which returns aborts;; /// this method should never be called by FrontendAction clients.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h:51,abort,aborts,51,interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/FrontendAction.h,1,['abort'],['aborts']
Safety,/// Provide a function to avoid emitting certain predicates. This is used to; /// defer some predicate checks until after others,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h:26,avoid,avoid,26,interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/GlobalISelMatchTable.h,1,['avoid'],['avoid']
Safety,/// Provide a global flag for disabling the PreRA hazard recognizer that; /// targets may choose to honor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:50,hazard,hazard,50,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['hazard'],['hazard']
Safety,/// Provides a hint to the processor to selectively reset the prediction; /// history of the current logical processor specified by a 32-bit integer; /// value \a __eax.; ///; /// This intrinsic corresponds to the <c> HRESET </c> instruction.; ///; /// \code{.operation}; /// IF __eax == 0; /// // nop; /// ELSE; /// FOR i := 0 to 31; /// IF __eax[i]; /// ResetPredictionFeature(i); /// FI; /// ENDFOR; /// FI; /// \endcode,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hresetintrin.h:62,predict,prediction,62,interpreter/llvm-project/clang/lib/Headers/hresetintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/hresetintrin.h,1,['predict'],['prediction']
Safety,/// Provides information whether source locations have already been parsed in; /// another FrontendAction.; ///; /// Is NOT thread-safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp:131,safe,safe,131,interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/Indexing.cpp,1,['safe'],['safe']
Safety,/// Provides unsafe access to ownership operations on SymbolStringPtr.; /// This class can be used to manage SymbolStringPtr instances from C.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SymbolStringPool.h:13,unsafe,unsafe,13,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SymbolStringPool.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/SymbolStringPool.h,1,['unsafe'],['unsafe']
Safety,/// PruneBlocksHandler is a special UninitVariablesHandler that is used; /// to detect when a CFGBlock has any *potential* use of an uninitialized; /// variable. It is mainly used to prune out work during the final; /// reporting pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp:80,detect,detect,80,interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UninitializedValues.cpp,1,['detect'],['detect']
Safety,"/// Query the target whether it would be prefered to create a predicated; /// vector loop, which can avoid the need to emit a scalar epilogue loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:101,avoid,avoid,101,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['avoid'],['avoid']
Safety,/// RAII class for safely pairing a StartedDeserializing call; /// with FinishedDeserializing.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h:19,safe,safely,19,interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExternalASTSource.h,1,['safe'],['safely']
Safety,"/// RDF progress helper.; /// This class provides callback functions to the RDataFrame. The event statistics; /// (including elapsed time, currently processed file, currently processed events, the rate of event processing; /// and an estimated remaining time (per file being processed)); /// are recorded and printed in the terminal every m events and every n seconds.; /// ProgressHelper::operator()(unsigned int, T&) is thread safe, and can be used as a callback in MT mode.; /// ProgressBar should be added after creating the dataframe object (df):; /// ~~~{.cpp}; /// ROOT::RDataFrame df(""tree"", ""file.root"");; /// ROOT::RDF::Experimental::AddProgressBar(df);; /// ~~~; /// alternatively RDataFrame can be cast to an RNode first giving it more flexibility.; /// For example, it can be called at any computational node, such as Filter or Define, not only the head node,; /// with no change to the ProgressBar function itself:; /// ~~~{.cpp}; /// ROOT::RDataFrame df(""tree"", ""file.root"");; /// auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; /// ROOT::RDF::Experimental::AddProgressBar(df_1);; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:429,safe,safe,429,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['safe'],['safe']
Safety,/// Reached timeout while waiting for the owner to release the lock.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h:12,timeout,timeout,12,interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/LockFileManager.h,1,['timeout'],['timeout']
Safety,"/// ReadAnyTokens - This is set to false when a file is first opened and true; /// any time a token is returned to the client or a (non-multiple-include); /// directive is parsed. When the final #endif is parsed this is reset back; /// to false, that way any tokens before the first #ifdef or after the last; /// #endif can be easily detected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h:334,detect,detected,334,interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,1,['detect'],['detected']
Safety,"/// ReadAnyTokens - This is set to false when a file is first opened and true; /// any time a token is returned to the client or a (non-multiple-include); /// directive is parsed. When the final \#endif is parsed this is reset back; /// to false, that way any tokens before the first \#ifdef or after the last; /// \#endif can be easily detected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h:337,detect,detected,337,interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/MultipleIncludeOpt.h,1,['detect'],['detected']
Safety,/// Ready and safe for clients to access.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:14,safe,safe,14,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,1,['safe'],['safe']
Safety,"/// Reclaim all the attributes in the given pool chain, which is; /// non-empty. Note that the current implementation is safe; /// against reclaiming things which were not actually allocated; /// with the allocator, although of course it's important to make; /// sure that their allocator lives at least as long as this one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h:121,safe,safe,121,interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ParsedAttr.h,1,['safe'],['safe']
Safety,"/// Recognizes a population count idiom in a non-countable loop.; ///; /// If detected, transforms the relevant code to issue the popcount intrinsic; /// function call, and returns true; otherwise, returns false.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:78,detect,detected,78,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['detect'],['detected']
Safety,/// Record a link in the Narrow IV def-use chain along with the WideIV that; /// computes the same value as the Narrow IV def. This avoids caching Use*; /// pointers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:132,avoid,avoids,132,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['avoid'],['avoids']
Safety,"/// Record that a given expression is a ""safe"" access of a weak object (e.g.; /// assigning it to a strong variable.); ///; /// Part of the implementation of -Wrepeated-use-of-weak.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:41,safe,safe,41,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,1,['safe'],['safe']
Safety,/// Record this SUnit in the HazardRecognizer.; /// Does not update CurCycle.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:29,Hazard,HazardRecognizer,29,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Hazard'],['HazardRecognizer']
Safety,/// Recovers the address of a local in a parent function. ParentVar is the; /// address of the variable used in the immediate parent function. It can; /// either be an alloca or a call to llvm.localrecover if there are nested; /// outlined functions. ParentFP is the frame pointer of the outermost parent; /// frame.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:4,Recover,Recovers,4,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['Recover'],['Recovers']
Safety,"/// Reduce a pair of compares that check if a value has exactly 1 bit set.; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:125,safe,safe,125,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safe']
Safety,"/// Reduce cast expression by removing redundant intermediate casts.; /// E.g.; /// - (char)(short)(int x) -> (char)(int x); /// - (int)(int x) -> int x; ///; /// \param V -- SymbolVal, which pressumably contains SymbolCast or any symbol; /// that is applicable for cast operation.; /// \param CastTy -- QualType, which `V` shall be cast to.; /// \return SVal with simplified cast expression.; /// \note: Currently only support integral casts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp:39,redund,redundant,39,interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Core/SValBuilder.cpp,1,['redund'],['redundant']
Safety,"/// Reduce the number of arguments in this call expression. This is used for; /// example during error recovery to drop extra arguments. There is no way; /// to perform the opposite because: 1.) We don't track how much storage; /// we have for the argument array 2.) This would potentially require growing; /// the argument array, something we cannot support since the arguments are; /// stored in a trailing array.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:103,recover,recovery,103,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['recover'],['recovery']
Safety,"/// Reduces maps in FIFO order, by N SUs. This is better than turning; /// every Nth memory SU into BarrierChain in buildSchedGraph(), since; /// it avoids unnecessary edges between seen SUs above the new BarrierChain,; /// and those below it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:149,avoid,avoids,149,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['avoid'],['avoids']
Safety,/// Redundant parentheses over an equality comparison can indicate; /// that the user intended an assignment used as condition.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:4,Redund,Redundant,4,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['Redund'],['Redundant']
Safety,"/// Register cleanup handler, which is used when the recovery context is; /// finished.; /// The recovery context owns the handler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:53,recover,recovery,53,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,2,['recover'],['recovery']
Safety,/// Register is not available and can't be recovered.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h:43,recover,recovered,43,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,1,['recover'],['recovered']
Safety,"/// Registers an externally loaded library. The library will be unloaded; /// when the program terminates.; ///; /// It is safe to call this function multiple times for the same library,; /// though ownership is only taken if there was no error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:123,safe,safe,123,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['safe'],['safe']
Safety,"/// Release SU to make it ready. If it's not in hazard, remove it from; /// pending queue (if already in) and push into available queue.; /// Otherwise, push the SU into pending queue.; ///; /// @param SU The unit to be released.; /// @param ReadyCycle Until which cycle the unit is ready.; /// @param InPQueue Whether SU is already in pending queue.; /// @param Idx Position offset in pending queue (if in it).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h:48,hazard,hazard,48,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineScheduler.h,1,['hazard'],['hazard']
Safety,"/// Remember what linkage name we originally had before stripping. If we end; /// up making two subprograms identical who originally had different linkage; /// names, then we need to make one of them distinct, to avoid them getting; /// uniqued. Maps the new node to the old linkage name.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp:213,avoid,avoid,213,interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/DebugInfo.cpp,1,['avoid'],['avoid']
Safety,"/// Remove a loop if it is dead.; ///; /// A loop is considered dead either if it does not impact the observable; /// behavior of the program other than finite running time, or if it is; /// required to make progress by an attribute such as 'mustprogress' or; /// 'llvm.loop.mustprogress' and does not make any. This may remove; /// infinite loops that have been required to make progress.; ///; /// This entire process relies pretty heavily on LoopSimplify form and LCSSA in; /// order to make various safety checks work.; ///; /// \returns true if any changes were made. This may mutate the loop even if it; /// is unable to delete it due to hoisting trivially loop invariant; /// instructions out of the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp:503,safe,safety,503,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopDeletion.cpp,1,['safe'],['safety']
Safety,"/// Remove all nodes from the list like clear(), but do not call; /// removeNodeFromList() or deleteNode().; ///; /// This should only be used immediately before freeing nodes in bulk to; /// avoid traversing the list and bringing all the nodes into cache.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h:192,avoid,avoid,192,interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/ilist.h,1,['avoid'],['avoid']
Safety,"/// Remove an edge whose source is in this RefSCC and target is *not*.; ///; /// This removes an inter-RefSCC edge. All inter-RefSCC edges originating; /// from this SCC have been fully explored by any in-flight DFS graph; /// formation, so this is always safe to call once you have the source; /// RefSCC.; ///; /// This operation does not change the cyclic structure of the graph and so; /// is very inexpensive. It may change the connectivity graph of the SCCs; /// though, so be careful calling this while iterating over them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:256,safe,safe,256,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,1,['safe'],['safe']
Safety,/// Remove copy constructor to avoid accidental copying.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/BodyFarm.h:31,avoid,avoid,31,interpreter/llvm-project/clang/include/clang/Analysis/BodyFarm.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/BodyFarm.h,1,['avoid'],['avoid']
Safety,"/// Remove empty sections from SectionsForRanges, to avoid generating; /// useless debug info for them.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp:53,avoid,avoid,53,interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCContext.cpp,1,['avoid'],['avoid']
Safety,/// Remove every use of this value in \p User that can safely be removed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h:55,safe,safely,55,interpreter/llvm-project/llvm/include/llvm/IR/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h,1,['safe'],['safely']
Safety,/// Remove every uses that can safely be removed.; ///; /// This will remove for example uses in llvm.assume.; /// This should be used when performing want to perform a tranformation but; /// some Droppable uses pervent it.; /// This function optionally takes a filter to only remove some droppable; /// uses.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h:31,safe,safely,31,interpreter/llvm-project/llvm/include/llvm/IR/Value.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Value.h,1,['safe'],['safely']
Safety,/// Remove old copies of the serialized diagnostics. This is necessary; /// so that we can detect when subprocesses write diagnostics that we should; /// merge into our own.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp:91,detect,detect,91,interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/SerializedDiagnosticPrinter.cpp,1,['detect'],['detect']
Safety,/// Remove redundant EpxandSCEVRecipes in \p Plan's entry block by replacing; /// them with already existing recipes expanding the same SCEV expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,1,['redund'],['redundant']
Safety,/// Remove redundant VPBasicBlocks by merging them into their predecessor if; /// the predecessor has a single successor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,1,['redund'],['redundant']
Safety,"/// Remove redundant casts of inductions.; ///; /// Such redundant casts are casts of induction variables that can be ignored,; /// because we already proved that the casted phi is equal to the uncasted phi; /// in the vectorized loop. There is no need to vectorize the cast - the same; /// value can be used for both the phi and casts in the vector loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlanTransforms.h,2,['redund'],['redundant']
Safety,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,2,['redund'],['redundant']
Safety,/// Remove redundant debug value MIs for the given machine function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,1,['redund'],['redundant']
Safety,/// Remove redundant definitions within sequences of consecutive location defs.; /// This is done using a backward scan to keep the last def describing a; /// specific variable/fragment.; ///; /// This implements removeRedundantDbgInstrsUsingBackwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['redund'],['redundant']
Safety,"/// Remove redundant instructions within sequences of consecutive dbg.value; /// instructions. This is done using a backward scan to keep the last dbg.value; /// describing a specific variable/fragment.; ///; /// BackwardScan strategy:; /// ----------------------; /// Given a sequence of consecutive DbgValueInst like this; ///; /// dbg.value ..., ""x"", FragmentX1 (*); /// dbg.value ..., ""y"", FragmentY1; /// dbg.value ..., ""x"", FragmentX2; /// dbg.value ..., ""x"", FragmentX1 (**); ///; /// then the instruction marked with (*) can be removed (it is guaranteed to be; /// obsoleted by the instruction marked with (**) as the latter instruction is; /// describing the same variable using the same fragment info).; ///; /// Possible improvements:; /// - Check fully overlapping fragments and not only identical fragments.; /// - Support dbg.declare. dbg.label, and possibly other meta instructions being; /// part of the sequence of consecutive instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['redund'],['redundant']
Safety,"/// Remove redundant leading ""./"" pieces and consecutive separators.; ///; /// @param path Input path.; /// @result The cleaned-up \a path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Path.h:11,redund,redundant,11,interpreter/llvm-project/llvm/include/llvm/Support/Path.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Path.h,1,['redund'],['redundant']
Safety,/// Remove redundant location defs using a forward scan. This can remove a; /// location definition that is redundant due to indicating that a variable has; /// the same value as is already being indicated by an earlier def.; ///; /// This implements removeRedundantDbgInstrsUsingForwardScan from; /// lib/Transforms/Utils/BasicBlockUtils.cpp for locations described with; /// FunctionVarLocsBuilder instead of with intrinsics,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,2,['redund'],['redundant']
Safety,"/// Remove redundant parentheses.; /// \warning; /// Setting this option to any value other than ``Leave`` could lead to; /// incorrect code formatting due to clang-format's lack of complete semantic; /// information. As such, extra care should be taken to review code changes; /// made by this option.; /// \endwarning; /// \version 17",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:11,redund,redundant,11,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['redund'],['redundant']
Safety,"/// Remove redundant spills in the same BB. Save those redundant spills in; /// SpillsToRm, and save the spill to keep and its BB in SpillBBToSpill map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,2,['redund'],['redundant']
Safety,"/// Remove redundant undef dbg.assign intrinsic from an entry block using a; /// forward scan.; /// Strategy:; /// ---------------------; /// Scanning forward, delete dbg.assign intrinsics iff they are undef, not; /// linked to an intrinsic, and don't share an aggregate variable with a debug; /// intrinsic that didn't meet the criteria. In other words, undef dbg.assigns; /// that come before non-undef debug intrinsics for the variable are; /// deleted. Given:; ///; /// dbg.assign undef, ""x"", FragmentX1 (*); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value %V, ""x"", FragmentX2; /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.assign undef, ""x"", FragmentX1; ///; /// then (only) the instruction marked with (*) can be removed.; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,redund,redundant,11,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,1,['redund'],['redundant']
Safety,"/// RemoveKey - Remove the specified StringMapEntry from the table, but do not; /// delete it. This aborts if the value isn't in the table.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:100,abort,aborts,100,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,2,['abort'],['aborts']
Safety,/// Removes redundant address calculations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp:12,redund,redundant,12,interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86OptimizeLEAs.cpp,1,['redund'],['redundant']
Safety,"/// Removing duplicate PHI operands to leave the PHI in a canonical and; /// predictable form.; ///; /// FIXME: It's really frustrating that we have to do this, but SSA-form in MIR; /// isn't what you might expect. We may have multiple entries in PHI nodes for; /// a single predecessor. This makes CFG-updating extremely complex, so here we; /// simplify all PHI nodes to a model even simpler than the IR's model: exactly; /// one entry per predecessor, regardless of how many edges there are.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:77,predict,predictable,77,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['predict'],['predictable']
Safety,"/// Replace a call to the specified intrinsic function.; /// If an intrinsic function must be implemented by the code generator; /// (such as va_start), this function should print a message and abort.; ///; /// Otherwise, if an intrinsic function call can be lowered, the code to; /// implement it (often a call to a non-intrinsic function) is inserted; /// _after_ the call instruction and the call is deleted. The caller must; /// be capable of handling this kind of change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h:194,abort,abort,194,interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,1,['abort'],['abort']
Safety,/// Replace all allocas in \p DynamicAllocas with code to allocate; /// space dynamically on the unsafe stack and store the dynamic unsafe stack; /// top to \p DynamicTop if non-null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:97,unsafe,unsafe,97,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,2,['unsafe'],['unsafe']
Safety,"/// Replace current source information with new such.; /// Avoid using this, the constructor argument is preferable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:59,Avoid,Avoid,59,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['Avoid'],['Avoid']
Safety,/// Replace the UseInst with a loop invariant expression if it is safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:66,safe,safe,66,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,1,['safe'],['safe']
Safety,"/// Replace with a (mostly) real path, or don't modify. Resolves symlinks; /// in the directory, using \a CachedDirs to avoid redundant lookups, but; /// leaves the filename as a possible symlink.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h:120,avoid,avoid,120,interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileCollector.h,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"/// Reports a bad alloc error, calling any user defined bad alloc; /// error handler. In contrast to the generic 'report_fatal_error'; /// functions, this function might not terminate, e.g. the user; /// defined error handler throws an exception, but it won't return.; ///; /// Note: When throwing an exception in the bad alloc handler, make sure that; /// the following unwind succeeds, e.g. do not trigger additional allocations; /// in the unwind chain.; ///; /// If no error handler is installed (default), throws a bad_alloc exception; /// if LLVM is compiled with exception support. Otherwise prints the error; /// to standard error and calls abort().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:649,abort,abort,649,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,1,['abort'],['abort']
Safety,"/// Reports a serious error, calling any installed error handler. These; /// functions are intended to be used for error conditions which are outside; /// the control of the compiler (I/O errors, invalid user input, etc.); ///; /// If no error handler is installed the default is to print the message to; /// standard error, followed by a newline.; /// After the error handler is called this function will call abort(), it; /// does not return.; /// NOTE: The std::string variant was removed to avoid a <string> dependency.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:411,abort,abort,411,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,2,"['abort', 'avoid']","['abort', 'avoid']"
Safety,"/// Represent a sequence of Call Frame Information instructions that, when read; /// in order, construct a table mapping PC to frame state. This can also be; /// referred to as ""CFI rules"" in DWARF literature to avoid confusion with; /// computer programs in the broader sense, and in this context each instruction; /// would be a rule to establish the mapping. Refer to pg. 172 in the DWARF5; /// manual, ""6.4.1 Structure of Call Frame Information"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h:212,avoid,avoid,212,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugFrame.h,1,['avoid'],['avoid']
Safety,/// Represents a single use of a weak object.; ///; /// Stores both the expression and whether the access is potentially unsafe; /// (i.e. it could potentially be warned about).; ///; /// Part of the implementation of -Wrepeated-use-of-weak.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h:121,unsafe,unsafe,121,interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ScopeInfo.h,1,['unsafe'],['unsafe']
Safety,"/// Represents an explicit template argument list in C++, e.g.,; /// the ""<int>"" in ""sort<int>"".; /// This is safe to be used inside an AST node, in contrast with; /// TemplateArgumentListInfo.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h:110,safe,safe,110,interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateBase.h,1,['safe'],['safe']
Safety,"/// Represents how an instruction should be mapped by the outliner.; /// \p Legal instructions are those which are safe to outline.; /// \p LegalTerminator instructions are safe to outline, but only as the; /// last instruction in a sequence.; /// \p Illegal instructions are those which cannot be outlined.; /// \p Invisible instructions are instructions which can be outlined, but; /// shouldn't actually impact the outlining result.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h:115,safe,safe,115,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOutliner.h,2,['safe'],['safe']
Safety,/// Represents moving 'bags of bits' around. Select same bank for entire; /// chain to avoid cross bank copies. Currently we select fprb for s64 and; /// gprb for s32 Ambiguous operands.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:87,avoid,avoid,87,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,1,['avoid'],['avoid']
Safety,/// Reset - This callback is invoked when a new block of; /// instructions is about to be schedule. The hazard state should be; /// set to an initialized state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:104,hazard,hazard,104,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['hazard'],['hazard']
Safety,/// Reset all state tracking for a newly encountered safepoint. Also; /// performs some consistency checking.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h:53,safe,safepoint,53,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.h,1,['safe'],['safepoint']
Safety,/// Reset the parameter list to having zero parameters.; ///; /// This is used in various places for error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:107,recover,recovery,107,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,1,['recover'],['recovery']
Safety,/// Reset the state of Unsafe and clear ToFreze if set.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp:23,Unsafe,Unsafe,23,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VectorCombine.cpp,1,['Unsafe'],['Unsafe']
Safety,/// Resets LLVM's pretty stack state so that stack traces are printed correctly; /// when there are nested CrashRecoveryContexts and the inner one recovers from; /// a crash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp:147,recover,recovers,147,interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseAST.cpp,1,['recover'],['recovers']
Safety,"/// Restores the topmost element of the ""pretty"" stack state to State, which; /// should come from a previous call to SavePrettyStackState(). This is; /// useful when using a CrashRecoveryContext in code that also uses; /// PrettyStackTraceEntries, to make sure the stack that's printed if a crash; /// happens after a crash that's been recovered by CrashRecoveryContext; /// doesn't have frames on it that were added in code unwound by the; /// CrashRecoveryContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PrettyStackTrace.h:337,recover,recovered,337,interpreter/llvm-project/llvm/include/llvm/Support/PrettyStackTrace.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/PrettyStackTrace.h,1,['recover'],['recovered']
Safety,"/// Result of the dependence checks, indicating whether the checked; /// dependences are safe for vectorization, require RT checks or are known to; /// be unsafe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:89,safe,safe,89,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"/// Retrieve a FileEntry that bypasses VFE, which is expected to be a virtual; /// file entry, to access the real file. The returned FileEntry will have; /// the same filename as FE but a different identity and its own stat.; ///; /// This should be used only for rare error recovery paths because it; /// bypasses all mapping and uniquing, blindly creating a new FileEntry.; /// There is no attempt to deduplicate these; if you bypass the same file; /// twice, you get two new file entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h:275,recover,recovery,275,interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/FileManager.h,1,['recover'],['recovery']
Safety,"/// Retrieve the body (definition) of the function. The function body might be; /// in any of the (re-)declarations of this function. The variant that accepts; /// a FunctionDecl pointer will set that function declaration to the actual; /// declaration containing the body (if there is one).; /// NOTE: For checking if there is a body, use hasBody() instead, to avoid; /// unnecessary AST de-serialization of the body.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:362,avoid,avoid,362,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['avoid'],['avoid']
Safety,/// Retrieve the default color auto detection function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h:36,detect,detection,36,interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/WithColor.h,1,['detect'],['detection']
Safety,"/// Retrieve the first unplaced basic block.; ///; /// This routine is called when we are unable to use the CFG to walk through; /// all of the basic blocks and form a chain due to unnatural loops in the CFG.; /// We walk through the function's blocks in order, starting from the; /// LastUnplacedBlockIt. We update this iterator on each call to avoid; /// re-scanning the entire sequence on repeated calls to this routine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:346,avoid,avoid,346,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['avoid'],['avoid']
Safety,"/// Retrieve the parser's current scope.; ///; /// This routine must only be used when it is certain that semantic analysis; /// and the parser are in precisely the same context, which is not the case; /// when, e.g., we are performing any kind of template instantiation.; /// Therefore, the only safe places to use this scope are in the parser; /// itself and in routines directly invoked from the parser and *never* from; /// template substitution or instantiation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:297,safe,safe,297,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['safe'],['safe']
Safety,/// Return a node that can be scheduled in this cycle. Requirements:; /// (1) Ready: latency has been satisfied; /// (2) No Hazards: resources are available; /// (3) No Interferences: may unschedule to break register interferences.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp:124,Hazard,Hazards,124,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/ScheduleDAGRRList.cpp,1,['Hazard'],['Hazards']
Safety,"/// Return a number greater or equal to the total number of entries in the; /// dataset.; ///; /// \note If you are interested in the total number of entries in a TChain,; /// this function will give that number once the last file of the chain; /// is opened. In general, using this instead of GetEntries will avoid; /// opening all files in the chain which could be very costly for very; /// large number of files stored at a remote location.; ///; /// The logic depends on whether the dataset is a TTree or a TChain. In the; /// first case, it simply returns the total number of entries in the tree. In; /// the latter case, it depends on which point of the processing of the chain; /// this function is called. During most of the chain processing, this; /// function will return TTree::kMaxEntries. When the chain arrives at the; /// last file, then the function will return the accumulated total number of; /// entries in the whole chain. A notable use case where this function; /// becomes quite useful is when writing the following for loop to traverse; /// the entries in the dataset:; ///; /// \code{.cpp}; /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; /// // Do something with the event in the dataset; /// }; /// \endcode; ///; /// In the example above, independently on whether the dataset is a TTree or; /// a TChain, the GetEntriesFast call will provide the correct stopping; /// condition for the loop (i.e. the total number of entries). In the TChain; /// case, calling GetEntries instead would open all the files in the chain; /// upfront which could be costly.; ///; /// The functionality offered by this method can also be seen when used in; /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; /// satisfied if \p ievent is strictly smaller than the total number of; /// entries in the dataset. In fact, even when the dataset is a TChain, the; /// first t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h:310,avoid,avoid,310,tree/tree/inc/TTree.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/inc/TTree.h,1,['avoid'],['avoid']
Safety,/// Return a pass that avoids creating store forward block issues in the hardware.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:23,avoid,avoids,23,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h,1,['avoid'],['avoids']
Safety,/// Return a pass that removes redundant LEA instructions and redundant address; /// recalculations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:31,redund,redundant,31,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h,2,['redund'],['redundant']
Safety,"/// Return a reciprocal estimate value for the input operand.; /// \p Enabled is a ReciprocalEstimate enum with value either 'Unspecified' or; /// 'Enabled' as set by a potential default override attribute.; /// If \p RefinementSteps is 'Unspecified', the number of Newton-Raphson; /// refinement iterations required to generate a sufficient (though not; /// necessarily IEEE-754 compliant) estimate is returned in that parameter.; /// A target may choose to implement its own refinement within this function.; /// If that's true, then return '0' as the number of RefinementSteps to avoid; /// any further refinement of the estimate.; /// An empty SDValue return means no estimate sequence can be created.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:583,avoid,avoid,583,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['avoid'],['avoid']
Safety,"/// Return a reference to the first or second member of a reference. Otherwise,; /// return a copy of the member of a temporary.; ///; /// When passing a range whose iterators return values instead of references,; /// the reference must be dropped from `decltype((elt.first))`, which will; /// always be a reference, to avoid returning a reference to a temporary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:320,avoid,avoid,320,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['avoid'],['avoid']
Safety,"/// Return a set of basic blocks to insert sinked instructions.; ///; /// The returned set of basic blocks (BBsToSinkInto) should satisfy:; ///; /// * Inside the loop \p L; /// * For each UseBB in \p UseBBs, there is at least one BB in BBsToSinkInto; /// that domintates the UseBB; /// * Has minimum total frequency that is no greater than preheader frequency; ///; /// The purpose of the function is to find the optimal sinking points to; /// minimize execution cost, which is defined as ""sum of frequency of; /// BBsToSinkInto"".; /// As a result, the returned BBsToSinkInto needs to have minimum total; /// frequency.; /// Additionally, if the total frequency of BBsToSinkInto exceeds preheader; /// frequency, the optimal solution is not sinking (return empty set).; ///; /// \p ColdLoopBBs is used to help find the optimal sinking locations.; /// It stores a list of BBs that is:; ///; /// * Inside the loop \p L; /// * Has a frequency no larger than the loop's preheader; /// * Sorted by BB frequency; ///; /// The complexity of the function is O(UseBBs.size() * ColdLoopBBs.size()).; /// To avoid expensive computation, we cap the maximum UseBBs.size() in its; /// caller.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp:1097,avoid,avoid,1097,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSink.cpp,1,['avoid'],['avoid']
Safety,"/// Return an ID for a diagnostic with the specified format string and; /// level.; ///; /// If this is the first request for this diagnostic, it is registered and; /// created, otherwise the existing ID is returned.; // FIXME: Replace this function with a create-only facilty like; // createCustomDiagIDFromFormatString() to enforce safe usage. At the time of; // writing, nearly all callers of this function were invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h:334,safe,safe,334,interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h,1,['safe'],['safe']
Safety,"/// Return an approximation of this SCEV expression's ""base"", or NULL for any; /// constant. Returning the expression itself is conservative. Returning a; /// deeper subexpression is more precise and valid as long as it isn't less; /// complex than another subexpression. For expressions involving multiple; /// unscaled values, we need to return the pointer-type SCEVUnknown. This avoids; /// forming chains across objects, such as: PrevOper==a[i], IVOper==b[i],; /// IVInc==b-a.; ///; /// Since SCEVUnknown is the rightmost type, and pointers are the rightmost; /// SCEVUnknown, we simply return the rightmost SCEV operand.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:382,avoid,avoids,382,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['avoid'],['avoids']
Safety,"/// Return an insertion point suitable for inserting a safe to speculate; /// instruction whose only user will be 'User' which has operands 'Ops'. A; /// trivial result would be the at the User itself, but we try to return a; /// loop invariant location if possible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:55,safe,safe,55,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['safe'],['safe']
Safety,/// Return false if the instruction should not be hoisted by MachineLICM.; ///; /// MachineLICM determines on its own whether the instruction is safe to; /// hoist; this gives the target a hook to extend this assessment and prevent; /// an instruction being hoisted from a given loop for target specific; /// reasons.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:145,safe,safe,145,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['safe'],['safe']
Safety,/// Return false if the next token is an identifier. An 'expected identifier'; /// error is emitted otherwise.; ///; /// The parser tries to recover from the error by checking if the next token; /// is a C++ keyword when parsing Objective-C++. Return false if the recovery; /// was successful.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:141,recover,recover,141,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,2,['recover'],"['recover', 'recovery']"
Safety,/// Return safe iteration space distance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:11,safe,safe,11,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,4,['safe'],['safe']
Safety,"/// Return squared weight of last bin that was requested with get().; /// \deprecated Use the safer weightSquared(std::size_t) const.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h:94,safe,safer,94,roofit/roofitcore/inc/RooDataHist.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooDataHist.h,1,['safe'],['safer']
Safety,"/// Return the (type-erased) address of the value of one variation of one column (can be safely cast back to a T*).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx:89,safe,safely,89,tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RVariationBase.hxx,1,['safe'],['safely']
Safety,"/// Return the LLVM name for an intrinsic, such as ""llvm.ppc.altivec.lvx"" or; /// ""llvm.ssa.copy.p0s_s.1"". Note, this version of getName supports overloads.; /// This is less efficient than the StringRef version of this function. If no; /// overloads are required, it is safe to use this version, but better to use; /// the StringRef version. If one of the types is based on an unnamed type, a; /// function type will be computed. Providing FT will avoid this computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Intrinsics.h:271,safe,safe,271,interpreter/llvm-project/llvm/include/llvm/IR/Intrinsics.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Intrinsics.h,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"/// Return the canonical predicate for the latch compare instruction, if; /// able to be calcuated. Else BAD_ICMP_PREDICATE.; ///; /// A predicate is considered as canonical if requirements below are all; /// satisfied:; /// 1. The first successor of the latch branch is the loop header; /// If not, inverse the predicate.; /// 2. One of the operands of the latch comparison is StepInst; /// If not, and; /// - if the current calcuated predicate is not ne or eq, flip the; /// predicate.; /// - else if the loop is increasing, return slt; /// (notice that it is safe to change from ne or eq to sign compare); /// - else if the loop is decreasing, return sgt; /// (notice that it is safe to change from ne or eq to sign compare); ///; /// Here is an example when both (1) and (2) are not satisfied:; /// \code; /// loop.header:; /// %iv = phi [%initialiv, %loop.preheader], [%inc, %loop.header]; /// %inc = add %iv, %step; /// %cmp = slt %iv, %finaliv; /// br %cmp, %loop.exit, %loop.header; /// loop.exit:; /// \endcode; /// - The second successor of the latch branch is the loop header instead; /// of the first successor (slt -> sge); /// - The first operand of the latch comparison (%cmp) is the IndVar (%iv); /// instead of the StepInst (%inc) (sge -> sgt); ///; /// The predicate would be sgt if both (1) and (2) are satisfied.; /// getCanonicalPredicate() returns sgt for this example.; /// Note: The IR is not changed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:562,safe,safe,562,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,2,['safe'],['safe']
Safety,/// Return the costs for our two available strategies for lowering a; /// div/rem operation which requires speculating at least one lane.; /// First result is for scalarization (will be invalid for scalable; /// vectors); second is for the safe-divisor strategy.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:240,safe,safe-divisor,240,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['safe'],['safe-divisor']
Safety,"/// Return the current size to request for ""safety"".",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:44,safe,safety,44,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h,1,['safe'],['safety']
Safety,"/// Return the error on the given point.; /// Safer method returning in any case the error and not the inverse as in the; /// function above.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h:46,Safe,Safer,46,math/mathcore/inc/Fit/BinData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Fit/BinData.h,1,['Safe'],['Safer']
Safety,"/// Return the hazard type of emitting this node. There are three; /// possible results. Either:; /// * NoHazard: it is legal to issue this instruction on this cycle.; /// * Hazard: issuing this instruction would stall the machine. If some; /// other instruction is available, issue it first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:15,hazard,hazard,15,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,2,"['Hazard', 'hazard']","['Hazard', 'hazard']"
Safety,"/// Return the number of currently available slot.; ///; /// The method is safe to call concurrently to other TThreadedObject methods.; /// Note that slots could be available but contain no data (i.e. a nullptr) if; /// they have not been used yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:75,safe,safe,75,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['safe'],['safe']
Safety,"/// Return the number of elements that are safe to operate on; /// simultaneously, multiplied by the size of the element in bits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:43,safe,safe,43,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['safe'],['safe']
Safety,"/// Return the register class of \p Reg, or null if Reg has not been assigned; /// a register class yet.; ///; /// \note A null register class can only happen when these two; /// conditions are met:; /// 1. Generic virtual registers are created.; /// 2. The machine function has not completely been through the; /// instruction selection process.; /// None of this condition is possible without GlobalISel for now.; /// In other words, if GlobalISel is not used or if the query happens after; /// the select pass, using getRegClass is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h:535,safe,safe,535,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineRegisterInfo.h,1,['safe'],['safe']
Safety,"/// Return the value of the flag in this raw_fd_ostream indicating whether an; /// output error has been encountered.; /// This doesn't implicitly flush any pending output. Also, it doesn't; /// guarantee to detect all errors unless the stream has been closed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:208,detect,detect,208,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['detect'],['detect']
Safety,"/// Return true (the default) if it is profitable to remove a sext_inreg(x); /// where the sext is redundant, and use x directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:99,redund,redundant,99,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['redund'],['redundant']
Safety,"/// Return true for DAG nodes that we ignore when computing the cost functions.; /// We ignore the back-edge recurrence in order to avoid unbounded recursion; /// in the calculation of the ASAP, ALAP, etc functions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp:132,avoid,avoid,132,interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachinePipeliner.cpp,1,['avoid'],['avoid']
Safety,"/// Return true for all instructions that only update; /// the first 32 or 64-bits of the destination register and leave the rest; /// unmodified. This can be used to avoid folding loads if the instructions; /// only update part of the destination register, and the non-updated part is; /// not needed. e.g. cvtss2sd, sqrtss. Unfolding the load from these; /// instructions breaks the partial register dependency and it can improve; /// performance. e.g.:; ///; /// movss (%rdi), %xmm0; /// cvtss2sd %xmm0, %xmm0; ///; /// Instead of; /// cvtss2sd (%rdi), %xmm0; ///; /// FIXME: This should be turned into a TSFlags.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp:167,avoid,avoid,167,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.cpp,1,['avoid'],['avoid']
Safety,/// Return true if Flow Control is an expensive operation that should be; /// avoided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:78,avoid,avoided,78,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['avoid'],['avoided']
Safety,/// Return true if \p I can be safely moved before \p InsertPoint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h:31,safe,safely,31,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,1,['safe'],['safely']
Safety,/// Return true if all instructions (except the terminator) in \p BB can be; /// safely moved before \p InsertPoint.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h:81,safe,safely,81,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/CodeMoverUtils.h,1,['safe'],['safely']
Safety,/// Return true if all non-terminator instructions in MBB can be safely; /// predicated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:65,safe,safely,65,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,1,['safe'],['safely']
Safety,/// Return true if all non-terminator instructions in MBB can be safely; /// speculated.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:65,safe,safely,65,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,2,['safe'],['safely']
Safety,"/// Return true if all of the instructions in the block can be speculatively; /// executed, and record the loads/stores that require masking.; /// \p SafePtrs is a list of addresses that are known to be legal and we know; /// that we can read from them without segfault.; /// \p MaskedOp is a list of instructions that have to be transformed into; /// calls to the appropriate masked intrinsic when the loop is vectorized; /// or dropped if the instruction is a conditional assume intrinsic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:150,Safe,SafePtrs,150,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['Safe'],['SafePtrs']
Safety,/// Return true if all users of the specified value will trap if the value is; /// dynamically null. PHIs keeps track of any phi nodes we've seen to avoid; /// reprocessing them.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:149,avoid,avoid,149,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,1,['avoid'],['avoid']
Safety,"/// Return true if every instruction in the range (Begin, End) is; /// guaranteed to transfer execution to its static successor. \p ScanLimit; /// bounds the search to avoid scanning huge blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:168,avoid,avoid,168,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['avoid'],['avoid']
Safety,/// Return true if it is safe to merge these two; /// terminator instructions together.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:25,safe,safe,25,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,"/// Return true if it is safe to move the specified; /// instruction from after the call to before the call, assuming that all; /// instructions between the call and this instruction are movable.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:25,safe,safe,25,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,1,['safe'],['safe']
Safety,"/// Return true if it is safe to move this instruction. If; /// SawStore is set to true, it means that there is a store (or call) between; /// the instruction's location and its intended destination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:25,safe,safe,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['safe'],['safe']
Safety,"/// Return true if it is worth folding MI into an extended register. That is,; /// if it's safe to pull it into the addressing mode of a load or store as a; /// shift.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:91,safe,safe,91,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['safe'],['safe']
Safety,"/// Return true if it's profitable for if-converter to duplicate instructions; /// of specified accumulated instruction latencies in the specified MBB to; /// enable if-conversion.; /// The probability of the instructions being executed is given by; /// Probability, and Confidence is a measure of our confidence that it; /// will be properly predicted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:343,predict,predicted,343,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,['predict'],['predicted']
Safety,"/// Return true if it's profitable to predicate; /// instructions with accumulated instruction latency of ""NumCycles""; /// of the specified basic block, where the probability of the instructions; /// being executed is given by Probability, and Confidence is a measure; /// of our confidence that it will be properly predicted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:316,predict,predicted,316,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,['predict'],['predicted']
Safety,/// Return true if it's safe to merge the two nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h:24,safe,safe,24,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceGraphBuilder.h,1,['safe'],['safe']
Safety,/// Return true if it's safe to move a machine; /// instruction that defines the specified register class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:24,safe,safe,24,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['safe'],['safe']
Safety,/// Return true if selects are only cheaper than branches if the branch is; /// unlikely to be predicted right.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:95,predict,predicted,95,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['predict'],['predicted']
Safety,"/// Return true if speculation of the given load must be suppressed to avoid; /// ordering or interfering with an active sanitizer. If not suppressed,; /// dereferenceability and alignment must be proven separately. Note: This; /// is only needed for raw reasoning; if you use the interface below; /// (isSafeToSpeculativelyExecute), this is handled internally.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:71,avoid,avoid,71,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,1,['avoid'],['avoid']
Safety,"/// Return true if the MachineBasicBlock can safely be split to the cold; /// section. On AArch64, certain instructions may cause a block to be unsafe; /// to split to the cold section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:45,safe,safely,45,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,"['safe', 'unsafe']","['safely', 'unsafe']"
Safety,"/// Return true if the control flow in \p RPOTraversal is irreducible.; ///; /// This is a generic implementation to detect CFG irreducibility based on loop; /// info analysis. It can be used for any kind of CFG (Loop, MachineLoop,; /// Function, MachineFunction, etc.) by providing an RPO traversal (\p; /// RPOTraversal) and the loop info analysis (\p LI) of the CFG. This utility; /// function is only recommended when loop info analysis is available. If loop; /// info analysis isn't available, please, don't compute it explicitly for this; /// purpose. There are more efficient ways to detect CFG irreducibility that; /// don't require recomputing loop info analysis (e.g., T1/T2 or Tarjan's; /// algorithm).; ///; /// Requirements:; /// 1) GraphTraits must be implemented for NodeT type. It is used to access; /// NodeT successors.; // 2) \p RPOTraversal must be a valid reverse post-order traversal of the; /// target CFG with begin()/end() iterator interfaces.; /// 3) \p LI must be a valid LoopInfoBase that contains up-to-date loop; /// analysis information of the CFG.; ///; /// This algorithm uses the information about reducible loop back-edges already; /// computed in \p LI. When a back-edge is found during the RPO traversal, the; /// algorithm checks whether the back-edge is one of the reducible back-edges in; /// loop info. If it isn't, the CFG is irreducible. For example, for the CFG; /// below (canonical irreducible graph) loop info won't contain any loop, so the; /// algorithm will return that the CFG is irreducible when checking the B <-; /// -> C back-edge.; ///; /// (A->B, A->C, B->C, C->B, C->D); /// A; /// / \; /// B<- ->C; /// |; /// D; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h:117,detect,detect,117,interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CFG.h,2,['detect'],['detect']
Safety,/// Return true if the current thread is recovering from a crash.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h:41,recover,recovering,41,interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CrashRecoveryContext.h,1,['recover'],['recovering']
Safety,/// Return true if the function can safely be outlined from.; /// A function \p MF is considered safe for outlining if an outlined function; /// produced from instructions in F will produce a program which produces the; /// same output for any set of given inputs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:36,safe,safely,36,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,2,['safe'],"['safe', 'safely']"
Safety,/// Return true if the given expression is safe to expand in the sense that; /// all materialized values are defined and safe to speculate at the specified; /// location and their operands are defined at this location.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:43,safe,safe,43,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,2,['safe'],['safe']
Safety,"/// Return true if the given expression is safe to expand in the sense that; /// all materialized values are safe to speculate anywhere their operands are; /// defined, and the expander is capable of expanding the expression.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h:43,safe,safe,43,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h,2,['safe'],['safe']
Safety,"/// Return true if the given instruction (assumed to be a memory access; /// instruction) has a volatile variant. If that's the case then we can avoid; /// addrspacecast to generic AS for volatile loads/stores. Default; /// implementation returns false, which prevents address space inference for; /// volatile loads/stores.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:145,avoid,avoid,145,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['avoid'],['avoid']
Safety,"/// Return true if the idiom is detected in the loop.; ///; /// Additionally:; /// 1) \p CntInst is set to the instruction Counting Leading Zeros (CTLZ); /// or nullptr if there is no such.; /// 2) \p CntPhi is set to the corresponding phi node; /// or nullptr if there is no such.; /// 3) \p Var is set to the value whose CTLZ could be used.; /// 4) \p DefX is set to the instruction calculating Loop exit condition.; ///; /// The core idiom we are trying to detect is:; /// \code; /// if (x0 == 0); /// goto loop-exit // the precondition of the loop; /// cnt0 = init-val;; /// do {; /// x = phi (x0, x.next); //PhiX; /// cnt = phi(cnt0, cnt.next);; ///; /// cnt.next = cnt + 1;; /// ...; /// x.next = x >> 1; // DefX; /// ...; /// } while(x.next != 0);; ///; /// loop-exit:; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:32,detect,detected,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,2,['detect'],"['detect', 'detected']"
Safety,"/// Return true if the idiom is detected in the loop.; ///; /// The core idiom we are trying to detect is:; /// \code; /// entry:; /// <...>; /// %bitmask = shl i32 1, %bitpos; /// br label %loop; ///; /// loop:; /// %x.curr = phi i32 [ %x, %entry ], [ %x.next, %loop ]; /// %x.curr.bitmasked = and i32 %x.curr, %bitmask; /// %x.curr.isbitunset = icmp eq i32 %x.curr.bitmasked, 0; /// %x.next = shl i32 %x.curr, 1; /// <...>; /// br i1 %x.curr.isbitunset, label %loop, label %end; ///; /// end:; /// %x.curr.res = phi i32 [ %x.curr, %loop ] <...>; /// %x.next.res = phi i32 [ %x.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:32,detect,detected,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,2,['detect'],"['detect', 'detected']"
Safety,"/// Return true if the idiom is detected in the loop.; ///; /// The core idiom we are trying to detect is:; /// \code; /// entry:; /// <...>; /// %start = <...>; /// %extraoffset = <...>; /// <...>; /// br label %for.cond; ///; /// loop:; /// %iv = phi i8 [ %start, %entry ], [ %iv.next, %for.cond ]; /// %nbits = add nsw i8 %iv, %extraoffset; /// %val.shifted = {{l,a}shr,shl} i8 %val, %nbits; /// %val.shifted.iszero = icmp eq i8 %val.shifted, 0; /// %iv.next = add i8 %iv, 1; /// <...>; /// br i1 %val.shifted.iszero, label %end, label %loop; ///; /// end:; /// %iv.res = phi i8 [ %iv, %loop ] <...>; /// %nbits.res = phi i8 [ %nbits, %loop ] <...>; /// %val.shifted.res = phi i8 [ %val.shifted, %loop ] <...>; /// %val.shifted.iszero.res = phi i1 [ %val.shifted.iszero, %loop ] <...>; /// %iv.next.res = phi i8 [ %iv.next, %loop ] <...>; /// <...>; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:32,detect,detected,32,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,2,['detect'],"['detect', 'detected']"
Safety,"/// Return true if the instruction does not have any effects besides; /// calculating the result and does not have undefined behavior.; ///; /// This method never returns true for an instruction that returns true for; /// mayHaveSideEffects; however, this method also does some other checks in; /// addition. It checks for undefined behavior, like dividing by zero or; /// loading from an invalid pointer (but not for undefined results, like a; /// shift with a shift amount larger than the width of the result). It checks; /// for malloc and alloca because speculatively executing them might cause a; /// memory leak. It also returns false for instructions related to control; /// flow, specifically terminators and PHI nodes.; ///; /// If the CtxI is specified this method performs context-sensitive analysis; /// and returns true if it is safe to execute the instruction immediately; /// before the CtxI.; ///; /// If the CtxI is NOT specified this method only looks at the instruction; /// itself and its operands, so if this method returns true, it is safe to; /// move the instruction as long as the correct dominance relationships for; /// the operands and users hold.; ///; /// This method can return true for instructions that read memory;; /// for such instructions, moving them may change the resulting value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:842,safe,safe,842,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,2,['safe'],['safe']
Safety,/// Return true if the instruction should be sunk by MachineSink.; ///; /// MachineSink determines on its own whether the instruction is safe to sink;; /// this gives the target a hook to override the default behavior with regards; /// to which instructions should be sunk.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:137,safe,safe,137,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['safe'],['safe']
Safety,/// Return true if the loop body is safe to clone in practice.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:36,safe,safe,36,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,1,['safe'],['safe']
Safety,"/// Return true if the minimal well-formed code unit subsequence at; /// Pos is considered a ""safe"" character for plain scalars.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp:94,safe,safe,94,interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/YAMLParser.cpp,1,['safe'],['safe']
Safety,/// Return true if the number of elements that are safe to operate on; /// simultaneously is not bounded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:51,safe,safe,51,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['safe'],['safe']
Safety,/// Return true if the specified constant can be handled by the code generator.; /// We don't want to generate something like:; /// void *X = &X/42;; /// because the code generator doesn't have a relocation that can handle that.; ///; /// This function should be called if C was not found (but just got inserted); /// in SimpleConstants to avoid having to rescan the same constants all the; /// time.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:340,avoid,avoid,340,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,1,['avoid'],['avoid']
Safety,"/// Return true if the target stores SafeStack pointer at a fixed offset in; /// some non-standard address space, and populates the address space and; /// offset as appropriate.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:37,Safe,SafeStack,37,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['Safe'],['SafeStack']
Safety,/// Return true if the value is known to produce a single fixed value across; /// all iterations on which it executes. Note that this does not imply; /// speculation safety. That must be established separately.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp:166,safe,safety,166,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopPredication.cpp,1,['safe'],['safety']
Safety,"/// Return true if this call calls a gc leaf function.; ///; /// A leaf function is a function that does not safepoint the thread during its; /// execution. During a call or invoke to such a function, the callers stack; /// does not have to be made parseable.; ///; /// Most passes can and should ignore this information, and it is only used; /// during lowering by the GC infrastructure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h:109,safe,safepoint,109,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Local.h,1,['safe'],['safepoint']
Safety,"/// Return true if this instruction cannot be safely duplicated.; /// For example, if the instruction has a unique labels attached; /// to it, duplicating it would cause multiple definition errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:46,safe,safely,46,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['safe'],['safely']
Safety,"/// Return true if this instruction cannot be safely; /// duplicated. For example, if the instruction has a unique labels attached; /// to it, duplicating it would cause multiple definition errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h:46,safe,safely,46,interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCInstrDesc.h,1,['safe'],['safely']
Safety,/// Return true if this personality may be safely removed if there; /// are no invoke instructions remaining in the current function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/EHPersonalities.h:43,safe,safely,43,interpreter/llvm-project/llvm/include/llvm/IR/EHPersonalities.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/EHPersonalities.h,1,['safe'],['safely']
Safety,/// Return true if we assume that the underlying value is unique in its scope; /// wrt. the Attributor analysis. That means it might not be unique but we can; /// still use pointer equality without risking to represent two instances with; /// one `llvm::Value`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:198,risk,risking,198,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['risk'],['risking']
Safety,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:200,safe,safe,200,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,4,['safe'],['safe']
Safety,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:38,safe,safe,38,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,2,['safe'],['safe']
Safety,/// Return true if we know that the underlying value is unique in its scope; /// wrt. the Attributor analysis. That means it might not be unique but we can; /// still use pointer equality without risking to represent two instances with; /// one `llvm::Value`.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:196,risk,risking,196,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['risk'],['risking']
Safety,/// Return true if-and-only-if we know how to (mechanically) both hoist and; /// sink a given instruction out of a loop. Does not address legality; /// concerns such as aliasing or speculation safety.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:193,safe,safety,193,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safety']
Safety,"/// Return true iff the idiom is detected in the loop.; ///; /// Additionally:; /// 1) \p CntInst is set to the instruction counting the population bit.; /// 2) \p CntPhi is set to the corresponding phi node.; /// 3) \p Var is set to the value whose population bits are being counted.; ///; /// The core idiom we are trying to detect is:; /// \code; /// if (x0 != 0); /// goto loop-exit // the precondition of the loop; /// cnt0 = init-val;; /// do {; /// x1 = phi (x0, x2);; /// cnt1 = phi(cnt0, cnt2);; ///; /// cnt2 = cnt1 + 1;; /// ...; /// x2 = x1 & (x1 - 1);; /// ...; /// } while(x != 0);; ///; /// loop-exit:; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:33,detect,detected,33,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,2,['detect'],"['detect', 'detected']"
Safety,"/// Return true on succesful entry read.; ///; /// TTreeReader encodes successful reads in the `kEntryValid` enum value, but; /// there can be other situations where the read is still valid. For now, these; /// are:; /// - If there was no match of the current entry in one or more friend trees; /// according to their respective indexes.; /// - If there was a missing branch at the start of a new tree in the dataset.; ///; /// In such situations, although the entry is not complete, the processing; /// should not be aborted and nodes of the computation graph will take action; /// accordingly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:518,abort,aborted,518,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['abort'],['aborted']
Safety,"/// Return whether a MachineInstr could be inserted at MI and safely define; /// the given register without affecting the program, ignoring any effects; /// on the provided instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:62,safe,safely,62,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,1,['safe'],['safely']
Safety,/// Return whether a MachineInstr could be inserted at MI and safely define; /// the given register without affecting the program.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:62,safe,safely,62,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,1,['safe'],['safely']
Safety,"/// Return whether removing this instruction will have no effect on the; /// program, ignoring the possible effects on some instructions, returning; /// the redundant use-def chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:157,redund,redundant,157,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,2,['redund'],['redundant']
Safety,"/// Return whether removing this instruction will have no effect on the; /// program, returning the redundant use-def chain.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h:100,redund,redundant,100,interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ReachingDefAnalysis.h,1,['redund'],['redundant']
Safety,/// Return whether this instruction can safely wrap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:40,safe,safely,40,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,1,['safe'],['safely']
Safety,/// Return whether we can safely mutate V's type to ExtTy without having to be; /// concerned with zero extending or truncation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp:26,safe,safely,26,interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/TypePromotion.cpp,1,['safe'],['safely']
Safety,/// Returns ARM processor family.; /// Avoid this function! CPU specifics should be kept local to this class; /// and preferably modeled with SubtargetFeatures or properties in; /// initializeProperties().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h:39,Avoid,Avoid,39,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64Subtarget.h,1,['Avoid'],['Avoid']
Safety,"/// Returns InlineResult::success() if the call site should be always inlined; /// because of user directives, and the inlining is viable. Returns; /// InlineResult::failure() if the inlining may never happen because of user; /// directives or incompatibilities detectable without needing callee traversal.; /// Otherwise returns std::nullopt, meaning that inlining should be decided; /// based on other criteria (e.g. cost modeling).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h:262,detect,detectable,262,interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InlineCost.h,1,['detect'],['detectable']
Safety,/// Returns RISC-V processor family.; /// Avoid this function! CPU specifics should be kept local to this class; /// and preferably modeled with SubtargetFeatures or properties in; /// initializeProperties().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.h:42,Avoid,Avoid,42,interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/RISCV/RISCVSubtarget.h,1,['Avoid'],['Avoid']
Safety,"/// Returns True if V can be considered as an induction variable in this; /// loop. V can be the induction phi, or some redundant cast in the def-use; /// chain of the inducion phi.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:120,redund,redundant,120,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['redund'],['redundant']
Safety,"/// Returns True if V is a cast that is part of an induction def-use chain,; /// and had been proven to be redundant under a runtime guard (in other; /// words, the cast has the same SCEV expression as the induction phi).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:107,redund,redundant,107,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['redund'],['redundant']
Safety,/// Returns a 0 terminated array of registers that can be safely used as; /// scratch registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:58,safe,safely,58,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['safe'],['safely']
Safety,"/// Returns a bitset indexed by physical register number indicating if a; /// register is a special register that has particular uses and should be; /// considered unavailable at all times, e.g. stack pointer, return address.; /// A reserved register:; /// - is not allocatable; /// - is considered always live; /// - is ignored by liveness tracking; /// It is often necessary to reserve the super registers of a reserved; /// register as well, to avoid them getting allocated indirectly. You may use; /// markSuperRegs() and checkAllSuperRegsMarked() in this case.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h:448,avoid,avoid,448,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetRegisterInfo.h,1,['avoid'],['avoid']
Safety,/// Returns a pass that clears pipeline hazards.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp:40,hazard,hazards,40,interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsBranchExpansion.cpp,1,['hazard'],['hazards']
Safety,"/// Returns a reference to the type cast instructions in the induction; /// update chain, that are redundant when guarded with a runtime; /// SCEV overflow check.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:99,redund,redundant,99,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,1,['redund'],['redundant']
Safety,"/// Returns a string representation of the errno value, using whatever; /// thread-safe variant of strerror() is available. Be sure to call this; /// immediately after the function that set errno, or errno may have been; /// overwritten by an intervening call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Errno.h:83,safe,safe,83,interpreter/llvm-project/llvm/include/llvm/Support/Errno.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Errno.h,1,['safe'],['safe']
Safety,"/// Returns a thread strategy for tasks requiring significant memory or other; /// resources. To be used for workloads where hardware_concurrency() proves to; /// be less efficient. Avoid this strategy if doing lots of I/O. Currently; /// based on physical cores, if available for the host system, otherwise falls; /// back to hardware_concurrency(). Returns 1 when LLVM is configured with; /// LLVM_ENABLE_THREADS = OFF.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h:182,Avoid,Avoid,182,interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Threading.h,1,['Avoid'],['Avoid']
Safety,"/// Returns a unique ID that is different for every instantiated RooAbsData object.; /// This ID can be used whether two RooAbsData are the same object, which is safer; /// than memory address comparisons that might result in false positives when; /// memory is reused.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h:162,safe,safer,162,roofit/roofitcore/inc/RooAbsData.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooAbsData.h,1,['safe'],['safer']
Safety,"/// Returns an adjusted FMA opcode that must be used in FMA instruction that; /// performs the same computations as the given \p MI but which has the; /// operands \p SrcOpIdx1 and \p SrcOpIdx2 commuted.; /// It may return 0 if it is unsafe to commute the operands.; /// Note that a machine instruction (instead of its opcode) is passed as the; /// first parameter to make it possible to analyze the instruction's uses and; /// commute the first operand of FMA even when it seems unsafe when you look; /// at the opcode. For example, it is Ok to commute the first operand of; /// VFMADD*SD_Int, if ONLY the lowest 64-bit element of the result is used.; ///; /// The returned FMA opcode may differ from the opcode in the given \p MI.; /// For example, commuting the operands #1 and #3 in the following FMA; /// FMA213 #1, #2, #3; /// results into instruction with adjusted opcode:; /// FMA231 #3, #2, #1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:234,unsafe,unsafe,234,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,2,['unsafe'],['unsafe']
Safety,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:343,avoid,avoid,343,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['avoid'],['avoid']
Safety,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:336,avoid,avoid,336,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,1,['avoid'],['avoid']
Safety,/// Returns the VPValue for \p V. \p OverrideAllowed can be used to disable; /// /// checking whether it is safe to query VPValues using IR Values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h:108,safe,safe,108,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/VPlan.h,1,['safe'],['safe']
Safety,"/// Returns the element immediate value of a vector shift operand if found.; /// This needs to detect a splat-like operation, e.g. a G_BUILD_VECTOR.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp:95,detect,detect,95,interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/GISel/AArch64InstructionSelector.cpp,1,['detect'],['detect']
Safety,"/// Returns the minimum safe size (in bytes) of a buffer that is intended to be used as a destination for PackBits; /// or a source for UnpackBits.; /// Passing a buffer that's less than this size will cause invalid memory reads and writes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx:24,safe,safe,24,tree/ntuple/v7/src/RColumnElement.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/RColumnElement.hxx,1,['safe'],['safe']
Safety,"/// Returns the most nullable nullability. This is used for message expressions; /// like [receiver method], where the nullability of this expression is either; /// the nullability of the receiver or the nullability of the return type of the; /// method, depending on which is more nullable. Contradicted is considered to; /// be the most nullable, to avoid false positive results.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp:352,avoid,avoid,352,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/NullabilityChecker.cpp,1,['avoid'],['avoid']
Safety,"/// Returns the parents of the given node (within the traversal scope).; ///; /// Note that this will lazily compute the parents of all nodes; /// and store them for later retrieval. Thus, the first call is O(n); /// in the number of AST nodes.; ///; /// Caveats and FIXMEs:; /// Calculating the parent map over all AST nodes will need to load the; /// full AST. This can be undesirable in the case where the full AST is; /// expensive to create (for example, when using precompiled header; /// preambles). Thus, there are good opportunities for optimization here.; /// One idea is to walk the given node downwards, looking for references; /// to declaration contexts - once a declaration context is found, compute; /// the parent map for the declaration context; if that can satisfy the; /// request, loading the whole AST can be avoided. Note that this is made; /// more complex by statements in templates having multiple parents - those; /// problems can be solved by building closure over the templated parts of; /// the AST, which also avoids touching large parts of the AST.; /// Additionally, we will want to add an interface to already give a hint; /// where to search for the parents, for example when looking at a statement; /// inside a certain function.; ///; /// 'NodeT' can be one of Decl, Stmt, Type, TypeLoc,; /// NestedNameSpecifier or NestedNameSpecifierLoc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ParentMapContext.h:831,avoid,avoided,831,interpreter/llvm-project/clang/include/clang/AST/ParentMapContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ParentMapContext.h,2,['avoid'],"['avoided', 'avoids']"
Safety,"/// Returns the preferred minimum clearance; /// before an instruction with an unwanted partial register update.; ///; /// Some instructions only write part of a register, and implicitly need to; /// read the other parts of the register. This may cause unwanted stalls; /// preventing otherwise unrelated instructions from executing in parallel in; /// an out-of-order CPU.; ///; /// For example, the x86 instruction cvtsi2ss writes its result to bits; /// [31:0] of the destination xmm register. Bits [127:32] are unaffected, so; /// the instruction needs to wait for the old value of the register to become; /// available:; ///; /// addps %xmm1, %xmm0; /// movaps %xmm0, (%rax); /// cvtsi2ss %rbx, %xmm0; ///; /// In the code above, the cvtsi2ss instruction needs to wait for the addps; /// instruction before it can issue, even though the high bits of %xmm0; /// probably aren't needed.; ///; /// This hook returns the preferred clearance before MI, measured in; /// instructions. Other defs of MI's operand OpNum are avoided in the last N; /// instructions before MI. It should only return a positive value for; /// unwanted dependencies. If the old bits of the defined register have; /// useful values, or if MI is determined to otherwise read the dependency,; /// the hook should return 0.; ///; /// The unwanted dependency may be handled by:; ///; /// 1. Allocating the same register for an MI def and use. That makes the; /// unwanted dependency identical to a required dependency.; ///; /// 2. Allocating a register for the def that has no defs in the previous N; /// instructions.; ///; /// 3. Calling breakPartialRegDependency() with the same arguments. This; /// allows the target to insert a dependency breaking instruction.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:1021,avoid,avoided,1021,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['avoid'],['avoided']
Safety,"/// Returns the priority of the category which \p IncludeName belongs to.; /// If \p CheckMainHeader is true and \p IncludeName is a main header, returns; /// 0. Otherwise, returns the priority of the matching category or INT_MAX.; /// NOTE: this API is not thread-safe!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h:265,safe,safe,265,interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/Inclusions/HeaderIncludes.h,1,['safe'],['safe']
Safety,"/// Returns the size of instructions in the block \p MBB, or std::nullopt if; /// we couldn't get a safe upper bound.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CompressJumpTables.cpp:100,safe,safe,100,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CompressJumpTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64CompressJumpTables.cpp,1,['safe'],['safe']
Safety,"/// Returns the size of the trailing data, if an object were; /// allocated with the given counts (The counts are in the same order; /// as the template arguments). This does not include the size of the; /// base object. The template arguments must be the same as those; /// used in the class; they are supplied here redundantly only so; /// that it's clear what the counts are counting in callers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h:317,redund,redundantly,317,interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/TrailingObjects.h,1,['redund'],['redundantly']
Safety,"/// Returns the target specific optimal type for load and store operations as; /// a result of memset, memcpy, and memmove lowering.; ///; /// If DstAlign is zero that means it's safe to destination alignment can; /// satisfy any constraint. Similarly if SrcAlign is zero it means there isn't; /// a need to check it against alignment requirement, probably because the; /// source does not need to be loaded. If 'IsMemset' is true, that means it's; /// expanding a memset. If 'ZeroMemset' is true, that means it's a memset of; /// zero. 'MemcpyStrSrc' indicates whether the memcpy source is constant so it; /// does not need to be loaded. It returns EVT::Other if the type should be; /// determined using generic target-independent logic.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp:179,safe,safe,179,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonISelLowering.cpp,1,['safe'],['safe']
Safety,/// Returns the target-specific address of the unsafe stack pointer.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:47,unsafe,unsafe,47,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['unsafe'],['unsafe']
Safety,"/// Returns the vcall visibility of the given type. This is the scope in which; /// a virtual function call could be made which ends up being dispatched to a; /// member function of this class. This scope can be wider than the visibility; /// of the class itself when the class has a more-visible dynamic base class.; /// The client should pass in an empty Visited set, which is used to prevent; /// redundant recursive processing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h:400,redund,redundant,400,interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenModule.h,1,['redund'],['redundant']
Safety,"/// Returns timeout for launching new browser process",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindowsManager.hxx:12,timeout,timeout,12,gui/webdisplay/inc/ROOT/RWebWindowsManager.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/inc/ROOT/RWebWindowsManager.hxx,1,['timeout'],['timeout']
Safety,"/// Returns true if Def would dominate a use in any instruction in BB.; /// If Def is an instruction in BB, then Def does not dominate BB.; ///; /// Does not accept Value to avoid ambiguity with dominance checks between; /// two basic blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h:174,avoid,avoid,174,interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Dominators.h,1,['avoid'],['avoid']
Safety,/// Returns true if PLT should be avoided for RTLib calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:34,avoid,avoided,34,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['avoid'],['avoided']
Safety,/// Returns true if VNI is killed by any PHI-def values in LI.; /// This may conservatively return true to avoid expensive computations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:107,avoid,avoid,107,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,1,['avoid'],['avoid']
Safety,/// Returns true if \p DependenceMI can clobber the liveIns in NullSucc block; /// if it was hoisted to the NullCheck block. This is used by caller; /// canHoistInst to decide if DependenceMI can be hoisted safely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp:207,safe,safely,207,interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ImplicitNullChecks.cpp,1,['safe'],['safely']
Safety,"/// Returns true if a pointer value \p A can be replace with another pointer; /// value \B if they are deemed equal through some means (e.g. information from; /// conditions).; /// NOTE: the current implementations is incomplete and unsound. It does not; /// reject all invalid cases yet, but will be made stricter in the future. In; /// particular this means returning true means unknown if replacement is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:407,safe,safe,407,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,1,['safe'],['safe']
Safety,/// Returns true if an entry safepoint is not required before this callsite in; /// the caller function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:29,safe,safepoint,29,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,/// Returns true if it is unsafe to move a copy instruction from \p UseReg to; /// \p DestReg over the instruction \p MI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:26,unsafe,unsafe,26,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,1,['unsafe'],['unsafe']
Safety,"/// Returns true if it's safe to use load / store of the specified type to; /// expand memcpy / memset inline.; ///; /// This is mostly true for all types except for some special cases. For; /// example, on X86 targets without SSE2 f64 load / store are done with fldl /; /// fstpl which also does type conversion. Note the specified type doesn't; /// have to be legal as the hook is used before type legalization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:25,safe,safe,25,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['safe'],['safe']
Safety,"/// Returns true if it's safe to use load / store of the; /// specified type to expand memcpy / memset inline. This is mostly true; /// for all types except for some special cases. For example, on X86; /// targets without SSE2 f64 load / store are done with fldl / fstpl which; /// also does type conversion. Note the specified type doesn't have to be; /// legal as the hook is used before type legalization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h:25,safe,safe,25,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.h,1,['safe'],['safe']
Safety,/// Returns true if the beginning of this instruction can be safely shortened; /// in length.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:61,safe,safely,61,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['safe'],['safely']
Safety,/// Returns true if the end of this instruction can be safely shortened in; /// length.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:55,safe,safely,55,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['safe'],['safely']
Safety,/// Returns true if the inline qualifier for \c Name is redundant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:56,redund,redundant,56,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['redund'],['redundant']
Safety,"/// Returns true if the instruction \p MI may alias \p Other.; /// This function uses multiple strategies to detect aliasing, whereas; /// aliasIsKnownForLoadStore just looks at the addresses of load/stores and is; /// tries to reason about base/index/offsets.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h:109,detect,detect,109,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LoadStoreOpt.h,1,['detect'],['detect']
Safety,"/// Returns true if the instruction could potentially depend on the value of; /// exec. If false, exec dependencies may safely be ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h:120,safe,safely,120,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.h,1,['safe'],['safely']
Safety,/// Returns true if the instruction creates an unavoidable hazard that; /// forces a boundary between store merge candidates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp:59,hazard,hazard,59,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/LoadStoreOpt.cpp,1,['hazard'],['hazard']
Safety,"/// Returns true if the instruction may be a suitable candidate for LICM.; /// e.g. If the instruction is a call, then it's obviously not safe to hoist it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:138,safe,safe,138,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['safe'],['safe']
Safety,/// Returns true if the instruction may be safely skipped during verification.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp:43,safe,safely,43,interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/SafepointIRVerifier.cpp,1,['safe'],['safely']
Safety,/// Returns true if the possibility of a signaling NaN can be safely; /// ignored.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/FPEnv.h:62,safe,safely,62,interpreter/llvm-project/llvm/include/llvm/IR/FPEnv.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/FPEnv.h,1,['safe'],['safely']
Safety,/// Returns true if the preprocessed entity that \arg PPEI iterator; /// points to is coming from the file \arg FID.; ///; /// Can be used to avoid implicit deserializations of preallocated; /// preprocessed entities if we only care about entities of a specific file; /// and not from files \#included in the range given at; /// \see getPreprocessedEntitiesInRange.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp:142,avoid,avoid,142,interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/PreprocessingRecord.cpp,1,['avoid'],['avoid']
Safety,/// Returns true if the preprocessed entity that \p PPEI iterator; /// points to is coming from the file \p FID.; ///; /// Can be used to avoid implicit deserializations of preallocated; /// preprocessed entities if we only care about entities of a specific file; /// and not from files \#included in the range given at; /// \see getPreprocessedEntitiesInRange.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h:138,avoid,avoid,138,interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/PreprocessingRecord.h,1,['avoid'],['avoid']
Safety,/// Returns true if the target can safely skip saving callee-saved registers; /// for noreturn nounwind functions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:35,safe,safely,35,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,3,['safe'],['safely']
Safety,/// Returns true if this function should be rewritten to include safepoint; /// polls and parseable call sites. The main point of this function is to be; /// an extension point for custom logic.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:65,safe,safepoint,65,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,/// Returns true if this loop is known to contain a call safepoint which; /// must unconditionally execute on any iteration of the loop which returns; /// to the loop header via an edge from Pred. Returns a conservative correct; /// answer; i.e. false is always valid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:57,safe,safepoint,57,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,1,['safe'],['safepoint']
Safety,"/// Returns true if we can statically tell that this value will never be a; /// ""useful"" constant. In practice, this means we've got something like an; /// alloca or a malloc call for which a comparison against a constant can; /// only be guarding dead code. Note that we are potentially giving up some; /// precision in dead code (a constant result) in favour of avoiding a; /// expensive search for a easily answered common query.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp:364,avoid,avoiding,364,interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/LazyValueInfo.cpp,1,['avoid'],['avoiding']
Safety,/// Returns true iff the block \p BB potentially may throw exception. It can; /// be false-positive in cases when we want to avoid complex analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:125,avoid,avoid,125,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['avoid'],['avoid']
Safety,/// Returns whether or not the AMDGPU unsafe floating point atomics are; /// allowed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:38,unsafe,unsafe,38,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['unsafe'],['unsafe']
Safety,"/// Rewrite image intrinsics to use register layouts expected by the subtarget.; ///; /// Depending on the subtarget, load/store with 16-bit element data need to be; /// rewritten to use the low half of 32-bit registers, or directly use a packed; /// layout. 16-bit addresses should also sometimes be packed into 32-bit; /// registers.; ///; /// We don't want to directly select image instructions just yet, but also want; /// to exposes all register repacking to the legalizer/combiners. We also don't; /// want a selected instruction entering RegBankSelect. In order to avoid; /// defining a multitude of intermediate image instructions, directly hack on; /// the intrinsic's arguments. In cases like a16 addresses, this requires; /// padding now unnecessary arguments with $noreg.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp:572,avoid,avoid,572,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPULegalizerInfo.cpp,1,['avoid'],['avoid']
Safety,/// Rewrite the device (=GPU) code state machine create in non-SPMD mode in; /// the cases we can avoid taking the address of a function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:98,avoid,avoid,98,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['avoid'],['avoid']
Safety,"/// Rewrite the loop's terminating condition if it uses a max computation.; ///; /// This is a narrow solution to a specific, but acute, problem. For loops; /// like this:; ///; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; ///; /// the trip count isn't just 'n', because 'n' might not be positive. And; /// unfortunately this can come up even for loops where the user didn't use; /// a C do-while loop. For example, seemingly well-behaved top-test loops; /// will commonly be lowered like this:; ///; /// if (n > 0) {; /// i = 0;; /// do {; /// p[i] = 0.0;; /// } while (++i < n);; /// }; ///; /// and then it's possible for subsequent optimization to obscure the if; /// test in such a way that indvars can't find it.; ///; /// When indvars can't find the if test in loops like this, it creates a; /// max expression, which allows it to give the loop a canonical; /// induction variable:; ///; /// i = 0;; /// max = n < 1 ? 1 : n;; /// do {; /// p[i] = 0.0;; /// } while (++i != max);; ///; /// Canonical induction variables are necessary because the loop passes; /// are designed around them. The most obvious example of this is the; /// LoopInfo analysis, which doesn't remember trip count values. It; /// expects to be able to rediscover the trip count each time it is; /// needed, and it does this using a simple analysis that only succeeds if; /// the loop has a canonical induction variable.; ///; /// However, when it comes time to generate code, the maximum operation; /// can be quite costly, especially if it's inside of an outer loop.; ///; /// This function solves this problem by detecting this type of loop and; /// rewriting their conditions from ICMP_NE back to ICMP_SLT, and deleting; /// the instructions for the maximum computation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp:1612,detect,detecting,1612,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopStrengthReduce.cpp,1,['detect'],['detecting']
Safety,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:369,avoid,avoid,369,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,2,['avoid'],['avoid']
Safety,"/// Run some code with ""sufficient"" stack space. (Currently, at least 256K is; /// guaranteed). Produces a warning if we're low on stack space and allocates; /// more in that case. Use this in code that may recurse deeply (for example,; /// in template instantiation) to avoid stack overflow.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:271,avoid,avoid,271,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avoid'],['avoid']
Safety,"/// Run the analyses until a fixpoint is reached or enforced (timeout).; ///; /// The attributes registered with this Attributor can be used after as long; /// as the Attributor is not destroyed (it owns the attributes now).; ///; /// \Returns CHANGED if the IR was changed, otherwise UNCHANGED.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:62,timeout,timeout,62,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['timeout'],['timeout']
Safety,/// Run the safepoint verifier over a single function. Crashes on failure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/SafepointIRVerifier.h:12,safe,safepoint,12,interpreter/llvm-project/llvm/include/llvm/IR/SafepointIRVerifier.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/SafepointIRVerifier.h,1,['safe'],['safepoint']
Safety,"/// Runs the given callback under the session lock, passing in the associated; /// ResourceKey. This is the safe way to associate resources with trackers.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:108,safe,safe,108,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,2,['safe'],['safe']
Safety,"/// Runtime conditionally aborts, always need to support recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:26,abort,aborts,26,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,2,"['abort', 'recover']","['aborts', 'recovery']"
Safety,"/// SDLSearch: Search for Static Device Library; /// The search for SDL bitcode files is consistent with how static host; /// libraries are discovered. That is, the -l option triggers a search for; /// files in a set of directories called the LINKPATH. The host library search; /// procedure looks for a specific filename in the LINKPATH. The filename for; /// a host library is lib<libname>.a or lib<libname>.so. For SDLs, there is an; /// ordered-set of filenames that are searched. We call this ordered-set of; /// filenames as SEARCH-ORDER. Since an SDL can either be device-type specific,; /// architecture specific, or generic across all architectures, a naming; /// convention and search order is used where the file name embeds the; /// architecture name <arch-name> (nvptx or amdgcn) and the GPU device type; /// <device-name> such as sm_30 and gfx906. <device-name> is absent in case of; /// device-independent SDLs. To reduce congestion in host library directories,; /// the search first looks for files in the “libdevice” subdirectory. SDLs that; /// are bc files begin with the prefix “lib”.; ///; /// Machine-code SDLs can also be managed as an archive (*.a file). The; /// convention has been to use the prefix “lib”. To avoid confusion with host; /// archive libraries, we use prefix ""libbc-"" for the bitcode SDL archives.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp:1236,avoid,avoid,1236,interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/CommonArgs.cpp,1,['avoid'],['avoid']
Safety,/// Safe iteration space distance.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:4,Safe,Safe,4,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,2,['Safe'],['Safe']
Safety,/// Safely reinterpret the subclass data bits to a more useful form.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h:4,Safe,Safely,4,interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/BasicBlock.h,1,['Safe'],['Safely']
Safety,"/// Same as Data, but avoids using the get.active.lane.mask intrinsic to; /// calculate the mask and instead implements this with a; /// splat/stepvector/cmp.; /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the; /// active.lane.mask intrinsic when it is not natively supported?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,avoid,avoids,22,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['avoid'],['avoids']
Safety,"/// Same as IRBuilder::CreateInBoundsGEP, but additionally emits a check to; /// detect undefined behavior when the pointer overflow sanitizer is enabled.; /// \p SignedIndices indicates whether any of the GEP indices are signed.; /// \p IsSubtraction indicates whether the expression used to form the GEP; /// is a subtraction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:81,detect,detect,81,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['detect'],['detect']
Safety,"/// Same as above, except if ``IncompleteFormat`` is non-null, its value; /// will be set to true if any of the affected ranges were not formatted due to; /// a non-recoverable syntax error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:165,recover,recoverable,165,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['recover'],['recoverable']
Safety,"/// Saves strings in the provided stable storage and returns a StringRef with a; /// stable character pointer. Saving the same string yields the same StringRef.; ///; /// Compared to StringSaver, it does more work but avoids saving the same string; /// multiple times.; ///; /// Compared to StringPool, it performs fewer allocations but doesn't support; /// refcounting/deletion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/StringSaver.h:218,avoid,avoids,218,interpreter/llvm-project/llvm/include/llvm/Support/StringSaver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/StringSaver.h,1,['avoid'],['avoids']
Safety,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:285,safe,safe,285,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,1,['safe'],['safe']
Safety,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:288,safe,safe,288,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,1,['safe'],['safe']
Safety,/// ScheduleDAGMI has scheduled an instruction - tell HazardRec; /// about it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h:54,Hazard,HazardRec,54,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZMachineScheduler.h,1,['Hazard'],['HazardRec']
Safety,"/// Second variant of isProfitableToIfCvt. This one; /// checks for the case where two basic blocks from true and false path; /// of a if-then-else (diamond) are predicated on mutally exclusive; /// predicates, where the probability of the true path being taken is given; /// by Probability, and Confidence is a measure of our confidence that it; /// will be properly predicted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h:368,predict,predicted,368,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonInstrInfo.h,1,['predict'],['predicted']
Safety,"/// Second variant of isProfitableToIfCvt. This one; /// checks for the case where two basic blocks from true and false path; /// of a if-then-else (diamond) are predicated on mutually exclusive; /// predicates, where the probability of the true path being taken is given; /// by Probability, and Confidence is a measure of our confidence that it; /// will be properly predicted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h:369,predict,predicted,369,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetInstrInfo.h,1,['predict'],['predicted']
Safety,"/// Select the best successor for a block.; ///; /// This looks across all successors of a particular block and attempts to; /// select the ""best"" one to be the layout successor. It only considers direct; /// successors which also pass the block filter. It will attempt to avoid; /// breaking CFG structure, but cave and break such structures in the case of; /// very hot successor edges.; ///; /// \returns The best successor block found, or null if none are viable, along; /// with a boolean indicating if tail duplication is necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:273,avoid,avoid,273,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['avoid'],['avoid']
Safety,/// Set instruction number of this MachineInstr. Avoid using unless you're; /// deserializing this information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:49,Avoid,Avoid,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,1,['Avoid'],['Avoid']
Safety,/// Set safelen.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:8,safe,safelen,8,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,3,['safe'],['safelen']
Safety,"/// Set source location info. Try to avoid this, putting; /// it in the constructor is preferable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h:37,avoid,avoid,37,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAGNodes.h,1,['avoid'],['avoid']
Safety,/// Set that PLT should be avoid for RTLib calls.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h:27,avoid,avoid,27,interpreter/llvm-project/llvm/include/llvm/IR/Module.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Module.h,1,['avoid'],['avoid']
Safety,"/// Set the ""delayed"" diagnostic that will be emitted once; /// the current diagnostic completes.; ///; /// If a diagnostic is already in-flight but the front end must; /// report a problem (e.g., with an inconsistent file system; /// state), this routine sets a ""delayed"" diagnostic that will be; /// emitted after the current diagnostic completes. This should; /// only be used for fatal errors detected at inconvenient; /// times. If emitting a delayed diagnostic causes a second delayed; /// diagnostic to be introduced, that second delayed diagnostic; /// will be ignored.; ///; /// \param DiagID The ID of the diagnostic being delayed.; ///; /// \param Arg1 A string argument that will be provided to the; /// diagnostic. A copy of this string will be stored in the; /// DiagnosticsEngine object itself.; ///; /// \param Arg2 A string argument that will be provided to the; /// diagnostic. A copy of this string will be stored in the; /// DiagnosticsEngine object itself.; ///; /// \param Arg3 A string argument that will be provided to the; /// diagnostic. A copy of this string will be stored in the; /// DiagnosticsEngine object itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:397,detect,detected,397,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['detect'],['detected']
Safety,"/// Set the JITTargetMachineBuilder for this instance.; ///; /// If this method is not called, JITTargetMachineBuilder::detectHost will be; /// used to construct a default target machine builder for the host platform.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h:120,detect,detectHost,120,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/LLJIT.h,1,['detect'],['detectHost']
Safety,"/// Set the array size to \p N, which the current array must have enough; /// capacity for.; ///; /// This does not construct or destroy any elements in the vector.; ///; /// Clients can use this in conjunction with capacity() to write past the end; /// of the buffer when they know that more elements are available, and only; /// update the size later. This avoids the cost of value initializing elements; /// which will only be overwritten.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:359,avoid,avoids,359,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['avoid'],['avoids']
Safety,"/// Set the bits set in \p Other.; ///; /// This method does /not/ support setting already-set bits, see \ref set; /// for the rationale. For a safe set union operation, use \ref operator|=.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h:144,safe,safe,144,interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/CoalescingBitVector.h,1,['safe'],['safe']
Safety,/// Set the code completion token range for detecting replacement range later; /// on.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:44,detect,detecting,44,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['detect'],['detecting']
Safety,"/// Set the current size to request for ""safety"" (or 0, if safety; /// threads should not be used).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h:41,safe,safety,41,interpreter/llvm-project/clang/tools/libclang/CIndexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndexer.h,2,['safe'],['safety']
Safety,"/// Set the default strategy.; /// The strategy is a parameter used only by Minuit and Minuit2.; /// Possible values are:; /// - `strat = 0` : rough approximation of Hessian using the gradient. Avoid computing the full Hessian matrix; /// - `strat = 1` (default and recommended one) - Use Hessian approximation but compute full Hessian at the end of minimization if needed.; /// - `strat = 2` Perform several full Hessian computations during the minimization. Slower and not always working better than `strat=1`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h:194,Avoid,Avoid,194,math/mathcore/inc/Math/MinimizerOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/MinimizerOptions.h,1,['Avoid'],['Avoid']
Safety,"/// Set the flag read by has_error() to false. If the error flag is set at the; /// time when this raw_ostream's destructor is called, report_fatal_error is; /// called to report the error. Use clear_error() after handling the error to; /// avoid this behavior.; ///; /// ""Errors should never pass silently.; /// Unless explicitly silenced.""; /// - from The Zen of Python, by Tim Peters; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:241,avoid,avoid,241,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['avoid'],['avoid']
Safety,"/// Set the globally-visible declarations associated with the given; /// identifier.; ///; /// If the AST reader is currently in a state where the given declaration IDs; /// cannot safely be resolved, they are queued until it is safe to resolve; /// them.; ///; /// \param II an IdentifierInfo that refers to one or more globally-visible; /// declarations.; ///; /// \param DeclIDs the set of declaration IDs with the name @p II that are; /// visible at global scope.; ///; /// \param Decls if non-null, this vector will be populated with the set of; /// deserialized declarations. These declarations will not be pushed into; /// scope.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp:181,safe,safely,181,interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Serialization/ASTReader.cpp,2,['safe'],"['safe', 'safely']"
Safety,"/// Set the link order to be used when fixing up definitions in JITDylib.; /// This will replace the previous link order, and apply to any symbol; /// resolutions made for definitions in this JITDylib after the call to; /// setLinkOrder (even if the definition itself was added before the; /// call).; ///; /// If LinkAgainstThisJITDylibFirst is true (the default) then this JITDylib; /// will add itself to the beginning of the LinkOrder (Clients should not; /// put this JITDylib in the list in this case, to avoid redundant lookups).; ///; /// If LinkAgainstThisJITDylibFirst is false then the link order will be used; /// as-is. The primary motivation for this feature is to support deliberate; /// shadowing of symbols in this JITDylib by a facade JITDylib. For example,; /// the facade may resolve function names to stubs, and the stubs may compile; /// lazily by looking up symbols in this dylib. Adding the facade dylib; /// as the first in the link order (instead of this dylib) ensures that; /// definitions within this dylib resolve to the lazy-compiling stubs,; /// rather than immediately materializing the definitions in this dylib.; ///; /// It is illegal to call this method on a defunct JITDylib and the client; /// is responsible for ensuring that they do not do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h:511,avoid,avoid,511,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/Orc/Core.h,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"/// Set the type parameters of this category.; ///; /// This function is used by the AST importer, which must import the type; /// parameters after creating their DeclContext to avoid loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:178,avoid,avoid,178,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['avoid'],['avoid']
Safety,"/// Set the type parameters of this class.; ///; /// This function is used by the AST importer, which must import the type; /// parameters after creating their DeclContext to avoid loops.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h:175,avoid,avoid,175,interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclObjC.h,1,['avoid'],['avoid']
Safety,"/// Set the value of a particular slot.; ///; /// This method is thread-safe as long as concurrent calls access different slots (i.e. pass a different; /// argument) and no thread accesses slot `i` via the arrow operator, so mixing usage of SetAtSlot; /// with usage of the arrow operator can be dangerous.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx:72,safe,safe,72,core/thread/inc/ROOT/TThreadedObject.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/TThreadedObject.hxx,1,['safe'],['safe']
Safety,/// Set this flag to true if RealPHI and ImagPHI were reached during reduction; /// detection.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp:84,detect,detection,84,interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ComplexDeinterleavingPass.cpp,1,['detect'],['detection']
Safety,/// Set to true if the outliner should run on all functions in the module; /// considered safe for outlining.; /// Set to true by default for compatibility with llc's -run-pass option.; /// Set when the pass is constructed in TargetPassConfig.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:90,safe,safe,90,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,1,['safe'],['safe']
Safety,"/// Set true while we are in the process of passing deserialized; /// ""interesting"" decls to consumer inside FinishedDeserializing().; /// This is used as a guard to avoid recursively repeating the process of; /// passing decls to consumer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:166,avoid,avoid,166,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['avoid'],['avoid']
Safety,/// Set value of DebugInstrNumberingCount field. Avoid using this unless; /// you're deserializing this data.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:49,Avoid,Avoid,49,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,1,['Avoid'],['Avoid']
Safety,/// Sets the object manager that MCJIT should use to avoid compilation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:53,avoid,avoid,53,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,1,['avoid'],['avoid']
Safety,"/// Sets the timeout for the entire request, in milliseconds. A zero or; /// negative value means the request never times out.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h:13,timeout,timeout,13,interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Debuginfod/HTTPClient.h,1,['timeout'],['timeout']
Safety,"/// Sets the user interrupt flag (UIF). Its effect takes place immediately; a; /// user interrupt may be delivered on the instruction boundary following; /// STUI. Can be executed only if CR4.UINT = 1, the logical processor is in; /// 64-bit mode, and software is not executing inside an enclave; otherwise,; /// each causes an invalid-opcode exception. Causes a transactional abort if; /// executed inside a transactional region; the abort loads EAX as it would; /// had it been due to an execution of STI.; ///; /// \headerfile <x86gprintrin.h>; ///; /// This intrinsic corresponds to the <c> STUI </c> instruction.; ///; /// \code{.operation}; /// UIF := 1; /// \endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h:377,abort,abort,377,interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/uintrintrin.h,2,['abort'],['abort']
Safety,/// Should be called for expressions in non-statement position to avoid; /// wrapping into expression statement.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp:66,avoid,avoid,66,interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/BuildTree.cpp,1,['avoid'],['avoid']
Safety,"/// ShouldPreferAnother - This callback may be invoked if getHazardType; /// returns NoHazard. If, even though there is no hazard, it would be better to; /// schedule another available instruction, this callback should return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:123,hazard,hazard,123,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,1,['hazard'],['hazard']
Safety,"/// Similar to ExecuteAndWait, but returns immediately.; /// @returns The \see ProcessInfo of the newly launched process.; /// \note On Microsoft Windows systems, users will need to either call; /// \see Wait until the process finished execution or win32 CloseHandle() API; /// on ProcessInfo.ProcessHandle to avoid memory leaks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:310,avoid,avoid,310,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,1,['avoid'],['avoid']
Safety,"/// Similar to the AnalyticalGradientCalculator, the ExternalInternalGradientCalculator; /// supplies Minuit with an externally calculated gradient. The main difference is that; /// ExternalInternalGradientCalculator expects that the external gradient calculator does; /// things in Minuit2-internal parameter space, which means many int2ext and ext2int; /// transformation steps are not necessary. This avoids loss of precision in some cases,; /// where trigonometrically transforming parameters back and forth can lose a few bits of; /// floating point precision on every pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/ExternalInternalGradientCalculator.h:404,avoid,avoids,404,math/minuit2/inc/Minuit2/ExternalInternalGradientCalculator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit2/inc/Minuit2/ExternalInternalGradientCalculator.h,1,['avoid'],['avoids']
Safety,/// Simple and conservative implementation of LoopSafetyInfo that can give; /// false-positive answers to its queries in order to avoid complicated; /// analysis.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:130,avoid,avoid,130,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,1,['avoid'],['avoid']
Safety,/// Simple check if we can CSE (we have the CSEInfo) or if this Opcode is; /// safe to CSE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h:79,safe,safe,79,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEMIRBuilder.h,1,['safe'],['safe']
Safety,/// Simple wrapper for toolchain detector with costly initialization. This; /// delays the creation of the actual detector until its first usage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h:33,detect,detector,33,interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/LazyDetector.h,2,['detect'],['detector']
Safety,/// Simplifies the given expression tree; /// by getting rid of algebraically redundant operations.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h:78,redund,redundant,78,interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h,1,['redund'],['redundant']
Safety,"/// Simplify a switch instruction by removing cases which can never fire. If the; /// uselessness of a case could be determined locally then constant propagation; /// would already have figured it out. Instead, walk the predecessors and; /// statically evaluate cases based on information available on that edge. Cases; /// that cannot fire no matter what the incoming edge can safely be removed. If; /// a case fires on every incoming edge then the entire switch can be removed; /// and replaced with a branch to the case destination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp:378,safe,safely,378,interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/CorrelatedValuePropagation.cpp,1,['safe'],['safely']
Safety,"/// Simplify the waitcnt, in the sense of removing redundant counts, and return; /// whether a waitcnt instruction is needed at all.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp:51,redund,redundant,51,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInsertWaitcnts.cpp,1,['redund'],['redundant']
Safety,"/// Since TFormula does very surprising things,; /// RooFit needs to do safety checks.; /// ```; /// TFormula form(""form"", ""x+y"");; /// form.Eval(3.);; /// ```; /// is, for example, legal, and silently uses an undefined; /// value for y. RooFit needs to detect this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFormula.cxx:72,safe,safety,72,roofit/roofitcore/test/testRooFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/test/testRooFormula.cxx,2,"['detect', 'safe']","['detect', 'safety']"
Safety,"/// Sink a top-level transpose inside matmuls and adds.; /// This creates and erases instructions as needed, and returns the newly; /// created instruction while updating the iterator to avoid invalidation. If; /// this returns nullptr, no new instruction was created.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp:187,avoid,avoid,187,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LowerMatrixIntrinsics.cpp,1,['avoid'],['avoid']
Safety,/// SinkInstruction - Determine whether it is safe to sink the specified machine; /// instruction out of its current block into a successor.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp:46,safe,safe,46,interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineSink.cpp,2,['safe'],['safe']
Safety,/// Size of the UnsafeStack Frame,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:16,Unsafe,UnsafeStack,16,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['Unsafe'],['UnsafeStack']
Safety,"/// Skip an InlineInfo object in the specified data at the specified offset.; ///; /// Used during the InlineInfo::lookup() call to quickly skip child InlineInfo; /// objects where the addres ranges isn't contained in the InlineInfo object; /// or its children. This avoids allocations by not appending child InlineInfo; /// objects to the InlineInfo::Children array.; ///; /// \param Data The binary stream to read the data from.; ///; /// \param Offset The byte offset within \a Data.; ///; /// \param SkippedRanges If true, address ranges have already been skipped.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp:267,avoid,avoids,267,interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DebugInfo/GSYM/InlineInfo.cpp,1,['avoid'],['avoids']
Safety,/// Skip the current line table and go to the following line table (if; /// present) immediately.; ///; /// \param RecoverableErrorHandler - report any recoverable prologue; /// parsing issues via this handler.; /// \param UnrecoverableErrorHandler - report any unrecoverable prologue; /// parsing issues via this handler.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h:115,Recover,RecoverableErrorHandler,115,interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/DWARF/DWARFDebugLine.h,2,"['Recover', 'recover']","['RecoverableErrorHandler', 'recoverable']"
Safety,"/// Skip to the end of the current statement, for error recovery.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h:56,recover,recovery,56,interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCParser/MCAsmParser.h,1,['recover'],['recovery']
Safety,"/// Skips all children of the current node and traverses to next node; ///; /// Note: This function takes care of incrementing the iterator. If you; /// always increment and call this function, you risk walking off the end.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h:198,risk,risk,198,interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DepthFirstIterator.h,1,['risk'],['risk']
Safety,"/// Slice \p Inc according to the information contained within this slice.; /// This is cached, so if called multiple times for the same \p BB & \p Inc; /// pair, it returns the same Sliced value as well.; ///; /// Note this *intentionally* does not return the same value for, say,; /// [%bb.0, %0] & [%bb.1, %0] as:; /// - It could cause issues with dominance (e.g. if bb.1 is seen first, then; /// the value in bb.1 may not be reachable from bb.0 if it's its; /// predecessor.); /// - We also want to make our extract instructions as local as possible so; /// the DAG has better chances of folding them out. Duplicating them like; /// that is beneficial in that regard.; ///; /// This is both a minor optimization to avoid creating duplicate; /// instructions, but also a requirement for correctness. It is not forbidden; /// for a PHI node to have the same [BB, Val] pair multiple times. If we; /// returned a new value each time, those previously identical pairs would all; /// have different incoming values (from the same block) and it'd cause a ""PHI; /// node has multiple entries for the same basic block with different incoming; /// values!"" verifier error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp:719,avoid,avoid,719,interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/AMDGPUCodeGenPrepare.cpp,1,['avoid'],['avoid']
Safety,"/// Soft abort function that interrupts macro execution but doesn't kill ROOT",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooErrorHandler.h:9,abort,abort,9,roofit/roofitcore/inc/RooErrorHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooErrorHandler.h,1,['abort'],['abort']
Safety,"/// Some binary operators require special handling to avoid poison and; /// undefined behavior. If a constant vector has undef elements, replace those; /// undefs with identity constants if possible because those are always safe; /// to execute. If no identity constant exists, replace undef with some other; /// safe constant.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h:54,avoid,avoid,54,interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/InstCombine/InstCombiner.h,3,"['avoid', 'safe']","['avoid', 'safe']"
Safety,/// Some instructions are used with both floating point and integer operands.; /// We assign InstType to such instructions as it helps us to avoid cross bank; /// copies. InstType deppends on context.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h:141,avoid,avoid,141,interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsRegisterBankInfo.h,1,['avoid'],['avoid']
Safety,"/// Some opcodes may create immediate undefined behavior when used with some; /// values (integer division-by-zero for example). Therefore, these operations; /// are not generally safe to move around or change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:180,safe,safe,180,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['safe'],['safe']
Safety,"/// Special case '[super init];' and '[self init];'; ///; /// Even though calling '[super init]' without assigning the result to self; /// and checking if the parent returns 'nil' is a bad pattern, it is common.; /// Additionally, our Self Init checker already warns about it. To avoid; /// overwhelming the user with messages from both checkers, we model the case; /// of '[super init]' in cases when it is not consumed by another expression; /// as if the call preserves the value of 'self'; essentially, assuming it can; /// never fail and return 'nil'.; /// Note, we don't want to just stop tracking the value since we want the; /// RetainCount checker to report leaks and use-after-free if SelfInit checker; /// is turned off.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h:280,avoid,avoid,280,interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/RetainSummaryManager.h,1,['avoid'],['avoid']
Safety,/// Special case of EmitSLEB128Value that avoids the client having to; /// pass in a MCExpr for constant integers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:42,avoid,avoids,42,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['avoid'],['avoids']
Safety,/// Special case of EmitULEB128Value that avoids the client having to; /// pass in a MCExpr for constant integers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:42,avoid,avoids,42,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['avoid'],['avoids']
Safety,/// Special case of EmitValue that avoids the client having to pass in; /// a MCExpr for MCSymbols.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:35,avoid,avoids,35,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['avoid'],['avoids']
Safety,"/// Special case of EmitValue that avoids the client having to pass; /// in a MCExpr for constant integers & prints in Hex format for certain; /// modes, pads the field with leading zeros to Size width",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:35,avoid,avoids,35,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['avoid'],['avoids']
Safety,/// Special case of EmitValue that avoids the client having to pass; /// in a MCExpr for constant integers & prints in Hex format for certain; /// modes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:35,avoid,avoids,35,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['avoid'],['avoids']
Safety,/// Special case of EmitValue that avoids the client having; /// to pass in a MCExpr for constant integers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:35,avoid,avoids,35,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['avoid'],['avoids']
Safety,/// Special case of eliminateFrameIndex. Returns true if the SGPR was spilled to; /// a VGPR and the stack slot can be safely eliminated when all other users are; /// handled.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp:119,safe,safely,119,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIRegisterInfo.cpp,1,['safe'],['safely']
Safety,/// Specialize FoldingSetTrait for SDVTListNode; /// to avoid computing temp FoldingSetNodeID and hash value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:56,avoid,avoid,56,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['avoid'],['avoid']
Safety,/// Specify if the library is application extension safe (or not).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h:52,safe,safe,52,interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TextAPI/InterfaceFile.h,1,['safe'],['safe']
Safety,/// Specify under what conditions this check can be recovered,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:52,recover,recovered,52,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['recover'],['recovered']
Safety,"/// Specify whether hidden declarations are visible, e.g.,; /// for recovery reasons.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h:68,recover,recovery,68,interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Lookup.h,1,['recover'],['recovery']
Safety,"/// Speculate a conditional basic block flattening the CFG.; ///; /// Note that this is a very risky transform currently. Speculating; /// instructions like this is most often not desirable. Instead, there is an MI; /// pass which can do it with full awareness of the resource constraints.; /// However, some cases are ""obvious"" and we should do directly. An example of; /// this is speculating a single, reasonably cheap instruction.; ///; /// There is only one distinct advantage to flattening the CFG at the IR level:; /// it makes very common but simplistic optimizations such as are common in; /// instcombine and the DAG combiner more powerful by removing CFG edges and; /// modeling their effects with easier to reason about SSA value graphs.; ///; ///; /// An illustration of this transform is turning this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// br i1 %cmp, label %EndBB, label %ThenBB; /// ThenBB:; /// %sub = sub %x, %y; /// br label BB2; /// EndBB:; /// %phi = phi [ %sub, %ThenBB ], [ 0, %EndBB ]; /// ...; /// \endcode; ///; /// Into this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// %sub = sub %x, %y; /// %cond = select i1 %cmp, 0, %sub; /// ...; /// \endcode; ///; /// \returns true if the conditional block is removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:95,risk,risky,95,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['risk'],['risky']
Safety,"/// Splits block B at the given index which must be greater than zero.; /// If SplitIndex == B.getSize() then this function is a no-op and returns B.; /// If SplitIndex < B.getSize() then this function returns a new block; /// covering the range [ 0, SplitIndex ), and B is modified to cover the range; /// [ SplitIndex, B.size() ).; ///; /// The optional Cache parameter can be used to speed up repeated calls to; /// splitBlock for a single block. If the value is None the cache will be; /// treated as uninitialized and splitBlock will populate it. Otherwise it; /// is assumed to contain the list of Symbols pointing at B, sorted in; /// descending order of offset.; ///; /// Notes:; ///; /// 1. splitBlock must be used with care. Splitting a block may cause; /// incoming edges to become invalid if the edge target subexpression; /// points outside the bounds of the newly split target block (E.g. an; /// edge 'S + 10 : Pointer64' where S points to a newly split block; /// whose size is less than 10). No attempt is made to detect invalidation; /// of incoming edges, as in general this requires context that the; /// LinkGraph does not have. Clients are responsible for ensuring that; /// splitBlock is not used in a way that invalidates edges.; ///; /// 2. The newly introduced block will have a new ordinal which will be; /// higher than any other ordinals in the section. Clients are responsible; /// for re-assigning block ordinals to restore a compatible order if; /// needed.; ///; /// 3. The cache is not automatically updated if new symbols are introduced; /// between calls to splitBlock. Any newly introduced symbols may be; /// added to the cache manually (descending offset order must be; /// preserved), or the cache can be set to None and rebuilt by; /// splitBlock on the next call.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:1031,detect,detect,1031,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['detect'],['detect']
Safety,/// Splits the chain into subchains where it's safe to hoist loads up to the; /// beginning of the sub-chain and it's safe to sink loads up to the end of; /// the sub-chain. Discards any length-1 subchains.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:47,safe,safe,47,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,2,['safe'],['safe']
Safety,"/// Start the event loop with a different mechanism depending on IMT/no IMT, data source/no data source.; /// Also perform a few setup and clean-up operations (jit actions if necessary, clear booked actions after the loop...).; /// The jitting phase is skipped if the `jit` parameter is `false` (unsafe, use with care).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx:296,unsafe,unsafe,296,tree/dataframe/src/RLoopManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/src/RLoopManager.cxx,1,['unsafe'],['unsafe']
Safety,/// Starting from \p Root find a top-down traversal order of the dominator; /// tree to visit all basic blocks containing the elements of \p Spills.; /// Redundant spills will be found and put into \p SpillsToRm at the same; /// time. \p SpillBBToSpill will be populated as part of the process and; /// maps a basic block to the first store occurring in the basic block.; /// \post SpillsToRm.union(Spills\@post) == Spills\@pre,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:154,Redund,Redundant,154,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['Redund'],['Redundant']
Safety,/// State of the stream error flags.; /// Sometimes it is not known to the checker what error flags are set.; /// This is indicated by setting more than one flag to true.; /// This is an optimization to avoid state splits.; /// A stream can either be in FEOF or FERROR but not both at the same time.; /// Multiple flags are set to handle the corresponding states together.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp:203,avoid,avoid,203,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/StreamChecker.cpp,1,['avoid'],['avoid']
Safety,"/// State used by the ""visit"" operation to avoid malloc traffic in; /// calls to visit().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h:43,avoid,avoid,43,interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ModuleManager.h,1,['avoid'],['avoid']
Safety,"/// Status variable indicating if this diagnostic is still active.; ///; // NOTE: This field is redundant with DiagObj (IsActive iff (DiagObj == 0)),; // but LLVM is not currently smart enough to eliminate the null check that; // Emit() would end up with if we used that as our status variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:96,redund,redundant,96,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['redund'],['redundant']
Safety,"/// Stepping through CacheLineStep<T> values in a vector<T> brings you to a new cache line.; /// Useful to avoid false sharing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx:107,avoid,avoid,107,tree/dataframe/inc/ROOT/RDF/Utils.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/Utils.hxx,1,['avoid'],['avoid']
Safety,/// Storage for the SmallVector elements. This is specialized for the N=0 case; /// to avoid allocating unnecessary storage.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:87,avoid,avoid,87,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['avoid'],['avoid']
Safety,"/// Storage for the SmallVector elements. This is specialized for the N=0 case; /// to avoid allocating unnecessary storage.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx:87,avoid,avoid,87,math/vecops/inc/ROOT/RVec.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/vecops/inc/ROOT/RVec.hxx,1,['avoid'],['avoid']
Safety,"/// Store instructions that are not fully formed in TemporaryInsts.; /// Also because CSE insertion happens lazily, we can remove insts from this; /// list and avoid inserting and then removing from the CSEMap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h:160,avoid,avoid,160,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/CSEInfo.h,1,['avoid'],['avoid']
Safety,/// Store the top level decls in the set to be processed later on.; /// (Doing this pre-processing avoids deserialization of data from PCH.),MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp:99,avoid,avoids,99,interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Frontend/AnalysisConsumer.cpp,1,['avoid'],['avoids']
Safety,"/// StringRef - Represent a constant reference to a string, i.e. a character; /// array and a length, which need not be null terminated.; ///; /// This class does not own the string data, it is expected to be used in; /// situations where the character data resides in some other buffer, whose; /// lifetime extends past that of the StringRef. For this reason, it is not in; /// general safe to store a StringRef.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h:387,safe,safe,387,interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringRef.h,1,['safe'],['safe']
Safety,"/// Summary string representation. This StringRef points to BC module; /// string table and is valid until module data is stored in memory.; /// This is guaranteed to happen until runThinLTOBackend function is; /// called, so it is safe to use this field during thin link. This field; /// is only valid if summary index was loaded from BC file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h:232,safe,safe,232,interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ModuleSummaryIndex.h,1,['safe'],['safe']
Safety,"/// Symbol records should point to complete types, but type records should; /// always point to incomplete types to avoid cycles in the type graph. Only; /// use this entry point when generating symbol records. The complete and; /// incomplete type indices only differ for record types. All other types use; /// the same index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h:116,avoid,avoid,116,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/CodeViewDebug.h,1,['avoid'],['avoid']
Safety,"/// TODO(jblomer): Not only the columns, but actually all the different objects of the descriptor would need; /// their own maps to avoid descriptor ID clashes. The need for the distinct column map was triggered by adding; /// support for multi-column representations. A follow-up patch should either fix the friend page source properly; /// or remove it in favor of the RNTupleProcessor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx:132,avoid,avoid,132,tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageSourceFriends.hxx,1,['avoid'],['avoid']
Safety,/// TODO: A large part of this logic is duplicated in InstCombine's; /// foldICmpBinOp(). We should be able to share that and avoid the code; /// duplication.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp:126,avoid,avoid,126,interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/InstructionSimplify.cpp,1,['avoid'],['avoid']
Safety,/// TODO: Figure out a way to avoid adding entry in; /// ICVReplacementValuesMap,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:30,avoid,avoid,30,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['avoid'],['avoid']
Safety,"/// TODO: Might pack better if we changed this to a Struct of Arrays, since; /// MachineOperand is width 32, making this struct width 33. We could also; /// potentially avoid storing the whole MachineOperand (sizeof=32), instead; /// choosing to store just the contents portion (sizeof=8) and a Kind enum,; /// since we already know it is some type of immediate value.; /// Stores a single debug operand, which can either be a MachineOperand for; /// directly storing immediate values, or a ValueIDNum representing some value; /// computed at some point in the program. IsConst is used as a discriminator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:169,avoid,avoid,169,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['avoid'],['avoid']
Safety,/// Take ownership of the stored error.; /// After calling this the Expected<T> is in an indeterminate state that can; /// only be safely destructed. No further calls (beside the destructor) should; /// be made on the Expected<T> value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h:131,safe,safely,131,interpreter/llvm-project/llvm/include/llvm/Support/Error.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Error.h,1,['safe'],['safely']
Safety,"/// Takes the read lock for the descriptor. Multiple threads can take the lock concurrently.; /// The underlying `std::shared_mutex`, however, is neither read nor write recursive:; /// within one thread, only one lock (shared or exclusive) must be acquired at the same time. This requires special; /// care in sections protected by `GetSharedDescriptorGuard()` and `GetExclDescriptorGuard()` especially to avoid; /// that the locks are acquired indirectly (e.g. by a call to `GetNEntries()`). As a general guideline, no other; /// method of the page source should be called (directly or indirectly) in a guarded section.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx:406,avoid,avoid,406,tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RPageStorage.hxx,1,['avoid'],['avoid']
Safety,"/// Target-specific DAG combining for ISD::SUB.; /// Target-independent combining lowers SELECT_CC nodes of the form; /// select_cc setg[ge] X, 0, X, -X; /// select_cc setgt X, -1, X, -X; /// select_cc setl[te] X, 0, -X, X; /// select_cc setlt X, 1, -X, X; /// which represent Integer ABS into:; /// Y = sra (X, size(X)-1); sub (xor (X, Y), Y); /// ARM instruction selection detects the latter and matches it to; /// ARM::ABS or ARM::t2ABS machine node.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:375,detect,detects,375,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,1,['detect'],['detects']
Safety,/// Tell the TypeLocBuilder that the type it is storing has been; /// modified in some safe way that doesn't affect type-location information.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.h:87,safe,safe,87,interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TypeLocBuilder.h,1,['safe'],['safe']
Safety,/// Tells the code generator that select is more expensive than a branch if; /// the branch is usually predicted right.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:103,predict,predicted,103,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['predict'],['predicted']
Safety,"/// Test if the given class represents instructions which are always safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:69,safe,safe,69,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,2,['safe'],['safe']
Safety,/// Test if the given class represents instructions which are always safe; /// to mark with the nounwind attribute.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:69,safe,safe,69,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,2,['safe'],['safe']
Safety,"/// Test if the given class represents instructions which are never safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:68,safe,safe,68,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,2,['safe'],['safe']
Safety,"/// Test whether an argument type which is to be passed indirectly (on the; /// stack) would have the equivalent layout if it was expanded into separate; /// arguments. If so, we prefer to do the latter to avoid inhibiting; /// optimizations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp:206,avoid,avoid,206,interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/X86.cpp,1,['avoid'],['avoid']
Safety,"/// Test whether entry to the loop is protected by a conditional between LHS; /// and RHS. This is used to help avoid max expressions in loop trip; /// counts, and to eliminate casts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:112,avoid,avoid,112,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['avoid'],['avoid']
Safety,/// The (vector) operation should be implemented by splitting it into; /// sub-vectors where the operation is legal. For example a <8 x s64> add; /// might be implemented as 4 separate <2 x s64> adds. There can be a leftover; /// if there are not enough elements for last sub-vector e.g. <7 x s64> add; /// will be implemented as 3 separate <2 x s64> adds and one s64 add. Leftover; /// types can be avoided by doing MoreElements first.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h:400,avoid,avoided,400,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/LegalizerInfo.h,1,['avoid'],['avoided']
Safety,/// The Error encountered during materialization. We use an Optional here to; /// avoid needing to manage an unconsumed success value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp:82,avoid,avoid,82,interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Linker/IRMover.cpp,1,['avoid'],['avoid']
Safety,"/// The I/O thread calls RPageSource::LoadClusters() asynchronously. The thread is mostly waiting for the; /// data to arrive (blocked by the kernel) and therefore can safely run in addition to the application; /// main threads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx:168,safe,safely,168,tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RClusterPool.hxx,1,['safe'],['safely']
Safety,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1181,safe,safe,1181,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,1,['safe'],['safe']
Safety,"/// The ObjC runtime may provide entrypoints that are likely to be faster; /// than an ordinary message send of the appropriate selector.; ///; /// The entrypoints are guaranteed to be equivalent to just sending the; /// corresponding message. If the entrypoint is implemented naively as just a; /// message send, using it is a trade-off: it sacrifices a few cycles of; /// overhead to save a small amount of code. However, it's possible for; /// runtimes to detect and special-case classes that use ""standard""; /// behavior; if that's dynamically a large proportion of all objects, using; /// the entrypoint will also be faster than using a message send.; ///; /// If the runtime does support a required entrypoint, then this method will; /// generate a call and return the resulting value. Otherwise it will return; /// std::nullopt and the caller can generate a msgSend instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:459,detect,detect,459,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['detect'],['detect']
Safety,/// The OpIdx-th cell contains the index in NewVRegs where the VRegs of the; /// OpIdx-th operand starts. -1 means we do not have such mapping yet.; /// Note: We use a SmallVector to avoid heap allocation for most cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:183,avoid,avoid,183,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['avoid'],['avoid']
Safety,"/// The SafeStack pass splits the stack of each function into the safe; /// stack, which is only accessed through memory safe dereferences (as; /// determined statically), and the unsafe stack, which contains all; /// local variables that are accessed in ways that we can't prove to; /// be safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:8,Safe,SafeStack,8,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,5,"['Safe', 'safe', 'unsafe']","['SafeStack', 'safe', 'unsafe']"
Safety,"/// The XCore ABI includes a type information section that communicates symbol; /// type information to the linker. The linker uses this information to verify; /// safety/correctness of things such as array bound and pointers et al.; /// The ABI only requires C (and XC) language modules to emit TypeStrings.; /// This type information (TypeString) is emitted into meta data for all global; /// symbols: definitions, declarations, functions & variables.; ///; /// The TypeString carries type, qualifier, name, size & value details.; /// Please see 'Tools Development Guide' section 2.16.2 for format details:; /// https://www.xmos.com/download/public/Tools-Development-Guide%28X9114A%29.pdf; /// The output is tested by test/CodeGen/xcore-stringtype.c.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:164,safe,safety,164,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,1,['safe'],['safety']
Safety,"/// The __builtin_clz* and __builtin_ctz* built-in; /// functions are specified to have undefined results for zero inputs, but; /// on targets that support these operations in a way that provides; /// well-defined results for zero without loss of performance, it is a good; /// idea to avoid optimizing based on that undef behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h:286,avoid,avoid,286,interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetInfo.h,1,['avoid'],['avoid']
Safety,"/// The __kmpc_target_deinit call in this kernel, if any. If we find more than; /// one we abort as the kernel is malformed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:91,abort,abort,91,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['abort'],['abort']
Safety,"/// The __kmpc_target_init call in this kernel, if any. If we find more than; /// one we abort as the kernel is malformed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp:89,abort,abort,89,interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/OpenMPOpt.cpp,1,['abort'],['abort']
Safety,"/// The await_suspend call performed by co_await is essentially asynchronous; /// to the execution of the coroutine. Inlining it normally into an unsplit; /// coroutine can cause miscompilation because the coroutine CFG misrepresents; /// the true control flow of the program: things that happen in the; /// await_suspend are not guaranteed to happen prior to the resumption of the; /// coroutine, and things that happen after the resumption of the coroutine; /// (including its exit and the potential deallocation of the coroutine frame); /// are not guaranteed to happen only after the end of await_suspend.; ///; /// See https://github.com/llvm/llvm-project/issues/56301 and; /// https://reviews.llvm.org/D157070 for the example and the full discussion.; ///; /// The short-term solution to this problem is to mark the call as uninlinable.; /// But we don't want to do this if the call is known to be trivial, which is; /// very common.; ///; /// The long-term solution may introduce patterns like:; ///; /// call @llvm.coro.await_suspend(ptr %awaiter, ptr %handle,; /// ptr @awaitSuspendFn); ///; /// Then it is much easier to perform the safety analysis in the middle end.; /// If it is safe to inline the call to awaitSuspend, we can replace it in the; /// CoroEarly pass. Otherwise we could replace it in the CoroSplit pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp:1143,safe,safety,1143,interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaCoroutine.cpp,2,['safe'],"['safe', 'safety']"
Safety,"/// The class detects jumps which bypass local variables declaration:; /// goto L;; /// int a;; /// L:; ///; /// This is simplified version of JumpScopeChecker. Primary differences:; /// * Detects only jumps into the scope local variables.; /// * Does not detect jumps out of the scope of local variables.; /// * Not limited to variables with initializers, JumpScopeChecker is limited.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/VarBypassDetector.h:14,detect,detects,14,interpreter/llvm-project/clang/lib/CodeGen/VarBypassDetector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/VarBypassDetector.h,3,"['Detect', 'detect']","['Detects', 'detect', 'detects']"
Safety,"/// The container type for each thread's partial result in an action helper; // We have to avoid to instantiate std::vector<bool> as that makes it impossible to return a reference to one of; // the thread-local results. In addition, a common definition for the type of the container makes it easy to swap; // the type of the underlying container if e.g. we see problems with false sharing of the thread-local results..",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx:91,avoid,avoid,91,tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/ActionHelpers.hxx,1,['avoid'],['avoid']
Safety,"/// The control block was read successfully. Aside from failures,; /// the AST file is safe to read into the current context.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h:87,safe,safe,87,interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Serialization/ASTReader.h,1,['safe'],['safe']
Safety,/// The core module pass which does a post-order walk of the SCCs and; /// runs a CGSCC pass over each one.; ///; /// Designed to allow composition of a CGSCCPass(Manager) and; /// a ModulePassManager. Note that this pass must be run with a module analysis; /// manager as it uses the LazyCallGraph analysis. It will also run the; /// \c CGSCCAnalysisManagerModuleProxy analysis prior to running the CGSCC; /// pass over the module to enable a \c FunctionAnalysisManager to be used; /// within this run safely.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:503,safe,safely,503,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['safe'],['safely']
Safety,/// The current initialization chain length. Tracked to avoid stack overflows.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:56,avoid,avoid,56,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['avoid'],['avoid']
Safety,"/// The default error handler function. It prints the message on stderr and; /// if abort is set it aborts the application. Replaces the minimal error handler; /// of TError.h as part of the gROOT construction. TError's minimal handler is put; /// back in place during the gROOT destruction.; /// @note `abort()` is only called if `abort_bool` is `true` and `level < gErrorIgnoreLevel`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx:84,abort,abort,84,core/base/src/TErrorDefaultHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TErrorDefaultHandler.cxx,3,['abort'],"['abort', 'aborts']"
Safety,"/// The default rule for __unsafe_unretained emits the RHS recursively,; /// stores into the unsafe variable, and propagates the result outward.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:93,unsafe,unsafe,93,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['unsafe'],['unsafe']
Safety,/// The depth of the context stack at the point when the most recent; /// error or warning was produced.; ///; /// This value is used to suppress printing of redundant context stacks; /// when there are multiple errors or warnings in the same instantiation.; // FIXME: Does this belong in Sema? It's tough to implement it anywhere else.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:158,redund,redundant,158,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['redund'],['redundant']
Safety,"/// The diagnostic state for the parent file. This is strictly redundant,; /// as looking up the DecomposedIncludedLoc for the FileID in the Files; /// map would give us this, but we cache it here for performance.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h:63,redund,redundant,63,interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/Diagnostic.h,1,['redund'],['redundant']
Safety,"/// The end index of this node's substring in the main string.; ///; /// Every leaf node must have its \p EndIdx incremented at the end of every; /// step in the construction algorithm. To avoid having to update O(N); /// nodes individually at the end of every step, the end index is stored; /// as a pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SuffixTreeNode.h:189,avoid,avoid,189,interpreter/llvm-project/llvm/include/llvm/Support/SuffixTreeNode.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SuffixTreeNode.h,2,['avoid'],['avoid']
Safety,"/// The entry block(s) of the cycle. The header is the only entry if; /// this is a loop. Is empty for the root ""cycle"", to avoid; /// unnecessary memory use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h:124,avoid,avoid,124,interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericCycleInfo.h,1,['avoid'],['avoid']
Safety,"/// The fixpoint analysis framework that orchestrates the attribute deduction.; ///; /// The Attributor provides a general abstract analysis framework (guided; /// fixpoint iteration) as well as helper functions for the deduction of; /// (LLVM-IR) attributes. However, also other code properties can be deduced,; /// propagated, and ultimately manifested through the Attributor framework. This; /// is particularly useful if these properties interact with attributes and a; /// co-scheduled deduction allows to improve the solution. Even if not, thus if; /// attributes/properties are completely isolated, they should use the; /// Attributor framework to reduce the number of fixpoint iteration frameworks; /// in the code base. Note that the Attributor design makes sure that isolated; /// attributes are not impacted, in any way, by others derived at the same time; /// if there is no cross-reasoning performed.; ///; /// The public facing interface of the Attributor is kept simple and basically; /// allows abstract attributes to one thing, query abstract attributes; /// in-flight. There are two reasons to do this:; /// a) The optimistic state of one abstract attribute can justify an; /// optimistic state of another, allowing to framework to end up with an; /// optimistic (=best possible) fixpoint instead of one based solely on; /// information in the IR.; /// b) This avoids reimplementing various kinds of lookups, e.g., to check; /// for existing IR attributes, in favor of a single lookups interface; /// provided by an abstract attribute subclass.; ///; /// NOTE: The mechanics of adding a new ""concrete"" abstract attribute are; /// described in the file comment.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h:1379,avoid,avoids,1379,interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/IPO/Attributor.h,1,['avoid'],['avoids']
Safety,"/// The following callbacks deal with tasks, which normally represent the; /// entire optimization and code generation pipeline for what will become a; /// single native object file. Each task has a unique identifier between 0 and; /// getMaxTasks()-1, which is supplied to the callback via the Task parameter.; /// A task represents the entire pipeline for ThinLTO and regular; /// (non-parallel) LTO, but a parallel code generation task will be split into; /// N tasks before code generation, where N is the parallelism level.; ///; /// LTO may decide to stop processing a task at any time, for example if the; /// module is empty or if a module hook (see below) returns false. For this; /// reason, the client should not expect to receive exactly getMaxTasks(); /// native object files.; /// A module hook may be used by a linker to perform actions during the LTO; /// pipeline. For example, a linker may use this function to implement; /// -save-temps. If this function returns false, any further processing for; /// that task is aborted.; ///; /// Module hooks must be thread safe with respect to the linker's internal; /// data structures. A module hook will never be called concurrently from; /// multiple threads with the same task ID, or the same module.; ///; /// Note that in out-of-process backend scenarios, none of the hooks will be; /// called for ThinLTO tasks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h:1034,abort,aborted,1034,interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/LTO/Config.h,2,"['abort', 'safe']","['aborted', 'safe']"
Safety,/// The function will remove redundant reinterprets casting in the presence; /// of the control flow,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp:29,redund,redundant,29,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64TargetTransformInfo.cpp,1,['redund'],['redundant']
Safety,"/// The goal of this function is to remove redundant calls to the SVE ptrue; /// intrinsic in each basic block within the given functions.; ///; /// SVE ptrues have two representations in LLVM IR:; /// - a logical representation -- an arbitrary-width scalable vector of i1s,; /// i.e. <vscale x N x i1>.; /// - a physical representation (svbool, <vscale x 16 x i1>) -- a 16-element; /// scalable vector of i1s, i.e. <vscale x 16 x i1>.; ///; /// The SVE ptrue intrinsic is used to create a logical representation of an SVE; /// predicate. Suppose that we have two SVE ptrue intrinsic calls: P1 and P2. If; /// P1 creates a logical SVE predicate that is at least as wide as the logical; /// SVE predicate created by P2, then all of the bits that are true in the; /// physical representation of P2 are necessarily also true in the physical; /// representation of P1. P1 'encompasses' P2, therefore, the intrinsic call to; /// P2 is redundant and can be replaced by an SVE reinterpret of P1 via; /// convert.{to,from}.svbool.; ///; /// Currently, this pass only coalesces calls to SVE ptrue intrinsics; /// if they match the following conditions:; ///; /// - the call to the intrinsic uses either the SV_ALL or SV_POW2 patterns.; /// SV_ALL indicates that all bits of the predicate vector are to be set to; /// true. SV_POW2 indicates that all bits of the predicate vector up to the; /// largest power-of-two are to be set to true.; /// - the result of the call to the intrinsic is not promoted to a wider; /// predicate. In this case, keeping the extra ptrue leads to better codegen; /// -- coalescing here would create an irreducible chain of SVE reinterprets; /// via convert.{to,from}.svbool.; ///; /// EXAMPLE:; ///; /// %1 = <vscale x 8 x i1> ptrue(i32 SV_ALL); /// ; Logical: <1, 1, 1, 1, 1, 1, 1, 1>; /// ; Physical: <1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0>; /// ...; ///; /// %2 = <vscale x 4 x i1> ptrue(i32 SV_ALL); /// ; Logical: <1, 1, 1, 1>; /// ; Physical: <1, 0, 0, 0, 1, 0, 0, 0,",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp:43,redund,redundant,43,interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/SVEIntrinsicOpts.cpp,2,['redund'],['redundant']
Safety,"/// The grammar doesn't allow a defining-type-specifier here, but we permit; /// one for error recovery purposes. Sema will reject.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h:95,recover,recovery,95,interpreter/llvm-project/clang/include/clang/Parse/Parser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Parse/Parser.h,1,['recover'],['recovery']
Safety,"/// The hash value for SDVTList is fixed, so cache it to avoid; /// hash calculation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h:57,avoid,avoid,57,interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SelectionDAG.h,1,['avoid'],['avoid']
Safety,"/// The instruction responsible for this alloca not having a known set; /// of slices.; ///; /// When an instruction (potentially) escapes the pointer to the alloca, we; /// store a pointer to that here and abort trying to form slices of the; /// alloca. This will be null if the alloca slices are analyzed successfully.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:207,abort,abort,207,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,1,['abort'],['abort']
Safety,/// The interface that lets the caller handle unsafe buffer usage analysis; /// results by overriding this class's handle... methods.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UnsafeBufferUsage.h:46,unsafe,unsafe,46,interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UnsafeBufferUsage.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Analysis/Analyses/UnsafeBufferUsage.h,1,['unsafe'],['unsafe']
Safety,/// The is the piece of the class that is implemented by subclasses. This; /// writes the \p Size bytes starting at; /// \p Ptr to the underlying stream.; ///; /// This function is guaranteed to only be called at a point at which it is; /// safe for the subclass to install a new buffer via SetBuffer.; ///; /// \param Ptr The start of the data to be written. For buffered streams this; /// is guaranteed to be the start of the buffer.; ///; /// \param Size The number of bytes to be written.; ///; /// \invariant { Size > 0 },MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h:241,safe,safe,241,interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_ostream.h,1,['safe'],['safe']
Safety,"/// The kind of location in use for a variable, where Mem is the stack home,; /// Val is an SSA value or const, and None means that there is not one single; /// kind (either because there are multiple or because there is none; it may; /// prove useful to split this into two values in the future).; ///; /// LocKind is a join-semilattice with the partial order:; /// None > Mem, Val; ///; /// i.e.; /// join(Mem, Mem) = Mem; /// join(Val, Val) = Val; /// join(Mem, Val) = None; /// join(None, Mem) = None; /// join(None, Val) = None; /// join(None, None) = None; ///; /// Note: the order is not `None > Val > Mem` because we're using DIAssignID; /// to name assignments and are not tracking the actual stored values.; /// Therefore currently there's no way to ensure that Mem values and Val; /// values are the same. This could be a future extension, though it's not; /// clear that many additional locations would be recovered that way in; /// practice as the likelihood of this sitation arising naturally seems; /// incredibly low.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp:918,recover,recovered,918,interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AssignmentTrackingAnalysis.cpp,1,['recover'],['recovered']
Safety,"/// The kind of message send this is, which is one of the; /// ReceiverKind values.; ///; /// We pad this out to a byte to avoid excessive masking and shifting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h:123,avoid,avoid,123,interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprObjC.h,1,['avoid'],['avoid']
Safety,/// The level of the last diagnostic emitted.; ///; /// The level of the last diagnostic emitted. Used to detect level changes; /// which change the amount of information displayed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DiagnosticRenderer.h:106,detect,detect,106,interpreter/llvm-project/clang/include/clang/Frontend/DiagnosticRenderer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/DiagnosticRenderer.h,1,['detect'],['detect']
Safety,"/// The location of the closing brace ('}') that completes; /// the lambda.; ///; /// The location of the brace is also available by looking up the; /// function call operator in the lambda class. However, it is; /// stored here to improve the performance of getSourceRange(), and; /// to avoid having to deserialize the function call operator from a; /// module file just to determine the source range.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h:289,avoid,avoid,289,interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ExprCXX.h,1,['avoid'],['avoid']
Safety,"/// The location of the weak bind info inside the binary is described by; /// LC_DYLD_INFO load command. Some C++ programs require dyld to unique symbols; /// so that all images in the process use the same copy of some code/data. This; /// step is done after binding. The content of the weak_bind info is an opcode; /// stream like the bind_info. But it is sorted alphabetically by symbol name.; /// This enable dyld to walk all images with weak binding information in order; /// and look for collisions. If there are no collisions, dyld does no updating.; /// That means that some fixups are also encoded in the bind_info. For; /// instance, all calls to ""operator new"" are first bound to libstdc++.dylib; /// using the information in bind_info. Then if some image overrides operator; /// new that is detected when the weak_bind information is processed and the; /// call to operator new is then rebound.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h:802,detect,detected,802,interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ObjCopy/MachO/MachOObject.h,1,['detect'],['detected']
Safety,"/// The locations where we stopped because the engine aborted analysis,; /// usually because it could not reason about something.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h:54,abort,aborted,54,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/CoreEngine.h,1,['abort'],['aborted']
Safety,/// The magic bytes should be set to GSYM_MAGIC. This helps detect if a file; /// is a GSYM file by scanning the first 4 bytes of a file or section.; /// This value might appear byte swapped,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h:60,detect,detect,60,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/Header.h,1,['detect'],['detect']
Safety,/// The main string table for the remarks.; /// Note: all remarks should use the strings from this string table to avoid; /// dangling references.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkLinker.h:115,avoid,avoid,115,interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkLinker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Remarks/RemarkLinker.h,1,['avoid'],['avoid']
Safety,"/// The merger will abort merging as soon as an error is encountered",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx:20,abort,abort,20,tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleMerger.hxx,1,['abort'],['abort']
Safety,"/// The model bases invalidation solely on being in the preserved set.; //; // FIXME: We should actually use two different concepts for analysis results; // rather than two different models, and avoid the indirect function call for; // ones that use the trivial behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h:195,avoid,avoid,195,interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManagerInternal.h,1,['avoid'],['avoid']
Safety,"/// The name of the handler function to be called when -ftrapv is; /// specified.; ///; /// If none is specified, abort (GCC-compatible behaviour).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h:114,abort,abort,114,interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/LangOptions.h,1,['abort'],['abort']
Safety,"/// The nested name specifier that qualifies the template name.; ///; /// The bit is used to indicate whether the ""template"" keyword was; /// present before the template name itself. Note that the; /// ""template"" keyword is always redundant in this case (otherwise,; /// the template name would be a dependent name and we would express; /// this name with DependentTemplateName).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h:231,redund,redundant,231,interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/TemplateName.h,1,['redund'],['redundant']
Safety,"/// The number of \p CodeSynthesisContexts that are not template; /// instantiations and, therefore, should not be counted as part of the; /// instantiation depth.; ///; /// When the instantiation depth reaches the user-configurable limit; /// \p LangOptions::InstantiationDepth we will abort instantiation.; // FIXME: Should we have a similar limit for other forms of synthesis?",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:287,abort,abort,287,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['abort'],['abort']
Safety,"/// The number of currently-active calls to Lex.; ///; /// Lex is reentrant, and asking for an (end-of-phase-4) token can often; /// require asking for multiple additional tokens. This counter makes it; /// possible for Lex to detect whether it's producing a token for the end; /// of phase 4 of translation or for some other situation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:227,detect,detect,227,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['detect'],['detect']
Safety,"/// The number of expansions that this pack expansion will; /// generate when substituted (+1), which is expected to be able to; /// hold at least 1024 according to [implimits]. However, as this limit; /// is somewhat easy to hit with template metaprogramming we'd prefer to; /// keep it as large as possible. At the moment it has been left as a; /// non-bitfield since this type safely fits in 64 bits as an unsigned, so; /// there is no reason to introduce the performance impact of a bitfield.; ///; /// This field will only have a non-zero value when some of the parameter; /// packs that occur within the pattern have been substituted but others; /// have not.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:380,safe,safely,380,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['safe'],['safely']
Safety,/// The number of newlines immediately before the \c Token after formatting.; ///; /// This is used to avoid overlapping whitespace replacements when \c Newlines; /// is recomputed for a finalized preprocessor branching directive.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h:103,avoid,avoid,103,interpreter/llvm-project/clang/lib/Format/FormatToken.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/FormatToken.h,1,['avoid'],['avoid']
Safety,/// The number of subtrees detected in this DAG.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h:27,detect,detected,27,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDFS.h,1,['detect'],['detected']
Safety,"/// The number of template arguments in the type-constraints, which is; /// expected to be able to hold at least 1024 according to [implimits].; /// However as this limit is somewhat easy to hit with template; /// metaprogramming we'd prefer to keep it as large as possible.; /// At the moment it has been left as a non-bitfield since this type; /// safely fits in 64 bits as an unsigned, so there is no reason to; /// introduce the performance impact of a bitfield.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:350,safe,safely,350,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,1,['safe'],['safely']
Safety,"/// The number of template arguments named in this class template; /// specialization, which is expected to be able to hold at least 1024; /// according to [implimits]. However, as this limit is somewhat easy to; /// hit with template metaprogramming we'd prefer to keep it as large; /// as possible. At the moment it has been left as a non-bitfield since; /// this type safely fits in 64 bits as an unsigned, so there is no reason; /// to introduce the performance impact of a bitfield.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h:371,safe,safely,371,interpreter/llvm-project/clang/include/clang/AST/Type.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Type.h,2,['safe'],['safely']
Safety,/// The operands of each instruction in each lane Operands[op_index][lane].; /// Note: This helps avoid the replication of the code that performs the; /// reordering of operands during buildTree_rec() and vectorizeTree().,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:98,avoid,avoid,98,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar. If so, build an expression referencing; /// that ivar.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,detect,detected,48,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['detect'],['detected']
Safety,"/// The parser has read a name in, and Sema has detected that we're currently; /// inside an ObjC method. Perform some additional checks and determine if we; /// should form a reference to an ivar.; ///; /// Ideally, most of this would be done by lookup, but there's; /// actually quite a lot of extra work involved.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:48,detect,detected,48,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['detect'],['detected']
Safety,"/// The pattern is very common in tests, and it is OK to use it there.; /// We have to heuristics for detecting tests: method name starts with ""test""; /// (used in XCTest), and a class name contains ""mock"" or ""test"" (used in; /// helpers which are not tests themselves, but used exclusively in tests).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp:102,detect,detecting,102,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/GCDAntipatternChecker.cpp,1,['detect'],['detecting']
Safety,"/// The position of the last instruction for materializing constants; /// for use in the current block. It resets to EmitStartPt when it makes sense; /// (for example, it's usually profitable to avoid function calls between the; /// definition and the use)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:195,avoid,avoid,195,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,1,['avoid'],['avoid']
Safety,/// The pruning interval. This is intended to be used to avoid scanning the; /// directory too often. It does not impact the decision of which file to; /// prune. A value of 0 forces the scan to occur. A value of std::nullopt; /// disables pruning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h:57,avoid,avoid,57,interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CachePruning.h,1,['avoid'],['avoid']
Safety,"/// The set of allocatable registers.; /// We'll be ignoring anti-dependencies on non-allocatable registers,; /// because they may not be safe to break.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h:138,safe,safe,138,interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/CriticalAntiDepBreaker.h,1,['safe'],['safe']
Safety,"/// The set of basic blocks that have terminators that cannot be fully; /// analyzed. These basic blocks cannot be re-ordered safely by; /// MachineBlockPlacement, and we must preserve physical layout of these; /// blocks and their successors through the pass.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp:126,safe,safely,126,interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineBlockPlacement.cpp,1,['safe'],['safely']
Safety,/// The set of invalidated RefSCCs which should be skipped if they are found; /// in \c RCWorklist.; ///; /// This is used to quickly prune out RefSCCs when they get deleted and; /// happen to already be on the worklist. We use this primarily to avoid; /// scanning the list and removing entries from it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:246,avoid,avoid,246,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['avoid'],['avoid']
Safety,/// The set of invalidated SCCs which should be skipped if they are found; /// in \c CWorklist.; ///; /// This is used to quickly prune out SCCs when they get deleted and happen; /// to already be on the worklist. We use this primarily to avoid scanning; /// the list and removing entries from it.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:239,avoid,avoid,239,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,1,['avoid'],['avoid']
Safety,/// The set of multilibs that the detected installation supports.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h:34,detect,detected,34,interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Gnu.h,2,['detect'],['detected']
Safety,/// The set of values known to be live across this safepoint,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:51,safe,safepoint,51,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['safe'],['safepoint']
Safety,"/// The single BatchAA instance that is used to cache AA queries. It will; /// not be invalidated over the whole run. This is safe, because:; /// 1. Only memory writes are removed, so the alias cache for memory; /// locations remains valid.; /// 2. No new instructions are added (only instructions removed), so cached; /// information for a deleted value cannot be accessed by a re-used new; /// value pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp:126,safe,safe,126,interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp,1,['safe'],['safe']
Safety,/// The smallest dependence distance in bytes in the loop. This may not be; /// the same as the maximum number of bytes that are safe to operate on; /// simultaneously.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:129,safe,safe,129,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,1,['safe'],['safe']
Safety,/// The source info for the template arguments as written.; /// FIXME: redundant with TypeAsWritten?,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h:71,redund,redundant,71,interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclTemplate.h,2,['redund'],['redundant']
Safety,"/// The source location for the field name or, for a base initializer; /// pack expansion, the location of the ellipsis.; ///; /// In the case of a delegating; /// constructor, it will still include the type's source location as the; /// Initializee points to the CXXConstructorDecl (to allow loop detection).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h:298,detect,detection,298,interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclCXX.h,1,['detect'],['detection']
Safety,"/// The specified terminator is a value equality comparison instruction; /// (either a switch or a branch on ""X == c"").; /// See if any of the predecessors of the terminator block are value comparisons; /// on the same value. If so, and if safe to do so, fold them together.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:240,safe,safe,240,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,1,['safe'],['safe']
Safety,"/// The stack of modules being built, which is used to detect; /// cycles in the module dependency graph as modules are being built, as; /// well as to describe why we're rebuilding a particular module.; ///; /// There is no way to set this value from the command line. If we ever need; /// to do so (e.g., if on-demand module construction moves out-of-process),; /// we can add a cc1-level option to do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h:55,detect,detect,55,interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/SourceManager.h,1,['detect'],['detect']
Safety,"/// The target data for the platform for which execution is being performed.; ///; /// Note: the DataLayout is LLVMContext specific because it has an; /// internal cache based on type pointers. It makes unsafe to reuse the; /// ExecutionEngine across context, we don't enforce this rule but undefined; /// behavior can occurs if the user tries to do it.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:203,unsafe,unsafe,203,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,1,['unsafe'],['unsafe']
Safety,"/// The tblgen-erated code passes in a fifth parameter of an arbitrary type, but; /// denormalizeSimpleFlags never looks at it. Avoid bloating compile-time with; /// unnecessary template instantiations and just ignore it with a variadic; /// argument.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp:128,Avoid,Avoid,128,interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Frontend/CompilerInvocation.cpp,1,['Avoid'],['Avoid']
Safety,"/// The time (in seconds) after which an unused module file will be; /// considered unused and will, therefore, be pruned.; ///; /// When the module cache is pruned, any module file that has not been; /// accessed in this many seconds will be removed. The default value is; /// large, e.g., a month, to avoid forcing infrequently-used modules to be; /// regenerated often.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h:303,avoid,avoid,303,interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/HeaderSearchOptions.h,1,['avoid'],['avoid']
Safety,"/// The user may write code that uses allocas outside of the declared lifetime; /// zone. This can happen when the user returns a reference to a local; /// data-structure. We can detect these cases and decide not to optimize the; /// code. If this flag is enabled, we try to save the user. This option; /// is treated as overriding LifetimeStartOnFirstUse below.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp:179,detect,detect,179,interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/StackColoring.cpp,1,['detect'],['detect']
Safety,/// The value location. Stored separately to avoid repeatedly; /// extracting it from MI.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp:45,avoid,avoid,45,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/VarLocBasedImpl.cpp,1,['avoid'],['avoid']
Safety,"/// The value types of the registers. This is the same size as ValueVTs and it; /// records, for each value, what the type of the assigned register or; /// registers are. (Individual values are never synthesized from more than one; /// type of register.); ///; /// With virtual registers, the contents of RegVTs is redundant with TLI's; /// getRegisterType member function, however when with physical registers; /// it is necessary to have a separate record of the types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h:315,redund,redundant,315,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.h,1,['redund'],['redundant']
Safety,"/// The version of the protocol class. Used to differentiate between ObjC1; /// and ObjC2 protocols. Objective-C 1 protocols can not contain optional; /// components and can not contain declared properties. We always emit; /// Objective-C 2 property structures, but we have to pretend that they're; /// Objective-C 1 property structures when targeting the GCC runtime or it; /// will abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp:384,abort,abort,384,interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjCGNU.cpp,1,['abort'],['abort']
Safety,/// The virtual base discovered on the path (if we are merely; /// detecting virtuals).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h:67,detect,detecting,67,interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h,1,['detect'],['detecting']
Safety,"/// The visit counters used to detect when a complete SCC is on the stack.; /// visitNum is the global counter.; ///; /// nodeVisitNumbers are per-node visit numbers, also used as DFS flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h:31,detect,detect,31,interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SCCIterator.h,1,['detect'],['detect']
Safety,/// The visitor detects NoteTags and displays the event notes they contain.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h:16,detect,detects,16,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/BugReporter/BugReporterVisitors.h,1,['detect'],['detects']
Safety,/// There is nothing more we can do to this live range. Abort compilation; /// if it can't be assigned.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h:56,Abort,Abort,56,interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegAllocEvictionAdvisor.h,1,['Abort'],['Abort']
Safety,/// Thin wrapper around an integer -- designed to give more type safety to; /// spill location numbers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:65,safe,safety,65,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,1,['safe'],['safety']
Safety,"/// This Pass first walks through all the MOVEM instructions; /// that are chained together and record each of the; /// instruction's properties like register mask and data; /// access type into a `MOVEState` instance.; /// Then we perform reduction / collapsing on this `MOVEMState`; /// representation before creating a new `MOVEM` instruction; /// based on the collapsed result, as well as removing; /// redundant `MOVEM` instructions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp:407,redund,redundant,407,interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/M68k/M68kCollapseMOVEMPass.cpp,1,['redund'],['redundant']
Safety,/// This assigns and keeps a per-bb relative ordering of load/store; /// instructions in the block that directly load or store an alloca.; ///; /// This functionality is important because it avoids scanning large basic; /// blocks multiple times when promoting many allocas in the same block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:191,avoid,avoids,191,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,1,['avoid'],['avoids']
Safety,"/// This callback is invoked for operations that are unsupported by the; /// target, which are registered to use 'custom' lowering, and whose defined; /// values are all legal. If the target has no operations that require custom; /// lowering, it need not implement this. The default implementation of this; /// aborts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:312,abort,aborts,312,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['abort'],['aborts']
Safety,/// This callback is invoked when a new block of instructions is about to be; /// scheduled. The hazard state is set to an initialized state.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:97,hazard,hazard,97,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,1,['hazard'],['hazard']
Safety,"/// This callback is invoked when a node result type is illegal for the; /// target, and the operation was registered to use 'custom' lowering for that; /// result type. The target places new result values for the node in Results; /// (their number and types must exactly match those of the original return; /// values of the node), or leaves Results empty, which indicates that the; /// node is not to be custom lowered after all.; ///; /// If the target has no operations that require custom lowering, it need not; /// implement this. The default implementation aborts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h:564,abort,aborts,564,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetLowering.h,1,['abort'],['aborts']
Safety,"/// This callback is invoked when an instruction is emitted to be scheduled,; /// to advance the hazard state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:97,hazard,hazard,97,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,1,['hazard'],['hazard']
Safety,"/// This callback is invoked whenever the next top-down instruction to be; /// scheduled cannot issue in the current cycle, either because of latency; /// or resource conflicts. This should increment the internal state of the; /// hazard recognizer so that previously ""Hazard"" instructions will now not; /// be hazards.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:231,hazard,hazard,231,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,3,"['Hazard', 'hazard']","['Hazard', 'hazard', 'hazards']"
Safety,"/// This callback may be invoked if getHazardType returns NoHazard. If, even; /// though there is no hazard, it would be better to schedule another; /// available instruction, this callback should return true.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h:101,hazard,hazard,101,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonHazardRecognizer.h,1,['hazard'],['hazard']
Safety,"/// This checks if the source of this function has drifted since this binary was; /// profiled previously.; /// For now, we are piggy backing on what PGO does to; /// detect this with instrumented profiles. PGO emits an hash of the IR and; /// checks if the hash has changed. Advanced basic block layout is usually done; /// on top of PGO optimized binaries and hence this check works well in; /// practice.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h:167,detect,detect,167,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,1,['detect'],['detect']
Safety,/// This class implements a trivial dead store elimination. We consider; /// only the redundant stores that are local to a single Basic Block.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h:86,redund,redundant,86,interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Scalar/DeadStoreElimination.h,1,['redund'],['redundant']
Safety,"/// This class is a thread-safe associative collection connecting; /// a 256 bits digest/hash to a collection of uid (integer); /// This is used in the handling of the StreamerInfo record in TFile.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/RConcurrentHashColl.hxx:27,safe,safe,27,core/thread/inc/ROOT/RConcurrentHashColl.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/inc/ROOT/RConcurrentHashColl.hxx,1,['safe'],['safe']
Safety,/// This class provides an abstraction for a timeout around an operation; /// that must complete in a given amount of time. Failure to complete before; /// the timeout is an unrecoverable situation and no mechanisms to attempt; /// to handle it are provided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Watchdog.h:45,timeout,timeout,45,interpreter/llvm-project/llvm/include/llvm/Support/Watchdog.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Watchdog.h,2,['timeout'],['timeout']
Safety,"/// This class provides information about the result of a visit.; ///; /// After walking all the users (recursively) of a pointer, the basic; /// infrastructure records some commonly useful information such as escape; /// analysis and whether the visit completed or aborted early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:266,abort,aborted,266,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,1,['abort'],['aborted']
Safety,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:1799,avoid,avoid,1799,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,1,['avoid'],['avoid']
Safety,"/// This class stores info we want to provide to or retain within an alias; /// query. By default, the root query is stateless and starts with a freshly; /// constructed info object. Specific alias analyses can use this query info to; /// store per-query state that is important for recursive or nested queries to; /// avoid recomputing. To enable preserving this state across multiple queries; /// where safe (due to the IR not changing), use a `BatchAAResults` wrapper.; /// The information stored in an `AAQueryInfo` is currently limitted to the; /// caches used by BasicAA, but can further be extended to fit other AA needs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h:319,avoid,avoid,319,interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/AliasAnalysis.h,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,/// This class works in conjunction with the post-RA scheduler to rename; /// registers to break register anti-dependencies (WAR hazards).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:129,hazard,hazards,129,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,1,['hazard'],['hazards']
Safety,"/// This constructor is meaningless.; /// It just provides a default constructor that can be used at link time; /// when GlobalISel is not built.; /// That way, targets can still inherit from this class without doing; /// crazy gymnastic to avoid link time failures.; /// \note That works because the constructor is inlined.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h:241,avoid,avoid,241,interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/RegisterBankInfo.h,1,['avoid'],['avoid']
Safety,"/// This constructor is used only internally for speed of construction of; /// temporaries. It is unsafe since it takes ownership of the pointer, so it; /// is not public.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h:98,unsafe,unsafe,98,interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/APInt.h,1,['unsafe'],['unsafe']
Safety,/// This function calls \p Iteration() until it returns false.; /// If number of iterations exceeds \p MaxCounter then an Error is returned.; /// This function should be used for loops which assumed to have number of; /// iterations significantly smaller than \p MaxCounter to avoid infinite; /// looping in error cases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Utils.h:277,avoid,avoid,277,interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Utils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DWARFLinker/Utils.h,1,['avoid'],['avoid']
Safety,"/// This function calls abort(), and prints the optional message to stderr.; /// Use the llvm_unreachable macro (that adds location info), instead of; /// calling this function directly.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:24,abort,abort,24,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,1,['abort'],['abort']
Safety,"/// This function de-facto defines a set of transformations that we consider; /// safe (in heuristical sense). These transformation if passed a safe value as; /// an input should provide a safe value (or an object that provides safe; /// values).; ///; /// For more context see Static Analyzer checkers documentation - specifically; /// webkit.UncountedCallArgsChecker checker. Allowed list of transformations:; /// - constructors of ref-counted types (including factory methods); /// - getters of ref-counted types; /// - member overloaded operators; /// - casts; /// - unary operators like ``&`` or ``*``; ///; /// If passed expression is of type uncounted pointer/reference we try to find; /// the ""origin"" of the pointer value.; /// Origin can be for example a local variable, nullptr, constant or; /// this-pointer.; ///; /// Certain subexpression nodes represent transformations that don't affect; /// where the memory address originates from. We try to traverse such; /// subexpressions to get to the relevant child nodes. Whenever we encounter a; /// subexpression that either can't be ignored, we don't model its semantics or; /// that has multiple children we stop.; ///; /// \p E is an expression of uncounted pointer/reference type.; /// If \p StopAtFirstRefCountedObj is true and we encounter a subexpression that; /// represents ref-counted object during the traversal we return relevant; /// sub-expression and true.; ///; /// \returns subexpression that we traversed to and if \p; /// StopAtFirstRefCountedObj is true we also return whether we stopped early.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h:82,safe,safe,82,interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/StaticAnalyzer/Checkers/WebKit/ASTUtils.h,4,['safe'],['safe']
Safety,"/// This function detects the AVG pattern between vectors of unsigned i8/i16,; /// which is c = (a + b + 1) / 2, and replace this operation with the efficient; /// ISD::AVGCEILU (AVG) instruction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:18,detect,detects,18,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['detect'],['detects']
Safety,"/// This function executes the program using the arguments provided. The; /// invoked program will inherit the stdin, stdout, and stderr file; /// descriptors, the environment and other configuration settings of the; /// invoking program.; /// This function waits for the program to finish, so should be avoided in; /// library functions that aren't expected to block. Consider using; /// ExecuteNoWait() instead.; /// \returns an integer result code indicating the status of the program.; /// A zero or positive value indicates the result code of the program.; /// -1 indicates failure to execute; /// -2 indicates a crash during execution or timeout",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h:304,avoid,avoided,304,interpreter/llvm-project/llvm/include/llvm/Support/Program.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Program.h,2,"['avoid', 'timeout']","['avoided', 'timeout']"
Safety,"/// This function is called when we suspect that the update-chain of a phi node; /// (whose symbolic SCEV expression sin \p PhiScev) contains redundant casts,; /// that can be ignored. (This can happen when the PSCEV rewriter adds a runtime; /// predicate P under which the SCEV expression for the phi can be the; /// AddRecurrence \p AR; See createAddRecFromPHIWithCast). We want to find the; /// cast instructions that are involved in the update-chain of this induction.; /// A caller that adds the required runtime predicate can be free to drop these; /// cast instructions, and compute the phi using \p AR (instead of some scev; /// expression with casts).; ///; /// For example, without a predicate the scev expression can take the following; /// form:; /// (Ext ix (Trunc iy ( Start + i*Step ) to ix) to iy); ///; /// It corresponds to the following IR sequence:; /// %for.body:; /// %x = phi i64 [ 0, %ph ], [ %add, %for.body ]; /// %casted_phi = ""ExtTrunc i64 %x""; /// %add = add i64 %casted_phi, %step; ///; /// where %x is given in \p PN,; /// PSE.getSCEV(%x) is equal to PSE.getSCEV(%casted_phi) under a predicate,; /// and the IR sequence that ""ExtTrunc i64 %x"" represents can take one of; /// several forms, for example, such as:; /// ExtTrunc1: %casted_phi = and %x, 2^n-1; /// or:; /// ExtTrunc2: %t = shl %x, m; /// %casted_phi = ashr %t, m; ///; /// If we are able to find such sequence, we return the instructions; /// we found, namely %casted_phi and the instructions on its use-def chain up; /// to the phi (not including the phi).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp:142,redund,redundant,142,interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/IVDescriptors.cpp,1,['redund'],['redundant']
Safety,"/// This function loads the dynamic library at the given path, using the; /// library load operation from the host operating system. The library; /// instance will be closed when closeLibrary is called or global destructors; /// are run, but there is no guarantee when the library will be unloaded.; ///; /// This returns a valid DynamicLibrary instance on success and an invalid; /// instance on failure (see isValid()). \p *Err will only be modified if the; /// library fails to load.; ///; /// It is safe to call this function multiple times for the same library.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:503,safe,safe,503,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['safe'],['safe']
Safety,/// This function permanently loads the dynamic library at the given path.; /// Use this instead of getPermanentLibrary() when you won't need to get; /// symbols from the library itself.; ///; /// It is safe to call this function multiple times for the same library.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:203,safe,safe,203,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['safe'],['safe']
Safety,"/// This function permanently loads the dynamic library at the given path; /// using the library load operation from the host operating system. The; /// library instance will only be closed when global destructors run, and; /// there is no guarantee when the library will be unloaded.; ///; /// This returns a valid DynamicLibrary instance on success and an invalid; /// instance on failure (see isValid()). \p *errMsg will only be modified if; /// the library fails to load.; ///; /// It is safe to call this function multiple times for the same library.; /// Open a dynamic library permanently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h:492,safe,safe,492,interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/DynamicLibrary.h,1,['safe'],['safe']
Safety,/// This function returns the ARCInstKind of the function attached to operand; /// bundle clang_arc_attachedcall. It returns std::nullopt if the call doesn't; /// have the operand bundle or the operand is null. Otherwise it returns either; /// RetainRV or UnsafeClaimRV.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h:256,Unsafe,UnsafeClaimRV,256,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h,1,['Unsafe'],['UnsafeClaimRV']
Safety,/// This function returns true if the value is inert. An ObjC ARC runtime call; /// taking an inert operand can be safely deleted.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:115,safe,safely,115,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['safe'],['safely']
Safety,/// This indicates what sub class the handle actually is.; ///; /// This is to avoid having a vtable for the light-weight handle pointers. The; /// fully general Callback version does have a vtable.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ValueHandle.h:79,avoid,avoid,79,interpreter/llvm-project/llvm/include/llvm/IR/ValueHandle.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/ValueHandle.h,1,['avoid'],['avoid']
Safety,"/// This is a 'vector' (really, a variable-sized array), optimized; /// for the case when the array is small. It contains some number of elements; /// in-place, which allows it to avoid heap allocation when the actual number of; /// elements is below that threshold. This allows normal ""small"" cases to be; /// fast without losing generality for large inputs.; ///; /// \note; /// In the absence of a well-motivated choice for the number of inlined; /// elements \p N, it is recommended to use \c SmallVector<T> (that is,; /// omitting the \p N). This will choose a default number of inlined elements; /// reasonable for allocation on the stack (for example, trying to keep \c; /// sizeof(SmallVector<T>) around 64 bytes).; ///; /// \warning This does not attempt to be exception safe.; ///; /// \see https://llvm.org/docs/ProgrammersManual.html#llvm-adt-smallvector-h",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:180,avoid,avoid,180,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,2,"['avoid', 'safe']","['avoid', 'safe']"
Safety,"/// This is a function compatible with cl::AddExtraVersionPrinter, which adds; /// info about the current target triple and detected CPU.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Host.h:124,detect,detected,124,interpreter/llvm-project/llvm/include/llvm/TargetParser/Host.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/TargetParser/Host.h,1,['detect'],['detected']
Safety,"/// This is a utility class used to parse user-provided text files with; /// ""special case lists"" for code sanitizers. Such files are used to; /// define an ""ABI list"" for DataFlowSanitizer and allow/exclusion lists for; /// sanitizers like AddressSanitizer or UndefinedBehaviorSanitizer.; ///; /// Empty lines and lines starting with ""#"" are ignored. Sections are defined; /// using a '[section_name]' header and can be used to specify sanitizers the; /// entries below it apply to. Section names are globs, and; /// entries without a section header match all sections (e.g. an '[*]' header; /// is assumed.); /// The remaining lines should have the form:; /// prefix:glob_pattern[=category]; /// If category is not specified, it is assumed to be empty string.; /// Definitions of ""prefix"" and ""category"" are sanitizer-specific. For example,; /// sanitizer exclusion support prefixes ""src"", ""mainfile"", ""fun"" and ""global"".; /// ""glob_pattern"" defines source files, main files, functions or globals which; /// shouldn't be instrumented.; /// Examples of categories:; /// ""functional"": used in DFSan to list functions with pure functional; /// semantics.; /// ""init"": used in ASan exclusion list to disable initialization-order bugs; /// detection for certain globals or source files.; /// Full special case list file example:; /// ---; /// [address]; /// # Excluded items:; /// fun:*_ZN4base6subtle*; /// global:*global_with_bad_access_or_initialization*; /// global:*global_with_initialization_issues*=init; /// type:*Namespace::ClassName*=init; /// src:file_with_tricky_code.cc; /// src:ignore-global-initializers-issues.cc=init; /// mainfile:main_file.cc; ///; /// [dataflow]; /// # Functions with pure functional semantics:; /// fun:cos=functional; /// fun:sin=functional; /// ---",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h:1237,detect,detection,1237,interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/SpecialCaseList.h,1,['detect'],['detection']
Safety,"/// This is actually a Contents enumerator, but is unsigned to avoid sign; /// extension and achieve better bitpacking with MSVC.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h:63,avoid,avoid,63,interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCSymbol.h,1,['avoid'],['avoid']
Safety,"/// This is called on memcpy dest pointer arguments attributed as immutable; /// during call. Try to use memcpy source directly if all of the following; /// conditions are satisfied.; /// 1. The memcpy dst is neither modified during the call nor captured by the; /// call. (if readonly, noalias, nocapture attributes on call-site.); /// 2. The memcpy dst is an alloca with known alignment & size.; /// 2-1. The memcpy length == the alloca size which ensures that the new; /// pointer is dereferenceable for the required range; /// 2-2. The src pointer has alignment >= the alloca alignment or can be; /// enforced so.; /// 3. The memcpy dst and src is not modified between the memcpy and the call.; /// (if MSSA clobber check is safe.); /// 4. The memcpy src is not modified during the call. (ModRef check shows no; /// Mod.)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp:729,safe,safe,729,interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp,1,['safe'],['safe']
Safety,/// This is internal intrinsic. C/C++ user should avoid calling it directly.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h:50,avoid,avoid,50,interpreter/llvm-project/clang/lib/Headers/amxintrin.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Headers/amxintrin.h,9,['avoid'],['avoid']
Safety,/// This is the base ObjectCache type which can be provided to an; /// ExecutionEngine for the purpose of avoiding compilation for Modules that; /// have already been compiled and an object file is available.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ObjectCache.h:106,avoid,avoiding,106,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ObjectCache.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ObjectCache.h,1,['avoid'],['avoiding']
Safety,/// This is the hazard recognizer used at -O0 by the PostRAHazardRecognizer; /// pass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp:16,hazard,hazard,16,interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/SIInstrInfo.cpp,1,['hazard'],['hazard']
Safety,"/// This is the main method. It parses BrainF from in1; /// and returns the module with a function; /// void brainf(); /// containing the resulting code.; /// On error, it calls abort.; /// The caller must delete the returned module.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h:178,abort,abort,178,interpreter/llvm-project/llvm/examples/BrainF/BrainF.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/BrainF/BrainF.h,1,['abort'],['abort']
Safety,/// This is the part of SmallVectorTemplateBase which does not depend on whether; /// the type T is a POD. The extra dummy template argument is used by ArrayRef; /// to avoid unnecessarily requiring T to be complete.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:169,avoid,avoid,169,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['avoid'],['avoid']
Safety,"/// This is the resource with the greatest queue, which the; /// scheduler tries to avoid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h:84,avoid,avoid,84,interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/SystemZ/SystemZHazardRecognizer.h,1,['avoid'],['avoid']
Safety,"/// This is the underlying implementation of all of the; /// ConstantDataSequential::get methods. They all thunk down to here, providing; /// the correct element type. We take the bytes in as a StringRef because; /// we *want* an underlying ""char*"" to avoid TBAA type punning violations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp:252,avoid,avoid,252,interpreter/llvm-project/llvm/lib/IR/Constants.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/IR/Constants.cpp,1,['avoid'],['avoid']
Safety,"/// This is used to detect recursion. In pathological situations we could hit; /// exponential behavior, but at least there is nothing unbounded.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h:20,detect,detect,20,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/Evaluator.h,1,['detect'],['detect']
Safety,/// This map contains entries for all of the PHI instructions that we; /// attempt to compute constant evolutions for. This allows us to avoid; /// potentially expensive recomputation of these properties. An instruction; /// maps to null if we are unable to compute its exit value.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:137,avoid,avoid,137,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,1,['avoid'],['avoid']
Safety,"/// This method returns an LLVM type corresponding to the specified EVT.; /// For integer types, this returns an unsigned type. Note that this will; /// abort for types that cannot be represented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h:153,abort,abort,153,interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ValueTypes.h,1,['abort'],['abort']
Safety,"/// This method returns the address of the specified function. As such it is; /// only useful for resolving library symbols, not code generated symbols.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.; ///; /// This function is deprecated for memory managers to be used with; /// MCJIT or RuntimeDyld. Use getSymbolAddress instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h:169,Abort,AbortOnFailure,169,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h,2,"['Abort', 'abort']","['AbortOnFailure', 'aborts']"
Safety,"/// This method returns the address of the specified function.; /// Our implementation will attempt to find functions in other; /// modules associated with the MCJITHelper to cross link functions; /// from one generated module to another.; ///; /// If \p AbortOnFailure is false and no function with the given name is; /// found, this function returns a null pointer. Otherwise, it prints a; /// message to stderr and aborts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp:255,Abort,AbortOnFailure,255,interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/examples/Kaleidoscope/MCJIT/cached/toy.cpp,8,"['Abort', 'abort']","['AbortOnFailure', 'aborts']"
Safety,/// This method returns whether or not it is safe for an object with the; /// given stack id to be bundled into the local area.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h:45,safe,safe,45,interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/TargetFrameLowering.h,1,['safe'],['safe']
Safety,"/// This overload will be used when the hazard recognizer is being used; /// by a non-scheduling pass, which does not use SUnits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:40,hazard,hazard,40,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,2,['hazard'],['hazard']
Safety,/// This pass combines interleaved loads into a pattern detectable by; /// InterleavedAccessPass.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp:56,detect,detectable,56,interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp,1,['detect'],['detectable']
Safety,/// This pass detects subregister lanes in a virtual register that are used; /// independently of other lanes and splits them into separate virtual; /// registers.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:14,detect,detects,14,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['detect'],['detects']
Safety,/// This pass inserts AVX vzeroupper instructions before each call to avoid; /// transition penalty between functions encoded with AVX and SSE.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:70,avoid,avoid,70,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h,1,['avoid'],['avoid']
Safety,"/// This pass lowers the \@llvm.load.relative and \@llvm.objc.* intrinsics to; /// instructions. This is unsafe to do earlier because a pass may combine the; /// constant initializer into the load, which may result in an overflowing; /// evaluation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:105,unsafe,unsafe,105,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,1,['unsafe'],['unsafe']
Safety,/// This pass optimizes arithmetic based on knowledge that is only used by; /// a reduction sequence and is therefore safe to reassociate in interesting; /// ways.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h:118,safe,safe,118,interpreter/llvm-project/llvm/lib/Target/X86/X86.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86.h,1,['safe'],['safe']
Safety,/// This pass performs the global (interprocedural) stack safety analysis (new; /// pass manager).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:58,safe,safety,58,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,1,['safe'],['safety']
Safety,/// This pass performs the global (interprocedural) stack safety analysis; /// (legacy pass manager).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:58,safe,safety,58,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,1,['safe'],['safety']
Safety,"/// This pass resets a MachineFunction when it has the FailedISel property; /// as if it was just created.; /// If EmitFallbackDiag is true, the pass will emit a; /// DiagnosticInfoISelFallback for every MachineFunction it resets.; /// If AbortOnFailedISel is true, abort compilation instead of resetting.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:239,Abort,AbortOnFailedISel,239,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,2,"['Abort', 'abort']","['AbortOnFailedISel', 'abort']"
Safety,/// This pass splits the stack into a safe stack and an unsafe stack to; /// protect against stack-based overflow vulnerabilities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h:38,safe,safe,38,interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Passes.h,2,"['safe', 'unsafe']","['safe', 'unsafe']"
Safety,"/// This placement form of operator new[] uses the ASTContext's allocator for; /// obtaining memory.; ///; /// We intentionally avoid using a nothrow specification here so that the calls; /// to this operator will not perform a null check on the result -- the; /// underlying allocator never returns null pointers.; ///; /// Usage looks like this (assuming there's an ASTContext 'Context' in scope):; /// @code; /// // Default alignment (8); /// char *data = new (Context) char[10];; /// // Specific alignment; /// char *data = new (Context, 4) char[10];; /// @endcode; /// Memory allocated through this placement new[] operator does not need to be; /// explicitly freed, as ASTContext will free all of this memory when it gets; /// destroyed. Please note that you cannot use delete on the pointer.; ///; /// @param Bytes The number of bytes to allocate. Calculated by the compiler.; /// @param C The ASTContext that provides the allocator.; /// @param Alignment The alignment of the allocated memory (if the underlying; /// allocator supports it).; /// @return The allocated memory. Could be nullptr.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h:128,avoid,avoid,128,interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTContext.h,1,['avoid'],['avoid']
Safety,"/// This represents '#pragma omp target parallel for simd' directive.; ///; /// \code; /// #pragma omp target parallel for simd private(a) map(b) safelen(c); /// \endcode; /// In this example directive '#pragma omp target parallel for simd' has clauses; /// 'private' with the variable 'a', 'map' with the variable 'b' and 'safelen'; /// with the variable 'c'.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:146,safe,safelen,146,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,2,['safe'],['safelen']
Safety,"/// This represents '#pragma omp target simd' directive.; ///; /// \code; /// #pragma omp target simd private(a) map(b) safelen(c); /// \endcode; /// In this example directive '#pragma omp target simd' has clauses 'private'; /// with the variable 'a', 'map' with the variable 'b' and 'safelen' with; /// the variable 'c'.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h:120,safe,safelen,120,interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/StmtOpenMP.h,2,['safe'],['safelen']
Safety,/// This represents 'safelen' clause in the '#pragma omp ...'; /// directive.; ///; /// \code; /// #pragma omp simd safelen(4); /// \endcode; /// In this example directive '#pragma omp simd' has clause 'safelen'; /// with single expression '4'.; /// If the safelen clause is used then no two iterations executed; /// concurrently with SIMD instructions can have a greater distance; /// in the logical iteration space than its value. The parameter of; /// the safelen clause must be a constant positive integer expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h:21,safe,safelen,21,interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/OpenMPClause.h,5,['safe'],['safelen']
Safety,/// This represents a data type for the stats and it helps us to; /// detect an overflow.; /// NOTE: This can be implemented as a template if there is an another type; /// needing this.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp:70,detect,detect,70,interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-dwarfdump/Statistics.cpp,1,['detect'],['detect']
Safety,"/// This static method returns true if the type Ty is big enough to; /// represent the value V. This can be used to avoid having the get method; /// assert when V is larger than Ty can represent. Note that there are two; /// versions of this method, one for unsigned and one for signed integers.; /// Although ConstantInt canonicalizes everything to an unsigned integer,; /// the signed version avoids callers having to convert a signed quantity; /// to the appropriate unsigned type before calling the method.; /// @returns true if V is a valid value for type Ty; /// Determine if the value is in range for the given type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h:116,avoid,avoid,116,interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Constants.h,2,['avoid'],"['avoid', 'avoids']"
Safety,/// This struct is used to defer RAUWs and `eraseFromParent` s. Using this; /// avoids having to worry about keeping around dangling pointers to Values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:80,avoid,avoids,80,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,1,['avoid'],['avoids']
Safety,/// This type defines the callback to add a file that is generated on the fly.; ///; /// Stream callbacks must be thread safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h:121,safe,safe,121,interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,1,['safe'],['safe']
Safety,/// This type defines the callback to add a pre-existing file (e.g. in a cache).; ///; /// Buffer callbacks must be thread safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h:123,safe,safe,123,interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/Caching.h,1,['safe'],['safe']
Safety,"/// Thread safe const iteration over all function infos.; ///; /// \param Callback A callback function that will get called with each; /// FunctionInfo. If the callback returns false, stop iterating.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:11,safe,safe,11,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,1,['safe'],['safe']
Safety,"/// Thread safe iteration over all function infos.; ///; /// \param Callback A callback function that will get called with each; /// FunctionInfo. If the callback returns false, stop iterating.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h:11,safe,safe,11,interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/DebugInfo/GSYM/GsymCreator.h,1,['safe'],['safe']
Safety,"/// Thread-safe allocator adaptor. Uses a spin lock on the assumption that; /// contention here is extremely rare.; ///; /// TODO: Using a spin lock on every allocation can be quite expensive when; /// contention is high. Since this is mainly used for BumpPtrAllocator and; /// SpecificBumpPtrAllocator, it'd be better to have a specific thread-safe; /// BumpPtrAllocator implementation that only use a fair lock when allocating a; /// new slab but otherwise using atomic and be lock-free.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadSafeAllocator.h:11,safe,safe,11,interpreter/llvm-project/llvm/include/llvm/Support/ThreadSafeAllocator.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ThreadSafeAllocator.h,2,['safe'],['safe']
Safety,"/// Thread-safe callback for RDataFrame.; /// It will record elapsed times and event statistics, and print a progress bar every n seconds (set by the; /// fPrintInterval). \param slot Ignored. \param value Ignored.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx:11,safe,safe,11,tree/dataframe/inc/ROOT/RDFHelpers.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDFHelpers.hxx,1,['safe'],['safe']
Safety,"/// Timeout for asynchronous opening.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx:4,Timeout,Timeout,4,io/io/v7/inc/ROOT/RFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/v7/inc/ROOT/RFile.hxx,1,['Timeout'],['Timeout']
Safety,"/// To avoid stack clash, allocation is performed by block and each block is; /// probed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:7,avoid,avoid,7,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['avoid'],['avoid']
Safety,"/// TokenConcatenation class, which answers the question of; /// ""Is it safe to emit two tokens without a whitespace between them, or; /// would that cause implicit concatenation of the tokens?""; ///; /// For example, it emitting two identifiers ""foo"" and ""bar"" next to each; /// other would cause the lexer to produce one ""foobar"" token. Emitting ""1""; /// and "")"" next to each other is safe.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h:72,safe,safe,72,interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,2,['safe'],['safe']
Safety,/// TokenInfo - This array contains information for each token on what; /// action to take when avoiding concatenation of tokens in the AvoidConcat; /// method.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h:96,avoid,avoiding,96,interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,2,"['Avoid', 'avoid']","['AvoidConcat', 'avoiding']"
Safety,"/// Tokenizes a Windows command line while attempting to avoid copies. If no; /// quoting or escaping was used, this produces substrings of the original; /// string. If a token requires unquoting, it will be allocated with the; /// StringSaver.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h:57,avoid,avoid,57,interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/CommandLine.h,1,['avoid'],['avoid']
Safety,"/// Top-level MachineScheduler pass driver.; ///; /// Visit blocks in function order. Divide each block into scheduling regions; /// and visit them bottom-up. Visiting regions bottom-up is not required, but is; /// consistent with the DAG builder, which traverses the interior of the; /// scheduling regions bottom-up.; ///; /// This design avoids exposing scheduling boundaries to the DAG builder,; /// simplifying the DAG builder's support for ""special"" target instructions.; /// At the same time the design allows target schedulers to operate across; /// scheduling boundaries, for example to bundle the boundary instructions; /// without reordering them. This creates complexity, because the target; /// scheduler must update the RegionBegin and RegionEnd positions cached by; /// ScheduleDAGInstrs whenever adding or removing instructions. A much simpler; /// design would be to split blocks at scheduling boundaries, but LLVM has a; /// general bias against block splitting purely for implementation simplicity.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp:341,avoid,avoids,341,interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineScheduler.cpp,1,['avoid'],['avoids']
Safety,"/// Trace the predicate state through a call.; ///; /// There are several layers of this needed to handle the full complexity of; /// calls.; ///; /// First, we need to send the predicate state into the called function. We do; /// this by merging it into the high bits of the stack pointer.; ///; /// For tail calls, this is all we need to do.; ///; /// For calls where we might return and resume the control flow, we need to; /// extract the predicate state from the high bits of the stack pointer after; /// control returns from the called function.; ///; /// We also need to verify that we intended to return to this location in the; /// code. An attacker might arrange for the processor to mispredict the return; /// to this valid but incorrect return address in the program rather than the; /// correct one. See the paper on this attack, called ""ret2spec"" by the; /// researchers, here:; /// https://christian-rossow.de/publications/ret2spec-ccs2018.pdf; ///; /// The way we verify that we returned to the correct location is by preserving; /// the expected return address across the call. One technique involves taking; /// advantage of the red-zone to load the return address from `8(%rsp)` where it; /// was left by the RET instruction when it popped `%rsp`. Alternatively, we can; /// directly save the address into a register that will be preserved across the; /// call. We compare this intended return address against the address; /// immediately following the call (the observed return address). If these; /// mismatch, we have detected misspeculation and can poison our predicate; /// state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1540,detect,detected,1540,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['detect'],['detected']
Safety,"/// Trace the predicate state through each of the blocks in the function,; /// hardening everything necessary along the way.; ///; /// We call this routine once the initial predicate state has been established; /// for each basic block in the function in the SSA updater. This routine traces; /// it through the instructions within each basic block, and for non-returning; /// blocks informs the SSA updater about the final state that lives out of the; /// block. Along the way, it hardens any vulnerable instruction using the; /// currently valid predicate state. We have to do these two things together; /// because the SSA updater only works across blocks. Within a block, we track; /// the current predicate state directly and update it as it changes.; ///; /// This operates in two passes over each block. First, we analyze the loads in; /// the block to determine which strategy will be used to harden them: hardening; /// the address or hardening the loaded value when loaded into a register; /// amenable to hardening. We have to process these first because the two; /// strategies may interact -- later hardening may change what strategy we wish; /// to use. We also will analyze data dependencies between loads and avoid; /// hardening those loads that are data dependent on a load with a hardened; /// address. We also skip hardening loads already behind an LFENCE as that is; /// sufficient to harden them against misspeculation.; ///; /// Second, we actively trace the predicate state through the block, applying; /// the hardening steps we determined necessary in the first pass as we go.; ///; /// These two passes are applied to each basic block. We operate one block at a; /// time to simplify reasoning about reachability and sequencing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:1225,avoid,avoid,1225,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,1,['avoid'],['avoid']
Safety,"/// Trace the predicate state through indirect branches, instrumenting them to; /// poison the state if a target is reached that does not match the expected; /// target.; ///; /// This is designed to mitigate Spectre variant 1 attacks where an indirect; /// branch is trained to predict a particular target and then mispredicts that; /// target in a way that can leak data. Despite using an indirect branch, this; /// is really a variant 1 style attack: it does not steer execution to an; /// arbitrary or attacker controlled address, and it does not require any; /// special code executing next to the victim. This attack can also be mitigated; /// through retpolines, but those require either replacing indirect branches; /// with conditional direct branches or lowering them through a device that; /// blocks speculation. This mitigation can replace these retpoline-style; /// mitigations for jump tables and other indirect branches within a function; /// when variant 2 isn't a risk while allowing limited speculation. Indirect; /// calls, however, cannot be mitigated through this technique without changing; /// the ABI in a fundamental way.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp:279,predict,predict,279,interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp,2,"['predict', 'risk']","['predict', 'risk']"
Safety,/// Track local uses of virtual registers. These uses are gathered by the DAG; /// builder and may be consulted by the scheduler to avoid iterating an entire; /// vreg use list.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h:132,avoid,avoid,132,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleDAGInstrs.h,1,['avoid'],['avoid']
Safety,/// Track the top-level decls which appeared in an ASTUnit which was loaded; /// from a source file.; //; // FIXME: This is just an optimization hack to avoid deserializing large parts; // of a PCH file when using the Index library on an ASTUnit loaded from; // source. In the long term we should make the Index library use efficient and; // more scalable search mechanisms.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:153,avoid,avoid,153,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['avoid'],['avoid']
Safety,"/// Track variable location debug instructions while using the instruction; /// referencing implementation. Such debug instructions do not need to be; /// updated during regalloc because they identify instructions rather than; /// register locations. However, they needs to be removed from the; /// MachineFunction during regalloc, then re-inserted later, to avoid; /// disrupting the allocator.; ///; /// \param MI Any DBG_VALUE / DBG_INSTR_REF / DBG_PHI instruction; /// \param Idx Last valid SlotIndex before instruction; ///; /// \returns Iterator to continue processing from after unlinking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp:359,avoid,avoid,359,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugVariables.cpp,1,['avoid'],['avoid']
Safety,/// Tracker counting backwards from the highest unsigned value possible to; /// avoid conflicting with the GVNs of assigned values. We start at -3 since; /// -2 and -1 are assigned by the DenseMap.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:80,avoid,avoid,80,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,1,['avoid'],['avoid']
Safety,"/// Tracker for converting machine value locations and variable values into; /// variable locations (the output of LiveDebugValues), recorded as DBG_VALUEs; /// specifying block live-in locations and transfers within blocks.; ///; /// Operating on a per-block basis, this class takes a (pre-loaded) MLocTracker; /// and must be initialized with the set of variable values that are live-in to; /// the block. The caller then repeatedly calls process(). TransferTracker picks; /// out variable locations for the live-in variable values (if there _is_ a; /// location) and creates the corresponding DBG_VALUEs. Then, as the block is; /// stepped through, transfers of values between machine locations are; /// identified and if profitable, a DBG_VALUE created.; ///; /// This is where debug use-before-defs would be resolved: a variable with an; /// unavailable value could materialize in the middle of a block, when the; /// value becomes available. Or, we could detect clobbers and re-specify the; /// variable in a backup location. (XXX these are unimplemented).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp:961,detect,detect,961,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.cpp,1,['detect'],['detect']
Safety,"/// Tracker for what values are in machine locations. Listens to the Things; /// being Done by various instructions, and maintains a table of what machine; /// locations have what values (as defined by a ValueIDNum).; ///; /// There are potentially a much larger number of machine locations on the; /// target machine than the actual working-set size of the function. On x86 for; /// example, we're extremely unlikely to want to track values through control; /// or debug registers. To avoid doing so, MLocTracker has several layers of; /// indirection going on, described below, to avoid unnecessarily tracking; /// any location.; ///; /// Here's a sort of diagram of the indexes, read from the bottom up:; ///; /// Size on stack Offset on stack; /// \ /; /// Stack Idx (Where in slot is this?); /// /; /// /; /// Slot Num (%stack.0) /; /// FrameIdx => SpillNum /; /// \ /; /// SpillID (int) Register number (int); /// \ /; /// LocationID => LocIdx; /// |; /// LocIdx => ValueIDNum; ///; /// The aim here is that the LocIdx => ValueIDNum vector is just an array of; /// values in numbered locations, so that later analyses can ignore whether the; /// location is a register or otherwise. To map a register / spill location to; /// a LocIdx, you have to use the (sparse) LocationID => LocIdx map. And to; /// build a LocationID for a stack slot, you need to combine identifiers for; /// which stack slot it is and where within that slot is being described.; ///; /// Register mask operands cause trouble by technically defining every register;; /// various hacks are used to avoid tracking registers that are never read and; /// only written by regmasks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h:486,avoid,avoid,486,interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/LiveDebugValues/InstrRefBasedImpl.h,3,['avoid'],['avoid']
Safety,"/// Tracks expected type during expression parsing, for use in code completion.; /// The type is tied to a particular token, all functions that update or consume; /// the type take a start location of the token they are looking at as a; /// parameter. This avoids updating the type on hot paths in the parser.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:257,avoid,avoids,257,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,1,['avoid'],['avoids']
Safety,"/// TrailingCommaInserter inserts trailing commas into container literals.; /// E.g.:; /// const x = [; /// 1,; /// ];; /// TrailingCommaInserter runs after formatting. To avoid causing a required; /// reformatting (and thus reflow), it never inserts a comma that'd exceed the; /// ColumnLimit.; ///; /// Because trailing commas disable binpacking of arrays, TrailingCommaInserter; /// is conceptually incompatible with bin packing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp:172,avoid,avoid,172,interpreter/llvm-project/clang/lib/Format/Format.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/Format.cpp,1,['avoid'],['avoid']
Safety,/// Transfers the given Block and all Symbols pointing to it to the given; /// Section.; ///; /// No attempt is made to check compatibility of the source and destination; /// sections. Blocks may be moved between sections with incompatible; /// permissions (e.g. from data to text). The client is responsible for; /// ensuring that this is safe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h:340,safe,safe,340,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/JITLink/JITLink.h,1,['safe'],['safe']
Safety,"/// Transforms a \p MachineBasicBlock into a \p vector of \p unsigneds; /// and appends it to \p UnsignedVec and \p InstrList.; ///; /// Two instructions are assigned the same integer if they are identical.; /// If an instruction is deemed unsafe to outline, then it will be assigned an; /// unique integer. The resulting mapping is placed into a suffix tree and; /// queried for candidates.; ///; /// \param MBB The \p MachineBasicBlock to be translated into integers.; /// \param TII \p TargetInstrInfo for the function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp:240,unsafe,unsafe,240,interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineOutliner.cpp,1,['unsafe'],['unsafe']
Safety,"/// TreeEntries only allow a single opcode, or an alternate sequence of; /// them (e.g, +, -). Therefore, we can safely use a boolean value for the; /// APO. It is set to 'true' if 'V' is attached to an inverse operation; /// in the left-linearized form (e.g., Sub/Div), and 'false' otherwise; /// (e.g., Add/Mul)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:113,safe,safely,113,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['safe'],['safely']
Safety,/// Tries to detect a compilation database location and load it.; ///; /// Looks for a compilation database in all parent paths of file 'SourceFile'; /// by calling loadFromDirectory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:13,detect,detect,13,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,1,['detect'],['detect']
Safety,/// Tries to detect a compilation database location and load it.; ///; /// Looks for a compilation database in directory 'SourceDir' and all; /// its parent paths by calling loadFromDirectory.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h:13,detect,detect,13,interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Tooling/CompilationDatabase.h,1,['detect'],['detect']
Safety,"/// Tries to find extractelement instructions with constant indices from fixed; /// vector type and gather such instructions into a bunch, which highly likely; /// might be detected as a shuffle of 1 or 2 input vectors. If this attempt was; /// successful, the matched scalars are replaced by poison values in \p VL for; /// future analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:173,detect,detected,173,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['detect'],['detected']
Safety,"/// Tries to find extractelement instructions with constant indices from fixed; /// vector type and gather such instructions into a bunch, which highly likely; /// might be detected as a shuffle of 1 or 2 input vectors. If this attempt; /// was successful, the matched scalars are replaced by poison values in \p VL; /// for future analysis.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:173,detect,detected,173,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,2,['detect'],['detected']
Safety,/// True if it's cheap enough to take parameters by value. Doing so avoids; /// overhead related to mitigations for reference invalidation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h:68,avoid,avoids,68,interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallVector.h,1,['avoid'],['avoids']
Safety,"/// True if the function recovers from an SEH exception, and therefore needs; /// to spill and restore the frame pointer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h:25,recover,recovers,25,interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h,1,['recover'],['recovers']
Safety,"/// True if the index should be subtracted rather than added. We don't simply; /// negate the Scale, to avoid losing the NSW flag: X - INT_MIN*1 may be; /// non-wrapping, while X + INT_MIN*(-1) wraps.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp:104,avoid,avoid,104,interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BasicAliasAnalysis.cpp,1,['avoid'],['avoid']
Safety,/// True if there is any unsafe math in the loop.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:25,unsafe,unsafe,25,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['unsafe'],['unsafe']
Safety,"/// True if this value is determined to be identical to OtherVNI; /// (in valuesIdentical). This is used with CR_Erase where the erased; /// copy is redundant, i.e. the source value is already the same as; /// the destination. In such cases the subranges need to be updated; /// properly. See comment at pruneSubRegValues for more info.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:149,redund,redundant,149,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['redund'],['redundant']
Safety,/// True to avoid tearing down the lexer etc on EOF,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:12,avoid,avoid,12,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['avoid'],['avoid']
Safety,"/// Try recover parser when module annotation appears where it must not; /// be found.; /// \returns false if the recover was successful and parsing may be continued, or; /// true if parser must bail out to top level and handle the token there.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:8,recover,recover,8,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,2,['recover'],['recover']
Safety,"/// Try to avoid chasing pointees, esp. structure pointees which may; /// unnecessary bring in a lot of types.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp:11,avoid,avoid,11,interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/BPF/BTFDebug.cpp,1,['avoid'],['avoid']
Safety,/// Try to detect a recurrence that monotonically increases/decreases from a; /// non-zero starting value. These are common as induction variables.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:11,detect,detect,11,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['detect'],['detect']
Safety,/// Try to detect a recurrence that the value of the induction variable is; /// always a power of two (or zero).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp:11,detect,detect,11,interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ValueTracking.cpp,1,['detect'],['detect']
Safety,"/// Try to emit a reference to the given value without producing it as; /// an l-value. This is just an optimization, but it avoids us needing; /// to emit global copies of variables if they're named without triggering; /// a formal use in a context where we can't emit a direct reference to them,; /// for instance if a block or lambda or a member of a local class uses a; /// const int variable or constexpr variable from an enclosing function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp:125,avoid,avoids,125,interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExpr.cpp,1,['avoid'],['avoids']
Safety,"/// Try to find existing copies of the incoming values in stack slots used for; /// statepoint spilling. If we can find a spill slot for the incoming value,; /// mark that slot as allocated, and reuse the same slot for this safepoint.; /// This helps to avoid series of loads and stores that only serve to reshuffle; /// values on the stack between calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp:224,safe,safepoint,224,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/StatepointLowering.cpp,2,"['avoid', 'safe']","['avoid', 'safepoint']"
Safety,"/// Try to find redundant insertvalue instructions, like the following ones:; /// %0 = insertvalue { i8, i32 } undef, i8 %x, 0; /// %1 = insertvalue { i8, i32 } %0, i8 %y, 0; /// Here the second instruction inserts values at the same indices, as the; /// first one, making the first one redundant.; /// It should be transformed to:; /// %0 = insertvalue { i8, i32 } undef, i8 %y, 0",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,redund,redundant,16,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,2,['redund'],['redundant']
Safety,"/// Try to fold (icmp(A & B) ==/!= 0) &/| (icmp(A & D) ==/!= E) into a single; /// (icmp(A & X) ==/!= Y), where the left-hand side and the right hand side; /// aren't of the common mask pattern type.; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:250,safe,safe,250,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safe']
Safety,"/// Try to fold (icmp(A & B) ==/!= C) &/| (icmp(A & D) ==/!= E) into a single; /// (icmp(A & X) ==/!= Y), where the left-hand side is of type Mask_NotAllZeros; /// and the right hand side is of type BMask_Mixed. For example,; /// (icmp (A & 12) != 0) & (icmp (A & 15) == 8) -> (icmp (A & 15) == 8).; /// Also used for logical and/or, must be poison safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:349,safe,safe,349,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['safe'],['safe']
Safety,/// Try to fold a sext/zext/aext dag node into a ConstantSDNode or; /// a build_vector of constants.; /// This function is called by the DAGCombiner when visiting sext/zext/aext; /// dag nodes (see for example method DAGCombiner::visitSIGN_EXTEND).; /// Vector extends are not folded if operations are legal; this is to; /// avoid introducing illegal build_vector dag nodes.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp:325,avoid,avoid,325,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/DAGCombiner.cpp,1,['avoid'],['avoid']
Safety,"/// Try to fold icmp (binop), X or icmp X, (binop).; /// TODO: A large part of this logic is duplicated in InstSimplify's; /// simplifyICmpWithBinOp(). We should be able to share that and avoid the code; /// duplication.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:188,avoid,avoid,188,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,1,['avoid'],['avoid']
Safety,/// Try to infer branch probabilities mimicking implementation of; /// BranchProbabilityInfo. Unlikely taken branches are marked so that the; /// inference algorithm can avoid sending flow along corresponding edges.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h:170,avoid,avoid,170,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SampleProfileInference.h,1,['avoid'],['avoid']
Safety,"/// Try to locks the file during the specified time.; ///; /// This function implements advisory locking on entire file. If it returns; /// <em>errc::success</em>, the file is locked by the calling process. Until the; /// process unlocks the file by calling \a unlockFile, all attempts to lock the; /// same file will fail/block. The process that locked the file may assume that; /// none of other processes read or write this file, provided that all processes; /// lock the file prior to accessing its content.; ///; /// @param FD The descriptor representing the file to lock.; /// @param Timeout Time in milliseconds that the process should wait before; /// reporting lock failure. Zero value means try to get lock only; /// once.; /// @returns errc::success if lock is successfully obtained,; /// errc::no_lock_available if the file cannot be locked, or platform-specific; /// error_code otherwise.; ///; /// @note Care should be taken when using this function in a multithreaded; /// context, as it may not prevent other threads in the same process from; /// obtaining a lock on the same file, even if they are using a different file; /// descriptor.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h:590,Timeout,Timeout,590,interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/FileSystem.h,1,['Timeout'],['Timeout']
Safety,"/// Try to move the specified instruction from its current block into the; /// beginning of DestBlock, which can only happen if it's safe to move the; /// instruction past all of the instructions between it and the end of its; /// block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:133,safe,safe,133,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,1,['safe'],['safe']
Safety,"/// Try to narrow the width of a splat shuffle. This could be generalized to any; /// shuffle with a constant operand, but we limit the transform to avoid; /// creating a shuffle type that targets may not be able to lower effectively.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:149,avoid,avoid,149,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['avoid'],['avoid']
Safety,"/// Try to narrow the width of an insert element. This could be generalized for; /// any vector constant, but we limit the transform to insertion into undef to; /// avoid potential backend problems from unsupported insertion widths. This; /// could also be extended to handle the case of inserting a scalar constant; /// into a vector variable.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:165,avoid,avoid,165,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['avoid'],['avoid']
Safety,"/// Try to optimize an AutoreleaseRV with a RetainRV or UnsafeClaimRV. If the; /// optimization occurs, returns true to indicate that the caller should; /// assume the instructions are dead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp:56,Unsafe,UnsafeClaimRV,56,interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/ObjCARC/ObjCARCOpts.cpp,1,['Unsafe'],['UnsafeClaimRV']
Safety,"/// Try to promote memory values to scalars by sinking stores out of; /// the loop and moving loads to before the loop. We do this by looping over; /// the stores in the loop, looking for stores to Must pointers which are; /// loop invariant. It takes a set of must-alias values, Loop exit blocks; /// vector, loop exit blocks insertion point vector, PredIteratorCache,; /// LoopInfo, DominatorTree, Loop, AliasSet information for all instructions; /// of the loop and loop safety information as arguments.; /// Diagnostics is emitted via \p ORE. It returns changed status.; /// \p AllowSpeculation is whether values should be hoisted even if they are not; /// guaranteed to execute in the loop, but are safe to speculatively execute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:474,safe,safety,474,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,2,['safe'],"['safe', 'safety']"
Safety,/// Try to recover by turning the given expression into a; /// call. Returns true if recovery was attempted or an error was; /// emitted; this may also leave the ExprResult invalid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h:11,recover,recover,11,interpreter/llvm-project/clang/include/clang/Sema/Sema.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/Sema.h,2,['recover'],"['recover', 'recovery']"
Safety,"/// Try to recover from invalid function values. When invalid function values; /// are encountered, a penalty term is returned to the minimiser to make it; /// back off. This sets the strength of this penalty. \note A strength of zero; /// is equivalent to a constant penalty (= the gradient vanishes, ROOT < 6.24).; /// Positive values lead to a gradient pointing away from the undefined; /// regions. Use ~10 to force the minimiser away from invalid function values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx:11,recover,recover,11,roofit/roofitcore/src/RooMinimizer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooMinimizer.cxx,1,['recover'],['recover']
Safety,/// Try to remove redundant dbg.value instructions from given basic block.; /// Returns true if at least one instruction was removed. Remove redundant; /// pseudo ops when RemovePseudoOp is true.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h:18,redund,redundant,18,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/BasicBlockUtils.h,2,['redund'],['redundant']
Safety,/// Try to replace a mathlib call to sqrt with the LLVM intrinsic. This avoids; /// pessimistic codegen that has to account for setting errno and can enable; /// vectorization.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp:72,avoid,avoids,72,interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/AggressiveInstCombine/AggressiveInstCombine.cpp,1,['avoid'],['avoids']
Safety,"/// TryAnnotateScopeToken - Like TryAnnotateTypeOrScopeToken but only; /// annotates C++ scope specifiers and template-ids. This returns; /// true if there was an error that could not be recovered from.; ///; /// Note that this routine emits an error if you call it with ::new or ::delete; /// as the current tokens, so only call it in contexts where these are invalid.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp:187,recover,recovered,187,interpreter/llvm-project/clang/lib/Parse/Parser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/Parser.cpp,1,['recover'],['recovered']
Safety,"/// Turn off crash debugging features; ///; /// Crash is expected, so disable crash reports and symbolization to reduce; /// output clutter and avoid potentially slow symbolization.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp:144,avoid,avoid,144,interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/llvm-reduce/llvm-reduce.cpp,1,['avoid'],['avoid']
Safety,"/// Twine - A lightweight data structure for efficiently representing the; /// concatenation of temporary values as strings.; ///; /// A Twine is a kind of rope, it represents a concatenated string using a; /// binary-tree, where the string is the preorder of the nodes. Since the; /// Twine can be efficiently rendered into a buffer when its result is used,; /// it avoids the cost of generating temporary values for intermediate string; /// results -- particularly in cases when the Twine result is never; /// required. By explicitly tracking the type of leaf nodes, we can also avoid; /// the creation of temporary strings for conversions operations (such as; /// appending an integer to a string).; ///; /// A Twine is not intended for use directly and should not be stored, its; /// implementation relies on the ability to store pointers to temporary stack; /// objects which may be deallocated at the end of a statement. Twines should; /// only be used as const references in arguments, when an API wishes; /// to accept possibly-concatenated strings.; ///; /// Twines support a special 'null' value, which always concatenates to form; /// itself, and renders as an empty string. This can be returned from APIs to; /// effectively nullify any concatenations performed on the result.; ///; /// \b Implementation; ///; /// Given the nature of a Twine, it is not possible for the Twine's; /// concatenation method to construct interior nodes; the result must be; /// represented inside the returned value. For this reason a Twine object; /// actually holds two values, the left- and right-hand sides of a; /// concatenation. We also have nullary Twine objects, which are effectively; /// sentinel values that represent empty strings.; ///; /// Thus, a Twine can effectively have zero, one, or two children. The \see; /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for; /// testing the number of children.; ///; /// We maintain a number of invariants on Twine objects (FIXME: ",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h:367,avoid,avoids,367,interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/Twine.h,2,['avoid'],"['avoid', 'avoids']"
Safety,/// Type for a function iterating over a number of declarations.; /// \returns true to continue iteration and false to abort.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h:119,abort,abort,119,interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Frontend/ASTUnit.h,1,['abort'],['abort']
Safety,"/// Type of BodyGen to use for region codegen; ///; /// Priv: If device pointer privatization is required, emit the body of the; /// region here. It will have to be duplicated: with and without; /// privatization.; /// DupNoPriv: If we need device pointer privatization, we need; /// to emit the body of the region with no privatization in the 'else' branch; /// of the conditional.; /// NoPriv: If we don't require privatization of device; /// pointers, we emit the body in between the runtime calls. This avoids; /// duplicating the body code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h:507,avoid,avoids,507,interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Frontend/OpenMP/OMPIRBuilder.h,1,['avoid'],['avoids']
Safety,"/// TypeStringCache caches the meta encodings of Types.; ///; /// The reason for caching TypeStrings is two fold:; /// 1. To cache a type's encoding for later uses;; /// 2. As a means to break recursive member type inclusion.; ///; /// A cache Entry can have a Status of:; /// NonRecursive: The type encoding is not recursive;; /// Recursive: The type encoding is recursive;; /// Incomplete: An incomplete TypeString;; /// IncompleteUsed: An incomplete TypeString that has been used in a; /// Recursive type encoding.; ///; /// A NonRecursive entry will have all of its sub-members expanded as fully; /// as possible. Whilst it may contain types which are recursive, the type; /// itself is not recursive and thus its encoding may be safely used whenever; /// the type is encountered.; ///; /// A Recursive entry will have all of its sub-members expanded as fully as; /// possible. The type itself is recursive and it may contain other types which; /// are recursive. The Recursive encoding must not be used during the expansion; /// of a recursive type's recursive branch. For simplicity the code uses; /// IncompleteCount to reject all usage of Recursive encodings for member types.; ///; /// An Incomplete entry is always a RecordType and only encodes its; /// identifier e.g. ""s(S){}"". Incomplete 'StubEnc' entries are ephemeral and; /// are placed into the cache during type expansion as a means to identify and; /// handle recursive inclusion of types as sub-members. If there is recursion; /// the entry becomes IncompleteUsed.; ///; /// During the expansion of a RecordType's members:; ///; /// If the cache contains a NonRecursive encoding for the member type, the; /// cached encoding is used;; ///; /// If the cache contains a Recursive encoding for the member type, the; /// cached encoding is 'Swapped' out, as it may be incorrect, and...; ///; /// If the member is a RecordType, an Incomplete encoding is placed into the; /// cache to break potential recursive inclusion of itself as a s",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp:734,safe,safely,734,interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/Targets/XCore.cpp,1,['safe'],['safely']
Safety,/// Types of redundant parentheses to remove.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h:13,redund,redundant,13,interpreter/llvm-project/clang/include/clang/Format/Format.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Format/Format.h,1,['redund'],['redundant']
Safety,"/// UnescapeAliasString - Supports literal braces in InstAlias asm string which; /// are escaped with '\\' to avoid being interpreted as variants. Braces must; /// be unescaped before c++ code is generated as (e.g.):; ///; /// AsmString = ""foo \{$\x01\}"";; ///; /// causes non-standard escape character warnings.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp:110,avoid,avoid,110,interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/AsmWriterEmitter.cpp,1,['avoid'],['avoid']
Safety,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:422,avoid,avoid,422,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,1,['avoid'],['avoid']
Safety,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable is equivalent to a GOT table entry; it contains the; /// the address of another symbol. Optimize it and replace accesses to these; /// ""GOT equivalents"" by using the GOT entry for the final global instead.; /// Compute GOT equivalent candidates among all global variables to avoid; /// emitting them if possible later on, after it use is replaced by a GOT entry; /// access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp:373,avoid,avoid,373,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/AsmPrinter.cpp,1,['avoid'],['avoid']
Safety,/// Unreachable-terminating branch taken probability.; ///; /// This is the probability for a branch being taken to a block that terminates; /// (eventually) in unreachable. These are predicted as unlikely as possible.; /// All reachable probability will proportionally share the remaining part.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp:184,predict,predicted,184,interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/BranchProbabilityInfo.cpp,1,['predict'],['predicted']
Safety,/// Unresolvable conflict. Abort the join.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp:27,Abort,Abort,27,interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RegisterCoalescer.cpp,1,['Abort'],['Abort']
Safety,/// Unsafe stack alignment. Each stack frame must ensure that the stack is; /// aligned to this value. We need to re-align the unsafe stack if the; /// alignment of any object on the stack exceeds this value.; ///; /// 16 seems like a reasonable upper bound on the alignment of objects that we; /// might expect to appear on the stack on most common targets.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:4,Unsafe,Unsafe,4,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,2,"['Unsafe', 'unsafe']","['Unsafe', 'unsafe']"
Safety,"/// UnsafeFPMath - This flag is enabled when the; /// -enable-unsafe-fp-math flag is specified on the command line. When; /// this flag is off (the default), the code generator is not allowed to; /// produce results that are ""less precise"" than IEEE allows. This includes; /// use of X86 instructions like FSIN and FCOS instead of libcalls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h:4,Unsafe,UnsafeFPMath,4,interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Target/TargetOptions.h,2,"['Unsafe', 'unsafe']","['UnsafeFPMath', 'unsafe-fp-math']"
Safety,"/// Update or overwrite the value starting at \p Offset with \c C.; ///; /// \param AllowOverwrite If \c true, this constant might overwrite (part of); /// a constant that has already been added. This flag is only used to; /// detect bugs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp:227,detect,detect,227,interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGExprConstant.cpp,1,['detect'],['detect']
Safety,/// Update the Save and Restore points such that \p MBB is in; /// the region that is dominated by Save and post-dominated by Restore; /// and Save and Restore still match the safe point definition.; /// Such point may not exist and Save and/or Restore may be null after; /// this call.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp:176,safe,safe,176,interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ShrinkWrap.cpp,1,['safe'],['safe']
Safety,"/// Update the branch weights of an exiting block of a peeled-off loop; /// iteration.; /// Let F is a weight of the edge to continue (fallthrough) into the loop.; /// Let E is a weight of the edge to an exit.; /// F/(F+E) is a probability to go to loop and E/(F+E) is a probability to; /// go to exit.; /// Then, Estimated ExitCount = F / E.; /// For I-th (counting from 0) peeled off iteration we set the weights for; /// the peeled exit as (EC - I, 1). It gives us reasonable distribution,; /// The probability to go to exit 1/(EC-I) increases. At the same time; /// the estimated exit count in the remainder loop reduces by I.; /// To avoid dealing with division rounding we can just multiple both part; /// of weights to E and use weight as (F - I * E, E).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:639,avoid,avoid,639,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,1,['avoid'],['avoid']
Safety,/// Updates the current safety status with \p S. We can go from Safe to; /// either PossiblySafeWithRtChecks or Unsafe and from; /// PossiblySafeWithRtChecks to Unsafe.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:24,safe,safety,24,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,4,"['Safe', 'Unsafe', 'safe']","['Safe', 'Unsafe', 'safety']"
Safety,/// Use a SmallVector to hold the elements here (even though it will never; /// reach its 'large' stage) to avoid calling the default ctors of elements; /// we will never use.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h:108,avoid,avoid,108,interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/SmallSet.h,1,['avoid'],['avoid']
Safety,/// Use of registers held in unsigned integer variables (or more rarely signed; /// integers) is no longer permitted to avoid ambiguity with upcoming support; /// for immediates.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h:120,avoid,avoid,120,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalISel/MachineIRBuilder.h,1,['avoid'],['avoid']
Safety,"/// Use of this should generally be avoided; instead,; /// replaceVariableLocationOp and addVariableLocationOps should be used where; /// possible to avoid creating invalid state.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugProgramInstruction.h:36,avoid,avoided,36,interpreter/llvm-project/llvm/include/llvm/IR/DebugProgramInstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/DebugProgramInstruction.h,4,['avoid'],"['avoid', 'avoided']"
Safety,"/// Use predicate to control both data and control flow, but modify; /// the trip count so that a runtime overflow check can be avoided; /// and such that the scalar epilogue loop can always be removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:128,avoid,avoided,128,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,1,['avoid'],['avoided']
Safety,"/// Use the CC1 tool callback when available, to avoid creating a new process",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Job.h:49,avoid,avoid,49,interpreter/llvm-project/clang/include/clang/Driver/Job.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Job.h,1,['avoid'],['avoid']
Safety,"/// Used to create reference output with the ""safe"" backend, if reference output; /// is not provided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp:46,safe,safe,46,interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/ExecutionDriver.cpp,1,['safe'],['safe']
Safety,"/// Used to create reference output with the ""safe"" backend, if reference; /// output is not provided. If there is a problem with the code generator; /// (e.g., llc crashes), this will return false and set Error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:46,safe,safe,46,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['safe'],['safe']
Safety,/// Used to detect recursive macro expansions.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp:12,detect,detect,12,interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/Syntax/Tokens.cpp,1,['detect'],['detect']
Safety,"/// Uses the ""source_filename"" instead of a Module hash ID for the suffix of; /// promoted locals during LTO. NOTE: This requires that the source filename; /// has a unique name / path to avoid name collisions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:188,avoid,avoid,188,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,1,['avoid'],['avoid']
Safety,/// Uses the CodeGenModule mangled name cache and avoids recomputing.; ///\returns the mangled name of a \c GD.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h:50,avoid,avoids,50,interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Interpreter/IncrementalParser.h,1,['avoid'],['avoids']
Safety,"/// VEX_L - Stands for a bit in the VEX opcode prefix meaning the current; /// instruction uses 256-bit wide registers. This is usually auto detected; /// if a VR256 register is used, but some AVX instructions also have this; /// field marked when using a f256 memory references.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h:141,detect,detected,141,interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/MCTargetDesc/X86BaseInfo.h,1,['detect'],['detected']
Safety,"/// VRRC = VADD_SPLAT Elt, EltSize - Temporary node to be expanded; /// during instruction selection to optimize a BUILD_VECTOR into; /// operations on splats. This is necessary to avoid losing these; /// optimizations due to constant folding.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h:181,avoid,avoid,181,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCISelLowering.h,1,['avoid'],['avoid']
Safety,"/// ValidForkedDiamond - Returns true if the 'true' and 'false' blocks (along; /// with their common predecessor) form a diamond if a common tail block is; /// extracted.; /// While not strictly a diamond, this pattern would form a diamond if; /// tail-merging had merged the shared tails.; /// EBB; /// _/ \_; /// | |; /// TBB FBB; /// / \ / \; /// FalseBB TrueBB FalseBB; /// Currently only handles analyzable branches.; /// Specifically excludes actual diamonds to avoid overlap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp:468,avoid,avoid,468,interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/IfConversion.cpp,1,['avoid'],['avoid']
Safety,"/// VarStreamArrayExtractor is intended to be specialized to provide customized; /// extraction logic. On input it receives a BinaryStreamRef pointing to the; /// beginning of the next record, but where the length of the record is not yet; /// known. Upon completion, it should return an appropriate Error instance if; /// a record could not be extracted, or if one could be extracted it should; /// return success and set Len to the number of bytes this record occupied in; /// the underlying stream, and it should fill out the fields of the value type; /// Item appropriately to represent the current record.; ///; /// You can specialize this template for your own custom value types to avoid; /// having to specify a second template argument to VarStreamArray (documented; /// below).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamArray.h:689,avoid,avoid,689,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamArray.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamArray.h,1,['avoid'],['avoid']
Safety,"/// Vectorize a single entry in the tree, the \p Idx-th operand of the entry; /// \p E.; /// \param PostponedPHIs true, if need to postpone emission of phi nodes to; /// avoid issues with def-use order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:170,avoid,avoid,170,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,"/// Vectorize a single entry in the tree.; /// \param PostponedPHIs true, if need to postpone emission of phi nodes to; /// avoid issues with def-use order.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp:124,avoid,avoid,124,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp,1,['avoid'],['avoid']
Safety,/// VerifySDNode - Check the given SDNode. Aborts if it is invalid.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp:43,Abort,Aborts,43,interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SelectionDAG/SelectionDAG.cpp,1,['Abort'],['Aborts']
Safety,/// Version of MapMetadata with type safety for MDNode.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:37,safe,safety,37,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,1,['safe'],['safety']
Safety,/// Version of MapValue with type safety for Constant.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h:34,safe,safety,34,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/ValueMapper.h,1,['safe'],['safety']
Safety,"/// Visit the children of the given cursor.; ///; /// \returns true if the visitation should be aborted, false if it; /// should continue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:96,abort,aborted,96,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['abort'],['aborted']
Safety,"/// Visit the given cursor and, if requested by the visitor,; /// its children.; ///; /// \param Cursor the cursor to visit.; ///; /// \param CheckedRegionOfInterest if true, then the caller already checked; /// that this cursor is within the region of interest.; ///; /// \returns true if the visitation should be aborted, false if it; /// should continue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp:315,abort,aborted,315,interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/tools/libclang/CIndex.cpp,1,['abort'],['aborted']
Safety,"/// VisitedVirtualBases - A set of all the visited virtual bases, used to; /// avoid visiting virtual bases more than once.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp:79,avoid,avoid,79,interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/RecordLayoutBuilder.cpp,1,['avoid'],['avoid']
Safety,/// Visits the symbols reachable from the given SVal using the provided; /// SymbolVisitor.; ///; /// This is a convenience API. Consider using ScanReachableSymbols class; /// directly when making multiple scans on the same state with the same; /// visitor to avoid repeated initialization cost.; /// \sa ScanReachableSymbols,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h:260,avoid,avoid,260,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h,1,['avoid'],['avoid']
Safety,"/// Walk the specified region of the CFG (defined by all blocks; /// dominated by the specified block, and that are in the current loop) in depth; /// first order w.r.t the DominatorTree. This allows us to visit definitions; /// before uses, allowing us to hoist a loop body in one pass without iteration.; /// Takes DomTreeNode, AAResults, LoopInfo, DominatorTree,; /// TargetLibraryInfo, Loop, AliasSet information for all; /// instructions of the loop and loop safety information as arguments.; /// Diagnostics is emitted via \p ORE. It returns changed status.; /// \p AllowSpeculation is whether values should be hoisted even if they are not; /// guaranteed to execute in the loop, but are safe to speculatively execute.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:464,safe,safety,464,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,2,['safe'],"['safe', 'safety']"
Safety,"/// Walk the specified region of the CFG (defined by all blocks; /// dominated by the specified block, and that are in the current loop) in; /// reverse depth first order w.r.t the DominatorTree. This allows us to visit; /// uses before definitions, allowing us to sink a loop body in one pass without; /// iteration. Takes DomTreeNode, AAResults, LoopInfo, DominatorTree,; /// TargetLibraryInfo, Loop, AliasSet information for all; /// instructions of the loop and loop safety information as; /// arguments. Diagnostics is emitted via \p ORE. It returns changed status.; /// \p CurLoop is a loop to do sinking on. \p OutermostLoop is used only when; /// this function is called by \p sinkRegionForLoopNest.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h:471,safe,safety,471,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/LoopUtils.h,1,['safe'],['safety']
Safety,/// Warning gadgets correspond to unsafe code patterns that warrants; /// an immediate warning.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp:34,unsafe,unsafe,34,interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Analysis/UnsafeBufferUsage.cpp,1,['unsafe'],['unsafe']
Safety,/// We don't want to treat 'case x : y' as a potential typo for 'case x::y'.; /// Disable this form of error recovery while we're parsing the case; /// expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp:109,recover,recovery,109,interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Parse/ParseStmt.cpp,1,['recover'],['recovery']
Safety,"/// We explicitly compute and set the unsafe stack layout for all unsafe; /// static alloca instructions. We save the unsafe ""base pointer"" in the; /// prologue into a local variable and restore it in the epilogue.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp:38,unsafe,unsafe,38,interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SafeStack.cpp,3,['unsafe'],['unsafe']
Safety,"/// We have an expression of the form (A & C) | (B & D). If A is a scalar or; /// vector composed of all-zeros or all-ones values and is the bitwise 'not' of; /// B, it can be used as the condition operand of a select instruction.; /// We will detect (A & C) | ~(B | D) when the flag ABIsTheSame enabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp:244,detect,detect,244,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp,1,['detect'],['detect']
Safety,"/// We need to preserve static reachibility of all loop exit blocks (this is); /// required by loop pass manager. In order to do it, we make the following; /// trick:; ///; /// preheader:; /// <preheader code>; /// br label %loop_header; ///; /// loop_header:; /// ...; /// br i1 false, label %dead_exit, label %loop_block; /// ...; ///; /// We cannot simply remove edge from the loop to dead exit because in this; /// case dead_exit (and its successors) may become unreachable. To avoid that,; /// we insert the following fictive preheader:; ///; /// preheader:; /// <preheader code>; /// switch i32 0, label %preheader-split,; /// [i32 1, label %dead_exit_1],; /// [i32 2, label %dead_exit_2],; /// ...; /// [i32 N, label %dead_exit_N],; ///; /// preheader-split:; /// br label %loop_header; ///; /// loop_header:; /// ...; /// br i1 false, label %dead_exit_N, label %loop_block; /// ...; ///; /// Doing so, we preserve static reachibility of all dead exits and can later; /// remove edges from the loop to these blocks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp:482,avoid,avoid,482,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopSimplifyCFG.cpp,1,['avoid'],['avoid']
Safety,"/// We only fold functions with finite arguments. Folding NaN and inf is; /// likely to be aborted with an exception anyway, and some host libms; /// have known errors raising exceptions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp:91,abort,aborted,91,interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Analysis/ConstantFolding.cpp,1,['abort'],['aborted']
Safety,"/// We store a pointer to the ASTContext in the UninitializedLatest; /// pointer, but to avoid circular type dependencies when we steal the low; /// bits of this pointer, we use a raw void* here.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h:89,avoid,avoid,89,interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Redeclarable.h,1,['avoid'],['avoid']
Safety,"/// We use a simple cost model for edit actions, which seems good enough.; /// Simple cost model for edit actions. This seems to make the matching; /// algorithm perform reasonably well.; /// The values range between 0 and 1, or infinity if this edit action should; /// always be avoided.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp:280,avoid,avoided,280,interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Tooling/ASTDiff/ASTDiff.cpp,1,['avoid'],['avoided']
Safety,"/// We want to produce a diagnostic at location IncLoc concerning an; /// unreachable effect at location MLoc (eg, where a desired entity was; /// declared or defined). Determine whether the right way to make MLoc; /// reachable is by #include, and if so, what header should be included.; ///; /// This is not necessarily fast, and might load unexpected module maps, so; /// should only be called by code that intends to produce an error.; ///; /// \param IncLoc The location at which the missing effect was detected.; /// \param MLoc A location within an unimported module at which the desired; /// effect occurred.; /// \return A file that can be #included to provide the desired effect. Null; /// if no such file could be determined or if a #include is not; /// appropriate (eg, if a module should be imported instead).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:508,detect,detected,508,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['detect'],['detected']
Safety,/// We'll reuse the same UniqueMachineInstr to avoid the new; /// allocation.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp:47,avoid,avoid,47,interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/GlobalISel/CSEInfo.cpp,1,['avoid'],['avoid']
Safety,"/// Weak VHs to keep track of indirect calls for the purposes of detecting; /// devirtualization.; ///; /// This is a map to avoid having duplicate entries. If a Value is; /// deallocated, its corresponding WeakTrackingVH will be nulled out. When; /// checking if a Value is in the map or not, also check if the corresponding; /// WeakTrackingVH is null to avoid issues with a new Value sharing the same; /// address as a deallocated one.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h:65,detect,detecting,65,interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CGSCCPassManager.h,3,"['avoid', 'detect']","['avoid', 'detecting']"
Safety,"/// When adding a pass manager pass that has the same type as this pass; /// manager, simply move the passes over. This is because we don't have use; /// cases rely on executing nested pass managers. Doing this could reduce; /// implementation complexity and avoid potential invalidation issues that may; /// happen with nested pass managers of the same type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h:259,avoid,avoid,259,interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/PassManager.h,1,['avoid'],['avoid']
Safety,"/// When an instruction is found to only use loop invariant operands that is; /// safe to hoist, this instruction is called to do the dirty work.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:82,safe,safe,82,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['safe'],['safe']
Safety,"/// When an instruction is found to only use loop invariant operands that; /// is safe to hoist, this instruction is called to do the dirty work.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp:82,safe,safe,82,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LICM.cpp,1,['safe'],['safe']
Safety,"/// When an instruction is found to use only loop invariant operands; /// that are safe to hoist, this instruction is called to do the dirty work.; /// It returns true if the instruction is hoisted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp:83,safe,safe,83,interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineLICM.cpp,1,['safe'],['safe']
Safety,"/// When emitting an object file, create and emit a real label. When emitting; /// textual assembly, this should do nothing to avoid polluting our output.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h:127,avoid,avoid,127,interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/MC/MCStreamer.h,1,['avoid'],['avoid']
Safety,"/// When enabling loop hints are provided we allow the vectorizer to change; /// the order of operations that is given by the scalar loop. This is not; /// enabled by default because can be unsafe or inefficient. For example,; /// reordering floating-point operations will change the way round-off; /// error accumulates in the loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h:190,unsafe,unsafe,190,interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Vectorize/LoopVectorizationLegality.h,1,['unsafe'],['unsafe']
Safety,"/// When printing type to be inserted into code in specific context, this; /// callback can be used to avoid printing the redundant part of the; /// qualifier. For example, when inserting code inside namespace foo, we; /// should print bar::SomeType instead of foo::bar::SomeType.; /// To do this, shouldPrintScope should return true on ""foo"" NamespaceDecl.; /// The printing stops at the first isScopeVisible() == true, so there will; /// be no calls with outer scopes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/PrettyPrinter.h:103,avoid,avoid,103,interpreter/llvm-project/clang/include/clang/AST/PrettyPrinter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/PrettyPrinter.h,2,"['avoid', 'redund']","['avoid', 'redundant']"
Safety,"/// When the MSVC runtime transfers control to us, either to an outlined; /// function or when returning to a parent frame after catching an exception, we; /// recover the parent frame pointer by doing arithmetic on the incoming EBP.; /// Here's the math:; /// RegNodeBase = EntryEBP - RegNodeSize; /// ParentFP = RegNodeBase - ParentFrameOffset; /// Subtracting RegNodeSize takes us to the offset of the registration node, and; /// subtracting the offset (negative on x86) takes us back to the parent FP.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp:160,recover,recover,160,interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86ISelLowering.cpp,1,['recover'],['recover']
Safety,"/// When we have an undecorated call, just emit it without adding; /// the unsafeClaim.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp:75,unsafe,unsafeClaim,75,interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CGObjC.cpp,1,['unsafe'],['unsafeClaim']
Safety,"/// When we have more than 1 ImmediateInvocationCandidates or previously; /// failed immediate invocations, we need to check for nested; /// ImmediateInvocationCandidates in order to avoid duplicate diagnostics.; /// Otherwise we only need to remove ReferenceToConsteval in the immediate; /// invocation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp:183,avoid,avoid,183,interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaExpr.cpp,1,['avoid'],['avoid']
Safety,/// Whether any divergence was detected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityInfo.h:31,detect,detected,31,interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/GenericUniformityInfo.h,1,['detect'],['detected']
Safety,/// Whether the field declarations of this record have been loaded; /// from external storage. To avoid unnecessary deserialization of; /// methods/nested types we allow deserialization of just the fields; /// when needed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:98,avoid,avoid,98,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['avoid'],['avoid']
Safety,"/// Whether the transformation should always rebuild AST nodes, even; /// if none of the children have changed.; ///; /// Subclasses may override this function to specify when the transformation; /// should rebuild all AST nodes.; ///; /// We must always rebuild all AST nodes when performing variadic template; /// pack expansion, in order to avoid violating the AST invariant that each; /// statement node appears at most once in its containing declaration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h:344,avoid,avoid,344,interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/TreeTransform.h,1,['avoid'],['avoid']
Safety,"/// Whether this function has an extended frame record [Ctx, FP, LR]. If so,; /// bit 60 of the in-memory FP will be 1 to enable other tools to detect the; /// extended record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.h:144,detect,detect,144,interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AArch64/AArch64MachineFunctionInfo.h,1,['detect'],['detect']
Safety,"/// Whether this function has an extended frame record [Ctx, RBP, Return; /// addr]. If so, bit 60 of the in-memory frame pointer will be 1 to enable; /// other tools to detect the extended record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h:170,detect,detect,170,interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86MachineFunctionInfo.h,1,['detect'],['detect']
Safety,"/// Whether this type; /// - is a dependent type (C++ [temp.dep.type]); /// - or it somehow involves an error, e.g. decltype(recovery-expr)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h:125,recover,recovery-expr,125,interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DependenceFlags.h,1,['recover'],['recovery-expr']
Safety,/// Whether to abort fixing a file when not all errors could be fixed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h:15,abort,abort,15,interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Frontend/FixItRewriter.h,1,['abort'],['abort']
Safety,"/// Whether we allow for extra compile-time budget to perform more; /// analysis to be more informative.; ///; /// This is useful to enable additional missed optimizations to be reported; /// that are normally too noisy. In this mode, we can use the extra analysis; /// (1) to filter trivial false positives or (2) to provide more context so; /// that non-trivial false positives can be quickly detected by the user.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h:395,detect,detected,395,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineOptimizationRemarkEmitter.h,1,['detect'],['detected']
Safety,/// Whether we allow for extra compile-time budget to perform more; /// analysis to produce fewer false positives.; ///; /// This is useful when reporting missed optimizations. In this case we can; /// use the extra analysis (1) to filter trivial false positives or (2) to; /// provide more context so that non-trivial false positives can be quickly; /// detected by the user.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:355,detect,detected,355,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,1,['detect'],['detected']
Safety,/// Whether we are allowed to insert extra padding between fields.; /// These padding are added to help AddressSanitizer detect; /// intra-object-overflow bugs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h:121,detect,detect,121,interpreter/llvm-project/clang/include/clang/AST/Decl.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Decl.h,1,['detect'],['detect']
Safety,/// Whether we are detecting virtual bases.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h:19,detect,detecting,19,interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h,1,['detect'],['detecting']
Safety,/// Whether we are finding multiple paths to detect ambiguities.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h:45,detect,detect,45,interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/CXXInheritance.h,1,['detect'],['detect']
Safety,/// Whether we hit an error due to reaching max allowed include depth. Allows; /// to avoid hitting the same error over and over again.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h:86,avoid,avoid,86,interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Preprocessor.h,1,['avoid'],['avoid']
Safety,/// Whether we should abort immediately instead of resetting the function.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ResetMachineFunctionPass.cpp:22,abort,abort,22,interpreter/llvm-project/llvm/lib/CodeGen/ResetMachineFunctionPass.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ResetMachineFunctionPass.cpp,1,['abort'],['abort']
Safety,"/// Which attributes cannot be applied to a type. The argument \p ASK indicates,; /// if only attributes that are known to be safely droppable are contained in; /// the mask; only attributes that might be unsafe to drop (e.g., ABI-related; /// attributes) are in the mask; or both.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h:126,safe,safely,126,interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Attributes.h,2,"['safe', 'unsafe']","['safely', 'unsafe']"
Safety,"/// While we could just interpret the enums as ints, we make the translation explicit; /// in order to avoid accidentally changing the on-disk numbers when adjusting the enum classes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx:103,avoid,avoid,103,tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleSerialize.hxx,1,['avoid'],['avoid']
Safety,"/// Wrap an object into a TObject. Sometimes needed to avoid reinterpret_cast or enable RTTI.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHelpers.h:55,avoid,avoid,55,roofit/roofitcore/inc/RooHelpers.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooHelpers.h,1,['avoid'],['avoid']
Safety,"/// Wrap the integer in a struct in order to avoid template specialization clash with std::uint64_t",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx:45,avoid,avoid,45,tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/inc/ROOT/RNTupleUtil.hxx,1,['avoid'],['avoid']
Safety,/// Wrapper function around std::equal to detect if pair-wise elements between; /// two ranges are the same.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:42,detect,detect,42,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['detect'],['detect']
Safety,/// Write to \p Stream the result of applying all changes to the; /// original buffer.; /// Note that it isn't safe to use this function to overwrite memory mapped; /// files in-place (PR17960). Consider using a higher-level utility such as; /// Rewriter::overwriteChangedFiles() instead.; ///; /// The original buffer is not actually changed.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Core/RewriteBuffer.h:111,safe,safe,111,interpreter/llvm-project/clang/include/clang/Rewrite/Core/RewriteBuffer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Rewrite/Core/RewriteBuffer.h,1,['safe'],['safe']
Safety,"/// Writes an array of objects of type T to the underlying stream, as if by; /// using memcpy. It is up to the caller to ensure that type of \p Obj can; /// be safely copied in this fashion, as no checks are made to ensure that; /// this is safe.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:160,safe,safely,160,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['safe'],"['safe', 'safely']"
Safety,"/// Writes the object \p Obj to the underlying stream, as if by using memcpy.; /// It is up to the caller to ensure that type of \p Obj can be safely copied; /// in this fashion, as no checks are made to ensure that this is safe.; ///; /// \returns a success error code if the data was successfully written,; /// otherwise returns an appropriate error code.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h:143,safe,safely,143,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamWriter.h,2,['safe'],"['safe', 'safely']"
Safety,"/// X = FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating point type; /// down to the precision of the destination VT. TRUNC is a flag, which is; /// always an integer that is zero or one. If TRUNC is 0, this is a; /// normal rounding, if it is 1, this FP_ROUND is known to not change the; /// value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// FP_EXTEND(FP_ROUND(X,1)) -> X which are not safe for; /// FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:588,safe,safe,588,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['safe'],['safe']
Safety,"/// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating; /// point type down to the precision of the destination VT. TRUNC is a; /// flag, which is always an integer that is zero or one. If TRUNC is 0,; /// this is a normal rounding, if it is 1, this FP_ROUND is known to not; /// change the value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't; /// removed.; /// It is used to limit optimizations while the DAG is being optimized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:609,safe,safe,609,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,1,['safe'],['safe']
Safety,"/// Zippy iterator that uses the second iterator for comparisons. For the; /// increment to be safe, the second range has to be the shortest.; /// Returns `enumerator_result` on dereference to provide `.index()` and; /// `.value()` member functions.; /// Note: Because the dereference operator returns `enumerator_result` as a; /// value instead of a reference and does not strictly conform to the C++17's; /// definition of forward iterator. However, it satisfies all the; /// forward_iterator requirements that the `zip_common` and `zippy` depend on; /// and fully conforms to the C++20 definition of forward iterator.; /// This is similar to `std::vector<bool>::iterator` that returns bit reference; /// wrappers on dereference.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h:95,safe,safe,95,interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/STLExtras.h,1,['safe'],['safe']
Safety,"/// \brief Allows a user function to catch and filter/analyse ROOT and cling diagnostics, e.g.; /// ```c++; /// FilterDiagsRAII RAII([] (int level, Bool_t abort,; /// const char *location, const char *msg) {; /// EXPECT_THAT(msg, Not(HasSubstr(""-Wunused-result"")));; /// });; /// ```",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/inc/ROOT/TestSupport.hxx:155,abort,abort,155,core/testsupport/inc/ROOT/TestSupport.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/testsupport/inc/ROOT/TestSupport.hxx,1,['abort'],['abort']
Safety,"/// \brief Asserts that the given transaction is not null, otherwise prints a; /// stack trace to stderr and aborts execution.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclCollector.cpp:109,abort,aborts,109,interpreter/cling/lib/Interpreter/DeclCollector.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DeclCollector.cpp,1,['abort'],['aborts']
Safety,"/// \brief Create a TChain object with options that avoid common causes of thread contention.; ///; /// In particular, set its kWithoutGlobalRegistration mode and reset its kMustCleanup bit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx:52,avoid,avoid,52,tree/tree/src/InternalTreeUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/InternalTreeUtils.cxx,1,['avoid'],['avoid']
Safety,"/// \brief Enable support for multi-threading within the ROOT code; /// in particular, enables the global mutex to make ROOT thread safe/aware.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TROOT.h:132,safe,safe,132,core/base/inc/TROOT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TROOT.h,1,['safe'],['safe']
Safety,"/// \brief Hide a global declaration from SemaLookup; internally used in; /// `invalidatePreviousDefinitions()'. This directly manipulates lookup; /// tables to avoid a patch to Clang.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DefinitionShadower.h:161,avoid,avoid,161,interpreter/cling/lib/Interpreter/DefinitionShadower.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DefinitionShadower.h,1,['avoid'],['avoid']
Safety,"/// \brief If enabled, allow AMDGPU unsafe floating point atomics.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetOptions.h:36,unsafe,unsafe,36,interpreter/llvm-project/clang/include/clang/Basic/TargetOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Basic/TargetOptions.h,1,['unsafe'],['unsafe']
Safety,"/// \brief In order to implement the runtime type binding and expression; /// evaluation we need to be able to compile code which contains unknown; /// symbols (undefined variables, types, functions, etc.). This cannot be done; /// by a compiler like clang, because it is not valid C++ code.; ///; /// DynamicExprTransformer transforms these unknown symbols into valid C++; /// code at AST (abstract syntax tree) level. Thus it provides an opportunity; /// their evaluation to happen at runtime. Several steps are performed:; ///; /// 1. Skip compiler's error diagnostics - if a compiler encounters unknown; /// symbol, by definition, it must output an error and it mustn't produce; /// machine code. Cling implements an extension to Clang semantic analyzer; /// that allows the compiler to recover even an unknown symbol is encountered.; /// For instance if the compiler sees a symbol it looks for its definition in; /// a internal structure (symbol table) and it is not found it asks whether; /// somebody else could provide the missing symbol. That is the place where; /// the DynamicIDHandler, which is controlled by DynamicExprTransformer comes; /// into play. It marks all unknown symbols as dependent as if they are; /// templates and are going to be resolved at first instantiation, with the; /// only difference that an instantiation never happens. The advantage is that; /// the unknown symbols are not diagnosed but the disadvantage is that; /// somebody needs to transform them into valid expressions with valid types.; ///; /// 2. Replace all dependent symbols - all artificially dependent symbols need; /// to be replaced with appropriate valid symbols in order the compiler to; /// produce executable machine code. The DynamicExprTransformer walks up all; /// statements and declarations that might be possibly marked earlier as; /// dependent and replaces them with valid expression, which preserves the; /// meant behavior. Main implementation goal is to replace the as little; /// as",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.h:791,recover,recover,791,interpreter/cling/lib/Interpreter/DynamicLookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.h,1,['recover'],['recover']
Safety,"/// \brief LifetimeHandler is used in case of initialization using address; /// on the automatic store (stack) instead of EvaluateT.; ///; /// The reason is to avoid the copy constructors that might be private.; /// This is part of complex transformation, which aims to preserve the; /// code behavior. For example:; /// @code; /// int i = 5;; /// MyClass my(dep->Symbol(i)); /// @endcode; /// where dep->Symbol() is a symbol not known at compile-time; /// transformed into:; /// @code; /// cling::runtime::internal::LifetimeHandler; /// __unique(""dep->Sybmol(*(int*)@)"",(void*[]){&i}, DC, ""MyClass"");; /// MyClass &my(*(MyClass*)__unique.getMemory());; /// @endcode",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLookupLifetimeHandler.h:160,avoid,avoid,160,interpreter/cling/include/cling/Interpreter/DynamicLookupLifetimeHandler.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/include/cling/Interpreter/DynamicLookupLifetimeHandler.h,1,['avoid'],['avoid']
Safety,"/// \brief Parses a requires clause.; /// \param RequiresToken The requires keyword token, which starts this clause.; /// \pre We need to be on the next token after the requires keyword.; /// \sa parseRequiresExpression; ///; /// Returns if it either has finished parsing the clause, or it detects, that; /// the clause is incorrect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:290,detect,detects,290,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['detect'],['detects']
Safety,"/// \brief Parses a requires expression.; /// \param RequiresToken The requires keyword token, which starts this clause.; /// \pre We need to be on the next token after the requires keyword.; /// \sa parseRequiresClause; ///; /// Returns if it either has finished parsing the expression, or it detects,; /// that the expression is incorrect.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp:294,detect,detects,294,interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Format/UnwrappedLineParser.cpp,1,['detect'],['detects']
Safety,"/// \brief Provides last resort lookup for failed unqualified lookups.; ///; /// This gets translated into InterpreterCallback's call.; ///; ///\param[out] R The recovered symbol.; ///\param[in] S The scope in which the lookup failed.; ///; ///\returns true if a suitable declaration is found.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp:162,recover,recovered,162,interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/InterpreterCallbacks.cpp,1,['recover'],['recovered']
Safety,"/// \brief Register systematic variations for for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] nVariations number of variations returned by the expression. The corresponding tags will be `""0""`,; /// `""1""`, etc. ; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; /// is avoided.; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:1083,avoid,avoided,1083,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['avoid'],['avoided']
Safety,"/// \brief Register systematic variations for multiple existing columns using auto-generated variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a string containing valid C++ code that evaluates to an RVec containing the varied; /// values for the specified column.; /// \param[in] nVariations number of variations returned by the expression. The corresponding tags will be `""0""`,; /// `""1""`, etc. ; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; /// is avoided.; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:751,avoid,avoided,751,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['avoid'],['avoided']
Safety,"/// \brief Register systematic variations for multiple existing columns using custom variation tags.; /// \param[in] colNames set of names of the columns for which varied values are provided.; /// \param[in] expression a callable that evaluates the varied values for the specified columns. The callable can; /// take any column values as input, similarly to what happens during Filter and Define calls. It must; /// return an RVec of varied values, one for each variation tag, in the same order as the tags.; /// \param[in] inputColumns the names of the columns to be passed to the callable.; /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; /// colName is used if none is provided.; ///; /// \note This overload ensures that the ambiguity between C++20 string, vector<string> construction from init list; /// is avoided.; ///; /// \sa This Vary() overload for more information.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx:955,avoid,avoided,955,tree/dataframe/inc/ROOT/RDF/RInterface.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/dataframe/inc/ROOT/RDF/RInterface.hxx,1,['avoid'],['avoided']
Safety,"/// \brief The result of a constraint satisfaction check, containing the; /// necessary information to diagnose an unsatisfied constraint.; ///; /// This is safe to store in an AST node, as opposed to ConstraintSatisfaction.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTConcept.h:157,safe,safe,157,interpreter/llvm-project/clang/include/clang/AST/ASTConcept.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/ASTConcept.h,1,['safe'],['safe']
Safety,"/// \brief Transforms a declaration with initializer of dependent type.; /// If an object on the free store is being initialized we use the; /// EvaluateT; /// If an object on the stack is being initialized it is transformed into; /// reference and an object on the free store is created in order to; /// avoid the copy constructors, which might be private; ///; /// For example:; /// @code; /// int i = 5;; /// MyClass my(dep->Symbol(i)); /// @endcode; /// where dep->Symbol() is of artificially dependent type it is being; /// transformed into:; /// @code; /// cling::runtime::internal::LifetimeHandler; /// __unique(""dep->Sybmol(*(int*)@)"",(void*[]){&i}, DC, ""MyClass"");; /// MyClass &my(*(MyClass*)__unique.getMemory());; /// @endcode; ///; /// Note: here our main priority is to preserve equivalent behavior. We have; /// to clean the heap memory afterwords.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.h:305,avoid,avoid,305,interpreter/cling/lib/Interpreter/DynamicLookup.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/cling/lib/Interpreter/DynamicLookup.h,1,['avoid'],['avoid']
Safety,"/// \brief Wrapper over a `void *` that may help to detect the use of invalid handles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx:52,detect,detect,52,tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/ntuple/v7/src/libdaos_mock/libdaos_mock.cxx,1,['detect'],['detect']
Safety,"/// \cond ROOFIT_INTERNAL; /*****************************************************************************; * Project: RooFit *; * Package: RooFitCore *; * @(#)root/roofitcore:$Id$; * Authors: *; * WV, Wouter Verkerke, UC Santa Barbara, verkerke@slac.stanford.edu *; * DK, David Kirkby, UC Irvine, dkirkby@uci.edu *; * *; * Copyright (c) 2000-2005, Regents of the University of California *; * and Stanford University. All rights reserved. *; * *; * Redistribution and use in source and binary forms, *; * with or without modification, are permitted according to the terms *; * listed in LICENSE (http://roofit.sourceforge.net/license.txt) *; *****************************************************************************/; /**; \file RooSentinel.cxx; \class RooSentinel; \ingroup Roofitcore. RooSentinel is a special purpose singleton class that terminates; all other RooFit singleton services when the process exits. All function RooFit singleton services are created on the heap with; a static wrapper function to avoid the 'static initialization order fiasco'; but are not automatically destroyed at the end of the session. This class; installs an atexit() function that takes care of this; **/",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSentinel.cxx:1015,avoid,avoid,1015,roofit/roofitcore/src/RooSentinel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSentinel.cxx,1,['avoid'],['avoid']
Safety,"/// \copydoc Sema::CorrectTypo; /// \note LookupKind must correspond to a valid Sema::LookupNameKind; ///; /// ExternalSemaSource::CorrectTypo is always given the first chance to; /// correct a typo (really, to offer suggestions to repair a failed lookup).; /// It will even be called when SpellChecking is turned off or after a; /// fatal error has already been detected.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h:363,detect,detected,363,interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/ExternalSemaSource.h,1,['detect'],['detected']
Safety,/// \file RemoveRedundantDebugValues.cpp; ///; /// The RemoveRedundantDebugValues pass removes redundant DBG_VALUEs that; /// appear in MIR after the register allocator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp:95,redund,redundant,95,interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/RemoveRedundantDebugValues.cpp,1,['redund'],['redundant']
Safety,"/// \return An upper bound for the vectorization factors (both fixed and; /// scalable). If the factors are 0, vectorization and interleaving should be; /// avoided up front.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:157,avoid,avoided,157,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['avoid'],['avoided']
Safety,"/// \return the maximized element count based on the targets vector; /// registers and the loop trip-count, but limited to a maximum safe VF.; /// This is a helper function of computeFeasibleMaxVF.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:133,safe,safe,133,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['safe'],['safe']
Safety,"/// \return the maximum legal scalable VF, based on the safe max number; /// of elements.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:56,safe,safe,56,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp,1,['safe'],['safe']
Safety,/// \returns list of attributes referencing type DIEs which might be; /// deduplicated.; /// Note: it does not include DW_AT_containing_type attribute to avoid; /// infinite recursion.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h:154,avoid,avoid,154,interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/DWARFLinker/Parallel/DWARFLinkerCompileUnit.h,1,['avoid'],['avoid']
Safety,/// \returns the \c ExecutorAddr of a \c GlobalDecl. This interface uses; /// the CodeGenModule's internal mangling cache to avoid recomputing the; /// mangled name.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h:125,avoid,avoid,125,interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Interpreter/Interpreter.h,1,['avoid'],['avoid']
Safety,"/// \returns true to continue indexing, or false to abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/IndexDataConsumer.h:52,abort,abort,52,interpreter/llvm-project/clang/include/clang/Index/IndexDataConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/IndexDataConsumer.h,2,['abort'],['abort']
Safety,"/// \returns true to continue indexing, or false to abort.; ///; /// This will be called for each module reference in an import decl.; /// For ""@import MyMod.SubMod"", there will be a call for 'MyMod' with the; /// 'reference' role, and a call for 'SubMod' with the 'declaration' role.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/IndexDataConsumer.h:52,abort,abort,52,interpreter/llvm-project/clang/include/clang/Index/IndexDataConsumer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Index/IndexDataConsumer.h,1,['abort'],['abort']
Safety,"/// aci_avoid_equal - Many tokens cannot be safely followed by an '='; /// character. For example, ""<<"" turns into ""<<="" when followed by an =.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h:44,safe,safely,44,interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,1,['safe'],['safely']
Safety,"/// aci_custom - AvoidConcat contains custom code to handle this token's; /// requirements, but it doesn't need to know the first character of the; /// token.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h:17,Avoid,AvoidConcat,17,interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,1,['Avoid'],['AvoidConcat']
Safety,"/// aci_custom_firstchar - AvoidConcat contains custom code to handle this; /// token's requirements, and it needs to know the first character of the; /// token.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h:27,Avoid,AvoidConcat,27,interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/TokenConcatenation.h,1,['Avoid'],['AvoidConcat']
Safety,/// addSafePoint - Notes the existence of a safe point. Num is the ID of the; /// label just prior to the safe point (if the code generator is using; /// MachineModuleInfo).,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:44,safe,safe,44,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,2,['safe'],['safe']
Safety,"/// after the setting is changed.; /// In case the file does not exist or is not a valid ROOT file,; /// it is made a Zombie. One can detect this situation with a code like:; /// ~~~{.cpp}; /// TFile f(""file.root"");; /// if (f.IsZombie()) {; /// std::cout << ""Error opening file"" << std::endl;; /// exit(-1);; /// }; /// ~~~; /// If you open a file instead with TFile::Open(""file.root"") use rather; /// the following code as a nullptr is returned.; /// ~~~{.cpp}; /// TFile* f = TFile::Open(""file.root"");; /// if (!f) {; /// std::cout << ""Error opening file"" << std::endl;; /// exit(-1);; /// }; /// ~~~; /// When opening the file, the system checks the validity of this directory.; /// If something wrong is detected, an automatic Recovery is performed. In; /// this case, the file is scanned sequentially reading all logical blocks; /// and attempting to rebuild a correct directory (see TFile::Recover).; /// One can disable the automatic recovery procedure when reading one; /// or more files by setting the environment variable ""TFile.Recover: 0""; /// in the system.rootrc file.; ///; /// A bit `TFile::kReproducible` can be enabled specifying; /// the `""reproducible""` url option when creating the file:; /// ~~~{.cpp}; /// TFile *f = TFile::Open(""name.root?reproducible"",""RECREATE"",""File title"");; /// ~~~; /// Unlike regular `TFile`s, the content of such file has reproducible binary; /// content when writing exactly same data. This achieved by writing pre-defined; /// values for creation and modification date of TKey/TDirectory objects and; /// null value for TUUID objects inside TFile. As drawback, TRef objects stored; /// in such file cannot be read correctly.; ///; /// In case the name of the file is not reproducible either (in case of; /// creating temporary filenames) a value can be passed to the reproducible; /// option to replace the name stored in the file.; /// ~~~{.cpp}; /// TFile *f = TFile::Open(""tmpname.root?reproducible=fixedname"",""RECREATE"",""File title"");; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:5489,Recover,Recover,5489,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['Recover'],['Recover']
Safety,/// an instruction for type-safe pointer arithmetic to; /// access elements of arrays and structs; ///,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h:28,safe,safe,28,interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Instructions.h,1,['safe'],['safe']
Safety,"/// at - Return the entry for the specified key, or abort if no such; /// entry exists.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h:52,abort,abort,52,interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/DenseMap.h,2,['abort'],['abort']
Safety,/// begin/end - Iterators for safe points.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:30,safe,safe,30,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,1,['safe'],['safe']
Safety,"/// binning scheme for the input (detector level)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldDensity.h:34,detect,detector,34,hist/unfold/inc/TUnfoldDensity.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/unfold/inc/TUnfoldDensity.h,1,['detect'],['detector']
Safety,/// buildDefaultInstruction - This function returns a MachineInstr with all; /// the instruction modifiers initialized to their default values. You can; /// use this function to avoid manually specifying each instruction modifier; /// operand when building a new instruction.; ///; /// \returns a MachineInstr with all the instruction modifiers initialized; /// to their default values.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h:178,avoid,avoid,178,interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/AMDGPU/R600InstrInfo.h,1,['avoid'],['avoid']
Safety,"/// canAddPseudoFlagDep - For A9 (and other out-of-order) implementations,; /// the 's' 16-bit instruction partially update CPSR. Abort the; /// transformation to avoid adding false dependency on last CPSR setting; /// instruction which hurts the ability for out-of-order execution engine; /// to do register renaming magic.; /// This function checks if there is a read-of-write dependency between the; /// last instruction that defines the CPSR and the current instruction. If there; /// is, then there is no harm done since the instruction cannot be retired; /// before the CPSR setting instruction anyway.; /// Note, we are not doing full dependency analysis here for the sake of compile; /// time. We're not looking for cases like:; /// r0 = muls ...; /// r1 = add.w r0, ...; /// ...; /// = mul.w r1; /// In this case it would have been ok to narrow the mul.w to muls since there; /// are indirect RAW dependency between the muls and the mul.w",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp:130,Abort,Abort,130,interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/Thumb2SizeReduction.cpp,2,"['Abort', 'avoid']","['Abort', 'avoid']"
Safety,"/// canAssignObjCInterfacesInBlockPointer - This routine is specifically written; /// for providing type-safety for objective-c pointers used to pass/return; /// arguments in block literals. When passed as arguments, passing 'A*' where; /// 'id' is expected is not OK. Passing 'Sub *"" where 'Super *"" is expected is; /// not OK. For the return type, the opposite is not OK.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp:105,safe,safety,105,interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/ASTContext.cpp,1,['safe'],['safety']
Safety,/// canMoveBeforeNode - Return true if it is safe to move the current matcher; /// across the specified one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.cpp:45,safe,safe,45,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.cpp,1,['safe'],['safe']
Safety,/// canMoveBeforeNode - Return true if it is safe to move the current; /// matcher across the specified one.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.h:45,safe,safe,45,interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/DAGISelMatcher.h,1,['safe'],['safe']
Safety,"/// canPatternMatch - If it is impossible for this pattern to match on this; /// target, fill in Reason and return false. Otherwise, return true. This is; /// used as a sanity check for .td files (to prevent people from writing stuff; /// that can never possibly work), and to prevent the pattern permuter from; /// generating stuff that is useless.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp:169,sanity check,sanity check,169,interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenDAGPatterns.cpp,1,['sanity check'],['sanity check']
Safety,"/// canPredicateInstrs - Returns true if all the instructions in MBB can safely; /// be predicates. The terminators are not considered.; ///; /// If instructions use any values that are defined in the head basic block,; /// the defining instructions are added to InsertAfter.; ///; /// Any clobbered regunits are added to ClobberedRegUnits.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp:73,safe,safely,73,interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/EarlyIfConversion.cpp,1,['safe'],['safely']
Safety,/// canReasonAbout - Not all ConstraintManagers can accurately reason about; /// all SVal values. This method returns true if the ConstraintManager can; /// reasonably handle a given SVal value. This is typically queried by; /// ExprEngine to determine if the value should be replaced with a; /// conjured symbolic value in order to recover some precision.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h:333,recover,recover,333,interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ConstraintManager.h,1,['recover'],['recover']
Safety,/// checkSubscript - Helper function for checkSrcSubscript and; /// checkDstSubscript to avoid duplicate code,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h:89,avoid,avoid,89,interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/DependenceAnalysis.h,1,['avoid'],['avoid']
Safety,"/// constructor (protected) to avoid user creating this class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx:31,avoid,avoid,31,math/mathcore/src/IntegratorOptions.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/src/IntegratorOptions.cxx,1,['avoid'],['avoid']
Safety,/// createHybridListDAGScheduler - This creates a bottom up register pressure; /// aware list scheduler that make use of latency information to avoid stalls; /// for long latency instructions in low register pressure mode. In high; /// register pressure mode it schedules to reduce register pressure.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h:144,avoid,avoid,144,interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/SchedulerRegistry.h,1,['avoid'],['avoid']
Safety,"/// debugCodeGenerator - This method narrows down a module to a function or; /// set of functions, using the CBE as a ``safe'' code generator for other; /// functions that are not under consideration.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h:120,safe,safe,120,interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/tools/bugpoint/BugDriver.h,1,['safe'],['safe']
Safety,/// eliminateRedundantSpills - SLI:VNI is known to be on the stack. Remove any; /// redundant spills of this value in SLI.reg and sibling copies.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp:84,redund,redundant,84,interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/InlineSpiller.cpp,1,['redund'],['redundant']
Safety,"/// emitAssembly - Print the frametable. The ocaml frametable format is thus:; ///; /// extern ""C"" struct align(sizeof(intptr_t)) {; /// uint16_t NumDescriptors;; /// struct align(sizeof(intptr_t)) {; /// void *ReturnAddress;; /// uint16_t FrameSize;; /// uint16_t NumLiveOffsets;; /// uint16_t LiveOffsets[NumLiveOffsets];; /// } Descriptors[NumDescriptors];; /// } caml${module}__frametable;; ///; /// Note that this precludes programs from stack frames larger than 64K; /// (FrameSize and LiveOffsets would overflow). FrameTablePrinter will abort if; /// either condition is detected in a function which uses the GC.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp:544,abort,abort,544,interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/AsmPrinter/OcamlGCPrinter.cpp,2,"['abort', 'detect']","['abort', 'detected']"
Safety,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:543,safe,safely,543,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,1,['safe'],['safely']
Safety,"/// findHoistingInsertPosAndDeps - Find the location to move common instructions; /// in successors to. The location is usually just before the terminator,; /// however if the terminator is a conditional branch and its previous; /// instruction is the flag setting instruction, the previous instruction is; /// the preferred location. This function also gathers uses and defs of the; /// instructions from the insertion point to the end of the block. The data is; /// used by HoistCommonCodeInSuccs to ensure safety.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp:509,safe,safety,509,interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/BranchFolding.cpp,1,['safe'],['safety']
Safety,"/// findPHICopyInsertPoint - Find a safe place in MBB to insert a copy from; /// SrcReg when following the CFG edge to SuccMBB. This needs to be after; /// any def of SrcReg, but before any subsequent point where control flow; /// might jump out of the basic block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.h:36,safe,safe,36,interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/PHIEliminationUtils.h,1,['safe'],['safe']
Safety,"/// fpto{s/u}i({u/s}itofp(X)) --> X or zext(X) or sext(X) or trunc(X); /// This is safe if the intermediate type has enough bits in its mantissa to; /// accurately represent all values of X. For example, this won't work with; /// i64 -> float -> i64.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:83,safe,safe,83,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,1,['safe'],['safe']
Safety,/// getDecisionType - Determines whether a ModRM decision with 255 entries can; /// be compacted by eliminating redundant information.; ///; /// @param decision - The decision to be compacted.; /// @return - The compactest available representation for the decision.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.cpp:112,redund,redundant,112,interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/X86DisassemblerTables.cpp,1,['redund'],['redundant']
Safety,"/// getHazardType - Return the hazard type of emitting this node. There are; /// three possible results. Either:; /// * NoHazard: it is legal to issue this instruction on this cycle.; /// * Hazard: issuing this instruction would stall the machine. If some; /// other instruction is available, issue it first.; /// * NoopHazard: issuing this instruction would break the program. If; /// some other instruction can be issued, do so, otherwise issue a noop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h:31,hazard,hazard,31,interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ScheduleHazardRecognizer.h,2,"['Hazard', 'hazard']","['Hazard', 'hazard']"
Safety,/// getHazardType - We return hazard for any non-branch instruction that would; /// terminate the dispatch group. We turn NoopHazard for any; /// instructions that wouldn't terminate the dispatch group that would cause a; /// pipeline flush.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp:30,hazard,hazard,30,interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/PowerPC/PPCHazardRecognizers.cpp,1,['hazard'],['hazard']
Safety,"/// getLLVMArchSuffixForARM - Get the LLVM arch name to use for a particular; /// CPU (or Arch, if CPU is generic).; // FIXME: This is redundant with -mcpu, why does LLVM use this.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp:135,redund,redundant,135,interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Driver/ToolChains/Arch/ARM.cpp,1,['redund'],['redundant']
Safety,"/// getMemSetPatternValue - If a strided store of the specified value is safe to; /// turn into a memset_pattern16, return a ConstantArray of 16 bytes that should; /// be passed in. Otherwise, return null.; ///; /// Note that we don't ever attempt to use memset_pattern8 or 4, because these; /// just replicate their input array and then pass on to memset_pattern16.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp:73,safe,safe,73,interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp,1,['safe'],['safe']
Safety,"/// getMutableDeclSpec - Return a non-const version of the DeclSpec. This; /// should be used with extreme care: declspecs can often be shared between; /// multiple declarators, so mutating the DeclSpec affects all of the; /// Declarators. This should only be done when the declspec is known to not; /// be shared or when in error recovery etc.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h:331,recover,recovery,331,interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Sema/DeclSpec.h,1,['recover'],['recovery']
Safety,"/// getOperandNamed - Return the index of the operand with the specified; /// non-empty name. If the instruction does not have an operand with the; /// specified name, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.h:168,abort,abort,168,interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.h,1,['abort'],['abort']
Safety,"/// getOperandNamed - Return the index of the operand with the specified; /// non-empty name. If the instruction does not have an operand with the; /// specified name, abort.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.cpp:168,abort,abort,168,interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/utils/TableGen/CodeGenInstruction.cpp,1,['abort'],['abort']
Safety,"/// getPointerToNamedFunction - This method returns the address of the; /// specified function by using the dlsym function call. As such it is only; /// useful for resolving library symbols, not code generated symbols.; ///; /// If AbortOnFailure is false and no function with the given name is; /// found, this function silently returns a null pointer. Otherwise,; /// it prints a message to stderr and aborts.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h:232,Abort,AbortOnFailure,232,interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/ExecutionEngine/MCJIT/MCJIT.h,2,"['Abort', 'abort']","['AbortOnFailure', 'aborts']"
Safety,"/// getPointerToNamedFunction - This method returns the address of the; /// specified function by using the dlsym function call. As such it is only; /// useful for resolving library symbols, not code generated symbols.; ///; /// If AbortOnFailure is false and no function with the given name is; /// found, this function silently returns a null pointer. Otherwise,; /// it prints a message to stderr and aborts.; ///; /// This function is deprecated for the MCJIT execution engine.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h:232,Abort,AbortOnFailure,232,interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ExecutionEngine/ExecutionEngine.h,2,"['Abort', 'abort']","['AbortOnFailure', 'aborts']"
Safety,/// getSpelling - This method is used to get the spelling of a token into a; /// SmallVector. Note that the returned StringRef may not point to the; /// supplied buffer if a copy can be avoided.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp:186,avoid,avoided,186,interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Preprocessor.cpp,1,['avoid'],['avoided']
Safety,"/// getSpelling - This method is used to get the spelling of a token into a; /// preallocated buffer, instead of as an std::string. The caller is required; /// to allocate enough space for the token, which is guaranteed to be at least; /// Tok.getLength() bytes long. The actual length of the token is returned.; ///; /// Note that this method may do two possible things: it may either fill in; /// the buffer specified with characters, or it may *change the input pointer*; /// to point to a constant buffer with the data already in it (avoiding a; /// copy). The caller is not allowed to modify the returned buffer pointer; /// if an internal buffer is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp:538,avoid,avoiding,538,interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Lex/Lexer.cpp,1,['avoid'],['avoiding']
Safety,"/// getSpelling - This method is used to get the spelling of a token into a; /// preallocated buffer, instead of as an std::string. The caller is required; /// to allocate enough space for the token, which is guaranteed to be at least; /// Tok.getLength() bytes long. The length of the actual result is returned.; ///; /// Note that this method may do two possible things: it may either fill in; /// the buffer specified with characters, or it may *change the input pointer*; /// to point to a constant buffer with the data already in it (avoiding a; /// copy). The caller is not allowed to modify the returned buffer pointer; /// if an internal buffer is returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h:539,avoid,avoiding,539,interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Lex/Lexer.h,1,['avoid'],['avoiding']
Safety,/// getSystemGPUArchs - Use a tool to detect the user's availible GPUs.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h:38,detect,detect,38,interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/ToolChain.h,1,['detect'],['detect']
Safety,"/// getTypeForEVT - This method returns an LLVM type corresponding to the; /// specified EVT. For integer types, this returns an unsigned type. Note; /// that this will abort for types that cannot be represented.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ValueTypes.cpp:169,abort,abort,169,interpreter/llvm-project/llvm/lib/CodeGen/ValueTypes.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/ValueTypes.cpp,1,['abort'],['abort']
Safety,"/// getblockFreq - Return block frequency. Return 0 if we don't have the; /// information. Please note that initial frequency is equal to 1024. It means; /// that we should not rely on the value itself, but only on the comparison to; /// the other block frequencies. We do this to avoid using of floating points.; /// For example, to get the frequency of a block relative to the entry block,; /// divide the integral value returned by this function (the; /// BlockFrequency::getFrequency() value) by getEntryFreq().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h:281,avoid,avoid,281,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h,1,['avoid'],['avoid']
Safety,"/// getblockFreq - Return block frequency. Return 0 if we don't have the; /// information. Please note that initial frequency is equal to ENTRY_FREQ. It; /// means that we should not rely on the value itself, but only on the; /// comparison to the other block frequencies. We do this to avoid using of; /// floating points.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h:287,avoid,avoid,287,interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/BlockFrequencyInfo.h,1,['avoid'],['avoid']
Safety,"/// given an offset into the array's underlying stream, return an; /// iterator to the record at that offset. This is considered unsafe; /// since the behavior is undefined if \p Offset does not refer to the; /// beginning of a valid record.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamArray.h:129,unsafe,unsafe,129,interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamArray.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/BinaryStreamArray.h,1,['unsafe'],['unsafe']
Safety,/// hasNoVMLxHazardUse - Return true if it's desirable to select a FP MLA / MLS; /// node. VFP / NEON fp VMLA / VMLS instructions have special RAW hazards (at; /// least on current ARM implementations) which should be avoidded.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp:147,hazard,hazards,147,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelDAGToDAG.cpp,2,"['avoid', 'hazard']","['avoidded', 'hazards']"
Safety,"/// incrementally calculate block frequencies when we split edges, to avoid; /// full CFG traversal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h:70,avoid,avoid,70,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h,1,['avoid'],['avoid']
Safety,/// insertNoop - If data hazard condition is found insert the target nop; /// instruction.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp:25,hazard,hazard,25,interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Mips/MipsInstrInfo.cpp,1,['hazard'],['hazard']
Safety,"/// install_fatal_error_handler - Installs a new error handler to be used; /// whenever a serious (non-recoverable) error is encountered by LLVM.; ///; /// If no error handler is installed the default is to print the error message; /// to stderr, and call exit(1). If an error handler is installed then it is; /// the handler's responsibility to log the message, it will no longer be; /// printed to stderr. If the error handler returns, then exit(1) will be; /// called.; ///; /// It is dangerous to naively use an error handler which throws an exception.; /// Even though some applications desire to gracefully recover from arbitrary; /// faults, blindly throwing exceptions through unfamiliar code isn't a way to; /// achieve this.; ///; /// \param user_data - An argument which will be passed to the install error; /// handler.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h:103,recover,recoverable,103,interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/ErrorHandling.h,2,['recover'],"['recover', 'recoverable']"
Safety,"/// isDefTriviallyDead - Return true if it is trivially safe to remove; /// this function definition from the module (because it isn't externally; /// visible, does not have its address taken, and has no callers). To make; /// this more accurate, call removeDeadConstantUsers first.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h:56,safe,safe,56,interpreter/llvm-project/llvm/include/llvm/IR/Function.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/IR/Function.h,1,['safe'],['safe']
Safety,/// isDereferenceableOrNull - Overload to allow clients with additional; /// knowledge about pointer dereferenceability to provide it and thereby; /// avoid conservative responses when a pointer is compared to null.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h:151,avoid,avoid,151,interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/CaptureTracking.h,1,['avoid'],['avoid']
Safety,"/// isDerivedFromC - Is the input derived from C.; ///; /// That is, does the lexer follow the rules of; /// TokenConcatenation::AvoidConcat. If this is the case, the preprocessor may; /// add and remove whitespace between tokens. Used to determine whether the; /// input can be processed by -fminimize-whitespace.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Types.h:129,Avoid,AvoidConcat,129,interpreter/llvm-project/clang/include/clang/Driver/Types.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/Driver/Types.h,1,['Avoid'],['AvoidConcat']
Safety,"/// isFMAFasterThanFMulAndFAdd - Return true if an FMA operation is faster; /// than a pair of fmul and fadd instructions. fmuladd intrinsics will be; /// expanded to FMAs when this method returns true, otherwise fmuladd is; /// expanded to fmul + fadd.; ///; /// ARM supports both fused and unfused multiply-add operations; we already; /// lower a pair of fmul and fadd to the latter so it's not clear that there; /// would be a gain or that the gain would be worthwhile enough to risk; /// correctness bugs.; ///; /// For MVE, we set this to true as it helps simplify the need for some; /// patterns (and we don't have the non-fused floating point instruction).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp:482,risk,risk,482,interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMISelLowering.cpp,1,['risk'],['risk']
Safety,"/// isLValue - True if this expression is an ""l-value"" according to; /// the rules of the current language. C and C++ give somewhat; /// different rules for this concept, but in general, the result of; /// an l-value expression identifies a specific object whereas the; /// result of an r-value expression is a value detached from any; /// specific storage.; ///; /// C++11 divides the concept of ""r-value"" into pure r-values; /// (""pr-values"") and so-called expiring values (""x-values""), which; /// identify specific objects that can be safely cannibalized for; /// their resources.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:538,safe,safely,538,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['safe'],['safely']
Safety,"/// isNullPointerConstant - C99 6.3.2.3p3 - Return whether this is a null; /// pointer constant or not, as well as the specific kind of constant detected.; /// Null pointer constants can be integer constant expressions with the; /// value zero, casts of zero to void*, nullptr (C++0X), or __null; /// (a GNU extension).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp:145,detect,detected,145,interpreter/llvm-project/clang/lib/AST/Expr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/AST/Expr.cpp,1,['detect'],['detected']
Safety,/// isNullPointerConstant - C99 6.3.2.3p3 - Test if this reduces down to; /// a Null pointer constant. The return value can further distinguish the; /// kind of NULL pointer constant that was detected.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h:192,detect,detected,192,interpreter/llvm-project/clang/include/clang/AST/Expr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/Expr.h,1,['detect'],['detected']
Safety,"/// isPotentiallyPHITranslatable - If this needs PHI translation, return true; /// if we have some hope of doing it. This should be used as a filter to; /// avoid calling PHITranslateValue in hopeless situations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:157,avoid,avoid,157,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,2,['avoid'],['avoid']
Safety,"/// isRedundantFlagInstr - check whether the first instruction, whose only; /// purpose is to update flags, can be made redundant.; /// CMPrr can be made redundant by SUBrr if the operands are the same.; /// CMPri can be made redundant by SUBri if the operands are the same.; /// CMPrr(r0, r1) can be made redundant by ADDr[ri](r0, r1, X).; /// This function can be extended later on.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:120,redund,redundant,120,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,4,['redund'],['redundant']
Safety,"/// isSafeToMove - Return true if it is safe to move this instruction. If; /// SawStore is set to true, it means that there is a store (or call) between; /// the instruction's location and its intended destination.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp:40,safe,safe,40,interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/MachineInstr.cpp,1,['safe'],['safe']
Safety,/// isSafeToMoveRegClassDefs - Return true if it's safe to move a machine; /// instruction that defines the specified register class.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h:51,safe,safe,51,interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/X86/X86InstrInfo.h,1,['safe'],['safe']
Safety,/// isSafeToMoveTogether - Returns true if it is safe to move I1 next to I2 such; /// that the two instructions can be paired in a combine.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp:49,safe,safe,49,interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/Hexagon/HexagonCopyToCombine.cpp,1,['safe'],['safe']
Safety,"/// isTagName() - This method is called *for error recovery purposes only*; /// to determine if the specified name is a valid tag name (""struct foo""). If; /// so, this returns the TST for the tag corresponding to it (TST_enum,; /// TST_union, TST_struct, TST_interface, TST_class). This is used to diagnose; /// cases in C where the user forgot to specify the tag.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp:51,recover,recovery,51,interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/Sema/SemaDecl.cpp,1,['recover'],['recovery']
Safety,"/// join - Join two live ranges (this, and other) together. This applies; /// mappings to the value numbers in the LHS/RHS ranges as specified. If; /// the ranges are not joinable, this aborts.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:186,abort,aborts,186,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,1,['abort'],['aborts']
Safety,"/// json::OStream allows writing well-formed JSON without materializing; /// all structures as json::Value ahead of time.; /// It's faster, lower-level, and less safe than OS << json::Value.; /// It also allows emitting more constructs, such as comments.; ///; /// Only one ""top-level"" object can be written to a stream.; /// Simplest usage involves passing lambdas (Blocks) to fill in containers:; ///; /// json::OStream J(OS);; /// J.array([&]{; /// for (const Event &E : Events); /// J.object([&] {; /// J.attribute(""timestamp"", int64_t(E.Time));; /// J.attributeArray(""participants"", [&] {; /// for (const Participant &P : E.Participants); /// J.value(P.toString());; /// });; /// });; /// });; ///; /// This would produce JSON like:; ///; /// [; /// {; /// ""timestamp"": 19287398741,; /// ""participants"": [; /// ""King Kong"",; /// ""Miley Cyrus"",; /// ""Cleopatra""; /// ]; /// },; /// ...; /// ]; ///; /// The lower level begin/end methods (arrayBegin()) are more flexible but; /// care must be taken to pair them correctly:; ///; /// json::OStream J(OS);; // J.arrayBegin();; /// for (const Event &E : Events) {; /// J.objectBegin();; /// J.attribute(""timestamp"", int64_t(E.Time));; /// J.attributeBegin(""participants"");; /// for (const Participant &P : E.Participants); /// J.value(P.toString());; /// J.attributeEnd();; /// J.objectEnd();; /// }; /// J.arrayEnd();; ///; /// If the call sequence isn't valid JSON, asserts will fire in debug mode.; /// This can be mismatched begin()/end() pairs, trying to emit attributes inside; /// an array, and so on.; /// With asserts disabled, this is undefined behavior.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h:162,safe,safe,162,interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/JSON.h,1,['safe'],['safe']
Safety,"/// kAuto detects the line break from the first line, kSystem picks the system's default",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx:10,detect,detects,10,io/io/inc/ROOT/RRawFile.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/inc/ROOT/RRawFile.hxx,1,['detect'],['detects']
Safety,/// live_begin/live_end - Iterators for live roots at a given safe point.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:62,safe,safe,62,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,1,['safe'],['safe']
Safety,"/// llvm_shutdown - Deallocate and destroy all ManagedStatic variables.; /// IMPORTANT: it's only safe to call llvm_shutdown() in single thread,; /// without any other threads executing LLVM APIs.; /// llvm_shutdown() should be the last use of LLVM APIs.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ManagedStatic.cpp:98,safe,safe,98,interpreter/llvm-project/llvm/lib/Support/ManagedStatic.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Support/ManagedStatic.cpp,1,['safe'],['safe']
Safety,"/// lowerIncomingArguments - To avoid having to handle incoming arguments; /// specially, we lower each arg to a copy instruction in the entry block. This; /// ensures that the argument value itself cannot be live out of the entry; /// block.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp:32,avoid,avoid,32,interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SjLjEHPrepare.cpp,1,['avoid'],['avoid']
Safety,/// operator bool - Detect a null ref.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:20,Detect,Detect,20,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['Detect'],['Detect']
Safety,"/// optimizeCompareInstr - Convert the instruction supplying the argument to the; /// comparison into one that sets the zero bit in the flags register;; /// Remove a redundant Compare instruction if an earlier instruction can set the; /// flags in the same way as Compare.; /// E.g. SUBrr(r1,r2) and CMPrr(r1,r2). We also handle the case where two; /// operands are swapped: SUBrr(r1,r2) and CMPrr(r2,r1), by updating the; /// condition code of instructions which use the flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp:166,redund,redundant,166,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.cpp,1,['redund'],['redundant']
Safety,"/// optimizeCompareInstr - Convert the instruction to set the zero flag so; /// that we can remove a ""comparison with zero""; Remove a redundant CMP; /// instruction if the flags can be updated in the same way by an earlier; /// instruction such as SUB.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h:134,redund,redundant,134,interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMBaseInstrInfo.h,1,['redund'],['redundant']
Safety,/// parseDirectiveAbort; /// ::= .abort [... message ...],MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp:34,abort,abort,34,interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/MC/MCParser/AsmParser.cpp,1,['abort'],['abort']
Safety,"/// perform prediction of the deep neural network; /// using batches (called by GetMvaValues)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodDL.h:12,predict,prediction,12,tmva/tmva/inc/TMVA/MethodDL.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/MethodDL.h,1,['predict'],['prediction']
Safety,"/// protected constructor to avoid user creating this class",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h:29,avoid,avoid,29,math/mathcore/inc/Math/IntegratorOptions.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/IntegratorOptions.h,2,['avoid'],['avoid']
Safety,/// pushFullExprCleanup - Push a cleanup to be run at the end of the; /// current full-expression. Safe against the possibility that; /// we're currently inside a conditionally-evaluated expression.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h:99,Safe,Safe,99,interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/lib/CodeGen/CodeGenFunction.h,1,['Safe'],['Safe']
Safety,/// raw_os_ostream - A raw_ostream that writes to an std::ostream. This is a; /// simple adaptor class. It does not check for output errors; clients should; /// use the underlying stream to detect errors.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_os_ostream.h:190,detect,detect,190,interpreter/llvm-project/llvm/include/llvm/Support/raw_os_ostream.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Support/raw_os_ostream.h,1,['detect'],['detect']
Safety,"/// remove - Remove the specified key/value pair from the map, but do not; /// erase it. This aborts if the key is not in the map.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h:94,abort,aborts,94,interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/StringMap.h,1,['abort'],['aborts']
Safety,"/// resolvedUndefsIn - While solving the dataflow for a function, we assume; /// that branches on undef values cannot reach any of their successors.; /// However, this is not a safe assumption. After we solve dataflow, this; /// method should be use to handle this. If this returns true, the solver; /// should be rerun.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h:177,safe,safe,177,interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Transforms/Utils/SCCPSolver.h,1,['safe'],['safe']
Safety,"/// safe evaluation of log(x) with a protections against negative or zero argument to the log; /// smooth linear extrapolation below function values smaller than epsilon; /// (better than a simple cut-off)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h:4,safe,safe,4,math/mathcore/inc/Math/Util.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mathcore/inc/Math/Util.h,1,['safe'],['safe']
Safety,"/// safeFind - Find a subtree that is known to exist. This is the same as; /// findFrom except is it assumed that x is in range.; /// @param i Starting index for the search.; /// @param x Key to search for.; /// @return First index with !stopLess(key[i], x), never size.; /// This is the first subtree that can possibly contain x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,safe,safeFind,4,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['safe'],['safeFind']
Safety,"/// safeFind - Find an interval that is known to exist. This is the same as; /// findFrom except is it assumed that x is at least within range of the last; /// interval.; /// @param i Starting index for the search.; /// @param x Key to search for.; /// @return First index with !stopLess(key[i].stop, x), never size.; /// This is the first interval that can possibly contain x.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,safe,safeFind,4,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['safe'],['safeFind']
Safety,"/// safeLookup - Get the subtree containing x, Assuming that x is in range.; /// @param x Key to search for.; /// @return Subtree containing x",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,safe,safeLookup,4,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['safe'],['safeLookup']
Safety,/// safeLookup - Lookup mapped value for a safe key.; /// It is assumed that x is within range of the last entry.; /// @param x Key to search for.; /// @param NotFound Value to return if x is not in any interval.; /// @return The mapped value at x or NotFound.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,safe,safeLookup,4,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,2,['safe'],"['safe', 'safeLookup']"
Safety,/// setInvalidDecl - Indicates the Decl had a semantic error. This; /// allows for graceful error recovery.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h:98,recover,recovery,98,interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/include/clang/AST/DeclBase.h,1,['recover'],['recovery']
Safety,"/// simplifyPartiallyRedundantLoad - If LoadI is an obviously partially; /// redundant load instruction, eliminate it by replacing it with a PHI node.; /// This is an important optimization that encourages jump threading, and needs; /// to be run interlaced with other jump threading tasks.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:77,redund,redundant,77,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['redund'],['redundant']
Safety,"/// splitRegInBlock - Split CurLI in the given block such that it enters the; /// block in IntvIn and leaves it on the stack (or not at all). Split points; /// are placed in a way that avoids putting uses in the stack interval. This; /// may require creating a local interval when there is interference.; ///; /// @param BI Block descriptor.; /// @param IntvIn Interval index entering the block. Not 0.; /// @param LeaveBefore When set, leave IntvIn before this point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:185,avoid,avoids,185,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,1,['avoid'],['avoids']
Safety,"/// splitRegOutBlock - Split CurLI in the given block such that it enters the; /// block on the stack (or isn't live-in at all) and leaves it in IntvOut.; /// Split points are placed to avoid interference and such that the uses are; /// not in the stack interval. This may require creating a local interval; /// when there is interference.; ///; /// @param BI Block descriptor.; /// @param IntvOut Interval index leaving the block.; /// @param EnterAfter When set, enter IntvOut after this point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h:186,avoid,avoid,186,interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/CodeGen/SplitKit.h,1,['avoid'],['avoid']
Safety,"/// threadEdge - We have decided that it is safe and profitable to factor the; /// blocks in PredBBs to one predecessor, then thread an edge from it to SuccBB; /// across BB. Transform the IR to reflect this change.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:44,safe,safe,44,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['safe'],['safe']
Safety,"/// timeout handler; /// used to process all qt5 events in main ROOT thread",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rootqt5.cpp:4,timeout,timeout,4,gui/qt5webdisplay/rootqt5.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/qt5webdisplay/rootqt5.cpp,1,['timeout'],['timeout']
Safety,"/// timeout handler; /// used to process all qt6 events in main ROOT thread",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/qt6webdisplay/rootqt6.cpp:4,timeout,timeout,4,gui/qt6webdisplay/rootqt6.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/qt6webdisplay/rootqt6.cpp,1,['timeout'],['timeout']
Safety,"/// timeout handler; /// used to process http requests in main ROOT thread",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx:4,timeout,timeout,4,net/http/src/THttpServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx,1,['timeout'],['timeout']
Safety,"/// timeout handler; /// used to process postponed requests in main ROOT thread",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowser.cxx:4,timeout,timeout,4,gui/browserv7/src/RBrowser.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RBrowser.cxx,2,['timeout'],['timeout']
Safety,/// tryThreadEdge - Thread an edge if it's safe and profitable to do so.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp:43,safe,safe,43,interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/JumpThreading.cpp,1,['safe'],['safe']
Safety,/// unsafeStart - Writable access to start() for iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,unsafe,unsafeStart,4,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['unsafe'],['unsafeStart']
Safety,/// unsafeStop - Writable access to stop() for iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,unsafe,unsafeStop,4,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['unsafe'],['unsafeStop']
Safety,/// unsafeValue - Writable access to value() for iterator.,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h:4,unsafe,unsafeValue,4,interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/ADT/IntervalMap.h,1,['unsafe'],['unsafeValue']
Safety,///////// Bank conflicts handled as hazards //////////////,MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp:36,hazard,hazards,36,interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Target/ARM/ARMHazardRecognizer.cpp,1,['hazard'],['hazards']
Safety,"///////////////////////////////////////////////////////////////////////////////////////////////////; /// Detect image format; /// There is special handling of "".screenshot.pdf"" and "".screenshot.png"" extensions; /// Creation of such files relies on headless browser functionality and fully supported only by Chrome browser",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebDisplayHandle.cxx:105,Detect,Detect,105,gui/webdisplay/src/RWebDisplayHandle.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebDisplayHandle.cxx,1,['Detect'],['Detect']
Safety,"///////////////////////////////////////////////////////////////////////////////////////////////; // Loss Function interface for boosted decision trees. Inherits from LossFunction; ///////////////////////////////////////////////////////////////////////////////////////////////; /* Must inherit LossFunction with the virtual keyword so that we only have to implement; * the LossFunction interface once.; *; * LossFunction; * / \; *SomeLossFunction LossFunctionBDT; * \ /; * \ /; * SomeLossFunctionBDT; *; * Without the virtual keyword the two would point to their own LossFunction objects; * and SomeLossFunctionBDT would have to implement the virtual functions of LossFunction twice, once; * for each object. See diagram below.; *; * LossFunction LossFunction; * | |; *SomeLossFunction LossFunctionBDT; * \ /; * \ /; * SomeLossFunctionBDT; *; * Multiple inheritance is often frowned upon. To avoid this, We could make LossFunctionBDT separate; * from LossFunction but it really is a type of loss function.; * We could also put LossFunction into LossFunctionBDT. In either of these scenarios, if you are doing; * different regression methods and want to compare the Loss this makes it more convoluted.; * I think that multiple inheritance seems justified in this case, but we could change it if it's a problem.; * Usually it isn't a big deal with interfaces and this results in the simplest code in this case.; */",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h:891,avoid,avoid,891,tmva/tmva/inc/TMVA/LossFunction.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/LossFunction.h,1,['avoid'],['avoid']
Safety,"//////////////////////////////////////////////////////////////////////////////////////////////; /// Mark pad modified and do update; /// For web canvas set async mode first to avoid blocking here",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx:176,avoid,avoid,176,gui/fitpanelv7/src/RFitPanel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/fitpanelv7/src/RFitPanel.cxx,1,['avoid'],['avoid']
Safety,"//////////////////////////////////////////////////////////////////////////////////////////; /// Check if started process(es) establish connection. After timeout such processed will be killed; /// Method invoked from http server thread, therefore appropriate mutex must be used on all relevant data",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:153,timeout,timeout,153,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////////////; /// Method to find potentially relevant candidate bounding boxes for safety calculation; /// given a point. Uses BVH to do so.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:159,safe,safety,159,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"/////////////////////////////////////////////////////////////////////////////////////; /// Create dialog instance to use as embedded dialog inside other widget; /// Embedded dialog started on the client side where FileDialogController.SaveAs() method called; /// Such method immediately send message with ""FILEDIALOG:"" prefix; /// On the server side widget should detect such message and call RFileDialog::Embed(); /// providing received string as second argument.; /// Returned instance of shared_ptr<RFileDialog> may be used to assign callback when file is selected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RFileDialog.cxx:364,detect,detect,364,gui/browserv7/src/RFileDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/browserv7/src/RFileDialog.cxx,1,['detect'],['detect']
Safety,"/////////////////////////////////////////////////////////////////////////////////////; /// Create dialog instance to use as embedded dialog inside provided widget; /// Loads libROOTBrowserv7 and tries to call RFileDialog::Embedded() method; /// Embedded dialog started on the client side where FileDialogController.SaveAs() method called; /// Such method immediately send message with ""FILEDIALOG:"" prefix; /// On the server side widget should detect such message and call RFileDialog::Embedded(); /// providing received string as second argument.; /// Returned instance of shared_ptr<RFileDialog> may be used to assign callback when file is selected",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:444,detect,detect,444,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['detect'],['detect']
Safety,"//////////////////////////////////////////////////////////////////////////////////; /// Wrapper for getting the safety from the parallel world. Takes care of; /// caching mechanics + talking to the parallel world.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:112,safe,safety,112,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safety']
Safety,"/////////////////////////////////////////////////////////////////////////////////; /// Set call-back function for data, received from the clients via websocket; ///; /// Function should have signature like void func(unsigned connid, const std::string &data); /// First argument identifies connection (unique for each window), second argument is received data; ///; /// At the moment when callback is assigned, RWebWindow working thread is detected.; /// If called not from main application thread, RWebWindow::Run() function must be regularly called from that thread.; ///; /// Most simple way to assign call-back - use of c++11 lambdas like:; /// ~~~ {.cpp}; /// auto win = RWebWindow::Create();; /// win->SetDefaultPage(""file:./page.htm"");; /// win->SetDataCallBack(; /// [](unsigned connid, const std::string &data) {; /// printf(""Conn:%u data:%s\n"", connid, data.c_str());; /// }; /// );; /// win->Show();; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx:439,detect,detected,439,gui/webdisplay/src/RWebWindow.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/webdisplay/src/RWebWindow.cxx,1,['detect'],['detected']
Safety,"/////////////////////////////////////////////////////////////////////////////////; /// Write array without size attribute; /// Also treat situation, when instead of one single array; /// chain of several elements should be produced; /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of underflow or overflow. See https://github.com/root-project/root/issues/6734 for more details.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TBufferXML.cxx:301,abort,aborts,301,io/xml/src/TBufferXML.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/xml/src/TBufferXML.cxx,1,['abort'],['aborts']
Safety,"////////////////////////////////////////////////////////////////////////////////; // RE-implement dummy functions to avoid users calling the; // corresponding implementations in TH1 or TH2; ////////////////////////////////////////////////////////////////////////////////; ////////////////////////////////////////////////////////////////////////////////; /// NOT IMPLEMENTED for TH2Poly",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx:117,avoid,avoid,117,hist/hist/src/TH2Poly.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2Poly.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// @brief Check and record whether this class has a consistent; /// Hash/RecursiveRemove setup (*) and then return the regular Hash value for; /// this object. The intent is for this routine to be called instead of directly; /// calling the function Hash during ""insert"" operations. See TObject::HasInconsistenTObjectHash();; ///; /// (*) The setup is consistent when all classes in the class hierarchy that overload; /// TObject::Hash do call ROOT::CallRecursiveRemoveIfNeeded in their destructor.; /// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TObject.h:598,safe,safe,598,core/base/inc/TObject.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/inc/TObject.h,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// A vectorized version of interpolateDim for boundary safe linear; /// interpolation of one dimensional histograms.; ///; /// \param[out] output An array of interpolated weights corresponding to the; /// values in xVals.; /// \param[in] xVals An array of event coordinates for which the weights should be; /// calculated.; /// \param[in] correctForBinSize Enable the inverse bin volume correction factor.; /// \param[in] cdfBoundaries Enable the special boundary condition for a cdf:; /// Underflow bins are assumed to have weight zero and; /// overflow bins have weight one. Otherwise, the; /// histogram is mirrored at the boundaries for the; /// interpolation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:138,safe,safe,138,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// A vectorized version of interpolateDim for boundary safe quadratic; /// interpolation of one dimensional histograms.; ///; /// \param[out] output An array of interpolated weights corresponding to the; /// values in xVals.; /// \param[in] xVals An array of event coordinates for which the weights should be; /// calculated.; /// \param[in] correctForBinSize Enable the inverse bin volume correction factor.; /// \param[in] cdfBoundaries Enable the special boundary condition for a cdf:; /// Underflow bins are assumed to have weight zero and; /// overflow bins have weight one. Otherwise, the; /// histogram is mirrored at the boundaries for the; /// interpolation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx:138,safe,safe,138,roofit/roofitcore/src/RooDataHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooDataHist.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Abort current tree of tasks.; /// After this call, the tree of tasks is ready to be executed again.; /// The application must take care of cleaning data structures created; /// by previous executions.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTask.cxx:86,Abort,Abort,86,core/base/src/TTask.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTask.cxx,1,['Abort'],['Abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Abort processing query.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx:86,Abort,Abort,86,gui/sessionviewer/src/TSessionViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/sessionviewer/src/TSessionViewer.cxx,1,['Abort'],['Abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Abort processing. If what = kAbortProcess, the Process() loop will be; /// aborted. If what = kAbortFile, the current file in a chain will be; /// aborted and the processing will continue with the next file, if there; /// is no next file then Process() will be aborted. Abort() can also be; /// called from Begin(), SlaveBegin(), Init() and Notify(). After abort; /// the SlaveTerminate() and Terminate() are always called. The abort flag; /// can be checked in these methods using GetAbort().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:86,Abort,Abort,86,tree/tree/src/TSelector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx,7,"['Abort', 'abort']","['Abort', 'abort', 'aborted']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Abort the application.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:86,Abort,Abort,86,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['Abort'],['Abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Action for menu-hiding timeout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSAViewer.cxx:109,timeout,timeout,109,graf3d/gl/src/TGLSAViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSAViewer.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Add a TFriendElement to the list of friends.; ///; /// This function:; /// - opens a file if filename is specified; /// - reads a Tree with name treename from the file (current directory); /// - adds the Tree to the list of friends; /// see other AddFriend functions; ///; /// A TFriendElement TF describes a TTree object TF in a file.; /// When a TFriendElement TF is added to the list of friends of an; /// existing TTree T, any variable from TF can be referenced in a query; /// to T.; ///; /// A tree keeps a list of friends. In the context of a tree (or a chain),; /// friendship means unrestricted access to the friends data. In this way; /// it is much like adding another branch to the tree without taking the risk; /// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; /// method. The tree in the diagram below has two friends (friend_tree1 and; /// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; ///; /// \image html ttree_friend1.png; ///; /// The AddFriend method has two parameters, the first is the tree name and the; /// second is the name of the ROOT file where the friend tree is saved.; /// AddFriend automatically opens the friend file. If no file name is given,; /// the tree called ft1 is assumed to be in the same file as the original tree.; ///; /// tree.AddFriend(""ft1"",""friendfile1.root"");; /// If the friend tree has the same name as the original tree, you can give it; /// an alias in the context of the friendship:; ///; /// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; /// Once the tree has friends, we can use TTree::Draw as if the friend's; /// variables were in the original tree. To specify which tree to use in; /// the Draw method, use the syntax:; /// ~~~ {.cpp}; /// <treeName>.<branchname>.<varname>; /// ~~~; /// If the variablename is enough to uniquely identify the variable, you can; /// leave out the tree and/o",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:804,risk,risk,804,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['risk'],['risk']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Add a new hit to the list of hits in detector A",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/JetEvent.cxx:123,detect,detector,123,tutorials/tree/JetEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/JetEvent.cxx,1,['detect'],['detector']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Add a new hit to the list of hits in detector B",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/JetEvent.cxx:123,detect,detector,123,tutorials/tree/JetEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tutorials/tree/JetEvent.cxx,1,['detect'],['detector']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Add a new particle to the list of particles for this event.; /// To avoid calling the very time consuming operator new for each track,; /// the standard but not well know C++ operator ""new with placement""; /// is called. If particle[i] is 0, a new MyParticle object will be created; /// otherwise the previous particle[i] will be overwritten.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:154,avoid,avoid,154,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Add a new track to the list of tracks for this event.; /// To avoid calling the very time consuming operator new for each track,; /// the standard but not well know C++ operator ""new with placement""; /// is called. If tracks[i] is 0, a new Track object will be created; /// otherwise the previous Track[i] will be overwritten.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/Event.cxx:148,avoid,avoid,148,test/Event.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/Event.cxx,2,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Add an object as first in list of primitives with speicified draw option; /// When \par modified set to kTRUE (default) pad will be marked as modified; /// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:246,avoid,avoid,246,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Add an object to list of primitives with speicified draw option; /// When \par modified set to kTRUE (default) pad will be marked as modified; /// Let avoid usage of gPad when drawing object(s) in canvas or in subpads.; ///; /// ~~~{.cpp}; /// auto c1 = new TCanvas(""c1"",""Canvas with subpoads"", 600, 600);; /// c1->Divide(2,2);; ///; /// for (Int_t n = 1; n <= 4; ++n) {; /// auto h1 = new TH1I(TString::Format(""hist_%d"",n), ""Random hist"", 100, -5, 5);; /// h1->FillRandom(""gaus"", 2000 + n*1000);; /// c1->GetPad(n)->Add(h1);; /// }; /// ~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:237,avoid,avoid,237,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Alternative constructor; /// User provides data and MC test spectra, as well as detector response matrix, diagonal covariance matrix of measured spectrum built from the uncertainties on measured spectrum",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:166,detect,detector,166,hist/hist/src/TSVDUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx,1,['detect'],['detector']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Assign values from the elements in `other` to our elements.; /// \warning This is not a conventional assignment operator. To avoid confusion, prefer using RooAbsCollection::assign().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCollection.cxx:211,avoid,avoid,211,roofit/roofitcore/src/RooAbsCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsCollection.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Asynchronous pad update.; /// In case of web-based canvas triggers update of the canvas on the client side,; /// but does not wait that real update is completed. Avoids blocking of caller thread.; /// Have to be used if called from other web-based widget to avoid logical dead-locks.; /// In case of normal canvas just canvas->Update() is performed.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx:248,Avoid,Avoids,248,graf2d/gpad/src/TCanvas.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TCanvas.cxx,4,"['Avoid', 'avoid']","['Avoids', 'avoid']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Attempt to recover file if not correctly closed; ///; /// The function returns the number of keys that have been recovered.; /// If no keys can be recovered, the file will be declared Zombie by; /// the calling function. This function is automatically called when; /// opening a file.; /// If the file is open in read only mode, the file is not modified.; /// If open in update mode and the function finds something to recover,; /// a new directory header is written to the file. When opening the file gain; /// no message from Recover will be reported.; /// If keys have been recovered, the file is usable and you can safely; /// read the corresponding objects.; /// If the file is not usable (a zombie), you can test for this case; /// with code like:; ///; /// ~~~{.cpp}; /// TFile f(""myfile.root"");; /// if (f.IsZombie()) {<actions to take if file is unusable>}; /// ~~~; ///; /// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; /// You can test if the file has been recovered with; ///; /// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; ///; /// When writing TTrees to a file, it is important to save the Tree header; /// at regular intervals (see TTree::AutoSave). If a file containing a Tree; /// is recovered, the last Tree header written to the file will be used.; /// In this case all the entries in all the branches written before writing; /// the header are valid entries.; /// One can disable the automatic recovery procedure by setting; ///; /// TFile.Recover 0; ///; /// in the <em>system.rootrc</em> file.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:97,recover,recover,97,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,13,"['Recover', 'recover', 'safe']","['Recover', 'recover', 'recovered', 'recovery', 'safely']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// AutoSave tree header every fAutoSave bytes.; ///; /// When large Trees are produced, it is safe to activate the AutoSave; /// procedure. Some branches may have buffers holding many entries.; /// If fAutoSave is negative, AutoSave is automatically called by; /// TTree::Fill when the number of bytes generated since the previous; /// AutoSave is greater than -fAutoSave bytes.; /// If fAutoSave is positive, AutoSave is automatically called by; /// TTree::Fill every N entries.; /// This function may also be invoked by the user.; /// Each AutoSave generates a new key on the file.; /// Once the key with the tree header has been written, the previous cycle; /// (if any) is deleted.; ///; /// Note that calling TTree::AutoSave too frequently (or similarly calling; /// TTree::SetAutoSave with a small value) is an expensive operation.; /// You should make tests for your own application to find a compromise; /// between speed and the quantity of information you may loose in case of; /// a job crash.; ///; /// In case your program crashes before closing the file holding this tree,; /// the file will be automatically recovered when you will connect the file; /// in UPDATE mode.; /// The Tree will be recovered at the status corresponding to the last AutoSave.; ///; /// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; /// This allows another process to analyze the Tree while the Tree is being filled.; ///; /// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; /// the current basket are closed-out and written to disk individually.; ///; /// By default the previous header is deleted after having written the new header.; /// if option contains ""Overwrite"", the previous Tree header is deleted; /// before written the new header. This option is slightly faster, but; /// the default option is safer in case of a problem (disk quota exceeded); /// when writing the new",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:177,safe,safe,177,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Automatically calculate a new size and expand the buffer to fit at least size_needed.; /// The goals is to minimize the number of memory allocation and the memory allocation; /// which avoiding too much memory wastage.; ///; /// If the size_needed is larger than the current size, the policy; /// is to expand to double the current size or the size_needed which ever is largest.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx:271,avoid,avoiding,271,core/base/src/TBuffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx,1,['avoid'],['avoiding']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Avoid boundaries to be equal.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDoubleSlider.cxx:86,Avoid,Avoid,86,gui/gui/src/TGDoubleSlider.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDoubleSlider.cxx,1,['Avoid'],['Avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Back-end for plotOn() implementation on RooSimultaneous which; /// needs special handling because a RooSimultaneous PDF cannot; /// project out its index category via integration. plotOn() will; /// abort if this is requested without providing a projection dataset.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx:285,abort,abort,285,roofit/roofitcore/src/RooSimultaneous.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx,1,['abort'],['abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Base function for ReadBuffer.; ///; /// Also gives out the position of the block in the internal buffer.; /// This helps TTreeCacheUnzip to avoid doing twice the binary search.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx:226,avoid,avoid,226,io/io/src/TFileCacheRead.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFileCacheRead.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Build a legend from the graphical objects in the pad.; ///; /// A simple method to build automatically a TLegend from the primitives in a TPad.; ///; /// Only those deriving from TAttLine, TAttMarker and TAttFill are added, excluding; /// TPave and TFrame derived classes.; ///; /// \return The built TLegend; ///; /// \param[in] x1, y1, x2, y2 The TLegend coordinates; /// \param[in] title The legend title. By default it is "" ""; /// \param[in] option The TLegend option; ///; /// The caller program owns the returned TLegend.; ///; /// If the pad contains some TMultiGraph or THStack the individual; /// graphs or histograms in them are added to the TLegend.; ///; /// ### Automatic placement of the legend; /// If `x1` is equal to `x2` and `y1` is equal to `y2` the legend will be automatically; /// placed to avoid overlapping with the existing primitives already displayed.; /// `x1` is considered as the width of the legend and `y1` the height. By default; /// the legend is automatically placed with width = `x1`= `x2` = 0.3 and; /// height = `y1`= `y2` = 0.21.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx:899,avoid,avoid,899,graf2d/gpad/src/TPad.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/gpad/src/TPad.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Called in connection with a timer timeout",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:120,timeout,timeout,120,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Called on every timer timeout. Moves / rotates the camera and optionally; /// produces a screenshot.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLAutoRotator.cxx:108,timeout,timeout,108,graf3d/gl/src/TGLAutoRotator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLAutoRotator.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Called when fTimer timeouts (every 0.025 second); /// Updates GUI of recorder",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx:105,timeout,timeouts,105,gui/recorder/src/TRecorder.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/recorder/src/TRecorder.cxx,1,['timeout'],['timeouts']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Check if bremsstrahlung is allowed and generate; /// a random decay length related to detector's material; /// radiation length (X0)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:172,detect,detector,172,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['detect'],['detector']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Check if given observable can be safely generated using the; /// pdfs internal generator mechanism (if that existsP). Observables; /// on which a PDF depends via more than route are not safe; /// for use with internal generators because they introduce; /// correlations not known to the internal generator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx:119,safe,safely,119,roofit/roofitcore/src/RooAbsPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsPdf.cxx,2,['safe'],"['safe', 'safely']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Check if pair production is allowed and generate; /// a random decay length related to detector's material; /// radiation length (X0).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:173,detect,detector,173,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['detect'],['detector']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Check if socket 's' is in the active list. Avoids the duplication; /// of active list via TMonitor::GetListOfActives().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx:129,Avoid,Avoids,129,net/net/src/TMonitor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx,1,['Avoid'],['Avoids']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Check of validity of safe distance for a given shape.; /// Sample points inside the 2x bounding box and compute safety. Generate; /// directions randomly in cos(theta) and compute distance to boundary. Check if; /// distance to boundary is bigger than safety.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx:107,safe,safe,107,geom/geompainter/src/TGeoChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx,3,['safe'],"['safe', 'safety']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Check of validity of the normal for a given shape.; /// Sample points inside the shape. Generate directions randomly in cos(theta); /// and propagate to boundary. Compute normal and safety at crossing point, plot; /// the point and generate a random direction so that (dir) dot (norm) <0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx:268,safe,safety,268,geom/geompainter/src/TGeoChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx,1,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Checks if an entity with the specified name is defined in Cling.; /// Returns kUnknown if the entity is not defined.; /// Returns kWithClassDefInline if the entity exists and has a ClassDefInline; /// Returns kKnown if the entity is defined.; ///; /// By default, structs, namespaces, classes, enums and unions are looked for.; /// If the flag isClassOrNamespaceOnly is true, classes, structs and; /// namespaces only are considered. I.e. if the name is an enum or a union,; /// the returned value is false.; ///; /// In the case where the class is not loaded and belongs to a namespace; /// or is nested, looking for the full class name is outputting a lots of; /// (expected) error messages. Currently the only way to avoid this is to; /// specifically check that each level of nesting is already loaded.; /// In case of templates the idea is that everything between the outer; /// '<' and '>' has to be skipped, e.g.: `aap<pippo<noot>::klaas>::a_class`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:806,avoid,avoid,806,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Clear string and make sure it has a capacity of nc.; /// \warning If nc > MaxSize(), then Fatal() is raised, and only MaxSize(); /// elements are allocated if Fatal does not abort; /// \return Resulting allocated capacity (after clamping, if needed)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx:260,abort,abort,260,core/base/src/TString.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TString.cxx,1,['abort'],['abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Collect all parents of class TEveScene. This is needed to; /// automatically detect which scenes need to be updated.; ///; /// Overriden in TEveScene to include itself and return.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx:163,detect,detect,163,graf3d/eve/src/TEveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx,1,['detect'],['detect']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Collect responses from slave sl. Returns the number of slaves that; /// responded (=1).; /// If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; /// which means wait forever).; /// If defined (>= 0) endtype is the message that stops this collection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:182,timeout,timeout,182,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,3,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Collect responses from the remote server.; /// Returns the number of messages received.; /// If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; /// which means wait forever).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx:182,timeout,timeout,182,net/net/src/TApplicationRemote.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationRemote.cxx,3,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Collect responses from the slave servers. Returns the number of messages; /// received. Can be 0 if there are no active slaves.; /// If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; /// which means wait forever).; /// If defined (>= 0) endtype is the message that stops this collection.; /// Collect also stops its execution from time to time to check for new; /// workers in Dynamic Startup mode.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:222,timeout,timeout,222,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,3,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Collect responses from the slave servers. Returns the number of slaves; /// that responded.; /// If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; /// which means wait forever).; /// If defined (>= 0) endtype is the message that stops this collection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:186,timeout,timeout,186,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,6,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Collect scene-parents from all children. This is needed to; /// automatically detect which scenes need to be updated during/after; /// a full sub-tree update.; /// Argument parent specifies parent in traversed hierarchy for which we can; /// skip the upwards search.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx:164,detect,detect,164,graf3d/eve/src/TEveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveElement.cxx,1,['detect'],['detect']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute de/dx for particle ""id"" into detector material; /// for more infos, please refer to the particle data booklet; /// from which the formulas has been extracted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:123,detect,detector,123,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['detect'],['detector']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from inside point to surface of the box.; /// Boundary safe algorithm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBBox.cxx:158,safe,safe,158,geom/geom/src/TGeoBBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBBox.cxx,2,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from inside point to surface of the cone (static); /// Boundary safe algorithm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx:167,safe,safe,167,geom/geom/src/TGeoCone.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from inside point to surface of the cone; /// Boundary safe algorithm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx:158,safe,safe,158,geom/geom/src/TGeoCone.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from inside point to surface of the trd1; /// Boundary safe algorithm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd1.cxx:158,safe,safe,158,geom/geom/src/TGeoTrd1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd1.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from inside point to surface of the trd2; /// Boundary safe algorithm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd2.cxx:158,safe,safe,158,geom/geom/src/TGeoTrd2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd2.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from inside point to surface of the tube (static); /// Boundary safe algorithm.; /// compute distance to surface; /// Do Z",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx:167,safe,safe,167,geom/geom/src/TGeoTube.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from inside point to surface of the tube segment (static); /// Boundary safe algorithm.; /// Do Z",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx:175,safe,safe,175,geom/geom/src/TGeoTube.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from inside point to surface of the tube segment; /// Boundary safe algorithm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx:166,safe,safe,166,geom/geom/src/TGeoTube.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from inside point to surface of the tube; /// Boundary safe algorithm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx:158,safe,safe,158,geom/geom/src/TGeoTube.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from outside point to surface of the box.; /// Boundary safe algorithm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBBox.cxx:159,safe,safe,159,geom/geom/src/TGeoBBox.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBBox.cxx,2,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from outside point to surface of the trd1; /// Boundary safe algorithm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd1.cxx:159,safe,safe,159,geom/geom/src/TGeoTrd1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd1.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from outside point to surface of the trd2; /// Boundary safe algorithm",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd2.cxx:159,safe,safe,159,geom/geom/src/TGeoTrd2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTrd2.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from outside point to surface of the tube and safe distance; /// Boundary safe algorithm.; /// fist localize point w.r.t tube",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx:149,safe,safe,149,geom/geom/src/TGeoTube.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx,2,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute distance from outside point to surface of the tube; /// Boundary safe algorithm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx:159,safe,safe,159,geom/geom/src/TGeoCone.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoCone.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute safe distance from each of the points in the input array.; /// Input: Array of point coordinates, array of statuses for these points, size of the arrays; /// Output: Safety values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx:94,safe,safe,94,geom/geom/src/TGeoArb8.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx,48,"['Safe', 'safe']","['Safety', 'safe']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute safe distance from the current point within an overlapping node",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:94,safe,safe,94,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute safe distance from the current point. This represent the distance; /// from POINT to the closest boundary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:94,safe,safe,94,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,2,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute safe linear step that can be made such that the error; /// between linear-helix extrapolation is less than EPSIL.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHelix.cxx:94,safe,safe,94,geom/geom/src/TGeoHelix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHelix.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute safety distance for a union node;",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBoolNode.cxx:94,safe,safety,94,geom/geom/src/TGeoBoolNode.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoBoolNode.cxx,3,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute safety for the parallel world; /// (original version based on TGeoVoxelFinder)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:94,safe,safety,94,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute safety for the parallel world; /// (trivial loop version for comparison/debugging)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:94,safe,safety,94,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute safety for the parallel world; /// (using pure BVH traversal, mainly for debugging/fallback since VoxelSafety should be faster)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:94,safe,safety,94,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute safety for the parallel world; /// used BVH structure with addiditional on-the-fly 3D grid/voxel caching ---> essentially an O(1) algorithm !)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:94,safe,safety,94,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute safety from POINT to segment between planes ipl, ipl+1 within safmin.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPcon.cxx:94,safe,safety,94,geom/geom/src/TGeoPcon.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoPcon.cxx,2,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute safety to sector iz, returning also the closest segment index.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoXtru.cxx:94,safe,safety,94,geom/geom/src/TGeoXtru.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoXtru.cxx,1,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute scatter angle into the detector's material; /// for the current particle; /// for more infos, please refer to the particle data booklet; /// from which the formulas has been extracted :; /// Multiple scattering through small angles.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:117,detect,detector,117,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['detect'],['detector']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Compute timing per ""FindNextBoundary"" + ""Safety"" call. Volume must be; /// in the current path.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx:127,Safe,Safety,127,geom/geompainter/src/TGeoChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx,1,['Safe'],['Safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Computes the distance in pixels from the given point to the given; /// text layout. Non-displaying space characters that occur at the end of; /// individual lines in the text layout are ignored for hit detection; /// purposes.; ///; /// The return value is 0 if the point (x, y) is inside the text layout.; /// If the point isn't inside the text layout then the return value is the; /// distance in pixels from the point to the text item.; ///; /// x, y -- Coordinates of point to check, with respect to the upper-left; /// corner of the text layout (in pixels).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:288,detect,detection,288,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['detect'],['detection']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Configures _typeversion tag in JSON; /// One can specify name of the JSON tag like ""_typeversion"" or ""$tv"" which will be used to store class version; /// Such tag can be used to correctly recover objects from JSON; /// If empty string is provided (default), class version will not be stored",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx:274,recover,recover,274,io/io/src/TBufferJSON.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx,1,['recover'],['recover']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Double_t variable bin size (along Y axis) 2-D histograms.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins along the X axis; /// \param[in] xlow low edge of the X axis first bin; /// \param[in] xup upper edge of the X axis last bin (not included in last bin); /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type double and size nbinsy+1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:205,avoid,avoid,205,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for Double_t variable bin size 2-D histograms.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type double and size nbinsy+1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:190,avoid,avoid,190,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for fix bin size 2-D histograms.; /// Creates the main histogram structure.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`,; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins along the X axis; /// \param[in] xlow low edge of the X axis first bin; /// \param[in] xup upper edge of the X axis last bin (not included in last bin); /// \param[in] nbinsy number of bins along the Y axis; /// \param[in] ylow low edge of the Y axis first bin; /// \param[in] yup upper edge of the Y axis last bin (not included in last bin)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:219,avoid,avoid,219,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for fix bin size 3-D histograms.; /// Creates the main histogram structure.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`,; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins along the X axis; /// \param[in] xlow low edge of the X axis first bin; /// \param[in] xup upper edge of the X axis last bin (not included in last bin); /// \param[in] nbinsy number of bins along the Y axis; /// \param[in] ylow low edge of the Y axis first bin; /// \param[in] yup upper edge of the Y axis last bin (not included in last bin); /// \param[in] nbinsz number of bins along the Z axis; /// \param[in] zlow low edge of the Z axis first bin; /// \param[in] zup upper edge of the Z axis last bin (not included in last bin)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:219,avoid,avoid,219,hist/hist/src/TH3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for fix bin size histograms.; /// Creates the main histogram structure.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`,; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbins number of bins; /// \param[in] xlow low edge of first bin; /// \param[in] xup upper edge of last bin (not included in last bin)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:215,avoid,avoid,215,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for the timer to stop/abort processing.; /// The 'timeout' is in seconds.; /// Make sure that 'to' make sense, i.e. not larger than 10 days;; /// the minimum value is 10 ms (0 does not seem to start the timer ...).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:120,abort,abort,120,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X and Y axis) 2-D histograms using input; /// arrays of type float.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type float and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type float and size nbinsy+1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:240,avoid,avoid,240,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X axis) 2-D histograms using an input array; /// of type double.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbinsx+1; /// \param[in] nbinsy number of bins along the Y axis; /// \param[in] ylow low edge of the Y axis first bin; /// \param[in] yup upper edge of the Y axis last bin (not included in last bin)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx:237,avoid,avoid,237,hist/hist/src/TH2.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH2.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; /// arrays of type double.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type double and size nbinsy+1; /// \param[in] nbinsz number of bins; /// \param[in] zbins array of low-edges for each bin.; /// This is an array of type double and size nbinsz+1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:244,avoid,avoid,244,hist/hist/src/TH3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size (along X, Y and Z axis) 3-D histograms using input; /// arrays of type float.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbinsx number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type float and size nbinsx+1; /// \param[in] nbinsy number of bins; /// \param[in] ybins array of low-edges for each bin.; /// This is an array of type float and size nbinsy+1; /// \param[in] nbinsz number of bins; /// \param[in] zbins array of low-edges for each bin.; /// This is an array of type float and size nbinsz+1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx:243,avoid,avoid,243,hist/hist/src/TH3.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH3.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size histograms using an input array of type double.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbins number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type double and size nbins+1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:213,avoid,avoid,213,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor for variable bin size histograms using an input array of type float.; /// Creates the main histogram structure.; ///; /// \param[in] name name of histogram (avoid blanks); /// \param[in] title histogram title.; /// If title is of the form `stringt;stringx;stringy;stringz`; /// the histogram title is set to `stringt`,; /// the x axis title to `stringx`, the y axis title to `stringy`, etc.; /// \param[in] nbins number of bins; /// \param[in] xbins array of low-edges for each bin.; /// This is an array of type float and size nbins+1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx:255,avoid,avoid,255,hist/hist/src/TH1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TH1.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructor from index category and full list of PDFs.; /// In this constructor form, a PDF must be supplied for each indexCat state; /// to avoid ambiguities. The PDFs are associated with the states of the; /// index category as they appear when iterating through the category states; /// with RooAbsCategory::begin() and RooAbsCategory::end(). This usually means; /// they are associated by ascending index numbers.; ///; /// PDFs may not overlap (i.e. share any variables) with the index category (function)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx:227,avoid,avoid,227,roofit/roofitcore/src/RooSimultaneous.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooSimultaneous.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Constructs item name from object name; /// if special symbols like '/', '#', ':', '&', '?' are used in object name; /// they will be replaced with '_'.; /// To avoid item name duplication, additional id number can be appended",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx:246,avoid,avoid,246,net/http/src/TRootSniffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Copy from an existing proxy.; /// It will accept any RooTemplateProxy instance, and attempt a dynamic_cast on its payload.; /// \param[in] theName Name of this proxy.; /// \param[in] owner Pointer to the owner this proxy should be registered to.; /// \param[in] other Instance of a different proxy whose payload should be copied.; /// \param[in] allowWrongTypes Instead of throwing a std::invalid_argument, only issue an; /// error message when payload with wrong type is found. This is unsafe, but may be necessary; /// when reading back legacy types. Defaults to false.; /// \throw std::invalid_argument if the types of the payloads are incompatible.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooTemplateProxy.h:573,unsafe,unsafe,573,roofit/roofitcore/inc/RooTemplateProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooTemplateProxy.h,1,['unsafe'],['unsafe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Copy, multiply from right and return product.; /// Avoid unless necessary.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrans.cxx:137,Avoid,Avoid,137,graf3d/eve/src/TEveTrans.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrans.cxx,2,['Avoid'],['Avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Create a TKey object for a TObject* and fill output buffer; ///; /// WARNING: in name avoid special characters like '^','$','.' that are used; /// by the regular expression parser (see TRegexp).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx:172,avoid,avoid,172,io/io/src/TKey.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Create a TKey object for any object obj of class cl d and fill; /// output buffer.; ///; /// WARNING: in name avoid special characters like '^','$','.' that are used; /// by the regular expression parser (see TRegexp).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx:196,avoid,avoid,196,io/io/src/TKey.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Create a TKey object with the specified name, title for the given class.; ///; /// WARNING: in name avoid special characters like '^','$','.' that are used; /// by the regular expression parser (see TRegexp).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx:186,avoid,avoid,186,io/io/src/TKey.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx,2,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Create a resource table and read the (possibly) three resource files,; /// i.e. `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`), `$HOME/<name>`; /// and `$PWD/<name>`. ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You; /// can read additional user defined resource files by creating additional TEnv; /// objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of; /// the `$HOME/<name>` resource file will be skipped. This might be useful in; /// case the home directory resides on an automounted remote file system; /// and one wants to avoid the file system from being mounted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:656,avoid,avoid,656,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Create a resource table and read the (possibly) three resource files,; /// i.e.\ `$ROOTSYS/etc/system<name>` (or `ROOTETCDIR/system<name>`),; /// `$HOME/<name>` and `$PWD/<name>`.; /// ROOT always reads "".rootrc"" (in TROOT::InitSystem()). You can; /// read additional user defined resource files by creating additional TEnv; /// objects. By setting the shell variable ROOTENV_NO_HOME=1 the reading of; /// the `$HOME/<name>` resource file will be skipped. This might be useful in; /// case the home directory resides on an auto-mounted remote file system; /// and one wants to avoid the file system from being mounted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TEnv.cxx:663,avoid,avoid,663,core/base/src/TEnv.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TEnv.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Create a secure temporary file by appending a unique; /// 6 letter string to base. The file will be created in; /// a standard (system) directory or in the directory; /// provided in dir. Optionally one can provide suffix; /// append to the final name - like extension "".txt"" or "".html"".; /// The full filename is returned in base; /// and a filepointer is returned for safely writing to the file; /// (this avoids certain security problems). Returns 0 in case; /// of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:456,safe,safely,456,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,2,"['avoid', 'safe']","['avoids', 'safely']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Create appropriate generator context for this convolution. If both input p.d.f.s support; /// internal generation, if it is safe to use them and if no observables other than the convolution; /// observable are requested for generation, use the specialized convolution generator context; /// which implements a smearing strategy in the convolution observable. If not return the; /// regular accept/reject generator context",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx:210,safe,safe,210,roofit/roofitcore/src/RooFFTConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFFTConvPdf.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Create timer that times out in ms milliseconds. If milliSec is 0; /// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; /// i.e. 10 ms). If mode == kTRUE then the timer is synchronous else; /// a-synchronous. The default is synchronous. Add a timer to the system; /// eventloop by calling TurnOn(). Set command to be executed from Notify(); /// or set the object whose HandleTimer() method will be called via Notify(),; /// derive from TTimer and override Notify() or connect slots to the; /// signals Timeout(), TurnOn() and TurnOff().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimer.cxx:165,timeout,timeout,165,core/base/src/TTimer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimer.cxx,3,"['Timeout', 'timeout']","['Timeout', 'timeout']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Creates embedded civetweb server; ///; /// @param args string with civetweb server configuration; ///; /// As main argument, http port should be specified like ""8090"".; /// Or one can provide combination of ipaddress and portnumber like ""127.0.0.1:8090""; /// Or one can specify unix socket name like ""x/tmp/root.socket""; /// Extra parameters like in URL string could be specified after '?' mark:; ///; /// thrds=N - there N is number of threads used by the civetweb (default is 10); /// top=name - configure top name, visible in the web browser; /// ssl_certificate=filename - SSL certificate, see docs/OpenSSL.md from civetweb; /// auth_file=filename - authentication file name, created with htdigets utility; /// auth_domain=domain - authentication domain; /// websocket_timeout=tm - set web sockets timeout in seconds (default 300); /// websocket_disable - disable web sockets handling (default enabled); /// bind - ip address to bind server socket; /// loopback - bind specified port to loopback 127.0.0.1 address; /// debug - enable debug mode, server always returns html page with request info; /// log=filename - configure civetweb log file; /// max_age=value - configures ""Cache-Control: max_age=value"" http header for all file-related requests, default 3600; /// socket_mode=value - configures unix socket mode, default is 0700; /// nocache - try to fully disable cache control for file requests; /// winsymlinks=no - do not resolve symbolic links on file system (Windows only), default true; /// dirlisting=no - enable/disable directory listing for browsing filesystem (default no); ///; /// Examples of valid args values:; ///; /// serv->CreateEngine(""http:8080?websocket_disable"");; /// serv->CreateEngine(""http:7546?thrds=30&websocket_timeout=20"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TCivetweb.cxx:888,timeout,timeout,888,net/http/src/TCivetweb.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TCivetweb.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Creates special thread to process all requests, directed to http server; ///; /// Should be used with care - only dedicated instance of TRootSniffer is allowed; /// By default THttpServer allows to access global lists pointers gROOT or gFile.; /// To be on the safe side, all kind of such access performed from the main thread.; /// Therefore usage of specialized thread means that no any global pointers will; /// be accessible by THttpServer",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx:347,safe,safe,347,net/http/src/THttpServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/THttpServer.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Custom streamer for the workspace. Stream contents of workspace; /// and code repository. When reading, read code repository first; /// and compile missing classes before proceeding with streaming; /// of workspace contents to avoid errors.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:313,avoid,avoid,313,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// De-activate a system event handler. Use this method to temporarily; /// disable an event handler to avoid it from being recursively called.; /// Use DeActivate() / Activate() instead of Remove() / Add() for this; /// purpose, since the Add() will add the handler back to the end of; /// the list of handlers and cause it to be called again for the same,; /// already handled, event.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSysEvtHandler.cxx:186,avoid,avoid,186,core/base/src/TSysEvtHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSysEvtHandler.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Default constructor; /// Initialisation of TSVDUnfold; /// User provides data and MC test spectra, as well as detector response matrix and the covariance matrix of the measured distribution",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx:196,detect,detector,196,hist/hist/src/TSVDUnfold.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TSVDUnfold.cxx,1,['detect'],['detector']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Define the options (their key words) that can be set in the option string.; ///; /// - UseRandomisedTrees choose at each node splitting a random set of variables; /// - UseNvars use UseNvars variables in randomised trees; /// - SeparationType the separation criterion applied in the node splitting.; /// known:; /// - GiniIndex; /// - MisClassificationError; /// - CrossEntropy; /// - SDivSqrtSPlusB; /// - nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); /// - nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; /// step size is determined by the events); /// - UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; /// (from the training) in the leaf node; /// - NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; /// misclassification error rate); /// - PruneMethod The Pruning method:; /// known:; /// - NoPruning // switch off pruning completely; /// - ExpectedError; /// - CostComplexity; /// - PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDT.cxx:1260,avoid,avoided,1260,tmva/tmva/src/MethodDT.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/MethodDT.cxx,1,['avoid'],['avoided']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Detect a collection written using a zero pointer in old versions of root.; /// In versions of ROOT older than 4.00/03, if a collection (TClonesArray; /// or STL container) was split but the pointer to the collection was zeroed; /// out, nothing was saved. Hence there is no __easy__ way to detect the; /// case. In newer versions, a zero is written so that a 'missing' collection; /// appears to be an empty collection.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx:86,Detect,Detect,86,tree/tree/src/TBranchElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranchElement.cxx,2,"['Detect', 'detect']","['Detect', 'detect']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Direct generation is safe if all components say so",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:107,safe,safe,107,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Directives should contain the description on how to compile and link a; /// shared lib. This description can be any valid shell command, including; /// the use of ';' to separate several instructions. However, shell specific; /// construct should be avoided. In particular this description can contain; /// environment variables, like $ROOTSYS (or %ROOTSYS% on windows).; /// ~~~ {.cpp}; /// Five special variables will be expanded before execution:; /// Variable name Expands to; /// ------------- ----------; /// $SourceFiles Name of source files to be compiled; /// $SharedLib Name of the shared library being created; /// $LibName Name of shared library without extension; /// $BuildDir Directory where the files will be created; /// $IncludePath value of fIncludePath; /// $LinkedLibs value of fLinkedLibs; /// $DepLibs libraries on which this library depends on; /// $ObjectFiles Name of source files to be compiler with; /// their extension changed to .o or .obj; /// $Opt location of the optimization/debug options; /// set fFlagsDebug and fFlagsOpt; /// ~~~; /// e.g.:; /// ~~~ {.cpp}; /// gSystem->SetMakeSharedLib(; /// ""KCC -n32 --strict $IncludePath -K0 \$Opt $SourceFile; /// --no_exceptions --signed_chars --display_error_number; /// --diag_suppress 68 -o $SharedLib"");; ///; /// gSystem->setMakeSharedLib(; /// ""Cxx $IncludePath -c $SourceFile;; /// ld -L/usr/lib/cmplrs/cxx -rpath /usr/lib/cmplrs/cxx -expect_unresolved; /// \$Opt -shared /usr/lib/cmplrs/cc/crt0.o /usr/lib/cmplrs/cxx/_main.o; /// -o $SharedLib $ObjectFile -lcxxstd -lcxx -lexc -lots -lc""; ///; /// gSystem->SetMakeSharedLib(; /// ""$HOME/mygcc/bin/g++ \$Opt -Wall -fPIC $IncludePath $SourceFile; /// -shared -o $SharedLib"");; ///; /// gSystem->SetMakeSharedLib(; /// ""cl -DWIN32 -D_WIN32 -D_MT -D_DLL -MD /O2 /G5 /MD -DWIN32; /// -D_WINDOWS $IncludePath $SourceFile; /// /link -PDB:NONE /NODEFAULTLIB /INCREMENTAL:NO /RELEASE /NOLO",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:336,avoid,avoided,336,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['avoid'],['avoided']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Disconnect every widget entry of the editor from its slot. Must be; /// called before UpdateEditor() to avoid recursive calls.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx:190,avoid,avoid,190,gui/ged/src/TStyleManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleManager.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Draw feedback creation proxy. When accessed via TProof avoids; /// link dependency on libProofPlayer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:141,avoid,avoids,141,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['avoid'],['avoids']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Draws the distribution (on the test sample) of the; /// impact on the network output of a small variation of; /// each input.; /// DrawDInputs() draws something that approximates the distribution of the; /// derivative of the NN w.r.t. each input. That quantity is recognized as; /// one of the measures to determine key quantities in the network.; ///; /// What is done is to vary one input around its nominal value and to see; /// how the NN changes. This is done for each entry in the sample and produces; /// a distribution.; ///; /// What you can learn from that is:; /// - is variable a really useful, or is my network insensitive to it ?; /// - is there any risk of big systematic ? Is the network extremely sensitive; /// to small variations of any of my inputs ?; ///; /// As you might understand, this is to be considered with care and can serve; /// as input for an ""educated guess"" when optimizing the network.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMLPAnalyzer.cxx:751,risk,risk,751,math/mlp/src/TMLPAnalyzer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/mlp/src/TMLPAnalyzer.cxx,1,['risk'],['risk']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Enable/disable the timer to stop/abort processing.; /// The 'timeout' is in seconds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:119,abort,abort,119,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,2,"['abort', 'timeout']","['abort', 'timeout']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Estimate safety to lateral plane defined by segment iseg in range [0,3]; /// Might be negative: plane seen only from inside.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx:95,safe,safety,95,geom/geom/src/TGeoArb8.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoArb8.cxx,1,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Estimates the error rate with the current set of parameters.; /// It calculates the area under the bkg rejection vs signal efficiency curve.; /// The value returned is 1-area.; /// This works but is less efficient than calculating the Risk using RiskPerf().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:321,Risk,Risk,321,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,2,['Risk'],"['Risk', 'RiskPerf']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Exception handler: we do not try to recover here, just exit.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:122,recover,recover,122,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['recover'],['recover']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Exception safe assignment operator",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx:96,safe,safe,96,tree/treeplayer/src/TFormLeafInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx,2,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Exception safe assignment operator.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx:96,safe,safe,96,tree/treeplayer/src/TFormLeafInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx,8,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Exception safe swap.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx:96,safe,safe,96,tree/treeplayer/src/TFormLeafInfo.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TFormLeafInfo.cxx,9,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Expand (or shrink) the I/O buffer to newsize bytes.; /// If copy is true (the default), the existing content of the; /// buffer is preserved, otherwise the buffer is returned zero-ed out.; ///; /// In order to avoid losing data, if the current length is greater than; /// the requested size, we only shrink down to the current length.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx:296,avoid,avoid,296,core/base/src/TBuffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TBuffer.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Explicitly deletes the shared properties list on exit to avoid problems; /// with the initialization order. Meant to be only used internally in RooFit; /// by RooSentinel.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx:143,avoid,avoid,143,roofit/roofitcore/src/RooRealVar.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooRealVar.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Find distance to next boundary and store it in fStep. Returns node to which this; /// boundary belongs. If PATH is specified, compute only distance to the node to which; /// PATH points. If STEPMAX is specified, compute distance only in case fSafety is smaller; /// than this value. STEPMAX represent the step to be made imposed by other reasons than; /// geometry (usually physics processes). Therefore in this case this method provides the; /// answer to the question : ""Is STEPMAX a safe step ?"" returning a NULL node and filling; /// fStep with a big number.; /// In case frombdr=kTRUE, the isotropic safety is set to zero.; ///; /// Note : safety distance for the current point is computed ONLY in case STEPMAX is; /// specified, otherwise users have to call explicitly TGeoManager::Safety() if; /// they want this computed for the current point.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:572,safe,safe,572,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,8,"['Safe', 'safe']","['Safety', 'safe', 'safety']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Flag all the elements as looked-up, so to avoid opening the files; /// if the functionality is not supported",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx:128,avoid,avoid,128,proof/proof/src/TDSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TDSet.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// For all classes in the workspace for which no class definition is; /// found in the ROOT class table extract source code stored in code; /// repository into temporary directory set by; /// setClassFileExportDir(), compile classes and link them with; /// current ROOT session. If a compilation error occurs print; /// instructions for user how to fix errors and recover workspace and; /// abort import procedure.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:447,recover,recover,447,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,2,"['abort', 'recover']","['abort', 'recover']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Forward determination of safety of internal generator code to; /// component p.d.f that would generate the given observable",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:111,safe,safety,111,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Function used internally to obtain the template prediction in the individual bins; /// 'bin' <=> 'i' (paper); /// 'par' <=> 'j' (paper)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:134,predict,prediction,134,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['predict'],['prediction']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Geometry checking. Optional overlap checkings (by sampling and by mesh). Optional; /// boundary crossing check + timing per volume.; ///; /// STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; /// checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; /// be called for the suspicious volumes.; ///; /// STAGE 2: normal overlap checking using the shapes mesh - fills the list of; /// overlaps.; ///; /// STAGE 3: shooting NRAYS rays from VERTEX and counting the total number of; /// crossings per volume (rays propagated from boundary to boundary until; /// geometry exit). Timing computed and results stored in a histo.; ///; /// STAGE 4: shooting 1 mil. random rays inside EACH volume and calling; /// FindNextBoundary() + Safety() for each call. The timing is normalized by the; /// number of crossings computed at stage 2 and presented as percentage.; /// One can get a picture on which are the most ""burned"" volumes during; /// transportation from geometry point of view. Another plot of the timing per; /// volume vs. number of daughters is produced.; ///; /// All histos are saved in the file statistics.root",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx:862,Safe,Safety,862,geom/geompainter/src/TGeoChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx,1,['Safe'],['Safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Geometry checking.; /// - if option contains 'o': Optional overlap checkings (by sampling and by mesh).; /// - if option contains 'b': Optional boundary crossing check + timing per volume.; ///; /// STAGE 1: extensive overlap checking by sampling per volume. Stdout need to be; /// checked by user to get report, then TGeoVolume::CheckOverlaps(0.01, ""s"") can; /// be called for the suspicious volumes.; ///; /// STAGE 2: normal overlap checking using the shapes mesh - fills the list of; /// overlaps.; ///; /// STAGE 3: shooting NRAYS rays from VERTEX and counting the total number of; /// crossings per volume (rays propagated from boundary to boundary until; /// geometry exit). Timing computed and results stored in a histo.; ///; /// STAGE 4: shooting 1 mil. random rays inside EACH volume and calling; /// FindNextBoundary() + Safety() for each call. The timing is normalized by the; /// number of crossings computed at stage 2 and presented as percentage.; /// One can get a picture on which are the most ""burned"" volumes during; /// transportation from geometry point of view. Another plot of the timing per; /// volume vs. number of daughters is produced.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:919,Safe,Safety,919,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['Safe'],['Safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Get a pointer to the element this material is made of.; /// This second call is to avoid warnings to not call a virtual; /// method from the constructor",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMaterial.cxx:169,avoid,avoid,169,geom/geom/src/TGeoMaterial.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoMaterial.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Get hash function for specified item; /// used to detect any changes in the specified object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx:136,detect,detect,136,net/http/src/TRootSniffer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/http/src/TRootSniffer.cxx,1,['detect'],['detect']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Get hash function for specified item; ///; /// Used to detect any changes in the specified object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/httpsniff/src/TRootSnifferFull.cxx:141,detect,detect,141,net/httpsniff/src/TRootSnifferFull.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/httpsniff/src/TRootSnifferFull.cxx,1,['detect'],['detect']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Get next packet;; /// A meaningfull difference to TPacketizer is the fact that this; /// packetizer, for each worker, tries to predict whether the worker; /// will finish processing it's local files before the end of the query.; /// If yes, it allocates, to those workers, files from non-slave filenodes; /// or from slaves that are overloaded. The check is done every time a new; /// file needs to be assigned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx:213,predict,predict,213,proof/proofplayer/src/TPacketizerAdaptive.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TPacketizerAdaptive.cxx,1,['predict'],['predict']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Graph constructor reading input from filename.; ///; /// `filename` is assumed to contain at least two columns of numbers.; /// The string format is by default `""%lg %lg""`.; /// This is a standard c formatting for `scanf()`.; /// For example, set format to `""%lg,%lg""` for a comma-separated file.; ///; /// If columns of numbers should be skipped, a `""%*lg""` or `""%*s""` for each column; /// can be added, e.g. `""%lg %*lg %lg""` would read x-values from the first and; /// y-values from the third column.; ///; /// For files separated by a specific delimiter different from ' ' and '\\t' (e.g.; /// ';' in csv files) you can avoid using `%*s` to bypass this delimiter by explicitly; /// specify the `option` argument,; /// e.g. option=`"" \\t,;""` for columns of figures separated by any of these characters; /// (' ', '\\t', ',', ';'); /// used once (e.g. `""1;1""`) or in a combined way (`"" 1;,;; 1""`).; /// Note in that case, the instantiation is about two times slower.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx:709,avoid,avoid,709,hist/hist/src/TGraph.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Graph2D constructor reading input from filename; /// filename is assumed to contain at least three columns of numbers.; /// For files separated by a specific delimiter different from ' ' and '\\t' (e.g. ';' in csv files); /// you can avoid using %*s to bypass this delimiter by explicitly specify the ""option"" argument,; /// e.g. option="" \\t,;"" for columns of figures separated by any of these characters (' ', '\\t', ',', ';'); /// used once (e.g. ""1;1"") or in a combined way ("" 1;,;; 1"").; /// Note in that case, the instantiation is about 2 times slower.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:320,avoid,avoid,320,hist/hist/src/TGraph2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Graph2D constructor with name, title and three vectors of doubles as input.; /// name : name of 2D graph (avoid blanks); /// title : 2D graph title; /// if title is of the form ""stringt;stringx;stringy;stringz""; /// the 2D graph title is set to stringt, the x axis title to stringx,; /// the y axis title to stringy,etc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx:192,avoid,avoid,192,hist/hist/src/TGraph2D.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraph2D.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// GraphErrors constructor reading input from `filename`.; ///; /// `filename` is assumed to contain at least 2 columns of numbers; ///; /// Convention for format (default=`""%lg %lg %lg %lg""`); ///; /// - format = `%lg %lg` read only 2 first columns into X,Y; /// - format = `%lg %lg %lg` read only 3 first columns into X,Y and EY; /// - format = `%lg %lg %lg %lg` read only 4 first columns into X,Y,EX,EY.; ///; /// For files separated by a specific delimiter different from ' ' and `\\t` (e.g. `;` in csv files); /// you can avoid using `%*s` to bypass this delimiter by explicitly specify the `option` argument,; /// e.g. `option="" \\t,;""` for columns of figures separated by any of these characters (`' ', '\\t', ',', ';'`); /// used once (e.g. `""1;1""`) or in a combined way (`"" 1;,;; 1""`).; ///; /// Note in that case, the instantiation is about 2 times slower.; /// In case a delimiter is specified, the format `""%lg %lg %lg""` will read X,Y,EX.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx:610,avoid,avoid,610,hist/hist/src/TGraphErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphErrors.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Handle Drop timeout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx:98,timeout,timeout,98,gui/gui/src/TGDNDManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGDNDManager.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Handle expiration of the shutdown timer. In the case of low activity the; /// process will be aborted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:180,abort,aborted,180,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,1,['abort'],['aborted']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Handle idle timeout. When this timer expires the registered idle command; /// will be executed by this routine and a signal will be emitted.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:98,timeout,timeout,98,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Handle standard C++ exceptions intercepted by the TSystem::Run().; ///; /// Virtual method EStatus Handle(std::exception& exc) is called on the; /// collection of handlers registered to TSystem. The return value of; /// each handler influences the continuation of handling procedure:; /// - kSEProceed - Proceed with passing of the exception to other; /// handlers, the exception has not been handled.; /// - kSEHandled - The exception has been handled, do not pass it to; /// other handlers.; /// - kSEAbort - Abort application.; /// If all handlers return kSEProceed TSystem::Run() rethrows the; /// exception, possibly resulting in process abortion.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSysEvtHandler.cxx:597,Abort,Abort,597,core/base/src/TSysEvtHandler.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSysEvtHandler.cxx,2,"['Abort', 'abort']","['Abort', 'abortion']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Handle the signal coming from the expiration of the timer; /// associated with an abort or stop request.; /// We raise an exception which will be processed in the; /// event loop.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:168,abort,abort,168,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,1,['abort'],['abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Helper routine to ry hard to avoid looking up in the Cling database as; /// this could enduce an unwanted autoparsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx:115,avoid,avoid,115,core/clingutils/src/TClingUtils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/clingutils/src/TClingUtils.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// If the semaphore value is > 0 then decrement it and carry on, else block.; /// If millisec > 0 then a relative timeout of millisec milliseconds is applied.; /// For backward compatibility with the first implementation, millisec == 0 means; /// no timeout.; /// Returns 1 if timed-out, 0 otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TSemaphore.cxx:197,timeout,timeout,197,core/thread/src/TSemaphore.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TSemaphore.cxx,2,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Import code of class 'tc' into the repository. If code is already in repository it is only imported; /// again if doReplace is false. The names and location of the source files is determined from the information; /// in TClass. If no location is found in the TClass information, the files are searched in the workspace; /// search path, defined by addClassDeclImportDir() and addClassImplImportDir() for declaration and implementation; /// files respectively. If files cannot be found, abort with error status, otherwise update the internal; /// class-to-file map and import the contents of the files, if they are not imported yet.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx:572,abort,abort,572,roofit/roofitcore/src/RooWorkspace.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooWorkspace.cxx,1,['abort'],['abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Imports the content of 'output' in the internal output list. Existing content; /// in the output list is discarded (unless found also in 'output').; /// In particular, if 'output' is nullptr or empty, reset the internal list.; /// On return, the content of 'output' is cleared to avoid double deletion issues.; /// (The caller is responsible of 'output' as container: its content is transferred; /// under the selector ownership).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:366,avoid,avoid,366,tree/tree/src/TSelector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// In case a previous safety value was computed, check if the safety region is; /// still safe for the current point and proposed step. Return value changed only; /// if proposed distance is safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx:105,safe,safety,105,geom/geom/src/TGeoNavigator.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoNavigator.cxx,4,['safe'],"['safe', 'safety']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// In case of a program crash, it will be possible to recover the data in the; /// tree up to the last AutoSave point.; /// This function may be called before filling a TTree to specify when the; /// branch buffers and TTree header are flushed to disk as part of; /// TTree::Fill().; /// The default is -300000000, ie the TTree will write data to disk once it; /// exceeds 300 MBytes.; /// CASE 1: If fAutoSave is positive the watermark is reached when a multiple of; /// fAutoSave entries have been filled.; /// CASE 2: If fAutoSave is negative the watermark is reached when -fAutoSave; /// bytes can be written to the file.; /// CASE 3: If fAutoSave is 0, AutoSave() will never be called automatically; /// as part of TTree::Fill().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:137,recover,recover,137,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,1,['recover'],['recover']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Init a PROOF slave object using the connection opened via s. Used to; /// avoid double opening when an attempt via TXSlave found a remote proofd.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx:160,avoid,avoid,160,proof/proof/src/TSlave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Initialize a new context for generating events with the specified; /// variables, using the specified PDF model. A prototype dataset (if provided); /// is not cloned and still belongs to the caller. The contents and shape; /// of this dataset can be changed between calls to generate() as long as the; /// expected columns to be copied to the generated dataset are present.; /// Any argument supplied in the forceDirect RooArgSet are always offered; /// for internal generation to the p.d.f., even if this is deemed unsafe by; /// the logic of RooGenContext.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx:602,unsafe,unsafe,602,roofit/roofitcore/src/RooGenContext.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooGenContext.cxx,1,['unsafe'],['unsafe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Initialize detector with material and dimensions",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.cxx:97,detect,detector,97,test/RootShower/MyDetector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyDetector.cxx,1,['detect'],['detector']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Initialize event ...; /// creates detector and set initial values",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:120,detect,detector,120,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['detect'],['detector']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Initialize the Thread package. This initializes the TThread and ROOT; /// global mutexes to make parts of ROOT thread safe/aware. This call is; /// implicit in case a TThread is created.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx:204,safe,safe,204,core/thread/src/TThread.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Initializes the tbb::task_arena within RTaskArenaWrapper.; ///; /// * Can't be reinitialized; /// * Checks for CPU bandwidth control and avoids oversubscribing; /// * If no BC in place and maxConcurrency<1, defaults to the default tbb number of threads,; /// which is CPU affinity aware; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/RTaskArena.cxx:223,avoid,avoids,223,core/imt/src/RTaskArena.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/imt/src/RTaskArena.cxx,1,['avoid'],['avoids']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Instantiate a clone of this resolution model representing a convolution with given; /// basis function. The owners object name is incorporated in the clones name; /// to avoid multiple convolution objects with the same name in complex PDF structures.; ///; /// Note: The 'inBasis' formula expression must be a RooFormulaVar that encodes the formula; /// in the title of the object and this expression must be an exact match against the; /// implemented basis function strings (see derived class implementation of method basisCode(); /// for those strings",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooResolutionModel.cxx:256,avoid,avoid,256,roofit/roofitcore/src/RooResolutionModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooResolutionModel.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Instantiate a clone of this resolution model representing a convolution with given; /// basis function. The owners object name is incorporated in the clones name; /// to avoid multiple convolution objects with the same name in complex PDF structures.; ///; /// RooAddModel will clone all the component models to create a composite convolution object",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx:256,avoid,avoid,256,roofit/roofitcore/src/RooAddModel.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAddModel.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Internal subprogram used by Create.; /// It explores newly defined cell with help of special short MC sampling.; /// As a result, estimates of kTRUE and drive volume is defined/determined; /// Average and dispersion of the weight distribution will is found along; /// each edge and the best edge (minimum dispersion, best maximum weight); /// is memorized for future use.; /// The optimal division point for eventual future cell division is; /// determined/recorded. Recorded are also minimum and maximum weight etc.; /// The volume estimate in all (inactive) parent cells is updated.; /// Note that links to parents and initial volume = 1/2 parent has to be; /// already defined prior to calling this routine.; ///; /// If fNmin > 0 then the total number of (training) events found in; /// the cell during the exploration is stored in the cell. This; /// information is used within PeekMax() to avoid splitting cells; /// which contain less than fNmin events.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx:982,avoid,avoid,982,tmva/tmva/src/PDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Load the specified macro on master, workers and, if notOnClient is; /// kFALSE, on the client. The macro file is uploaded if new or updated.; /// Additional files to be uploaded (or updated, if needed) can be specified; /// after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"".; /// If existing in the same directory, a header basename(macro).h or .hh, is also; /// uploaded.; /// The default is to load the macro also on the client; notOnClient can be used; /// to avoid loading on the client.; /// On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers; /// only, and collection is not done; if uniqueWorkers is kFALSE, collection; /// from the previous request is done, and broadcasting + collection from the; /// other workers is done.; /// The wrks arg can be used on the master to limit the set of workers.; /// Returns 0 in case of success and -1 in case of error.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:558,avoid,avoid,558,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// MD5 assignment operator. Special assignment operator avoids; /// copying unnecessary temp arrays when finalized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMD5.cxx:139,avoid,avoids,139,core/base/src/TMD5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMD5.cxx,1,['avoid'],['avoids']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// MD5 copy ctor. Special copy ctor avoids copying unnecessary; /// temp arrays when finalized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMD5.cxx:119,avoid,avoids,119,core/base/src/TMD5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMD5.cxx,1,['avoid'],['avoids']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Make a step from current point along the helix and compute new point, direction and angle; /// To reach a plane/ shape boundary, one has to:; /// 1. Compute the safety to the plane/boundary; /// 2. Define / update a helix according local field and particle state (position, direction, charge); /// 3. Compute the magnetic safety (maximum distance for which the field can be considered constant); /// 4. Call TGeoHelix::Step() having as argument the minimum between 1. and 3.; /// 5. Repeat from 1. until the step to be made is small enough.; /// 6. Add to the total step the distance along a straight line from the last point; /// to the plane/shape boundary",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHelix.cxx:247,safe,safety,247,geom/geom/src/TGeoHelix.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoHelix.cxx,2,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Method to initialize the safety voxel at a specific 3D voxel (grid) index; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:111,safe,safety,111,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Method which adds the sWeights to the dataset.; ///; /// The SPlot will contain two new variables for each yield parameter:; /// - `L_<varname>` is the likelihood for each event, i.e., the pdf evaluated for the a given value of the variable ""varname"".; /// - `<varname>_sw` is the value of the sWeight for the variable ""varname"" for each event.; ///; /// Find Parameters in the PDF to be considered fixed when calculating the SWeights; /// and be sure to NOT include the yields in that list.; ///; /// After fixing non-yield parameters, this function will start a fit by calling; /// ```; /// pdf->fitTo(*fSData, RooFit::Extended(true), RooFit::SumW2Error(true), RooFit::PrintLevel(-1), RooFit::PrintEvalErrors(-1)).; /// ```; /// One can pass additional arguments to `fitTo`, such as `RooFit::Range(""fitrange"")`, as `arg5`, `arg6`, `arg7`, `arg8`.; ///; /// \note A `RooFit::Range` may be necessary to get expected results if you initially fit in a range; /// and/or called `pdf->fixCoefRange(""fitrange"")` on `pdf`.; /// Pass `arg5`, `arg6`, `arg7`, `arg8` AT YOUR OWN RISK.; ///; /// \param[in] pdf PDF to fit to data to compute s weights.; /// \param[in] yieldsTmp Yields to use to compute s weights.; /// \param[in] projDeps These will not be normalized over when calculating the sWeights,; /// and will be considered parameters, not observables.; /// \param[in] includeWeights Include weights of the input data in calculation of s weights.; /// \param[in] arg5,arg6,arg7,arg8 Optional additional arguments for the fitting step.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/SPlot.cxx:1156,RISK,RISK,1156,roofit/roostats/src/SPlot.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roostats/src/SPlot.cxx,1,['RISK'],['RISK']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Minimization function for H1s using a Likelihood method.; /// Basically, it forms the likelihood by determining the Poisson; /// probability that given a number of entries in a particular bin,; /// the fit would predict it's value. This is then done for each bin,; /// and the sum of the logs is taken as the likelihood.; /// PDF: P=exp(-f(x_i))/[F_i]!*(f(x_i))^[F_i]; /// where F_i - experimental value, f(x_i) - expected theoretical value; /// [F_i] - integer part of F_i.; /// drawback is that if F_i>Int_t - GetSumLog will fail; /// for big F_i is faster to use Euler's Gamma-function",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:298,predict,predict,298,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['predict'],['predict']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Minimization function for H1s using a Likelihood method.; /// Basically, it forms the likelihood by determining the Poisson; /// probability that given a number of entries in a particular bin,; /// the fit would predict it's value. This is then done for each bin,; /// and the sum of the logs is taken as the likelihood.; ///; /// Default method (function evaluated at center of bin); /// for each point the cache contains the following info; /// - 1D : bc,e,xc (bin content, error, x of center of bin); /// - 2D : bc,e,xc,yc; /// - 3D : bc,e,xc,yc,zc",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:298,predict,predict,298,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['predict'],['predict']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Minimization function for H1s using a Likelihood method.; /// Basically, it forms the likelihood by determining the Poisson; /// probability that given a number of entries in a particular bin,; /// the fit would predict it's value. This is then done for each bin,; /// and the sum of the logs is taken as the likelihood.; ///; /// The ""I""ntegral method is used; /// for each point the cache contains the following info; /// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); /// - 2D : bc,e,xc,xw,yc,yw; /// - 3D : bc,e,xc,xw,yc,yw,zc,zw",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx:298,predict,predict,298,math/fumili/src/TFumili.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/fumili/src/TFumili.cxx,1,['predict'],['predict']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Move particle ""id"" by step dist, update the distance covered; /// then check if out of detector's bounds.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx:173,detect,detector,173,test/RootShower/MyEvent.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/test/RootShower/MyEvent.cxx,1,['detect'],['detector']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Move to a canvas named `<name>_canvas`; create the canvas if not existing.; /// Used to avoid screwing up existing plots when non default names are used; /// for the final objects",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx:174,avoid,avoid,174,proof/proofplayer/src/TProofDraw.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofDraw.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Now let calculate what physical instance we really need.; /// Some redundant code is used to speed up the cases where; /// they are no dimensions.; ///; /// We know that instance is less that fCumulUsedSize[0] so; /// we can skip the modulo when virt_dim is 0.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:153,redund,redundant,153,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['redund'],['redundant']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Open a connection to a MySQL DB server. The db arguments should be; /// of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; /// ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; /// the password that should be used for the connection.; ///; /// In addition, several parameters can be specified in url after ""?"" symbol:; /// timeout=N n is connect timeout is seconds; /// socket=socketname socketname should be name of Unix socket, used; /// for connection; /// multi_statements tell the server that the client may send multiple; /// statements in a single string (separated by ;);; /// multi_results tell the server that the client can handle multiple; /// result sets from multiple-statement executions or; /// stored procedures; /// reconnect=0|1 enable or disable automatic reconnection to the server; /// if the connection is found to have been lost; /// compress use the compressed client/server protocol; /// cnf_file=filename Read options from the named option file instead of; /// from my.cnf; /// cnf_group=groupname Read options from the named group from my.cnf or the; /// file specified with cnf_file option; /// If several parameters are specified, they should be separated by ""&"" symbol; /// Example of connection argument:; /// TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/src/TMySQLServer.cxx:435,timeout,timeout,435,sql/mysql/src/TMySQLServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/sql/mysql/src/TMySQLServer.cxx,3,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Overloadable function in which derived classes can implement; /// consistency checks of the variables. If this function returns; /// true, indicating an error, the fitter or generator will abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:275,abort,abort,275,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,1,['abort'],['abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Overridden function of PDEFoam to avoid native foam output.; /// Draw TMVA-process bar instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx:120,avoid,avoid,120,tmva/tmva/src/PDEFoam.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoam.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Parse a string boolean expression and do a syntax check. Find top; /// level boolean operator and returns its type. Fill the two; /// substrings to which this operator applies. The returned integer is :; /// - -1 : parse error; /// - 0 : no boolean operator; /// - 1 : union - represented as '+' in expression; /// - 2 : difference (subtraction) - represented as '-' in expression; /// - 3 : intersection - represented as '*' in expression.; /// Parentheses should be used to avoid ambiguities. For instance :; /// - A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); /// eliminate not needed parentheses",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx:562,avoid,avoid,562,geom/geom/src/TGeoManager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoManager.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; /// commands MIGRAD, HESSE in succession; ///; /// The following named arguments are supported; ///; /// <table>; /// <tr><th> <th> Options to control construction of chi2; /// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; /// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; /// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; /// (in RooFit jargon, ""if the pdf can be extended"").; /// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; /// and the chi2 will fall back to the total data weight to scale the normalized pdf.; /// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; /// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; /// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; /// printed and you'll most likely get garbage results.; /// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; /// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; /// Multiple comma separated range names can be specified.; /// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; /// <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization (on by default); /// <tr><td> `IntegrateBins()`",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx:494,predict,predicted,494,roofit/roofitcore/src/RooAbsReal.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsReal.cxx,4,['predict'],"['predicted', 'prediction']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Perform a quick sanity check to ensure we won't overflow the X; /// coordinate space.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx:102,sanity check,sanity check,102,gui/gui/src/TGFont.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGFont.cxx,1,['sanity check'],['sanity check']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Poll over the read descriptor for to secs;; /// Return:; /// >0 ready to poll; /// 0 timeout; /// -1 invalid descriptor; /// <-1 -errno from 'poll'",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx:171,timeout,timeout,171,net/rpdutils/src/rpdconn.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdconn.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Print the overlaps which were detected during real tracking",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx:116,detect,detected,116,geom/geom/src/TGeoParallelWorld.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoParallelWorld.cxx,1,['detect'],['detected']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Private helper function which will dispatch to; /// TObjectTable::AddObj.; /// Included here to avoid circular dependency between header files.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx:182,avoid,avoid,182,core/base/src/TObject.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TObject.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// REveGeoManagerHolder; /// Exception-safe global variable holders; ////////////////////////////////////////////////////////////////////////////////",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/inc/ROOT/REveUtil.hxx:122,safe,safe,122,graf3d/eve7/inc/ROOT/REveUtil.hxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/inc/ROOT/REveUtil.hxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Read TObject data members from JSON.; /// Do not call TObject::Streamer() to avoid special tweaking of TBufferJSON interface",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx:163,avoid,avoid,163,io/io/src/TBufferJSON.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Read class version from I/O buffer; ///; /// To be used when streaming out member-wise streamed collection where we do not; /// care (not save) about the byte count and can safely ignore missing streamerInfo; /// (since they usually indicate empty collections).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:259,safe,safely,259,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,1,['safe'],['safely']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Read the contents of the argset in ASCII form from given stream.; ///; /// The stream is read to end-of-file and each line is assumed to be; /// of the form; /// \code; /// <argName> = <argValue>; /// \endcode; /// Lines starting with argNames not matching any element in the list; /// will be ignored with a warning message. In addition limited C++ style; /// preprocessing and flow control is provided. The following constructions; /// are recognized:; /// \code; /// include ""include.file""; /// \endcode; /// Include given file, recursive inclusion OK; /// \code; /// if (<boolean_expression>); /// <name> = <value>; /// ....; /// else if (<boolean_expression>); /// ....; /// else; /// ....; /// endif; /// \endcode; ///; /// All expressions are evaluated by RooFormula, and may involve any of; /// the sets variables.; /// \code; /// echo <Message>; /// \endcode; /// Print console message while reading from stream; /// \code; /// abort; /// \endcode; /// Force termination of read sequence with error status; ///; /// The value of each argument is read by the arguments readFromStream; /// function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooArgSet.cxx:1023,abort,abort,1023,roofit/roofitcore/src/RooArgSet.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooArgSet.cxx,1,['abort'],['abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Recall TBuffer function to avoid gcc warning message",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx:113,avoid,avoid,113,io/io/src/TBufferJSON.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx,2,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Render DrawElements in elementVec with given timeout.; /// If clipPlanes is non-zero, test each element against its; /// clipping planes.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx:131,timeout,timeout,131,graf3d/gl/src/TGLScene.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLScene.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Replace 'oldServer' with 'newServer', specifying whether the new server has; /// value or shape server properties.; ///; /// \warning This function should not be used! This method is quite unsafe for; /// many reasons. For once, the new server will be put at the end of the server; /// list, no matter the position of the original server. This might mess up; /// code that expects the servers to be in a certain order. Furthermore, the; /// proxy objects corresponding to the server are not updated, leaving the; /// object in an invalid state where the servers are out of sync with the; /// proxies. This can have very bad consequences. Finally, by having to; /// manually specify the value and shape server properties, it is very easy to; /// get them wrong.; ///; /// If you want to safely replace a server, you should use; /// RooAbsArg::redirectServers(), which replaces the server in-place at the; /// same position of the server list, keeps the same value and shape server; /// properties, and also updates the corresponding proxies.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx:275,unsafe,unsafe,275,roofit/roofitcore/src/RooAbsArg.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsArg.cxx,2,"['safe', 'unsafe']","['safely', 'unsafe']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Reset all baskets' state arrays. This function is only called by main; /// thread and parallel processing from upper layers should be disabled such; /// as IMT in TTree::GetEntry(). Other threads should not call this function; /// since it is not thread-safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:340,safe,safe,340,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Reset the read basket TBuffer memory allocation if needed.; ///; /// This allows to reduce the number of memory allocation while avoiding to; /// always use the maximum size.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx:215,avoid,avoiding,215,tree/tree/src/TBasket.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBasket.cxx,1,['avoid'],['avoiding']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Retrieve specific ROOT password from $HOME/fpw, if any.; /// To avoid problems with NFS-root-squashing, if 'root' changes temporarly the; /// uid/gid to those of the target user (usr).; /// If OK, returns pass length and fill 'pass' with the password, null-terminated.; /// ('pass' is allocated externally to contain max lpwmax bytes).; /// If the file does not exists, return 0 and an empty pass.; /// If any problems with the file occurs, return a negative; /// code, -2 indicating wrong file permissions.; /// If any problem with changing ugid's occurs, prints a warning trying anyhow; /// to read the password hash.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:150,avoid,avoid,150,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return a list containing the TEnums of a class.; ///; /// The list returned is safe to use from multiple thread without explicitly; /// taking the ROOT global lock.; ///; /// In the case the TClass represents a namespace, the returned list will; /// implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); ///; /// In the case the TClass represents a class or struct and requestListLoading; /// is true, the list is immutable (and thus safe to access from multiple thread; /// without taking the global lock at all).; ///; /// In the case the TClass represents a class or struct and requestListLoading; /// is false, the list is mutable and thus we return a TListOfEnumsWithLock; /// which will implicit take the ROOT global lock upon any access.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:165,safe,safe,165,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,2,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return a valid index in fImage tables to avoid seg-fault by accessing out of; /// indices out of array's ranges.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx:127,avoid,avoid,127,graf2d/asimage/src/TASImage.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf2d/asimage/src/TASImage.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return l-value pointer to contents. If the contents derive from RooAbsLValue or RooAbsCategoryLValue,; /// the conversion is safe, and the function directly returns the pointer using a static_cast.; /// If the template parameter of this proxy is not an LValue type, then; /// - in a debug build, a dynamic_cast with an assertion is used.; /// - in a release build, a static_cast is forced, irrespective of what the type of the object actually is. This; /// is dangerous, but equivalent to the behaviour before refactoring the RooFit proxies.; /// \deprecated This function is unnecessary if the template parameter is RooAbsRealLValue (+ derived types) or; /// RooAbsCategoryLValue (+derived types), as arg() will always return the correct type.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooTemplateProxy.h:211,safe,safe,211,roofit/roofitcore/inc/RooTemplateProxy.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/inc/RooTemplateProxy.h,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return number of sockets in the active list. If timeout > 0, remove from; /// the list those sockets which did not have any activity since timeout; /// millisecs. If timeout = 0, then reset activity timestamp on all active; /// sockets. This time out is typically used if GetActive() is used to see; /// how many remotes still need to send something. If they pass the timeout; /// they will be skipped and GetActive() will return 0 and the loop can be; /// exited.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx:134,timeout,timeout,134,net/net/src/TMonitor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx,4,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return numbers of sockets that are ready for reading or writing.; /// Wait a maximum of timeout milliseconds.; /// Return 0 if timed-out. Return < 0 in case of error.; /// If rdready and/or wrready are not 0, the lists of sockets with; /// something to read and/or write are also returned.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx:174,timeout,timeout,174,net/net/src/TMonitor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return pointer to object identified by namecycle.; ///; /// Properties:; /// - namecycle has the format name;cycle; /// - name = * is illegal, cycle = * is illegal; /// - cycle = """" or cycle = 9999 ==> apply to a memory object; ///; /// Examples:; /// | %Pattern | Explanation |; /// |----------|-------------|; /// | foo | get object named foo in memory if object is not in memory, try with highest cycle from file |; /// | foo;1 | get cycle 1 of foo on file |; ///; /// The retrieved object should in principle derive from TObject.; /// If not, the function TDirectoryFile::Get<T> should be called.; /// However, this function will still work for a non-TObject, provided that; /// the calling application cast the return type to the correct type (which; /// is the actual type of the object).; ///; /// ### The Get<T> Method; /// The method Get<T> offers better protection and avoids the need for any; /// cast:; /// ~~~{.cpp}; /// auto objPtr = directory->Get<MyClass>(""some object"");; /// if (objPtr) { ... the object exist and inherits from MyClass ... }; /// ~~~; ///; /// ### Very important note about inheritance; /// In case the class of this object derives from TObject but not; /// as a first inheritance, one must use dynamic_cast<>().; ///; /// #### Example 1 - Normal case:; ///; /// class MyClass : public TObject, public AnotherClass; ///; /// then on return, one can adopt a C style cast:; ///; /// auto objPtr = (MyClass*)directory->Get(""some object of MyClass"");; ///; /// #### Example 2 - Special case:; ///; /// class MyClass : public AnotherClass, public TObject; ///; /// then on return, one must do:; ///; /// auto objPtr = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; ///; /// Of course, dynamic_cast<> can also be used in the example 1.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx:965,avoid,avoids,965,io/io/src/TDirectoryFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TDirectoryFile.cxx,1,['avoid'],['avoids']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return pointer to object identified by namecycle.; ///; /// namecycle has the format name;cycle; /// - name = * is illegal, cycle = * is illegal; /// - cycle = """" or cycle = 9999 ==> apply to a memory object; ///; /// examples:; /// - foo : get object named foo in memory; /// if object is not in memory, try with highest cycle from file; /// - foo;1 : get cycle 1 of foo on file; ///; /// The retrieved object should in principle derive from TObject.; /// If not, the function TDirectory::GetObject should be called.; /// However, this function will still work for a non-TObject, providing that; /// the calling application cast the return type to the correct type (which; /// is the actual type of the object).; ///; /// NOTE:; ///; /// The method GetObject offer better protection and avoid the need; /// for any cast:; /// ~~~ {.cpp}; /// MyClass *obj;; /// directory->GetObject(""some object"",obj);; /// if (obj) { ... the object exist and inherits from MyClass ... }; /// ~~~; ///; /// VERY IMPORTANT NOTE:; ///; /// In case the class of this object derives from TObject but not; /// as a first inheritance, one must use dynamic_cast<>().; /// #### Example 1: Normal case:; /// ~~~ {.cpp}; /// class MyClass : public TObject, public AnotherClass; /// ~~~; /// then on return, one can do:; /// ~~~ {.cpp}; /// MyClass *obj = (MyClass*)directory->Get(""some object of MyClass"");; /// ~~~; /// #### Example 2: Special case:; /// ~~~ {.cpp}; /// class MyClass : public AnotherClass, public TObject; /// ~~~; /// then on return, one must do:; /// ~~~ {.cpp}; /// MyClass *obj = dynamic_cast<MyClass*>(directory->Get(""some object of MyClass""));; /// ~~~; /// Of course, dynamic_cast<> can also be used in the example 1.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx:874,avoid,avoid,874,core/base/src/TDirectory.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDirectory.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return pointer to socket for which an event is waiting.; /// Wait a maximum of timeout milliseconds.; /// If return is due to timeout it returns (TSocket *)-1.; /// Select() can be interrupt by a call to Interrupt() (e.g. connected with a; /// Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; /// in such a case.; /// Return 0 in case of any other error situation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx:165,timeout,timeout,165,net/net/src/TMonitor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TMonitor.cxx,2,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return the ""template prediction"" corresponding to the fit result (this is not; /// the same as the weighted sum of template distributions, as template statistical; /// uncertainties are taken into account).; /// Note that the name of this histogram will simply be the same as that of the; /// ""data"" histogram, prefixed with the string ""Fraction fit to hist: "".; /// Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if; /// the class is deleted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:107,predict,prediction,107,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['predict'],['prediction']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return the adjusted MC template (Aji) for template (parm).; /// Note that the (Aji) times fractions only sum to the total prediction; /// of the fit if all weights are 1.; /// Note also that the histogram is managed by the TFractionFitter class, so the returned pointer will be invalid if; /// the class is deleted",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx:208,predict,prediction,208,hist/hist/src/TFractionFitter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TFractionFitter.cxx,1,['predict'],['prediction']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return the base address at which we would like the next TMapFile's; /// mapped data to start.; ///; /// For now, we let the system decide (start address 0). There are; /// a lot of issues to deal with here to make this work reasonably,; /// including:; /// - Avoid memory collisions with existing mapped address spaces; /// - Reclaim address spaces when their mmalloc heaps are unmapped; /// - When mmalloc heaps are shared between processes they have to be; /// mapped at the same addresses in each; ///; /// Once created, a mmalloc heap that is to be mapped back in must be; /// mapped at the original address. I.e. each TMapFile will expect; /// to be remapped at it's original address. This becomes a problem if; /// the desired address is already in use.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx:345,Avoid,Avoid,345,io/io/src/TMapFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TMapFile.cxx,1,['Avoid'],['Avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return the date & time as a string (ctime() format).; /// Result is copied into out (and out is returned). Make sure; /// out can at least contain 26 characters. Thread safe.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDatime.cxx:255,safe,safe,255,core/base/src/TDatime.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TDatime.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return the date & time as a string.; ///; /// Result is pointer to a statically allocated string.; /// User should copy this into their own buffer before calling; /// this method again.; ///; /// Option ""l"" returns it in local zone format; /// (can be applied to default or compact format).; ///; /// Default format is RFC822 compliant:; /// ~~~ {.cpp}; /// ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; /// ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec""; /// ~~~; ///; /// Option ""c"" compact is (almost) ISO 8601 compliant:; /// - ""2001-01-02 18:11:12.9999999999Z""; /// - ""2001-01-02 10:11:12.9999999999-0800"" if PST; /// * uses ""-"" as date separator as specified in ISO 8601; /// * uses ""."" rather than preferred "","" for decimal separator; /// * -HHMM is the difference between local and UTC (if behind, + if ahead).; ///; /// The ""-HHMM"" is replaced with ""Z"" if given as UTC.; /// To be strictly conforming it should use ""T"" instead of the; /// blank separating the date and time.; ///; /// Option ""2"" returns as {sec,nsec} integers.; ///; /// Option ""s"" returns ""2001-01-02 18:11:12"" with an implied UTC,; /// overrides ""l"" option.; ///; /// Internally uses a circular list of buffers to avoid problems; /// using AsString multiple times in a single statement.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimeStamp.cxx:1298,avoid,avoid,1298,core/base/src/TTimeStamp.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimeStamp.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return the entry list, corresponding to treename and filename; /// By default, the filename is first tried as is, and then, if the corresponding list; /// is not found, the filename is expanded to the absolute path, and compared again.; /// To avoid it, use option ""ne""",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx:330,avoid,avoid,330,tree/tree/src/TEntryList.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TEntryList.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return the expected number of events associated with the extendable input PDF; /// in the product. If there is no extendable term, abort.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx:217,abort,abort,217,roofit/roofitcore/src/RooProdPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooProdPdf.cxx,1,['abort'],['abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return the number of objects in array (i.e. number of non-empty slots).; /// This is a thread-unsafe version of GetEntriesFast. Use it only if sure; /// it will not be invoked concurrently.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjArray.cxx:180,unsafe,unsafe,180,core/cont/src/TObjArray.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TObjArray.cxx,1,['unsafe'],['unsafe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return true if it is safe to generate the convolution observable; /// from the internal generator (this is the case if the chosen resolution; /// model is the truth model)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx:107,safe,safe,107,roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; /// classes in the class hierarchy that overload TObject::Hash do call; /// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; /// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:309,safe,safe,309,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; /// classes in the class hierarchy that overload TObject::Hash do call; /// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; /// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; /// This routines is used for a small subset of the class for which we need; /// the answer before gROOT is properly initialized.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:309,safe,safe,309,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Returns TRUE if the url in 'path' points to the local file system.; /// This is used to avoid going through the NIC card for local operations.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:174,avoid,avoid,174,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Returns a cloned version of fPassedHistogram; ///; /// Notes:; /// - The histogram is filled with unit weights. You might want to scale; /// it with the global weight GetWeight().; /// - The returned object is owned by the user who has to care about the; /// deletion of the new TH1 object.; /// - This histogram is by default NOT attached to the current directory; /// to avoid duplication of data. If you want to store it automatically; /// during the next TFile::Write() command, you have to attach it to; /// the corresponding directory.; ///; /// ~~~~~~~{.cpp}; /// TFile* pFile = new TFile(""passed.root"",""update"");; /// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; /// TH1* copy = pEff->GetCopyPassedHisto();; /// copy->SetDirectory(gDirectory);; /// pFile->Write();; /// ~~~~~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:459,avoid,avoid,459,hist/hist/src/TEfficiency.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Returns a cloned version of fTotalHistogram; ///; /// Notes:; /// - The histogram is filled with unit weights. You might want to scale; /// it with the global weight GetWeight().; /// - The returned object is owned by the user who has to care about the; /// deletion of the new TH1 object.; /// - This histogram is by default NOT attached to the current directory; /// to avoid duplication of data. If you want to store it automatically; /// during the next TFile::Write() command, you have to attach it to; /// the corresponding directory.; ///; /// ~~~~~~~{.cpp}; /// TFile* pFile = new TFile(""total.root"",""update"");; /// TEfficiency* pEff = (TEfficiency*)gDirectory->Get(""my_eff"");; /// TH1* copy = pEff->GetCopyTotalHisto();; /// copy->SetDirectory(gDirectory);; /// pFile->Write();; /// ~~~~~~~",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx:458,avoid,avoid,458,hist/hist/src/TEfficiency.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TEfficiency.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Returns checksum of specified file in digest argument. Returns -1 in; /// case of error, 0 otherwise. This method preserves the modtime of the; /// file so it can be safely used in conjunction with methods that keep; /// track of the file's modtime. Static utility function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMD5.cxx:252,safe,safely,252,core/base/src/TMD5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMD5.cxx,1,['safe'],['safely']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Returns checksum of specified file. The returned TMD5 object must; /// be deleted by the user. Returns 0 in case the file does not exists; /// or in case of error. This function preserves the modtime of the file; /// so it can be safely used in conjunction with methods that keep track; /// of the file's modtime. Static utility function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMD5.cxx:316,safe,safely,316,core/base/src/TMD5.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TMD5.cxx,1,['safe'],['safely']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Returns kTRUE if stager 's' is compatible with current stager. Avoids; /// multiple instantiations of the potentially the same TNetXNGFileStager.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGFileStager.cxx:149,Avoid,Avoids,149,net/netxng/src/TNetXNGFileStager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/netxng/src/TNetXNGFileStager.cxx,1,['Avoid'],['Avoids']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Returns kTRUE if stager 's' is compatible with current stager.; /// Avoids multiple instantiations of the potentially the same TNetSystem.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFileStager.cxx:154,Avoid,Avoids,154,net/net/src/TNetFileStager.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TNetFileStager.cxx,1,['Avoid'],['Avoids']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Returns open timeout (in ms).",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:99,timeout,timeout,99,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Returns scaling factor between screen points and GL viewport pixels.; /// This is what is returned by gVirtualX->GetOpenGLScalingFactor() but is; /// cached here to avoid a virtual function call as it is used quite often in; /// TGLPhysical shape when drawing the selection highlight.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx:251,avoid,avoid,251,graf3d/gl/src/TGLUtil.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLUtil.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Returns the gauss weight between the 'cell' and a given coordinate 'txvec'.; ///; /// Parameters:; /// - cell - the cell; ///; /// - txvec - the transformed event variables (in [0,1]) (coordinates <0 are; /// set to 0, >1 are set to 1); ///; /// Returns:; ///; /// \f[; /// e^(\frac{-(\frac{d}{\sigma})^2}{2}); /// \f]; ///; /// where:; /// - d - is the euclidean distance between 'txvec' and the point of the 'cell'; /// which is most close to 'txvec' (in order to avoid artefacts because of the; /// form of the cells).; /// - \f$ sigma = \frac{1}{VolFrac} \f$",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoamKernelGauss.cxx:552,avoid,avoid,552,tmva/tmva/src/PDEFoamKernelGauss.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/PDEFoamKernelGauss.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Safe method to add a block to the pendingList.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx:86,Safe,Safe,86,io/io/src/TFilePrefetch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx,1,['Safe'],['Safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Safe method to add a block to the readList.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx:86,Safe,Safe,86,io/io/src/TFilePrefetch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx,1,['Safe'],['Safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Safe method to remove a block from the pendingList.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx:86,Safe,Safe,86,io/io/src/TFilePrefetch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFilePrefetch.cxx,1,['Safe'],['Safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Same as TTree::Branch but automatic detection of the class name.; /// \see TTree::Branch for other details.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx:122,detect,detection,122,tree/tree/src/TTree.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTree.cxx,3,['detect'],['detection']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Sanity check",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitResult.cxx:86,Sanity check,Sanity check,86,roofit/roofitcore/src/RooFitResult.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooFitResult.cxx,1,['Sanity check'],['Sanity check']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Sanity check various values.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTableLayout.cxx:86,Sanity check,Sanity check,86,gui/gui/src/TGTableLayout.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/gui/src/TGTableLayout.cxx,1,['Sanity check'],['Sanity check']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Sent stop/abort request to PROOF server.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx:96,abort,abort,96,proof/proof/src/TSlave.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TSlave.cxx,1,['abort'],['abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set Min/Max cuts so that they are within detected limits.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrack.cxx:127,detect,detected,127,graf3d/eve/src/TEveTrack.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve/src/TEveTrack.cxx,2,['detect'],['detected']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set address of this branch directly from a TBuffer to avoid streaming.; ///; /// Note: We do not take ownership of the buffer.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx:140,avoid,avoid,140,tree/tree/src/TBranch.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TBranch.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set an alias for this session. If reconnection is supported, the alias; /// will be communicated to the remote coordinator so that it can be recovered; /// when reconnecting",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx:227,recover,recovered,227,proof/proof/src/TProof.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProof.cxx,2,['recover'],['recovered']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set cache as finished.; /// There are three scenarios that a basket is set as finished:; /// 1. The basket has already been unzipped.; /// 2. The thread is aborted from unzipping process.; /// 3. To avoid other tasks/threads work on this basket,; /// main thread marks the basket as finished and designates itself; /// to unzip this basket.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:242,abort,aborted,242,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,2,"['abort', 'avoid']","['aborted', 'avoid']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set class pointer; /// This method is not thread safe",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TIsAProxy.cxx:135,safe,safe,135,core/meta/src/TIsAProxy.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TIsAProxy.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set file open timeout.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/dcache/src/TDCacheFile.cxx:100,timeout,timeout,100,io/dcache/src/TDCacheFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/dcache/src/TDCacheFile.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set global timeout for menu-hiding in mili-seconds.; /// Static function.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSAViewer.cxx:97,timeout,timeout,97,graf3d/gl/src/TGLSAViewer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLSAViewer.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set the fraction of extra range used when doing an FFT convolution.; /// The extra range is often needed to avoid mirroring effect of the resulting convolution; /// function at the borders.; /// By default an extra range of 0.1 is used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx:194,avoid,avoid,194,hist/hist/src/TF1Convolution.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1Convolution.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set the location where ACLiC will create libraries and use as; /// a scratch area. If unset, libraries will be created at the same; /// location than the script.; ///; /// \param build_dir the name of the build directory; /// \param isflat If false (default), then the libraries are actually stored; /// in sub-directories of 'build_dir' including the full pathname; /// of the script. If the script is located at `/full/path/name/macro.C`; /// the library will be located at `build_dir+/full/path/name/macro_C.so`; /// If 'isflat' is true, then no subdirectory is created and the library; /// is created directly in the directory 'build_dir'. Note that in this; /// mode there is a risk than 2 script of the same in different source; /// directory will over-write each other.; /// \note This `build_dir` can also be controlled via `ACLiC.BuildDir` in; /// your `.rootrc`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx:769,risk,risk,769,core/base/src/TSystem.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TSystem.cxx,1,['risk'],['risk']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set this collection to use a RW lock upon access, making it thread safe.; /// Return the previous state.; ///; /// Note: To test whether the usage is enabled do:; /// collection->TestBit(TCollection::kUseRWLock);",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TCollection.cxx:153,safe,safe,153,core/cont/src/TCollection.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/cont/src/TCollection.cxx,2,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set timeout (active if > 0)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx:90,timeout,timeout,90,net/auth/src/TAuthenticate.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/auth/src/TAuthenticate.cxx,1,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Set visualization-parameter model element.; /// Calling of this function from outside of EVE should in principle; /// be avoided as it can lead to dis-synchronization of viz-tag and; /// viz-model.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx:207,avoid,avoided,207,graf3d/eve7/src/REveElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/eve7/src/REveElement.cxx,1,['avoid'],['avoided']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Sets open timeout time (in ms). Returns previous timeout value.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx:96,timeout,timeout,96,io/io/src/TFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TFile.cxx,2,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Setup colors - avoid setting things not required; /// for current draw flags.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPhysicalShape.cxx:101,avoid,avoid,101,graf3d/gl/src/TGLPhysicalShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/gl/src/TGLPhysicalShape.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Slot called every time the name is changed. Provide some protection; /// to avoid letting the user use an empty name or an already used one.; /// A warning message can be shown and the OK button disabled.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleDialog.cxx:162,avoid,avoid,162,gui/ged/src/TStyleDialog.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/gui/ged/src/TStyleDialog.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Smooth data with Super smoother.; /// Smooth the (x, y) values by Friedman's ``super smoother''.; ///; /// \param[in] grin graph for smoothing; /// \param[in] option specific options; /// \param[in] span the fraction of the observations in the span of the running lines; /// smoother, or 0 to choose this by leave-one-out cross-validation.; /// \param[in] bass controls the smoothness of the fitted curve.; /// Values of up to 10 indicate increasing smoothness.; /// \param[in] isPeriodic if TRUE, the x values are assumed to be in [0, 1]; /// and of period 1.; /// \param[in] w case weights; ///; /// Details:; ///; /// supsmu is a running lines smoother which chooses between three spans for; /// the lines. The running lines smoothers are symmetric, with k/2 data points; /// each side of the predicted point, and values of k as 0.5 * n, 0.2 * n and; /// 0.05 * n, where n is the number of data points. If span is specified,; /// a single smoother with span span * n is used.; ///; /// The best of the three smoothers is chosen by cross-validation for each; /// prediction. The best spans are then smoothed by a running lines smoother; /// and the final prediction chosen by linear interpolation.; ///; /// The FORTRAN code says: ``For small samples (n < 40) or if there are; /// substantial serial correlations between observations close in x - value,; /// then a prespecified fixed span smoother (span > 0) should be used.; /// Reasonable span values are 0.2 to 0.4.''; ///; /// References:; /// - Friedman, J. H. (1984) SMART User's Guide.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 1.; /// - Friedman, J. H. (1984) A variable span scatterplot smoother.; /// Laboratory for Computational Statistics,; /// Stanford University Technical Report No. 5.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx:882,predict,predicted,882,hist/hist/src/TGraphSmooth.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphSmooth.cxx,3,['predict'],"['predicted', 'prediction']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Solves the system for a given set of residuals. Assembles the right-hand side appropriate; /// to the matrix factored in factor, solves the system using the factorization produced there,; /// partitions the solution vector into step components, then recovers the step components; /// eliminated during the block elimination that produced the augmented system form .",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverBase.cxx:336,recover,recovers,336,math/quadp/src/TQpLinSolverBase.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/quadp/src/TQpLinSolverBase.cxx,1,['recover'],['recovers']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Starts the timer with a milliSec timeout. If milliSec is 0; /// then the timeout will be the minimum timeout (see TSystem::ESysConstants,; /// i.e. 10 ms), if milliSec is -1 then the time interval as previously; /// specified (in ctor or SetTime()) will be used.; /// If singleShot is kTRUE, the timer will be activated only once,; /// otherwise it will continue until it is stopped.; /// See also TurnOn(), Stop(), TurnOff().",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimer.cxx:119,timeout,timeout,119,core/base/src/TTimer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TTimer.cxx,3,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Static function that (de)activates multithreading unzipping; ///; /// The possible options are:; /// - kEnable _Enable_ it, which causes an automatic detection and launches the; /// additional thread if the number of cores in the machine is greater than; /// one; /// - kDisable _Disable_ will not activate the additional thread.; /// - kForce _Force_ will start the additional thread even if there is only one; /// core. the default will be taken as kEnable.; ///; /// Returns 0 if there was an error, 1 otherwise.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx:236,detect,detection,236,tree/tree/src/TTreeCacheUnzip.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TTreeCacheUnzip.cxx,1,['detect'],['detection']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Static function to set `fgMaxPointsPerLine` for graph painting. When graphs; /// are painted with lines, they are split into chunks of length `fgMaxPointsPerLine`.; /// This allows to paint line with an ""infinite"" number of points. In some case; /// this ""chunks painting"" technic may create artefacts at the chunk's boundaries.; /// For instance when zooming deeply in a PDF file. To avoid this effect it might; /// be necessary to increase the chunks' size using this function:; /// `TGraphPainter::SetMaxPointsPerLine(20000)`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx:471,avoid,avoid,471,hist/histpainter/src/TGraphPainter.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/histpainter/src/TGraphPainter.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Static method called via the thread timer to execute in the main; /// thread certain commands. This to avoid sophisticated locking and; /// possible deadlocking.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx:189,avoid,avoid,189,core/thread/src/TThread.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Static method providing a thread safe printf. Appends a newline.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx:119,safe,safe,119,core/thread/src/TThread.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/thread/src/TThread.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Static method returning kTRUE if some new colors have been defined after; /// initialisation or since the last call to this method. This allows to avoid; /// the colors and palette streaming in TCanvas::Streamer if not needed.; /// If method called once with set_always_on = 1, all next canvases will be; // saved with color palette - disregard if new colors created or not.; /// To reset such mode, just call methoid once with set_always_on = -1",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx:233,avoid,avoid,233,core/base/src/TColor.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TColor.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Static method to add/avoid to add automatically functions to the global list (gROOT->GetListOfFunctions() ); /// After having called this static method, all the functions created afterwards will follow the; /// desired behaviour.; ///; /// By default the functions are added automatically; /// It returns the previous status (true if the functions are added automatically)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:107,avoid,avoid,107,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Static method to compute distance from outside point to a tube with given parameters; /// Boundary safe algorithm.; /// check Z planes",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx:185,safe,safe,185,geom/geom/src/TGeoTube.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Static method to compute distance to arbitrary tube segment from outside point; /// Boundary safe algorithm.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx:179,safe,safe,179,geom/geom/src/TGeoTube.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoTube.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Static method to compute safety w.r.t a phi corner defined by cosines/sines; /// of the angles phi1, phi2.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx:111,safe,safety,111,geom/geom/src/TGeoShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx,1,['safe'],['safety']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Stop the process after this event. If timeout is positive, start; /// a timer firing after timeout seconds to hard-stop time-expensive; /// events.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx:124,timeout,timeout,124,proof/proofplayer/src/TProofPlayer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofplayer/src/TProofPlayer.cxx,2,['timeout'],['timeout']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Store provided object as JSON structure; /// Allows to configure different TBufferJSON properties before converting object into JSON; /// Actual object class must be specified here; /// Method can be safely called once - after that TBufferJSON instance must be destroyed; /// Code should look like:; ///; /// auto obj = new UserClass();; /// TBufferJSON buf;; /// buf.SetCompact(TBufferJSON::kNoSpaces); // change any other settings in TBufferJSON; /// auto json = buf.StoreObject(obj, TClass::GetClass<UserClass>());; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx:286,safe,safely,286,io/io/src/TBufferJSON.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx,1,['safe'],['safely']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Stub implementation to avoid forcing implementation at this stage",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx:109,avoid,avoid,109,geom/geom/src/TGeoShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geom/src/TGeoShape.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Stub to avoid forcing implementation at this stage",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TShape.cxx:94,avoid,avoid,94,graf3d/g3d/src/TShape.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/graf3d/g3d/src/TShape.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// TGraphAsymmErrors constructor reading input from filename; /// filename is assumed to contain at least 2 columns of numbers; ///; /// convention for format (default=`""%lg %lg %lg %lg %lg %lg""`); /// - format = `""%lg %lg""` read only 2 first columns into X, Y; /// - format = `""%lg %lg %lg %lg""` read only 4 first columns into X, Y, ELY, EHY; /// - format = `""%lg %lg %lg %lg %lg %lg""` read only 6 first columns into X, Y, EXL, EYH, EYL, EHY; ///; /// For files separated by a specific delimiter different from `' '` and `'\\t'` (e.g. `';'` in csv files); /// you can avoid using `%*s` to bypass this delimiter by explicitly specify the `""option"" argument,; /// e.g. `option="" \\t,;""` for columns of figures separated by any of these characters `(' ', '\\t', ',', ';')`; /// used once `(e.g. ""1;1"")` or in a combined way `("" 1;,;; 1"")`.; /// Note in that case, the instantiation is about 2 times slower.; /// In case a delimiter is specified, the format `""%lg %lg %lg""` will read X,Y,EX.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx:652,avoid,avoid,652,hist/hist/src/TGraphAsymmErrors.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TGraphAsymmErrors.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Template method to write array of arbitrary dimensions; /// Different methods can be used for store last array dimension -; /// either JsonWriteArrayCompress<T>() or JsonWriteConstChar(); /// \note Due to the current limit of the buffer size, the function aborts execution of the program in case of overflow. See https://github.com/root-project/root/issues/6734 for more details.; ///",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx:342,abort,aborts,342,io/io/src/TBufferJSON.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferJSON.cxx,1,['abort'],['aborts']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Test for shape navigation methods. Summary for test numbers:; /// - 1: DistFromInside/Outside. Sample points inside the shape. Generate; /// directions randomly in cos(theta). Compute DistFromInside and move the; /// point with bigger distance. Compute DistFromOutside back from new point.; /// Plot d-(d1+d2); /// - 2: Safety test. Sample points inside the bounding and compute safety. Generate; /// directions randomly in cos(theta) and compute distance to boundary. Check if; /// distance to boundary is bigger than safety",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx:406,Safe,Safety,406,geom/geompainter/src/TGeoChecker.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/geom/geompainter/src/TGeoChecker.cxx,3,"['Safe', 'safe']","['Safety', 'safety']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// The PROOF error handler function. It prints the message on fgErrorHandlerFile and; /// if abort is set it aborts the application.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx:176,abort,abort,176,proof/proof/src/TProofServ.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proof/src/TProofServ.cxx,2,['abort'],"['abort', 'aborts']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either TSelHist::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.; ///; /// The processing can be stopped by calling Abort().; ///; /// Use fStatus to set the return value of TTree::Process().; ///; /// The return value is currently not used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHist.cxx:823,Abort,Abort,823,proof/proofbench/src/TSelHist.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/proof/proofbench/src/TSelHist.cxx,1,['Abort'],['Abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either TSelectorEntries::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.; ///; /// The processing can be stopped by calling Abort().; ///; /// Use fStatus to set the return value of TTree::Process().; ///; /// The return value is currently not used.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorEntries.cxx:831,Abort,Abort,831,tree/treeplayer/src/TSelectorEntries.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TSelectorEntries.cxx,1,['Abort'],['Abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// The Process() function is called for each entry in the tree (or possibly; /// keyed object in the case of PROOF) to be processed. The entry argument; /// specifies which entry in the currently loaded tree is to be processed.; /// It can be passed to either t01::GetEntry() or TBranch::GetEntry(); /// to read either all or the required parts of the data. When processing; /// keyed objects with PROOF, the object is already loaded and is available; /// via the fObject pointer.; ///; /// This function should contain the ""body"" of the analysis. It can contain; /// simple or elaborate selection criteria, run algorithms on the data; /// of the event and typically fill histograms.; ///; /// The processing can be stopped by calling Abort().; ///; /// Use fStatus to set the return value of TTree::Process().; ///; /// The return value is currently not used.; ///; /// WARNING when a selector is used with a TChain, you must use; /// the pointer to the current TTree to call GetEntry(entry).; /// The entry is always the local entry number in the current tree.; /// Assuming that fChain is the pointer to the TChain being processed,; /// use: `fChain->GetTree()->GetEntry(entry)`.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx:818,Abort,Abort,818,tree/tree/src/TSelector.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/tree/src/TSelector.cxx,1,['Abort'],['Abort']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// The early 3.00/00 and 3.01/01 versions used to store; /// dm->GetTypeName instead of dm->GetFullTypename; /// if this case is detected, the element type name is modified.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx:212,detect,detected,212,core/meta/src/TStreamerElement.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TStreamerElement.cxx,1,['detect'],['detected']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// The error handler function. It prints the message on stderr and; /// if abort is set it aborts the application.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx:158,abort,abort,158,net/net/src/TApplicationServer.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TApplicationServer.cxx,2,['abort'],"['abort', 'aborts']"
Safety,"////////////////////////////////////////////////////////////////////////////////; /// The following finds the gradient directed path in parameter space.; /// More work is needed... FT, 24/9/2006; ///; /// The algorithm is currently as follows (if not otherwise stated, the sample; /// used below is [fPathIdx1,fPathIdx2]):; ///; /// 1. Set offset to -average(y(true)) and all coefs=0 => average of F(x)==0; /// 2. FindGDTau() : start scanning using several paths defined by different tau; /// choose the tau yielding the best path; /// 3. start the scanning the chosen path; /// 4. check error rate at a given frequency; /// data used for check: [fPerfIdx1,fPerfIdx2]; /// 5. stop when either of the following conditions are fullfilled:; /// 1. loop index==fGDNPathSteps; /// 2. error > fGDErrScale*errmin; /// 3. only in DEBUG mode: risk is not monotonously decreasing; ///; /// The algorithm will warn if:; /// 1. the error rate was still decreasing when loop finished -> increase fGDNPathSteps!; /// 2. minimum was found at an early stage -> decrease fGDPathStep; /// 3. DEBUG: risk > previous risk -> entered chaotic region (regularization is too small)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx:834,risk,risk,834,tmva/tmva/src/RuleFitParams.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/src/RuleFitParams.cxx,3,['risk'],['risk']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// The function returns a TString with the arguments of a method from the; /// scope (scopeName), but modified with respect to Doxygen syntax - spacing; /// around special symbols and adding the missing scopes (""std::"").; /// ""FormatMethodArgsForDoxygen"" works for functions defined inside namespaces; /// as well. We avoid looking up twice for the TFunction by passing ""func"".; ///; /// \param[in] scopeName the name of the class/namespace/struct; /// \param[in] func pointer to the method",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx:401,avoid,avoid,401,core/base/src/TApplication.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/base/src/TApplication.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// This function forces RooRealIntegral to offer all integration dependents; /// to RooAbsAnaConvPdf::getAnalyticalIntegralWN() for consideration for; /// internal integration, if RooRealIntegral considers this to be unsafe (e.g. due; /// to hidden Jacobian terms).; ///; /// RooAbsAnaConvPdf will not attempt to actually integrate all these dependents; /// but feed them to the resolution models integration interface, which will; /// make the final determination on how to integrate these dependents.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx:300,unsafe,unsafe,300,roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/roofit/roofitcore/src/RooAbsAnaConvPdf.cxx,1,['unsafe'],['unsafe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// This function installs a global IsA function for this class.; /// The global IsA function will be used if there is no local IsA function (fIsA); ///; /// A global IsA function has the signature:; ///; /// ~~~ {.cpp}; /// TClass *func( TClass *cl, const void *obj);; /// ~~~; ///; /// 'cl' is a pointer to the TClass object that corresponds to the; /// 'pointer type' used to retrieve the value 'obj'; ///; /// For example with:; /// ~~~ {.cpp}; /// TNamed * m = new TNamed(""example"",""test"");; /// TObject* o = m; /// ~~~; /// and; /// the global IsA function would be called with TObject::Class() as; /// the first parameter and the exact numerical value in the pointer; /// 'o'.; ///; /// In other word, inside the global IsA function. it is safe to C-style; /// cast the value of 'obj' into a pointer to the class described by 'cl'.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx:829,safe,safe,829,core/meta/src/TClass.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/meta/src/TClass.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// This function is called TTreePlayer::UpdateFormulaLeaves, itself; /// called by TChain::LoadTree when a new Tree is loaded.; /// Because Trees in a TChain may have a different list of leaves, one; /// must update the leaves numbers in the TTreeFormula used by the TreePlayer.; ///; /// A safer alternative would be to recompile the whole thing .... However; /// currently compile HAS TO be called from the constructor!",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx:374,safe,safer,374,tree/treeplayer/src/TTreeFormula.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tree/treeplayer/src/TTreeFormula.cxx,1,['safe'],['safer']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// This is a global templated function that searches for k-nearest neighbors.; /// list contains all nodes that are closest to event; /// and have sum of event weights >= nfind.; /// Only nodes with positive weights are added to list.; /// Requirement for used classes:; /// - each node contains maximum and minimum values of splitting variable; /// for all its children; /// - min and max range is checked to avoid descending into; /// nodes that are definitely outside current minimum neighbourhood.; ///; /// This function should be modified with care.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/NodekNN.h:493,avoid,avoid,493,tmva/tmva/inc/TMVA/NodekNN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/NodekNN.h,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// This is a global templated function that searches for k-nearest neighbors.; /// list contains k or less nodes that are closest to event.; /// only nodes with positive weights are added to list.; /// each node contains maximum and minimum values of splitting variable; /// for all its children - this range is checked to avoid descending into; /// nodes that are definitely outside current minimum neighbourhood.; ///; /// This function should be modified with care.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/NodekNN.h:406,avoid,avoid,406,tmva/tmva/inc/TMVA/NodekNN.h,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/tmva/tmva/inc/TMVA/NodekNN.h,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// This method is called by the super-class TWebFile when a HTTP header; /// for this file is retrieved. We scan the 'Server' header to detect the; /// type of S3 server this file is hosted on and to determine if it is; /// known to support multi-range HTTP GET requests. Some S3 servers (for; /// instance Amazon's) do not support that feature and when they; /// receive a multi-range request they sent back the whole file contents.; /// For this class, if the server do not support multirange requests; /// we issue multiple single-range requests instead.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx:219,detect,detect,219,net/net/src/TS3WebFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/net/src/TS3WebFile.cxx,1,['detect'],['detect']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Thread-safe check on StreamerInfos of a TClass",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx:93,safe,safe,93,io/io/src/TBufferFile.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TBufferFile.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// To avoid problems due to compiler optmization; /// Taken from Viega&Messier, ""Secure Programming Cookbook"", O'Really, #13.2; /// (see discussion there)",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx:89,avoid,avoid,89,net/rpdutils/src/rpdutils.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/net/rpdutils/src/rpdutils.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// To find the machine precision; ///; /// Compares its argument with the value 1.0, and returns; /// the value .TRUE. if they are equal. To find EPSMAC; /// safely by foiling the Fortran optimiser",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx:241,safe,safely,241,math/minuit/src/TMinuit.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/math/minuit/src/TMinuit.cxx,1,['safe'],['safely']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// To read an object (non deriving from TObject) from the file.; ///; /// If expectedClass is not null, we checked that that actual class of the; /// object stored is suitable to be stored in a pointer pointing to an object; /// of class 'expectedClass'. We also adjust the value of the returned address; /// so that it is suitable to be cast (C-Style); /// a pointer pointing to an object of class 'expectedClass'.; ///; /// So for example if the class Bottom inherits from Top and the object; /// stored is of type Bottom you can safely do:; /// ~~~{.cpp}; /// auto TopClass = TClass::GetClass(""Top"");; /// auto ptr = (Top*) key->ReadObjectAny( TopClass );; /// if (ptr==0) printError(""the object stored in the key is not of the expected type\n"");; /// ~~~; /// The object associated to this key is read from the file into memory.; /// Once the key structure is read (via Streamer) the class identifier; /// of the object is known.; /// Using the class identifier we find the TClass object for this class.; /// A TClass object contains a full description (i.e. dictionary) of the; /// associated class. In particular the TClass object can create a new; /// object of the class type it describes. This new object now calls its; /// Streamer function to rebuilt itself.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx:615,safe,safely,615,io/io/src/TKey.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/io/io/src/TKey.cxx,1,['safe'],['safely']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Try hard to avoid looking up in the Cling database as this could enduce; /// an unwanted autoparsing.",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx:98,avoid,avoid,98,core/metacling/src/TCling.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/core/metacling/src/TCling.cxx,1,['avoid'],['avoid']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Type safe interface (static method); /// A TGraph is created with new with num points and the pointer to the; /// graph is returned by the function. It is the responsibility of the; /// user to delete the object.; /// if num is invalid (<=0) NULL is returned",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:91,safe,safe,91,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['safe'],['safe']
Safety,"////////////////////////////////////////////////////////////////////////////////; /// Type: unsafe but fast interface filling the arrays x and w (static method); ///; /// Given the number of sampling points this routine fills the arrays x and w; /// of length num, containing the abscissa and weight of the Gauss-Legendre; /// n-point quadrature formula.; ///; /// Gauss-Legendre:; /** \f[; W(x)=1 -1<x<1 \\; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}; \f]; **/; /// num is the number of sampling points (>0); /// x and w are arrays of size num; /// eps is the relative precision; ///; /// If num<=0 or eps<=0 no action is done.; ///; /// Reference: Numerical Recipes in C, Second Edition",MatchSource.CODE_COMMENT,root-project,root,v6-32-06,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx:92,unsafe,unsafe,92,hist/hist/src/TF1.cxx,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/hist/hist/src/TF1.cxx,1,['unsafe'],['unsafe']
